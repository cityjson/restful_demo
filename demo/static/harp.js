var harp =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./lib/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/rbush/rbush.min.js":
/*!***************************************************************************!*\
  !*** /home/travis/build/heremaps/harp.gl/node_modules/rbush/rbush.min.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(t,i){ true?module.exports=i():undefined}(this,function(){"use strict";function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h)}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1)}}(t,r,e||0,a||t.length-1,h||n)}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return-1}function a(t,i){h(t,0,t.children.length,i,t)}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h)}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r)}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h))}i=e.pop()}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return!1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return!0;n.push(e)}}i=n.pop()}return!1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){var r=this.data;this.data=n,n=r}this._insert(n,this.data.height-n.height-1,!0)}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0])}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1))}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s)}i=h||i.children[0]}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i)},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o)},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox)},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p)}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r)},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a)}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s)}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t)},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox)},r});


/***/ }),

/***/ "../harp-datasource-protocol/index-decoder.ts":
/*!****************************************************!*\
  !*** ../harp-datasource-protocol/index-decoder.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/StyleSetEvaluator */ "../harp-datasource-protocol/lib/StyleSetEvaluator.ts"));
__export(__webpack_require__(/*! ./lib/Extruder */ "../harp-datasource-protocol/lib/Extruder.ts"));
__export(__webpack_require__(/*! ./lib/Outliner */ "../harp-datasource-protocol/lib/Outliner.ts"));
__export(__webpack_require__(/*! ./lib/Expr */ "../harp-datasource-protocol/lib/Expr.ts"));
__export(__webpack_require__(/*! ./lib/ThreeBufferUtils */ "../harp-datasource-protocol/lib/ThreeBufferUtils.ts"));


/***/ }),

/***/ "../harp-datasource-protocol/index.ts":
/*!********************************************!*\
  !*** ../harp-datasource-protocol/index.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/ColorUtils */ "../harp-datasource-protocol/lib/ColorUtils.ts"));
__export(__webpack_require__(/*! ./lib/Expr */ "../harp-datasource-protocol/lib/Expr.ts"));
__export(__webpack_require__(/*! ./lib/Techniques */ "../harp-datasource-protocol/lib/Techniques.ts"));
__export(__webpack_require__(/*! ./lib/TechniqueParams */ "../harp-datasource-protocol/lib/TechniqueParams.ts"));
__export(__webpack_require__(/*! ./lib/Theme */ "../harp-datasource-protocol/lib/Theme.ts"));
__export(__webpack_require__(/*! ./lib/InterpolatedProperty */ "../harp-datasource-protocol/lib/InterpolatedProperty.ts"));
__export(__webpack_require__(/*! ./lib/InterpolatedPropertyDefs */ "../harp-datasource-protocol/lib/InterpolatedPropertyDefs.ts"));
__export(__webpack_require__(/*! ./lib/WorkerServiceProtocol */ "../harp-datasource-protocol/lib/WorkerServiceProtocol.ts"));
__export(__webpack_require__(/*! ./lib/WorkerTilerProtocol */ "../harp-datasource-protocol/lib/WorkerTilerProtocol.ts"));
__export(__webpack_require__(/*! ./lib/WorkerDecoderProtocol */ "../harp-datasource-protocol/lib/WorkerDecoderProtocol.ts"));
__export(__webpack_require__(/*! ./lib/DecodedTile */ "../harp-datasource-protocol/lib/DecodedTile.ts"));
__export(__webpack_require__(/*! ./lib/TileInfo */ "../harp-datasource-protocol/lib/TileInfo.ts"));
__export(__webpack_require__(/*! ./lib/ThemeVisitor */ "../harp-datasource-protocol/lib/ThemeVisitor.ts"));
__export(__webpack_require__(/*! ./lib/StringEncodedNumeral */ "../harp-datasource-protocol/lib/StringEncodedNumeral.ts"));


/***/ }),

/***/ "../harp-datasource-protocol/lib/ColorUtils.ts":
/*!*****************************************************!*\
  !*** ../harp-datasource-protocol/lib/ColorUtils.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const THREE = __webpack_require__(/*! three */ "three");
const SHIFT_TRANSPARENCY = 24;
const SHIFT_RED = 16;
const SHIFT_GREEN = 8;
const SHIFT_BLUE = 0;
// tslint:disable: no-bitwise
//    Allow bitwise operations for colors decoding
// tslint:disable-next-line: no-bitwise
const HEX_FULL_CHANNEL = 0xff;
const HEX_RGB_MASK = 0xffffff;
const HEX_TRGB_MASK = 0xffffffff;
const tmpColor = new THREE.Color();
/**
 * Utilities to convert RGBA colors encoded in custom number (hex) format to THREE.Color objects.
 *
 * The functions provided allows for conversion from and to our custom number based color format,
 * which contains transparency, red, green and blue color channels in a way that each channel
 * occupies 8 bits of resulting number (color format 0xTTRRGGBB).
 * In order to preserve compatibility with THREE.Color class and its hexadecimal color
 * representation, we do not store __alpha__ channel in encoded color's number, but replace it
 * with __transparency__ channel, which is simply opposite to alpha:
 * ```transparency = 0xFF - alpha```
 * Such channel value is stored on the oldest bits (octet) in the integral color (numeric) value,
 * so it is fully compatible with THREE.Color numerical representation (@see [[THREE.Color.getHex]],
 * [[THREE.Color.setHex]]).
 * See also [[getHexFromRgba]] and [[getRgbaFromHex]] for more info about conversion.
 */
var ColorUtils;
(function (ColorUtils) {
    /**
     * Encodes RGBA channels in custom number coded format (represented in hex as 0xTTRRGGBB).
     *
     * We do not use direct alpha channel mapping to hex in order to preserve compatibility
     * with THREE.js color format (0xRRGGBB). This is done by encoding transparency
     * (255 - alpha) instead of alpha on the oldest bits, shifted by [[SHIFT_TRANSPARENCY]].
     * This way simple 0xRRGGBB color is equal to 0x00RRGGBB without transparency and
     * color defining transparency (alpha < 255) is always recognizable by the oldest
     * bit set:
     * ```typescript
     * (color >> SHIFT_TRANSPARENCY) !== 0.
     * ```
     * @note All input components are floating points in <0, 1> range (inclusively).
     * @note Although method encodes transparency channel in single number value, it is still
     * compatible with THREE.js number based color coding (0xRRGGBB), so you may pass this value to
     * [[THREE.Color]] c-tor, but keep in mind that transparency will be silently ignored.
     */
    function getHexFromRgba(r, g, b, a) {
        harp_utils_1.assert(a >= 0 && a <= 1);
        const t = HEX_FULL_CHANNEL - Math.floor(a * HEX_FULL_CHANNEL);
        return ((t << SHIFT_TRANSPARENCY) ^
            ((r * HEX_FULL_CHANNEL) << SHIFT_RED) ^
            ((g * HEX_FULL_CHANNEL) << SHIFT_GREEN) ^
            ((b * HEX_FULL_CHANNEL) << SHIFT_BLUE));
    }
    ColorUtils.getHexFromRgba = getHexFromRgba;
    /**
     * Encodes RGB all color channels in single number with format 0xRRGGBB.
     *
     * All input channels should be in <0, 1> range (inclusively).
     * See also [[getHexFromRgba]] for more information about [[THREE.Color]] compatibility.
     *
     * @note This method is fully compatible with THREE.js color encoding, so
     * you may pass this value directly to THREE.Color c-tor.
     */
    function getHexFromRgb(r, g, b) {
        harp_utils_1.assert(r >= 0 && r <= 1);
        harp_utils_1.assert(g >= 0 && g <= 1);
        harp_utils_1.assert(b >= 0 && b <= 1);
        return (((r * HEX_FULL_CHANNEL) << SHIFT_RED) ^
            ((g * HEX_FULL_CHANNEL) << SHIFT_GREEN) ^
            ((b * HEX_FULL_CHANNEL) << SHIFT_BLUE));
    }
    ColorUtils.getHexFromRgb = getHexFromRgb;
    /**
     * Encode and convert HSL value to number coded color format (0xRRGGBB).
     *
     * @see getHexFromRgb.
     * @param h Hue component value between 0 and 1.
     * @param s Saturation value between 0 and 1.
     * @param l Lightness channel between 0 and 1.
     */
    function getHexFromHsl(h, s, l) {
        harp_utils_1.assert(h >= 0 && h <= 1);
        harp_utils_1.assert(s >= 0 && s <= 1);
        harp_utils_1.assert(l >= 0 && l <= 1);
        return tmpColor.setHSL(h, s, l).getHex();
    }
    ColorUtils.getHexFromHsl = getHexFromHsl;
    /**
     * Retrieve RGBA channels separately from number encoded custom color format.
     *
     * Provides an easy way for channels extraction (r, g, b, a) from custom number coded color
     * format.
     *
     * @see getHexFromRgba.
     * @param hex The number encoded color value (0xRRGGBB or 0xTTRRGGBB in hex).
     * @returns r, g, b, a channels in simple object, where each channel value is saved as floating
     * point from 0 to 1 inclusively.
     */
    function getRgbaFromHex(hex) {
        harp_utils_1.assert((hex & ~HEX_TRGB_MASK) === 0, "Wrong hex format");
        return {
            r: ((hex >> SHIFT_RED) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL,
            g: ((hex >> SHIFT_GREEN) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL,
            b: ((hex >> SHIFT_BLUE) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL,
            a: (HEX_FULL_CHANNEL - ((hex >> SHIFT_TRANSPARENCY) & HEX_FULL_CHANNEL)) /
                HEX_FULL_CHANNEL
        };
    }
    ColorUtils.getRgbaFromHex = getRgbaFromHex;
    /**
     * Determines if number encoded color contains alpha (opacity) defined and different then 255.
     *
     * @param hex The number encoded color (0xRRGGBB or 0xTTRRGGBB in hex).
     * @returns True if color has transparency defined.
     */
    function hasAlphaInHex(hex) {
        harp_utils_1.assert((hex & ~HEX_TRGB_MASK) === 0, "Wrong hex format");
        return hex >> SHIFT_TRANSPARENCY !== 0;
    }
    ColorUtils.hasAlphaInHex = hasAlphaInHex;
    /**
     * Retrieves alpha color channel from hex encoded color value.
     *
     * @see getHexFromRgba.
     * @param hex The number encoded color value (representable as 0xRRGGBB or 0xTTRRGGBB in hex).
     * @returns The floating point alpha component in <0, 1> range.
     */
    function getAlphaFromHex(hex) {
        harp_utils_1.assert((hex & ~HEX_TRGB_MASK) === 0, "Wrong hex format");
        return (((HEX_FULL_CHANNEL - (hex >> SHIFT_TRANSPARENCY)) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL);
    }
    ColorUtils.getAlphaFromHex = getAlphaFromHex;
    /**
     * Remove transparency info from the number coded color, makes it compatible with external libs.
     *
     * @see getAlphaFromHex.
     * @param hex The number encoded color value (representable as 0xRRGGBB or 0xTTRRGGBB in hex).
     * @returns number coded color value representable as 0xRRGGBB in hex.
     */
    function removeAlphaFromHex(hex) {
        harp_utils_1.assert((hex & ~HEX_TRGB_MASK) === 0, "Wrong hex format");
        return hex & HEX_RGB_MASK;
    }
    ColorUtils.removeAlphaFromHex = removeAlphaFromHex;
})(ColorUtils = exports.ColorUtils || (exports.ColorUtils = {}));


/***/ }),

/***/ "../harp-datasource-protocol/lib/DecodedTile.ts":
/*!******************************************************!*\
  !*** ../harp-datasource-protocol/lib/DecodedTile.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
/**
 * Returns an array with the data type specified as parameter.
 *
 * @param attr specifies which type of data is being stored in the array
 */
function getArrayConstructor(attr) {
    switch (attr) {
        case "float":
            return Float32Array;
        case "uint8":
            return Uint8Array;
        case "uint16":
            return Uint16Array;
        case "uint32":
            return Uint32Array;
        case "int8":
            return Int8Array;
        case "int16":
            return Int16Array;
        case "int32":
            return Int32Array;
    }
}
exports.getArrayConstructor = getArrayConstructor;
/**
 * Geometry types supported by [[Geometry]] objects.
 */
var GeometryType;
(function (GeometryType) {
    GeometryType[GeometryType["Unspecified"] = 0] = "Unspecified";
    GeometryType[GeometryType["Point"] = 1] = "Point";
    GeometryType[GeometryType["Line"] = 2] = "Line";
    GeometryType[GeometryType["SolidLine"] = 3] = "SolidLine";
    GeometryType[GeometryType["Text"] = 4] = "Text";
    GeometryType[GeometryType["TextPath"] = 5] = "TextPath";
    GeometryType[GeometryType["ExtrudedLine"] = 6] = "ExtrudedLine";
    GeometryType[GeometryType["Polygon"] = 7] = "Polygon";
    GeometryType[GeometryType["ExtrudedPolygon"] = 8] = "ExtrudedPolygon";
    GeometryType[GeometryType["Object3D"] = 9] = "Object3D";
    GeometryType[GeometryType["Other"] = 1000] = "Other";
})(GeometryType = exports.GeometryType || (exports.GeometryType = {}));
/**
 * Returns the projection object specified in the parameter.
 *
 * @param projectionName string describing projection to be used
 */
function getProjection(projectionName) {
    switch (projectionName) {
        case "mercator":
            return harp_geoutils_1.mercatorProjection;
        case "webMercator":
            return harp_geoutils_1.webMercatorProjection;
        case "sphere":
            return harp_geoutils_1.sphereProjection;
        case "normalizedEquirectangular":
            return harp_geoutils_1.normalizedEquirectangularProjection;
        case "equirectangular":
            return harp_geoutils_1.equirectangularProjection;
        default:
            throw new Error(`Unknown projection ${projectionName}`);
    } // switch
}
exports.getProjection = getProjection;
/**
 * String with the projection's name.
 *
 * @param projection `Projection` object containing the name of the projection to retrieve
 */
function getProjectionName(projection) {
    if (projection === harp_geoutils_1.mercatorProjection) {
        return "mercator";
    }
    else if (projection === harp_geoutils_1.webMercatorProjection) {
        return "webMercator";
    }
    else if (projection === harp_geoutils_1.sphereProjection) {
        return "sphere";
    }
    else if (projection === harp_geoutils_1.normalizedEquirectangularProjection) {
        return "normalizedEquirectangular";
    }
    else if (projection === harp_geoutils_1.equirectangularProjection) {
        return "equirectangular";
    }
    throw new Error("Unknown projection");
}
exports.getProjectionName = getProjectionName;
/**
 * @returns Feature id from the provided attribute map.
 */
function getFeatureId(attributeMap) {
    if (attributeMap === undefined) {
        return 0;
    }
    if (typeof attributeMap === "number") {
        return attributeMap;
    }
    if (attributeMap.hasOwnProperty("$id")) {
        return attributeMap.$id;
    }
    return 0;
}
exports.getFeatureId = getFeatureId;


/***/ }),

/***/ "../harp-datasource-protocol/lib/Env.ts":
/*!**********************************************!*\
  !*** ../harp-datasource-protocol/lib/Env.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @hidden
 */
class Env {
    /**
     * Returns property in [[Env]] by name.
     *
     * @param name Name of property.
     */
    lookup(_name) {
        return undefined;
    }
    /**
     * Return an object containing all properties of this environment. (Here: empty object).
     */
    unmap() {
        return {};
    }
}
exports.Env = Env;
/**
 * Adds access to map specific environment properties.
 */
class MapEnv extends Env {
    constructor(entries, parent) {
        super();
        this.entries = entries;
        this.parent = parent;
    }
    /**
     * Returns property in [[Env]] by name.
     *
     * @param name Name of property.
     * @override
     */
    lookup(name) {
        if (this.entries.hasOwnProperty(name)) {
            const value = this.entries[name];
            if (value !== undefined) {
                return value;
            }
        }
        return this.parent ? this.parent.lookup(name) : undefined;
    }
    /**
     * Return an object containing all properties of this environment, takes care of the parent
     * object.
     * @override
     */
    unmap() {
        const obj = this.parent ? this.parent.unmap() : {};
        for (const key in this.entries) {
            if (this.entries.hasOwnProperty(key)) {
                obj[key] = this.entries[key];
            }
        }
        return obj;
    }
}
exports.MapEnv = MapEnv;


/***/ }),

/***/ "../harp-datasource-protocol/lib/ExponentialInterpolant.ts":
/*!*****************************************************************!*\
  !*** ../harp-datasource-protocol/lib/ExponentialInterpolant.ts ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const three_1 = __webpack_require__(/*! three */ "three");
class ExponentialInterpolant extends three_1.Interpolant {
    constructor() {
        super(...arguments);
        /**
         * Exponent value. Defaults to `2.0`.
         */
        this.exponent = 2.0;
    }
    // Note: We need to disable linting here as tslint thinks this function is never used, though it
    // indeed is called by ``Interpolant.evaluate(level)``.
    // tslint:disable-next-line
    interpolate_(i1, t0, t, t1) {
        const result = this.resultBuffer;
        // TODO: Remove when Interpolant types are fixed.
        const values = this.sampleValues;
        const stride = this.valueSize;
        const offset1 = i1 * stride;
        const offset0 = offset1 - stride;
        const weight1 = Math.pow((t - t0) / (t1 - t0), this.exponent);
        const weight0 = 1 - weight1;
        for (let i = 0; i !== stride; ++i) {
            result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
        }
        return result;
    }
}
exports.ExponentialInterpolant = ExponentialInterpolant;


/***/ }),

/***/ "../harp-datasource-protocol/lib/Expr.ts":
/*!***********************************************!*\
  !*** ../harp-datasource-protocol/lib/Expr.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const ExprEvaluator_1 = __webpack_require__(/*! ./ExprEvaluator */ "../harp-datasource-protocol/lib/ExprEvaluator.ts");
const ExprInstantiator_1 = __webpack_require__(/*! ./ExprInstantiator */ "../harp-datasource-protocol/lib/ExprInstantiator.ts");
const ExprParser_1 = __webpack_require__(/*! ./ExprParser */ "../harp-datasource-protocol/lib/ExprParser.ts");
const InterpolatedProperty_1 = __webpack_require__(/*! ./InterpolatedProperty */ "../harp-datasource-protocol/lib/InterpolatedProperty.ts");
const InterpolatedPropertyDefs_1 = __webpack_require__(/*! ./InterpolatedPropertyDefs */ "../harp-datasource-protocol/lib/InterpolatedPropertyDefs.ts");
const Theme_1 = __webpack_require__(/*! ./Theme */ "../harp-datasource-protocol/lib/Theme.ts");
__export(__webpack_require__(/*! ./Env */ "../harp-datasource-protocol/lib/Env.ts"));
const exprEvaluator = new ExprEvaluator_1.ExprEvaluator();
const exprInstantiator = new ExprInstantiator_1.ExprInstantiator();
/**
 * The dependencies of an [[Expr]].
 */
class ExprDependencies {
    constructor() {
        /**
         * The properties needed to evaluate the [[Expr]].
         */
        this.properties = new Set();
    }
}
exports.ExprDependencies = ExprDependencies;
class ComputeExprDependencies {
    /**
     * Gets the dependencies of an [[Expr]].
     *
     * @param expr The [[Expr]] to process.
     * @param scope The evaluation scope. Defaults to [[ExprScope.Value]].
     * @param dependencies The output [[Set]] of dependency names.
     */
    static of(expr) {
        const dependencies = new ExprDependencies();
        expr.accept(this.instance, dependencies);
        return dependencies;
    }
    visitNullLiteralExpr(expr, context) {
        // nothing to do
    }
    visitBooleanLiteralExpr(expr, context) {
        // nothing to do
    }
    visitNumberLiteralExpr(expr, context) {
        // nothing to do
    }
    visitStringLiteralExpr(expr, context) {
        // nothing to do
    }
    visitObjectLiteralExpr(expr, context) {
        // nothing to do
    }
    visitVarExpr(expr, context) {
        context.properties.add(expr.name);
    }
    visitHasAttributeExpr(expr, context) {
        context.properties.add(expr.name);
    }
    visitContainsExpr(expr, context) {
        expr.value.accept(this, context);
    }
    visitCallExpr(expr, context) {
        if (expr.op === "zoom" && expr.args.length === 0) {
            context.zoom = true;
        }
        else {
            expr.args.forEach(childExpr => childExpr.accept(this, context));
        }
    }
    visitMatchExpr(expr, context) {
        expr.value.accept(this, context);
        expr.branches.forEach(([_, branch]) => branch.accept(this, context));
        expr.fallback.accept(this, context);
    }
    visitCaseExpr(expr, context) {
        expr.branches.forEach(([condition, branch]) => {
            condition.accept(this, context);
            branch.accept(this, context);
        });
        expr.fallback.accept(this, context);
    }
}
ComputeExprDependencies.instance = new ComputeExprDependencies();
function isJsonExpr(v) {
    return Array.isArray(v) && v.length > 0 && typeof v[0] === "string";
}
exports.isJsonExpr = isJsonExpr;
/**
 * The evaluation scope of an [[Expr]].
 */
var ExprScope;
(function (ExprScope) {
    /**
     * The scope of an [[Expr]] used as value of an attribute.
     */
    ExprScope[ExprScope["Value"] = 0] = "Value";
    /**
     * The scope of an [[Expr]] used in a [[Technique]] `when` condition.
     */
    ExprScope[ExprScope["Condition"] = 1] = "Condition";
    /**
     * The scope of an [[Expr]] used as dynamic property attribute value.
     */
    ExprScope[ExprScope["Dynamic"] = 2] = "Dynamic";
})(ExprScope = exports.ExprScope || (exports.ExprScope = {}));
/**
 * Abstract class defining a shape of a [[Theme]]'s expression
 */
class Expr {
    /**
     * Tests of given value is an [[Expr]].
     *
     * @param value The object to test.
     */
    static isExpr(value) {
        return value instanceof Expr;
    }
    /**
     * Creates an expression from the given `code`.
     *
     * @param code The code to parse.
     * @returns The parsed [[Expr]].
     * @deprecated
     */
    static parse(code) {
        const parser = new ExprParser_1.ExprParser(code);
        const expr = parser.parse();
        return expr;
    }
    /**
     * Parse expression in JSON form.
     *
     * If `definitions` are defined, then references (`['ref', name]`) are resolved.
     *
     * Pass `definitionExprCache` to reuse `Expr` instances created from definitions across
     * many `fromJSON` calls.
     *
     * @param node expression in JSON format to parse
     * @param definitions optional set of definitions needed definition resolved by `ref` operator
     * @param definitionExprCache optional cache of `Expr` instances derived from `definitions`
     */
    static fromJSON(node, definitions, definitionExprCache) {
        const referenceResolverState = definitions !== undefined
            ? {
                definitions,
                lockedNames: new Set(),
                cache: definitionExprCache || new Map()
            }
            : undefined;
        return parseNode(node, referenceResolverState);
    }
    /**
     * Evaluate an expression returning a [[Value]] object.
     *
     * @param env The [[Env]] used to lookup symbols.
     * @param scope The evaluation scope. Defaults to [[ExprScope.Value]].
     * @param cache A cache of previously computed results.
     */
    evaluate(env, scope = ExprScope.Value, cache) {
        return this.accept(exprEvaluator, new ExprEvaluator_1.ExprEvaluatorContext(exprEvaluator, env, scope, cache));
    }
    /**
     * Instantiates this [[Expr]] by resolving references to the `get` and
     * `has` operator using the given instantiation context.
     *
     * @param context The [[InstantationContext]] used to resolve names.
     */
    instantiate(context) {
        return this.accept(exprInstantiator, context);
    }
    /**
     * Gets the dependencies of this [[Expr]].
     */
    dependencies() {
        if (!this.m_dependencies) {
            this.m_dependencies = ComputeExprDependencies.of(this);
        }
        return this.m_dependencies;
    }
    /**
     * Create a unique object that is structurally equivalent to this [[Expr]].
     *
     * @param pool The [[ExprPool]] used to create a unique
     * equivalent object of this [[Expr]].
     */
    intern(pool) {
        return pool.add(this);
    }
    toJSON() {
        return new ExprSerializer().serialize(this);
    }
    /**
     * Returns `true` if a dynamic execution context is required to evaluate this [[Expr]].
     */
    isDynamic() {
        if (this.m_isDynamic === undefined) {
            this.m_isDynamic = this.exprIsDynamic();
        }
        return this.m_isDynamic;
    }
}
exports.Expr = Expr;
/**
 * Var expression.
 * @hidden
 */
class VarExpr extends Expr {
    constructor(name) {
        super();
        this.name = name;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitVarExpr(this, context);
    }
    /** @override */
    exprIsDynamic() {
        return false;
    }
}
exports.VarExpr = VarExpr;
class LiteralExpr extends Expr {
    /**
     * Create a [[LiteralExpr]] from the given value.
     *
     * @param value A constant value.
     */
    static fromValue(value) {
        switch (typeof value) {
            case "boolean":
                return new BooleanLiteralExpr(value);
            case "number":
                return new NumberLiteralExpr(value);
            case "string":
                return new StringLiteralExpr(value);
            case "object":
                return value === null ? NullLiteralExpr.instance : new ObjectLiteralExpr(value);
            default:
                throw new Error(`failed to create a literal from '${value}'`);
        } // switch
    }
    /** @override */
    exprIsDynamic() {
        return false;
    }
}
exports.LiteralExpr = LiteralExpr;
/**
 * Null literal expression.
 * @hidden
 */
class NullLiteralExpr extends LiteralExpr {
    constructor() {
        super();
        /** @override */
        this.value = null;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitNullLiteralExpr(this, context);
    }
    /** @override */
    exprIsDynamic() {
        return false;
    }
}
exports.NullLiteralExpr = NullLiteralExpr;
NullLiteralExpr.instance = new NullLiteralExpr();
/**
 * Boolean literal expression.
 * @hidden
 */
class BooleanLiteralExpr extends LiteralExpr {
    constructor(value) {
        super();
        this.value = value;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitBooleanLiteralExpr(this, context);
    }
}
exports.BooleanLiteralExpr = BooleanLiteralExpr;
/**
 * Number literal expression.
 * @hidden
 */
class NumberLiteralExpr extends LiteralExpr {
    constructor(value) {
        super();
        this.value = value;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitNumberLiteralExpr(this, context);
    }
}
exports.NumberLiteralExpr = NumberLiteralExpr;
/**
 * String literal expression.
 * @hidden
 */
class StringLiteralExpr extends LiteralExpr {
    constructor(value) {
        super();
        this.value = value;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitStringLiteralExpr(this, context);
    }
}
exports.StringLiteralExpr = StringLiteralExpr;
/**
 * Object literal expression.
 * @hidden
 */
class ObjectLiteralExpr extends LiteralExpr {
    constructor(value) {
        super();
        this.value = value;
    }
    get isArrayLiteral() {
        return Array.isArray(this.value);
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitObjectLiteralExpr(this, context);
    }
}
exports.ObjectLiteralExpr = ObjectLiteralExpr;
/**
 * A has expression with an attribute, for example `has(ref)`.
 * @hidden
 */
class HasAttributeExpr extends Expr {
    constructor(name) {
        super();
        this.name = name;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitHasAttributeExpr(this, context);
    }
    /** @override */
    exprIsDynamic() {
        return false;
    }
}
exports.HasAttributeExpr = HasAttributeExpr;
/**
 * A contains expression.
 * @hidden
 */
class ContainsExpr extends Expr {
    constructor(value, elements) {
        super();
        this.value = value;
        this.elements = elements;
    }
    static isValidElementsArray(elements) {
        if (!Array.isArray(elements) || elements.length === 0) {
            return false;
        }
        const elementTy = typeof elements[0];
        if (elementTy === "number" || elementTy === "string") {
            return elements.every(element => typeof element === elementTy);
        }
        return false;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitContainsExpr(this, context);
    }
    /** @override */
    exprIsDynamic() {
        return this.value.isDynamic();
    }
}
exports.ContainsExpr = ContainsExpr;
/**
 * @hidden
 */
class CallExpr extends Expr {
    constructor(op, args) {
        super();
        this.op = op;
        this.args = args;
    }
    /**
     * Returns the child nodes of this [[Expr]].
     * @deprecated
     */
    get children() {
        return this.args;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitCallExpr(this, context);
    }
    /** @override */
    exprIsDynamic() {
        const descriptor = this.descriptor || ExprEvaluator_1.ExprEvaluator.getOperator(this.op);
        if (descriptor && descriptor.isDynamicOperator && descriptor.isDynamicOperator(this)) {
            return true;
        }
        return this.args.some(e => e.isDynamic());
    }
}
exports.CallExpr = CallExpr;
/**
 * @hidden
 */
class MatchExpr extends Expr {
    constructor(value, branches, fallback) {
        super();
        this.value = value;
        this.branches = branches;
        this.fallback = fallback;
    }
    /**
     * Tests if the given JSON node is a valid label for the `"match"` operator.
     *
     * @param node A JSON value.
     */
    static isValidMatchLabel(node) {
        switch (typeof node) {
            case "number":
            case "string":
                return true;
            case "object":
                if (!Array.isArray(node) || node.length === 0) {
                    return false;
                }
                const elementTy = typeof node[0];
                if (elementTy === "number" || elementTy === "string") {
                    return node.every(t => typeof t === elementTy);
                }
                return false;
            default:
                return false;
        } // switch
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitMatchExpr(this, context);
    }
    /** @override */
    exprIsDynamic() {
        return (this.value.isDynamic() ||
            this.branches.some(([_, branch]) => branch.isDynamic()) ||
            this.fallback.isDynamic());
    }
}
exports.MatchExpr = MatchExpr;
/**
 * @hidden
 */
class CaseExpr extends Expr {
    constructor(branches, fallback) {
        super();
        this.branches = branches;
        this.fallback = fallback;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitCaseExpr(this, context);
    }
    /** @override */
    exprIsDynamic() {
        return (this.branches.some(([cond, branch]) => cond.isDynamic() || branch.isDynamic()) ||
            this.fallback.isDynamic());
    }
}
exports.CaseExpr = CaseExpr;
/**
 * @hidden
 */
class ExprSerializer {
    serialize(expr) {
        return expr.accept(this, undefined);
    }
    visitNullLiteralExpr(expr, context) {
        return null;
    }
    visitBooleanLiteralExpr(expr, context) {
        return expr.value;
    }
    visitNumberLiteralExpr(expr, context) {
        return expr.value;
    }
    visitStringLiteralExpr(expr, context) {
        return expr.value;
    }
    visitObjectLiteralExpr(expr, context) {
        return ["literal", expr.value];
    }
    visitVarExpr(expr, context) {
        return ["get", expr.name];
    }
    visitHasAttributeExpr(expr, context) {
        return ["has", expr.name];
    }
    visitContainsExpr(expr, context) {
        return ["in", this.serialize(expr.value), expr.elements];
    }
    visitCallExpr(expr, context) {
        return [expr.op, ...expr.args.map(childExpr => this.serialize(childExpr))];
    }
    visitMatchExpr(expr, context) {
        const branches = [];
        for (const [label, body] of expr.branches) {
            branches.push(label, this.serialize(body));
        }
        return ["match", this.serialize(expr.value), ...branches, this.serialize(expr.fallback)];
    }
    visitCaseExpr(expr, context) {
        const branches = [];
        for (const [condition, body] of expr.branches) {
            branches.push(this.serialize(condition), this.serialize(body));
        }
        return ["case", ...branches, this.serialize(expr.fallback)];
    }
}
function parseNode(node, referenceResolverState) {
    if (Array.isArray(node)) {
        return parseCall(node, referenceResolverState);
    }
    else if (node === null) {
        return NullLiteralExpr.instance;
    }
    else if (typeof node === "boolean") {
        return new BooleanLiteralExpr(node);
    }
    else if (typeof node === "number") {
        return new NumberLiteralExpr(node);
    }
    else if (typeof node === "string") {
        return new StringLiteralExpr(node);
    }
    throw new Error(`failed to create expression from: ${JSON.stringify(node)}`);
}
function parseCall(node, referenceResolverState) {
    const op = node[0];
    if (typeof op !== "string") {
        throw new Error("expected a builtin function name");
    }
    switch (op) {
        case "!has":
        case "!in":
            return new CallExpr("!", [parseCall([op.slice(1), ...node.slice(1)])]);
        case "ref":
            return resolveReference(node, referenceResolverState);
        case "get":
            return parseGetExpr(node, referenceResolverState);
        case "has":
            return parseHasExpr(node, referenceResolverState);
        case "in":
            return parseInExpr(node, referenceResolverState);
        case "literal":
            return parseLiteralExpr(node);
        case "match":
            return parseMatchExpr(node, referenceResolverState);
        case "case":
            return parseCaseExpr(node, referenceResolverState);
        default:
            return makeCallExpr(op, node, referenceResolverState);
    } // switch
}
function parseGetExpr(node, referenceResolverState) {
    if (node[2] !== undefined) {
        return makeCallExpr("get", node, referenceResolverState);
    }
    const name = node[1];
    if (typeof name !== "string") {
        throw new Error(`expected the name of an attribute`);
    }
    return new VarExpr(name);
}
function parseHasExpr(node, referenceResolverState) {
    if (node[2] !== undefined) {
        return makeCallExpr("has", node, referenceResolverState);
    }
    const name = node[1];
    if (typeof name !== "string") {
        throw new Error(`expected the name of an attribute`);
    }
    return new HasAttributeExpr(name);
}
function parseInExpr(node, referenceResolverState) {
    const elements = node[2];
    if (!ContainsExpr.isValidElementsArray(elements)) {
        // tslint:disable-next-line: max-line-length
        throw new Error(`'in' expects an array of number or string literals`);
    }
    return new ContainsExpr(parseNode(node[1], referenceResolverState), elements);
}
function parseLiteralExpr(node) {
    const obj = node[1];
    if (obj === null || typeof obj !== "object") {
        throw new Error("expected an object or array literal");
    }
    return new ObjectLiteralExpr(obj);
}
function parseMatchExpr(node, referenceResolverState) {
    if (node.length < 4) {
        throw new Error("not enough arguments");
    }
    if (!(node.length % 2)) {
        throw new Error("fallback is missing in 'match' expression");
    }
    const value = parseNode(node[1], referenceResolverState);
    const conditions = [];
    for (let i = 2; i < node.length - 1; i += 2) {
        const label = node[i];
        if (!MatchExpr.isValidMatchLabel(label)) {
            throw new Error(`'${JSON.stringify(label)}' is not a valid label for 'match'`);
        }
        const expr = parseNode(node[i + 1], referenceResolverState);
        conditions.push([label, expr]);
    }
    const fallback = parseNode(node[node.length - 1], referenceResolverState);
    return new MatchExpr(value, conditions, fallback);
}
function parseCaseExpr(node, referenceResolverState) {
    if (node.length < 3) {
        throw new Error("not enough arguments");
    }
    if (node.length % 2) {
        throw new Error("fallback is missing in 'case' expression");
    }
    const branches = [];
    for (let i = 1; i < node.length - 1; i += 2) {
        const condition = parseNode(node[i], referenceResolverState);
        const expr = parseNode(node[i + 1], referenceResolverState);
        branches.push([condition, expr]);
    }
    const caseFallback = parseNode(node[node.length - 1], referenceResolverState);
    return new CaseExpr(branches, caseFallback);
}
function makeCallExpr(op, node, referenceResolverState) {
    return new CallExpr(op, node.slice(1).map(childExpr => parseNode(childExpr, referenceResolverState)));
}
function resolveReference(node, referenceResolverState) {
    if (typeof node[1] !== "string") {
        throw new Error(`expected the name of an attribute`);
    }
    if (referenceResolverState === undefined) {
        throw new Error(`ref used with no definitions`);
    }
    const name = node[1];
    if (referenceResolverState.lockedNames.has(name)) {
        throw new Error(`circular referene to '${name}'`);
    }
    if (!(name in referenceResolverState.definitions)) {
        throw new Error(`definition '${name}' not found`);
    }
    const cachedEntry = referenceResolverState.cache.get(name);
    if (cachedEntry !== undefined) {
        return cachedEntry;
    }
    let definitionEntry = referenceResolverState.definitions[name];
    let result;
    if (Theme_1.isLiteralDefinition(definitionEntry)) {
        return Expr.fromJSON(definitionEntry);
    }
    else if (Theme_1.isBoxedDefinition(definitionEntry)) {
        if (InterpolatedProperty_1.isInterpolatedPropertyDefinition(definitionEntry.value)) {
            // found a reference to an interpolation using
            // the deprecated object-like syntax.
            return Expr.fromJSON(InterpolatedPropertyDefs_1.interpolatedPropertyDefinitionToJsonExpr(definitionEntry.value));
        }
        else if (isJsonExpr(definitionEntry.value)) {
            definitionEntry = definitionEntry.value;
        }
        else {
            return Expr.fromJSON(definitionEntry.value);
        }
    }
    if (isJsonExpr(definitionEntry)) {
        referenceResolverState.lockedNames.add(name);
        try {
            result = parseNode(definitionEntry, referenceResolverState);
        }
        finally {
            referenceResolverState.lockedNames.delete(name);
        }
    }
    else {
        throw new Error(`unsupported definition ${name}`);
    }
    referenceResolverState.cache.set(name, result);
    return result;
}


/***/ }),

/***/ "../harp-datasource-protocol/lib/ExprEvaluator.ts":
/*!********************************************************!*\
  !*** ../harp-datasource-protocol/lib/ExprEvaluator.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Expr_1 = __webpack_require__(/*! ./Expr */ "../harp-datasource-protocol/lib/Expr.ts");
const ArrayOperators_1 = __webpack_require__(/*! ./operators/ArrayOperators */ "../harp-datasource-protocol/lib/operators/ArrayOperators.ts");
const CastOperators_1 = __webpack_require__(/*! ./operators/CastOperators */ "../harp-datasource-protocol/lib/operators/CastOperators.ts");
const ColorOperators_1 = __webpack_require__(/*! ./operators/ColorOperators */ "../harp-datasource-protocol/lib/operators/ColorOperators.ts");
const ComparisonOperators_1 = __webpack_require__(/*! ./operators/ComparisonOperators */ "../harp-datasource-protocol/lib/operators/ComparisonOperators.ts");
const FeatureOperators_1 = __webpack_require__(/*! ./operators/FeatureOperators */ "../harp-datasource-protocol/lib/operators/FeatureOperators.ts");
const FlowOperators_1 = __webpack_require__(/*! ./operators/FlowOperators */ "../harp-datasource-protocol/lib/operators/FlowOperators.ts");
const InterpolationOperators_1 = __webpack_require__(/*! ./operators/InterpolationOperators */ "../harp-datasource-protocol/lib/operators/InterpolationOperators.ts");
const MapOperators_1 = __webpack_require__(/*! ./operators/MapOperators */ "../harp-datasource-protocol/lib/operators/MapOperators.ts");
const MathOperators_1 = __webpack_require__(/*! ./operators/MathOperators */ "../harp-datasource-protocol/lib/operators/MathOperators.ts");
const MiscOperators_1 = __webpack_require__(/*! ./operators/MiscOperators */ "../harp-datasource-protocol/lib/operators/MiscOperators.ts");
const ObjectOperators_1 = __webpack_require__(/*! ./operators/ObjectOperators */ "../harp-datasource-protocol/lib/operators/ObjectOperators.ts");
const StringOperators_1 = __webpack_require__(/*! ./operators/StringOperators */ "../harp-datasource-protocol/lib/operators/StringOperators.ts");
const TypeOperators_1 = __webpack_require__(/*! ./operators/TypeOperators */ "../harp-datasource-protocol/lib/operators/TypeOperators.ts");
const operatorDescriptors = new Map();
/*
 * @hidden
 */
class ExprEvaluatorContext {
    constructor(evaluator, env, scope, cache) {
        this.evaluator = evaluator;
        this.env = env;
        this.scope = scope;
        this.cache = cache;
        this.m_partialEvaluation = false;
    }
    /**
     * `true` if the this context is used to partially evaluate expressions.
     */
    get partialEvaluation() {
        return this.m_partialEvaluation;
    }
    /**
     * Evaluate the given expression.
     *
     * @param expr The [[Expr]] to evaluate.
     */
    evaluate(expr) {
        if (expr !== undefined) {
            return expr.accept(this.evaluator, this);
        }
        throw new Error("Failed to evaluate expression");
    }
    /**
     * Partially evaluate the given expression.
     *
     * @param expr The [[Expr]] to evaluate.
     */
    partiallyEvaluate(expr) {
        if (expr === undefined) {
            throw new Error("Failed to evaluate expression");
        }
        const previousEvaluationMode = this.m_partialEvaluation;
        this.m_partialEvaluation = true;
        try {
            const value = expr.accept(this.evaluator, this);
            this.m_partialEvaluation = previousEvaluationMode;
            if (value instanceof Expr_1.Expr) {
                return value;
            }
            return Expr_1.LiteralExpr.fromValue(value);
        }
        catch (error) {
            // rethrow the exception
            throw error;
        }
        finally {
            // reset the evaluation mode.
            this.m_partialEvaluation = previousEvaluationMode;
        }
    }
}
exports.ExprEvaluatorContext = ExprEvaluatorContext;
/**
 * [[ExprEvaluator]] is used to evaluate [[Expr]] in a given environment.
 *
 * @hidden
 */
class ExprEvaluator {
    static defineOperator(op, builtin) {
        operatorDescriptors.set(op, builtin);
    }
    static defineOperators(builtins) {
        Object.getOwnPropertyNames(builtins).forEach(p => {
            this.defineOperator(p, builtins[p]);
        });
    }
    /**
     * Returns the [[OperatorDescriptor]] for the given operator name.
     * @hidden
     */
    static getOperator(op) {
        return operatorDescriptors.get(op);
    }
    visitVarExpr(expr, context) {
        const value = context.env.lookup(expr.name);
        return value !== undefined ? value : null;
    }
    visitNullLiteralExpr(expr, context) {
        return null;
    }
    visitBooleanLiteralExpr(expr, context) {
        return expr.value;
    }
    visitNumberLiteralExpr(expr, context) {
        return expr.value;
    }
    visitStringLiteralExpr(expr, context) {
        return expr.value;
    }
    visitObjectLiteralExpr(expr, context) {
        return expr.value;
    }
    visitHasAttributeExpr(expr, context) {
        return context.env.lookup(expr.name) !== undefined;
    }
    visitContainsExpr(expr, context) {
        const value = expr.value.accept(this, context);
        const result = expr.elements.includes(value);
        if (context.cache !== undefined) {
            context.cache.set(expr, result);
        }
        return result;
    }
    visitMatchExpr(match, context) {
        const r = context.evaluate(match.value);
        for (const [label, body] of match.branches) {
            if (Array.isArray(label) && label.includes(r)) {
                return context.evaluate(body);
            }
            else if (label === r) {
                return context.evaluate(body);
            }
        }
        return context.evaluate(match.fallback);
    }
    visitCaseExpr(match, context) {
        for (const [condition, body] of match.branches) {
            if (context.evaluate(condition)) {
                return context.evaluate(body);
            }
        }
        return context.evaluate(match.fallback);
    }
    visitCallExpr(expr, context) {
        if (context.cache !== undefined) {
            const v = context.cache.get(expr);
            if (v !== undefined) {
                return v;
            }
        }
        const descriptor = expr.descriptor || operatorDescriptors.get(expr.op);
        if (descriptor) {
            expr.descriptor = descriptor;
            const result = descriptor.call(context, expr);
            if (context.cache) {
                context.cache.set(expr, result);
            }
            return result;
        }
        throw new Error(`undefined operator '${expr.op}`);
    }
}
exports.ExprEvaluator = ExprEvaluator;
ExprEvaluator.defineOperators(CastOperators_1.CastOperators);
ExprEvaluator.defineOperators(ComparisonOperators_1.ComparisonOperators);
ExprEvaluator.defineOperators(MathOperators_1.MathOperators);
ExprEvaluator.defineOperators(StringOperators_1.StringOperators);
ExprEvaluator.defineOperators(ColorOperators_1.ColorOperators);
ExprEvaluator.defineOperators(TypeOperators_1.TypeOperators);
ExprEvaluator.defineOperators(MiscOperators_1.MiscOperators);
ExprEvaluator.defineOperators(FlowOperators_1.FlowOperators);
ExprEvaluator.defineOperators(ArrayOperators_1.ArrayOperators);
ExprEvaluator.defineOperators(InterpolationOperators_1.InterpolationOperators);
ExprEvaluator.defineOperators(ObjectOperators_1.ObjectOperators);
ExprEvaluator.defineOperators(FeatureOperators_1.FeatureOperators);
ExprEvaluator.defineOperators(MapOperators_1.MapOperators);


/***/ }),

/***/ "../harp-datasource-protocol/lib/ExprInstantiator.ts":
/*!***********************************************************!*\
  !*** ../harp-datasource-protocol/lib/ExprInstantiator.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Expr_1 = __webpack_require__(/*! ./Expr */ "../harp-datasource-protocol/lib/Expr.ts");
const Env_1 = __webpack_require__(/*! ./Env */ "../harp-datasource-protocol/lib/Env.ts");
const emptyEnv = new Env_1.Env();
/**
 * @hidden
 */
class ExprInstantiator {
    visitNullLiteralExpr(expr, _context) {
        return expr;
    }
    visitBooleanLiteralExpr(expr, _context) {
        return expr;
    }
    visitNumberLiteralExpr(expr, _context) {
        return expr;
    }
    visitStringLiteralExpr(expr, _context) {
        return expr;
    }
    visitObjectLiteralExpr(expr, _context) {
        return expr;
    }
    visitVarExpr(expr, context) {
        if (context.preserve && context.preserve.has(expr.name)) {
            return expr;
        }
        const value = context.env.lookup(expr.name);
        return Expr_1.LiteralExpr.fromValue(value !== undefined ? value : null);
    }
    visitHasAttributeExpr(expr, context) {
        if (context.preserve && context.preserve.has(expr.name)) {
            return expr;
        }
        const value = context.env.lookup(expr.name) !== undefined;
        return Expr_1.LiteralExpr.fromValue(value);
    }
    visitContainsExpr(expr, context) {
        const value = expr.value.accept(this, context);
        if (value instanceof Expr_1.LiteralExpr) {
            const result = expr.elements.includes(value.value);
            return Expr_1.LiteralExpr.fromValue(result);
        }
        return value === expr.value ? expr : new Expr_1.ContainsExpr(value, expr.elements);
    }
    visitCallExpr(expr, context) {
        const args = expr.args.map(arg => arg.accept(this, context));
        if (args.some((a, i) => a !== expr.args[i])) {
            return new Expr_1.CallExpr(expr.op, args);
        }
        return expr;
    }
    visitMatchExpr(match, context) {
        const value = match.value.accept(this, context);
        if (value instanceof Expr_1.LiteralExpr) {
            const r = value.value;
            for (const [label, body] of match.branches) {
                if (Array.isArray(label) && label.includes(r)) {
                    return body.accept(this, context);
                }
                else if (label === r) {
                    return body.accept(this, context);
                }
            }
            return match.fallback.accept(this, context);
        }
        let changed = match.value !== value;
        const branches = match.branches.map(([label, branch]) => {
            const newBranch = branch.accept(this, context);
            if (newBranch !== branch) {
                changed = true;
            }
            return [label, newBranch];
        });
        const fallback = match.fallback.accept(this, context);
        if (fallback !== match.fallback) {
            changed = true;
        }
        return changed ? new Expr_1.MatchExpr(value, branches, fallback) : match;
    }
    visitCaseExpr(expr, context) {
        const branches = [];
        let changed = false;
        for (const [condition, branch] of expr.branches) {
            const newCondition = condition.accept(this, context);
            const deps = newCondition.dependencies();
            if (!deps.zoom && deps.properties.size === 0) {
                if (Boolean(newCondition.evaluate(emptyEnv, Expr_1.ExprScope.Condition))) {
                    return branch.accept(this, context);
                }
            }
            else {
                if (newCondition !== condition) {
                    changed = true;
                }
                branches.push([newCondition, branch]);
            }
        }
        if (branches.length === 0) {
            // all the conditions of this CaseExpr evaluated
            // to false, so the resulting of instantiating this CaseExpr
            // is the same as instantiating its fallback expression.
            return expr.fallback.accept(this, context);
        }
        if (branches.length !== expr.branches.length) {
            // the number of branches changed, this means that
            // some of the branches had constant expressions that
            // evaluate to false. In this case the resulting
            // `CaseExpr` has less branches.
            changed = true;
        }
        // Instantiate the body of all the branches of this CaseExpr
        // that have dynamic conditions.
        branches.forEach(branch => {
            const instantiatedBranch = branch[1].accept(this, context);
            if (instantiatedBranch !== branch[1]) {
                changed = true;
            }
            branch[1] = instantiatedBranch;
        });
        const fallback = expr.fallback.accept(this, context);
        if (fallback !== expr.fallback) {
            changed = true;
        }
        if (!changed) {
            // nothing changed, return the old expression.
            return expr;
        }
        return new Expr_1.CaseExpr(branches, fallback);
    }
}
exports.ExprInstantiator = ExprInstantiator;


/***/ }),

/***/ "../harp-datasource-protocol/lib/ExprParser.ts":
/*!*****************************************************!*\
  !*** ../harp-datasource-protocol/lib/ExprParser.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Expr_1 = __webpack_require__(/*! ./Expr */ "../harp-datasource-protocol/lib/Expr.ts");
/**
 * Character value
 */
var Character;
(function (Character) {
    Character[Character["Tab"] = 9] = "Tab";
    Character[Character["Lf"] = 10] = "Lf";
    Character[Character["Cr"] = 13] = "Cr";
    Character[Character["Space"] = 32] = "Space";
    Character[Character["LParen"] = 40] = "LParen";
    Character[Character["RParen"] = 41] = "RParen";
    Character[Character["Comma"] = 44] = "Comma";
    Character[Character["Dot"] = 46] = "Dot";
    Character[Character["LBracket"] = 91] = "LBracket";
    Character[Character["Backslash"] = 92] = "Backslash";
    Character[Character["RBracket"] = 93] = "RBracket";
    Character[Character["_0"] = 48] = "_0";
    Character[Character["_9"] = 57] = "_9";
    Character[Character["_"] = 95] = "_";
    Character[Character["A"] = 64] = "A";
    Character[Character["Z"] = 90] = "Z";
    Character[Character["a"] = 97] = "a";
    Character[Character["z"] = 122] = "z";
    Character[Character["DoubleQuote"] = 34] = "DoubleQuote";
    Character[Character["SingleQuote"] = 39] = "SingleQuote";
    Character[Character["Exclaim"] = 33] = "Exclaim";
    Character[Character["Equal"] = 61] = "Equal";
    Character[Character["Caret"] = 94] = "Caret";
    Character[Character["Tilde"] = 126] = "Tilde";
    Character[Character["Dollar"] = 36] = "Dollar";
    Character[Character["Less"] = 60] = "Less";
    Character[Character["Greater"] = 62] = "Greater";
    Character[Character["Bar"] = 124] = "Bar";
    Character[Character["Amp"] = 38] = "Amp";
})(Character || (Character = {}));
/**
 * Check if a codepoint is a whitespace character.
 */
function isSpace(codepoint) {
    switch (codepoint) {
        case Character.Tab:
        case Character.Lf:
        case Character.Cr:
        case Character.Space:
            return true;
        default:
            return false;
    } // switch
}
/**
 * Check if codepoint is a digit character.
 */
function isNumber(codepoint) {
    return codepoint >= Character._0 && codepoint <= Character._9;
}
/**
 * Check if codepoint is a letter character.
 */
function isLetter(codepoint) {
    return ((codepoint >= Character.a && codepoint <= Character.z) ||
        (codepoint >= Character.A && codepoint <= Character.Z));
}
/**
 * Check if codepoint is either a digit or a letter character.
 */
function isLetterOrNumber(codepoint) {
    return isLetter(codepoint) || isNumber(codepoint);
}
/**
 * Check if codepoint is an identification character: underscore, dollar sign, dot or bracket.
 */
function isIdentChar(codepoint) {
    return (isLetterOrNumber(codepoint) ||
        codepoint === Character._ ||
        codepoint === Character.Dollar ||
        codepoint === Character.Dot ||
        codepoint === Character.LBracket ||
        codepoint === Character.RBracket);
}
/**
 * Tokens used in theme grammar.
 */
var Token;
(function (Token) {
    Token[Token["Eof"] = 0] = "Eof";
    Token[Token["Error"] = 1] = "Error";
    Token[Token["Identifier"] = 2] = "Identifier";
    Token[Token["Number"] = 3] = "Number";
    Token[Token["String"] = 4] = "String";
    Token[Token["Comma"] = 5] = "Comma";
    Token[Token["LParen"] = 6] = "LParen";
    Token[Token["RParen"] = 7] = "RParen";
    Token[Token["LBracket"] = 8] = "LBracket";
    Token[Token["RBracket"] = 9] = "RBracket";
    Token[Token["Exclaim"] = 10] = "Exclaim";
    Token[Token["TildeEqual"] = 11] = "TildeEqual";
    Token[Token["CaretEqual"] = 12] = "CaretEqual";
    Token[Token["DollarEqual"] = 13] = "DollarEqual";
    Token[Token["EqualEqual"] = 14] = "EqualEqual";
    Token[Token["ExclaimEqual"] = 15] = "ExclaimEqual";
    Token[Token["Less"] = 16] = "Less";
    Token[Token["Greater"] = 17] = "Greater";
    Token[Token["LessEqual"] = 18] = "LessEqual";
    Token[Token["GreaterEqual"] = 19] = "GreaterEqual";
    Token[Token["BarBar"] = 20] = "BarBar";
    Token[Token["AmpAmp"] = 21] = "AmpAmp";
})(Token || (Token = {}));
/**
 * Maps a token to its string name.
 */
function tokenSpell(token) {
    switch (token) {
        case Token.Eof:
            return "eof";
        case Token.Error:
            return "error";
        case Token.Identifier:
            return "identifier";
        case Token.Number:
            return "number";
        case Token.String:
            return "string";
        case Token.Comma:
            return ",";
        case Token.LParen:
            return "(";
        case Token.RParen:
            return ")";
        case Token.LBracket:
            return "[";
        case Token.RBracket:
            return "]";
        case Token.Exclaim:
            return "!";
        case Token.TildeEqual:
            return "~=";
        case Token.CaretEqual:
            return "^=";
        case Token.DollarEqual:
            return "$=";
        case Token.EqualEqual:
            return "==";
        case Token.ExclaimEqual:
            return "!=";
        case Token.Less:
            return "<";
        case Token.Greater:
            return ">";
        case Token.LessEqual:
            return "<=";
        case Token.GreaterEqual:
            return ">=";
        case Token.BarBar:
            return "||";
        case Token.AmpAmp:
            return "&&";
        default:
            throw new Error(`invalid token ${token}`);
    }
}
/**
 * Lexer class implementation.
 */
class Lexer {
    constructor(code) {
        this.code = code;
        this.m_token = Token.Error;
        this.m_index = 0;
        this.m_char = Character.Lf;
    }
    /**
     * Single lexer token.
     */
    token() {
        return this.m_token;
    }
    /**
     * Parsed text.
     */
    text() {
        return this.m_text || "";
    }
    /**
     * Go to the next token.
     */
    next() {
        this.m_token = this.yylex();
        if (this.m_token === Token.Error) {
            throw new Error(`unexpected character ${this.m_char}`);
        }
        return this.m_token;
    }
    yyinp() {
        this.m_char = this.code.codePointAt(this.m_index++) || 0;
    }
    yylex() {
        this.m_text = undefined;
        while (isSpace(this.m_char)) {
            this.yyinp();
        }
        if (this.m_char === 0) {
            return Token.Eof;
        }
        const ch = this.m_char;
        this.yyinp();
        switch (ch) {
            case Character.LParen:
                return Token.LParen;
            case Character.RParen:
                return Token.RParen;
            case Character.LBracket:
                return Token.LBracket;
            case Character.RBracket:
                return Token.RBracket;
            case Character.Comma:
                return Token.Comma;
            case Character.SingleQuote:
            case Character.DoubleQuote: {
                const start = this.m_index - 1;
                while (this.m_char && this.m_char !== ch) {
                    // ### TODO handle escape sequences
                    this.yyinp();
                }
                if (this.m_char !== ch) {
                    throw new Error("Unfinished string literal");
                }
                this.yyinp();
                this.m_text = this.code.substring(start, this.m_index - 2);
                return Token.String;
            }
            case Character.Exclaim:
                if (this.m_char === Character.Equal) {
                    this.yyinp();
                    return Token.ExclaimEqual;
                }
                return Token.Exclaim;
            case Character.Caret:
                if (this.m_char === Character.Equal) {
                    this.yyinp();
                    return Token.CaretEqual;
                }
                return Token.Error;
            case Character.Tilde:
                if (this.m_char === Character.Equal) {
                    this.yyinp();
                    return Token.TildeEqual;
                }
                return Token.Error;
            case Character.Equal:
                if (this.m_char === Character.Equal) {
                    this.yyinp();
                    return Token.EqualEqual;
                }
                return Token.Error;
            case Character.Less:
                if (this.m_char === Character.Equal) {
                    this.yyinp();
                    return Token.LessEqual;
                }
                return Token.Less;
            case Character.Greater:
                if (this.m_char === Character.Equal) {
                    this.yyinp();
                    return Token.GreaterEqual;
                }
                return Token.Greater;
            case Character.Bar:
                if (this.m_char === Character.Bar) {
                    this.yyinp();
                    return Token.BarBar;
                }
                return Token.Error;
            case Character.Amp:
                if (this.m_char === Character.Amp) {
                    this.yyinp();
                    return Token.AmpAmp;
                }
                return Token.Error;
            default: {
                const start = this.m_index - 2;
                if (isLetter(ch) ||
                    ch === Character._ ||
                    (ch === Character.Dollar && isIdentChar(this.m_char))) {
                    while (isIdentChar(this.m_char)) {
                        this.yyinp();
                    }
                    this.m_text = this.code.substring(start, this.m_index - 1);
                    return Token.Identifier;
                }
                else if (isNumber(ch)) {
                    while (isNumber(this.m_char)) {
                        this.yyinp();
                    }
                    if (this.m_char === Character.Dot) {
                        this.yyinp();
                        while (isNumber(this.m_char)) {
                            this.yyinp();
                        }
                    }
                    this.m_text = this.code.substring(start, this.m_index - 1);
                    return Token.Number;
                }
                else if (ch === Character.Dollar) {
                    if (this.m_char === Character.Equal) {
                        this.yyinp();
                        return Token.DollarEqual;
                    }
                    return Token.Error;
                }
            }
        }
        return Token.Error;
    }
}
function getEqualityOp(token) {
    switch (token) {
        case Token.TildeEqual:
            return "~=";
        case Token.CaretEqual:
            return "^=";
        case Token.DollarEqual:
            return "$=";
        case Token.EqualEqual:
            return "==";
        case Token.ExclaimEqual:
            return "!=";
        default:
            return undefined;
    } // switch
}
function getRelationalOp(token) {
    switch (token) {
        case Token.Less:
            return "<";
        case Token.Greater:
            return ">";
        case Token.LessEqual:
            return "<=";
        case Token.GreaterEqual:
            return ">=";
        default:
            return undefined;
    } // switch
}
class ExprParser {
    constructor(code) {
        this.lex = new Lexer(code);
        this.lex.next();
    }
    parse() {
        return this.parseLogicalOr();
    }
    yyexpect(token) {
        if (this.lex.token() !== token) {
            throw new Error(`Syntax error: Expected token '${tokenSpell(token)}' but ` +
                `found '${tokenSpell(this.lex.token())}'`);
        }
        this.lex.next();
    }
    parsePrimary() {
        switch (this.lex.token()) {
            case Token.Identifier: {
                const text = this.lex.text();
                switch (text) {
                    case "has":
                        this.lex.next(); // skip has keyword
                        this.yyexpect(Token.LParen);
                        const hasAttribute = this.lex.text();
                        this.yyexpect(Token.Identifier);
                        this.yyexpect(Token.RParen);
                        return new Expr_1.HasAttributeExpr(hasAttribute);
                    case "length":
                        this.lex.next(); // skip length keyword
                        this.yyexpect(Token.LParen);
                        const value = this.parseLogicalOr();
                        this.yyexpect(Token.RParen);
                        return new Expr_1.CallExpr("length", [value]);
                    default:
                        const expr = new Expr_1.VarExpr(text);
                        this.lex.next();
                        return expr;
                }
            }
            case Token.LParen: {
                this.lex.next();
                const expr = this.parseLogicalOr();
                this.yyexpect(Token.RParen);
                return expr;
            }
            default:
                return this.parseLiteral();
        } // switch
    }
    parseLiteral() {
        switch (this.lex.token()) {
            case Token.Number: {
                const expr = new Expr_1.NumberLiteralExpr(parseFloat(this.lex.text()));
                this.lex.next();
                return expr;
            }
            case Token.String: {
                const expr = new Expr_1.StringLiteralExpr(this.lex.text());
                this.lex.next();
                return expr;
            }
            default:
                throw new Error("Syntax error");
        } // switch
    }
    parseUnary() {
        if (this.lex.token() === Token.Exclaim) {
            this.lex.next();
            return new Expr_1.CallExpr("!", [this.parseUnary()]);
        }
        return this.parsePrimary();
    }
    parseRelational() {
        let expr = this.parseUnary();
        while (true) {
            if (this.lex.token() === Token.Identifier && this.lex.text() === "in") {
                this.lex.next();
                this.yyexpect(Token.LBracket);
                const elements = [this.parseLiteral()];
                while (this.lex.token() === Token.Comma) {
                    this.lex.next();
                    elements.push(this.parseLiteral());
                }
                this.yyexpect(Token.RBracket);
                expr = new Expr_1.ContainsExpr(expr, elements.map(literal => literal.value));
            }
            else {
                const op = getRelationalOp(this.lex.token());
                if (op === undefined) {
                    break;
                }
                this.lex.next();
                const right = this.parseUnary();
                expr = new Expr_1.CallExpr(op, [expr, right]);
            }
        }
        return expr;
    }
    parseEquality() {
        let expr = this.parseRelational();
        while (true) {
            const op = getEqualityOp(this.lex.token());
            if (op === undefined) {
                break;
            }
            this.lex.next();
            const right = this.parseRelational();
            expr = new Expr_1.CallExpr(op, [expr, right]);
        }
        return expr;
    }
    parseLogicalAnd() {
        const expr = this.parseEquality();
        if (this.lex.token() !== Token.AmpAmp) {
            return expr;
        }
        const expressions = [expr];
        do {
            this.lex.next();
            expressions.push(this.parseEquality());
        } while (this.lex.token() === Token.AmpAmp);
        return new Expr_1.CallExpr("all", expressions);
    }
    parseLogicalOr() {
        const expr = this.parseLogicalAnd();
        if (this.lex.token() !== Token.BarBar) {
            return expr;
        }
        const expressions = [expr];
        do {
            this.lex.next();
            expressions.push(this.parseLogicalAnd());
        } while (this.lex.token() === Token.BarBar);
        return new Expr_1.CallExpr("any", expressions);
    }
}
exports.ExprParser = ExprParser;


/***/ }),

/***/ "../harp-datasource-protocol/lib/ExprPool.ts":
/*!***************************************************!*\
  !*** ../harp-datasource-protocol/lib/ExprPool.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Expr_1 = __webpack_require__(/*! ./Expr */ "../harp-datasource-protocol/lib/Expr.ts");
/**
 * [[ExprPool]] maintains a set of unique interned [[Expr]] objects.
 *
 * @hidden
 */
class ExprPool {
    constructor() {
        this.m_booleanLiterals = new Map();
        this.m_numberLiterals = new Map();
        this.m_stringLiterals = new Map();
        this.m_objectLiterals = new Map();
        this.m_varExprs = new Map();
        this.m_hasAttributeExprs = new Map();
        this.m_inExprs = new Map();
        this.m_matchExprs = [];
        this.m_caseExprs = [];
        this.m_callExprs = new Map();
    }
    /**
     * Add `expr` to this [[ExprPool]] and return a unique [[Expr]]
     * object that is structurally equivalent to `expr`.
     *
     * @param expr The [[Expr]] to add to this [[ExprPool]].
     * @returns A unique [[Expr]] that is structurally equivalent to `expr`.
     */
    add(expr) {
        return expr.accept(this, undefined);
    }
    visitNullLiteralExpr(expr, context) {
        return Expr_1.NullLiteralExpr.instance;
    }
    visitBooleanLiteralExpr(expr, context) {
        const e = this.m_booleanLiterals.get(expr.value);
        if (e) {
            return e;
        }
        this.m_booleanLiterals.set(expr.value, expr);
        return expr;
    }
    visitNumberLiteralExpr(expr, context) {
        const e = this.m_numberLiterals.get(expr.value);
        if (e) {
            return e;
        }
        this.m_numberLiterals.set(expr.value, expr);
        return expr;
    }
    visitStringLiteralExpr(expr, context) {
        const e = this.m_stringLiterals.get(expr.value);
        if (e) {
            return e;
        }
        this.m_stringLiterals.set(expr.value, expr);
        return expr;
    }
    visitObjectLiteralExpr(expr, context) {
        const e = this.m_objectLiterals.get(expr.value);
        if (e) {
            return e;
        }
        this.m_objectLiterals.set(expr.value, expr);
        return expr;
    }
    visitVarExpr(expr, context) {
        const e = this.m_varExprs.get(expr.name);
        if (e) {
            return e;
        }
        this.m_varExprs.set(expr.name, expr);
        return expr;
    }
    visitHasAttributeExpr(expr, context) {
        const e = this.m_hasAttributeExprs.get(expr.name);
        if (e) {
            return e;
        }
        this.m_hasAttributeExprs.set(expr.name, expr);
        return expr;
    }
    visitContainsExpr(expr, context) {
        const value = expr.value.accept(this, context);
        if (!this.m_inExprs.has(value)) {
            this.m_inExprs.set(value, []);
        }
        const inExprs = this.m_inExprs.get(value);
        for (const inExpr of inExprs) {
            if (inExpr.elements.length !== expr.elements.length) {
                continue;
            }
            // find the index of the first element in the cached 'in' expr
            // that is not contained in 'expr.elements'.
            const i = inExpr.elements.findIndex(x => !expr.elements.includes(x));
            if (i === -1) {
                return inExpr;
            }
        }
        const e = new Expr_1.ContainsExpr(value, expr.elements);
        this.m_inExprs.set(value, [e]);
        return e;
    }
    visitMatchExpr(expr, context) {
        const value = expr.value.accept(this, context);
        const branches = expr.branches.map(([label, body]) => [
            label,
            body.accept(this, context)
        ]);
        const fallback = expr.fallback.accept(this, context);
        for (const candidate of this.m_matchExprs) {
            if (candidate.value !== value) {
                continue;
            }
            if (candidate.fallback !== fallback) {
                continue;
            }
            if (candidate.branches.length !== branches.length) {
                continue;
            }
            let branchesMatching = true;
            for (let i = 0; i < branches.length; i++) {
                if (branches[i][0] !== candidate.branches[i][0] ||
                    branches[i][1] !== candidate.branches[i][1]) {
                    branchesMatching = false;
                    break;
                }
            }
            if (branchesMatching) {
                return candidate;
            }
        }
        const r = new Expr_1.MatchExpr(value, branches, fallback);
        this.m_matchExprs.push(r);
        return r;
    }
    visitCaseExpr(expr, context) {
        const branches = expr.branches.map(([condition, body]) => [
            condition.accept(this, context),
            body.accept(this, context)
        ]);
        const fallback = expr.fallback.accept(this, context);
        for (const candidate of this.m_caseExprs) {
            if (candidate.fallback !== fallback) {
                continue;
            }
            if (candidate.branches.length !== branches.length) {
                continue;
            }
            let branchesMatching = true;
            for (let i = 0; i < branches.length; i++) {
                if (branches[i][0] !== candidate.branches[i][0] ||
                    branches[i][1] !== candidate.branches[i][1]) {
                    branchesMatching = false;
                    break;
                }
            }
            if (branchesMatching) {
                return candidate;
            }
        }
        const r = new Expr_1.CaseExpr(branches, fallback);
        this.m_caseExprs.push(r);
        return r;
    }
    visitCallExpr(expr, context) {
        // rewrite the actual arguments
        const expressions = expr.args.map(childExpr => childExpr.accept(this, context));
        // ensure we have a valid set of interned expressions for the calls
        if (!this.m_callExprs.has(expr.op)) {
            this.m_callExprs.set(expr.op, []);
        }
        // get the calls for the given operator.
        const calls = this.m_callExprs.get(expr.op);
        for (const call of calls) {
            // check the number of arguments
            if (call.args.length !== expressions.length) {
                continue;
            }
            // find the index of the first mismatch.
            let index = 0;
            for (; index < call.args.length; ++index) {
                if (call.args[index] !== expressions[index]) {
                    break;
                }
            }
            if (index === call.args.length) {
                // no mismatch found, return the 'interned' call.
                return call;
            }
        }
        const e = new Expr_1.CallExpr(expr.op, expressions);
        calls.push(e);
        return e;
    }
}
exports.ExprPool = ExprPool;


/***/ }),

/***/ "../harp-datasource-protocol/lib/Extruder.ts":
/*!***************************************************!*\
  !*** ../harp-datasource-protocol/lib/Extruder.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Fills an index buffer with the indices for the extruded walls for a polygon contour.
 *
 * @param indexBuffer Index buffer to be filled.
 * @param vertexOffset Starting offset of the vertices composing the contour.
 * @param vertexStride Number of elements per contour vertex.
 * @param contour Vertices that compose the contour.
 * @param contourEdges Collection of booleans indicating if contour edges should be added.
 * @param boundaryWalls If `false`, walls in tile boundaries will not be created.
 *
 */
function addExtrudedWalls(indexBuffer, vertexOffset, vertexStride, contour, contourEdges, boundaryWalls) {
    // Infer the index buffer's position of the vertices that form the extruded-polygons' walls
    // by stepping through the contour segment by segment.
    const nSegments = contour.length / vertexStride;
    for (let i = 0; i < nSegments; ++i) {
        const vFootprint0 = vertexOffset + i * 2;
        const vRoof0 = vFootprint0 + 1;
        const vFootprint1 = vertexOffset + ((i + 1) % nSegments) * 2;
        const vRoof1 = vFootprint1 + 1;
        if (boundaryWalls !== false || contourEdges === undefined) {
            indexBuffer.push(vFootprint0, vRoof0, vRoof1, vRoof1, vFootprint1, vFootprint0);
        }
        else if (contourEdges[i]) {
            indexBuffer.push(vFootprint0, vRoof0, vRoof1, vRoof1, vFootprint1, vFootprint0);
        }
    }
}
exports.addExtrudedWalls = addExtrudedWalls;


/***/ }),

/***/ "../harp-datasource-protocol/lib/InterpolatedProperty.ts":
/*!***************************************************************!*\
  !*** ../harp-datasource-protocol/lib/InterpolatedProperty.ts ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const ColorUtils_1 = __webpack_require__(/*! ./ColorUtils */ "../harp-datasource-protocol/lib/ColorUtils.ts");
const ExponentialInterpolant_1 = __webpack_require__(/*! ./ExponentialInterpolant */ "../harp-datasource-protocol/lib/ExponentialInterpolant.ts");
const Expr_1 = __webpack_require__(/*! ./Expr */ "../harp-datasource-protocol/lib/Expr.ts");
const InterpolatedPropertyDefs_1 = __webpack_require__(/*! ./InterpolatedPropertyDefs */ "../harp-datasource-protocol/lib/InterpolatedPropertyDefs.ts");
const StringEncodedNumeral_1 = __webpack_require__(/*! ./StringEncodedNumeral */ "../harp-datasource-protocol/lib/StringEncodedNumeral.ts");
const logger = harp_utils_1.LoggerManager.instance.create("InterpolatedProperty");
const interpolants = [
    THREE.DiscreteInterpolant,
    THREE.LinearInterpolant,
    THREE.CubicInterpolant,
    ExponentialInterpolant_1.ExponentialInterpolant
];
const tmpBuffer = new Array(StringEncodedNumeral_1.StringEncodedNumeralFormatMaxSize);
/**
 * Checks if a property is interpolated.
 * @param p property to be checked
 */
function isInterpolatedPropertyDefinition(p) {
    if (p &&
        p.interpolationMode === undefined &&
        Array.isArray(p.values) &&
        p.values.length > 0 &&
        p.values[0] !== undefined &&
        Array.isArray(p.zoomLevels) &&
        p.zoomLevels.length > 0 &&
        p.zoomLevels[0] !== undefined &&
        p.values.length === p.zoomLevels.length) {
        return true;
    }
    return false;
}
exports.isInterpolatedPropertyDefinition = isInterpolatedPropertyDefinition;
/**
 * Type guard to check if an object is an instance of `InterpolatedProperty`.
 */
function isInterpolatedProperty(p) {
    if (p &&
        p.interpolationMode !== undefined &&
        p.zoomLevels instanceof Float32Array &&
        p.values !== undefined &&
        p.values.length > 0 &&
        (p.zoomLevels.length === p.values.length / 4 ||
            p.zoomLevels.length === p.values.length / 3 ||
            p.zoomLevels.length === p.values.length)) {
        return true;
    }
    return false;
}
exports.isInterpolatedProperty = isInterpolatedProperty;
/**
* Get the value of the specified property in given `env`.

* @param property Property of a technique.
* @param env The [[Env]] used to evaluate the property
*/
function getPropertyValue(property, env) {
    if (Expr_1.Expr.isExpr(property)) {
        return property.evaluate(env, Expr_1.ExprScope.Dynamic);
    }
    if (isInterpolatedProperty(property)) {
        return evaluateInterpolatedProperty(property, env);
    }
    if (typeof property !== "string") {
        // Property in numeric or array, etc. format
        return property;
    }
    else {
        // Non-interpolated string encoded numeral parsing
        const pixelToMeters = env.lookup("$pixelToMeters") || 1;
        const value = StringEncodedNumeral_1.parseStringEncodedNumeral(property, pixelToMeters);
        return value !== undefined ? value : property;
    }
}
exports.getPropertyValue = getPropertyValue;
function evaluateInterpolatedProperty(property, env) {
    const level = env.lookup("$zoom");
    const pixelToMeters = env.lookup("$pixelToMeters");
    if (property._stringEncodedNumeralType !== undefined) {
        switch (property._stringEncodedNumeralType) {
            case StringEncodedNumeral_1.StringEncodedNumeralType.Meters:
            case StringEncodedNumeral_1.StringEncodedNumeralType.Pixels:
                return getInterpolatedMetric(property, level, pixelToMeters);
            case StringEncodedNumeral_1.StringEncodedNumeralType.Hex:
            case StringEncodedNumeral_1.StringEncodedNumeralType.RGB:
            case StringEncodedNumeral_1.StringEncodedNumeralType.RGBA:
            case StringEncodedNumeral_1.StringEncodedNumeralType.HSL:
                return getInterpolatedColor(property, level);
        }
    }
    return getInterpolatedMetric(property, level, pixelToMeters);
}
exports.evaluateInterpolatedProperty = evaluateInterpolatedProperty;
function getInterpolatedMetric(property, level, pixelToMeters) {
    const nChannels = property.values.length / property.zoomLevels.length;
    const interpolant = new interpolants[property.interpolationMode](property.zoomLevels, property.values, nChannels);
    if (property.interpolationMode === InterpolatedPropertyDefs_1.InterpolationMode.Exponential &&
        property.exponent !== undefined) {
        interpolant.exponent = property.exponent;
    }
    interpolant.evaluate(level);
    if (property._stringEncodedNumeralDynamicMask === undefined) {
        return interpolant.resultBuffer[0];
    }
    else {
        const maskInterpolant = new interpolants[property.interpolationMode](property.zoomLevels, property._stringEncodedNumeralDynamicMask, 1);
        if (property.interpolationMode === InterpolatedPropertyDefs_1.InterpolationMode.Exponential &&
            property.exponent !== undefined) {
            maskInterpolant.exponent = property.exponent;
        }
        maskInterpolant.evaluate(level);
        return (interpolant.resultBuffer[0] *
            (1 + maskInterpolant.resultBuffer[0] * (pixelToMeters - 1)));
    }
}
function getInterpolatedColor(property, level) {
    const nChannels = property.values.length / property.zoomLevels.length;
    const interpolant = new interpolants[property.interpolationMode](property.zoomLevels, property.values, nChannels);
    if (property.interpolationMode === InterpolatedPropertyDefs_1.InterpolationMode.Exponential &&
        property.exponent !== undefined) {
        interpolant.exponent = property.exponent;
    }
    interpolant.evaluate(level);
    harp_utils_1.assert(nChannels === 3 || nChannels === 4);
    // ColorUtils.getHexFromRgba() does not clamp the values which may be out of
    // color channels range (0 <= c <= 1) after interpolation.
    if (nChannels === 4) {
        return ColorUtils_1.ColorUtils.getHexFromRgba(THREE.Math.clamp(interpolant.resultBuffer[0], 0, 1), THREE.Math.clamp(interpolant.resultBuffer[1], 0, 1), THREE.Math.clamp(interpolant.resultBuffer[2], 0, 1), THREE.Math.clamp(interpolant.resultBuffer[3], 0, 1));
    }
    else {
        return ColorUtils_1.ColorUtils.getHexFromRgb(THREE.Math.clamp(interpolant.resultBuffer[0], 0, 1), THREE.Math.clamp(interpolant.resultBuffer[1], 0, 1), THREE.Math.clamp(interpolant.resultBuffer[2], 0, 1));
    }
}
/**
 * Convert JSON representation of interpolated property to internal, normalized version that
 * can be evaluated by [[getPropertyValue]].
 */
function createInterpolatedProperty(prop) {
    removeDuplicatePropertyValues(prop);
    const interpolationMode = prop.interpolation !== undefined
        ? InterpolatedPropertyDefs_1.InterpolationMode[prop.interpolation]
        : InterpolatedPropertyDefs_1.InterpolationMode.Discrete;
    const zoomLevels = new Float32Array(prop.zoomLevels);
    const firstValue = prop.values[0];
    switch (typeof firstValue) {
        default:
        case "number":
        case "boolean":
            return {
                interpolationMode,
                zoomLevels,
                values: new Float32Array(prop.values),
                exponent: prop.exponent
            };
        case "string":
            // TODO: Minimize effort for pre-matching the numeral format.
            const matchedFormat = StringEncodedNumeral_1.StringEncodedNumeralFormats.find(format => format.regExp.test(firstValue));
            if (matchedFormat === undefined) {
                if (interpolationMode === InterpolatedPropertyDefs_1.InterpolationMode.Discrete) {
                    return {
                        interpolationMode,
                        zoomLevels,
                        values: prop.values
                    };
                }
                logger.error(`No StringEncodedNumeralFormat matched ${firstValue}.`);
                return undefined;
            }
            let needsMask = false;
            const propValues = new Float32Array(prop.values.length * matchedFormat.size);
            const maskValues = new Float32Array(prop.values.length);
            needsMask = procesStringEnocodedNumeralInterpolatedProperty(matchedFormat, prop, propValues, maskValues);
            return {
                interpolationMode,
                zoomLevels,
                values: propValues,
                exponent: prop.exponent,
                _stringEncodedNumeralType: matchedFormat.type,
                _stringEncodedNumeralDynamicMask: needsMask ? maskValues : undefined
            };
    }
}
exports.createInterpolatedProperty = createInterpolatedProperty;
function removeDuplicatePropertyValues(p) {
    const eps = 0.001;
    // detect cubic interpolations and remove stops
    // closer than `eps`, this is needed to avoid
    // possible NaN generated by the cubic interpolator.
    const isCubic = p.interpolation === "Cubic";
    for (let i = 0; i < p.values.length; ++i) {
        const firstIdx = p.zoomLevels.findIndex(a => {
            return isCubic ? Math.abs(a - p.zoomLevels[i]) < eps : a === p.zoomLevels[i];
        });
        if (firstIdx !== i) {
            p.zoomLevels.splice(--i, 1);
            p.values.splice(--i, 1);
        }
    }
}
function procesStringEnocodedNumeralInterpolatedProperty(baseFormat, prop, propValues, maskValues) {
    let needsMask = false;
    const allowedValueFormats = baseFormat.type === StringEncodedNumeral_1.StringEncodedNumeralType.Meters ||
        baseFormat.type === StringEncodedNumeral_1.StringEncodedNumeralType.Pixels
        ? StringEncodedNumeral_1.StringEncodedMetricFormats
        : StringEncodedNumeral_1.StringEncodedColorFormats;
    for (let valueIdx = 0; valueIdx < prop.values.length; ++valueIdx) {
        let matched = false;
        for (const valueFormat of allowedValueFormats) {
            const value = prop.values[valueIdx];
            matched = valueFormat.decoder(value, tmpBuffer);
            if (!matched) {
                continue;
            }
            if (valueFormat.mask !== undefined) {
                maskValues[valueIdx] = valueFormat.mask;
                needsMask = true;
            }
            for (let i = 0; i < valueFormat.size; ++i) {
                propValues[valueIdx * valueFormat.size + i] = tmpBuffer[i];
            }
            break;
        }
        if (!matched) {
            throw Error(`Not all interpolation values match the same format: ${JSON.stringify(prop)}`);
        }
    }
    return needsMask;
}


/***/ }),

/***/ "../harp-datasource-protocol/lib/InterpolatedPropertyDefs.ts":
/*!*******************************************************************!*\
  !*** ../harp-datasource-protocol/lib/InterpolatedPropertyDefs.ts ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Interpolation mode used when computing a [[InterpolatedProperty]] value for a given zoom level.
 */
var InterpolationMode;
(function (InterpolationMode) {
    InterpolationMode[InterpolationMode["Discrete"] = 0] = "Discrete";
    InterpolationMode[InterpolationMode["Linear"] = 1] = "Linear";
    InterpolationMode[InterpolationMode["Cubic"] = 2] = "Cubic";
    InterpolationMode[InterpolationMode["Exponential"] = 3] = "Exponential";
})(InterpolationMode = exports.InterpolationMode || (exports.InterpolationMode = {}));
/**
 * Converts an [[InterpolatedPropertyDefinition]] to a [[JsonExpr]].
 *
 * @param property A valid [[InterpolatedPropertyDefinition]]
 */
function interpolatedPropertyDefinitionToJsonExpr(property) {
    if (property.interpolation === undefined || property.interpolation === "Discrete") {
        const step = ["step", ["zoom"], property.values[0]];
        for (let i = 1; i < property.zoomLevels.length; ++i) {
            step.push(property.zoomLevels[i], property.values[i]);
        }
        return step;
    }
    const interpolation = ["interpolate"];
    switch (property.interpolation) {
        case "Linear":
            interpolation.push(["linear"]);
            break;
        case "Cubic":
            interpolation.push(["cubic"]);
            break;
        case "Exponential":
            interpolation.push([
                "exponential",
                property.exponent !== undefined ? property.exponent : 2
            ]);
            break;
        default:
            throw new Error(`interpolation mode '${property.interpolation}' is not supported`);
    } //switch
    interpolation.push(["zoom"]);
    for (let i = 0; i < property.zoomLevels.length; ++i) {
        interpolation.push(property.zoomLevels[i], property.values[i]);
    }
    return interpolation;
}
exports.interpolatedPropertyDefinitionToJsonExpr = interpolatedPropertyDefinitionToJsonExpr;


/***/ }),

/***/ "../harp-datasource-protocol/lib/Outliner.ts":
/*!***************************************************!*\
  !*** ../harp-datasource-protocol/lib/Outliner.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const currEdgeStart = new THREE.Vector2();
const currEdgeGoal = new THREE.Vector2();
const prevEdgeStart = new THREE.Vector2();
const prevEdgeGoal = new THREE.Vector2();
/**
 * Fills an index buffer with the indices for the edges of a polygon contour.
 *
 * @param indexBuffer Edge index buffer to be filled.
 * @param vertexOffset Starting offset of the vertices composing the contour.
 * @param vertexStride Number of elements per contour vertex.
 * @param polygonContour Vertices that compose the contour.
 * @param polygonContourEdges Collection of booleans indicating if contour edges should be added.
 */
function addPolygonEdges(indexBuffer, vertexOffset, vertexStride, polygonContour, polygonContourEdges, isExtruded, addFootprintEdges, wallEdgeSlope) {
    for (let i = 0; i < polygonContourEdges.length; ++i) {
        if (polygonContourEdges[i]) {
            if (isExtruded === true) {
                const vFootprint0 = vertexOffset + i * 2;
                const vRoof0 = vFootprint0 + 1;
                const vFootprint1 = vertexOffset + ((i + 1) % polygonContourEdges.length) * 2;
                const vRoof1 = vFootprint1 + 1;
                if (addFootprintEdges === true) {
                    indexBuffer.push(vFootprint0, vFootprint1);
                }
                indexBuffer.push(vRoof0, vRoof1);
                const prevEdgeIdx = (i === 0 ? polygonContourEdges.length : i) - 1;
                if (polygonContourEdges[prevEdgeIdx]) {
                    if (wallEdgeSlope !== undefined) {
                        const v0x = polygonContour[i * vertexStride];
                        const v0y = polygonContour[i * vertexStride + 1];
                        const v1x = polygonContour[((i + 1) % polygonContourEdges.length) * vertexStride];
                        const v1y = polygonContour[((i + 1) % polygonContourEdges.length) * vertexStride + 1];
                        currEdgeStart.set(v0x, v0y);
                        currEdgeGoal.set(v1x, v1y);
                        prevEdgeStart.set(polygonContour[prevEdgeIdx * vertexStride], polygonContour[prevEdgeIdx * vertexStride + 1]);
                        prevEdgeGoal.set(currEdgeStart.x, currEdgeStart.y);
                        if (prevEdgeGoal
                            .sub(prevEdgeStart)
                            .normalize()
                            .dot(currEdgeGoal.sub(currEdgeStart).normalize()) <= wallEdgeSlope) {
                            indexBuffer.push(vFootprint0, vRoof0);
                        }
                    }
                    else {
                        indexBuffer.push(vFootprint0, vRoof0);
                    }
                }
            }
            else {
                const vFoot0 = vertexOffset + i;
                const vRoof0 = vertexOffset + ((i + 1) % polygonContourEdges.length);
                indexBuffer.push(vFoot0, vRoof0);
            }
        }
    }
}
exports.addPolygonEdges = addPolygonEdges;


/***/ }),

/***/ "../harp-datasource-protocol/lib/StringEncodedNumeral.ts":
/*!***************************************************************!*\
  !*** ../harp-datasource-protocol/lib/StringEncodedNumeral.ts ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const three_1 = __webpack_require__(/*! three */ "three");
const ColorUtils_1 = __webpack_require__(/*! ./ColorUtils */ "../harp-datasource-protocol/lib/ColorUtils.ts");
const tmpColor = new three_1.Color();
/**
 * Enumeration of supported string encoded numerals.
 */
var StringEncodedNumeralType;
(function (StringEncodedNumeralType) {
    StringEncodedNumeralType[StringEncodedNumeralType["Meters"] = 0] = "Meters";
    StringEncodedNumeralType[StringEncodedNumeralType["Pixels"] = 1] = "Pixels";
    StringEncodedNumeralType[StringEncodedNumeralType["Hex"] = 2] = "Hex";
    StringEncodedNumeralType[StringEncodedNumeralType["RGB"] = 3] = "RGB";
    StringEncodedNumeralType[StringEncodedNumeralType["RGBA"] = 4] = "RGBA";
    StringEncodedNumeralType[StringEncodedNumeralType["HSL"] = 5] = "HSL";
})(StringEncodedNumeralType = exports.StringEncodedNumeralType || (exports.StringEncodedNumeralType = {}));
const StringEncodedMeters = {
    type: StringEncodedNumeralType.Meters,
    size: 1,
    regExp: /^((?=\.\d|\d)(?:\d+)?(?:\.?\d*))m$/,
    decoder: (encodedValue, target) => {
        const match = StringEncodedMeters.regExp.exec(encodedValue);
        return match ? (target[0] = Number(match[1])) !== undefined : false;
    }
};
const StringEncodedPixels = {
    type: StringEncodedNumeralType.Pixels,
    size: 1,
    mask: 1.0,
    regExp: /^((?=\.\d|\d)(?:\d+)?(?:\.?\d*))px$/,
    decoder: (encodedValue, target) => {
        const match = StringEncodedPixels.regExp.exec(encodedValue);
        if (match === null) {
            return false;
        }
        target[0] = Number(match[1]);
        return true;
    }
};
const StringEncodedHex = {
    type: StringEncodedNumeralType.Hex,
    size: 4,
    regExp: /^\#((?:[0-9A-Fa-f][0-9A-Fa-f]){3,4}|[0-9A-Fa-f]{3,4})$/,
    decoder: (encodedValue, target) => {
        const match = StringEncodedHex.regExp.exec(encodedValue);
        if (match === null) {
            return false;
        }
        const hex = match[1];
        const size = hex.length;
        // Only few sizes are possible for given reg-exp.
        harp_utils_1.assert(size === 3 || size === 4 || size === 6 || size === 8, `Matched incorrect hex color format`);
        // Note that we simply ignore alpha channel value.
        // TODO: To be resolved with HARP-7517
        if (size === 3 || size === 4) {
            // #RGB or #RGBA
            target[0] = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
            target[1] = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
            target[2] = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
            target[3] = size === 4 ? parseInt(hex.charAt(3) + hex.charAt(3), 16) / 255 : 1;
        }
        else if (size === 6 || size === 8) {
            // #RRGGBB or #RRGGBBAA
            target[0] = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
            target[1] = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
            target[2] = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
            target[3] = size === 8 ? parseInt(hex.charAt(6) + hex.charAt(7), 16) / 255 : 1;
        }
        return true;
    }
};
const StringEncodedRGB = {
    type: StringEncodedNumeralType.RGB,
    size: 3,
    // tslint:disable-next-line:max-line-length
    regExp: /^rgb\( ?(?:([0-9]{1,2}|1[0-9]{1,2}|2[0-4][0-9]|25[0-5]), ?)(?:([0-9]{1,2}|1[0-9]{1,2}|2[0-4][0-9]|25[0-5]), ?)(?:([0-9]{1,2}|1[0-9]{1,2}|2[0-4][0-9]|25[0-5])) ?\)$/,
    decoder: (encodedValue, target) => {
        const channels = StringEncodedRGB.regExp.exec(encodedValue);
        if (channels === null) {
            return false;
        }
        target[0] = parseInt(channels[1], 10) / 255;
        target[1] = parseInt(channels[2], 10) / 255;
        target[2] = parseInt(channels[3], 10) / 255;
        return true;
    }
};
const StringEncodedRGBA = {
    type: StringEncodedNumeralType.RGBA,
    size: 4,
    // tslint:disable-next-line:max-line-length
    regExp: /^rgba\( ?(?:([0-9]{1,2}|1[0-9]{1,2}|2[0-4][0-9]|25[0-5]), ?)(?:([0-9]{1,2}|1[0-9]{1,2}|2[0-4][0-9]|25[0-5]), ?)(?:([0-9]{1,2}|1[0-9]{1,2}|2[0-4][0-9]|25[0-5]), ?)(?:(0(?:\.[0-9]+)?|1(?:\.0+)?)) ?\)$/,
    decoder: (encodedValue, target) => {
        const channels = StringEncodedRGBA.regExp.exec(encodedValue);
        if (channels === null) {
            return false;
        }
        target[0] = parseInt(channels[1], 10) / 255;
        target[1] = parseInt(channels[2], 10) / 255;
        target[2] = parseInt(channels[3], 10) / 255;
        target[3] = parseFloat(channels[4]);
        return true;
    }
};
const StringEncodedHSL = {
    type: StringEncodedNumeralType.HSL,
    size: 3,
    // tslint:disable-next-line:max-line-length
    regExp: /^hsl\( ?((?:[0-9]|[1-9][0-9]|1[0-9]{1,2}|2[0-9]{1,2}|3[0-5][0-9]|360)), ?(?:([0-9]|[1-9][0-9]|100)%), ?(?:([0-9]|[1-9][0-9]|100)%) ?\)$/,
    decoder: (encodedValue, target) => {
        const channels = StringEncodedHSL.regExp.exec(encodedValue);
        if (channels === null) {
            return false;
        }
        tmpColor.setHSL(parseInt(channels[1], 10) / 360, parseInt(channels[2], 10) / 100, parseInt(channels[3], 10) / 100);
        target[0] = tmpColor.r;
        target[1] = tmpColor.g;
        target[2] = tmpColor.b;
        return true;
    }
};
/**
 * Array of all supported [[StringEncodedNumeralFormat]]s describing sizes, lengths and distances.
 */
exports.StringEncodedMetricFormats = [
    StringEncodedMeters,
    StringEncodedPixels
];
const StringEncodedMetricFormatMaxSize = exports.StringEncodedMetricFormats.reduce((a, b) => Math.max(a, b.size), 0);
/**
 * Array of all supported [[StringEncodedNumeralFormat]]s describing color data.
 */
exports.StringEncodedColorFormats = [
    StringEncodedHex,
    StringEncodedRGB,
    StringEncodedRGBA,
    StringEncodedHSL
];
const StringEncodedColorFormatMaxSize = exports.StringEncodedColorFormats.reduce((a, b) => Math.max(a, b.size), 0);
/**
 * Array of supported [[StringEncodedNumeralFormat]]s (intended to be indexed with
 * [[StringEncodedNumeralType]] enum).
 */
exports.StringEncodedNumeralFormats = [
    ...exports.StringEncodedMetricFormats,
    ...exports.StringEncodedColorFormats
];
exports.StringEncodedNumeralFormatMaxSize = Math.max(StringEncodedColorFormatMaxSize, StringEncodedMetricFormatMaxSize);
const tmpBuffer = new Array(exports.StringEncodedNumeralFormatMaxSize);
/**
 * Parse string encoded numeral values using all known [[StringEncodedNumeralFormats]].
 *
 * @param numeral The string representing numeric value.
 * @param pixelToMeters The ratio used to convert from meters to pixels (default 1.0).
 * @returns Number parsed or __undefined__ if non of the numeral patterns matches the expression
 * provided in [[numeral]].
 */
function parseStringEncodedNumeral(numeral, pixelToMeters = 1.0) {
    let result;
    const formatMatch = (format) => {
        if (format.decoder(numeral, tmpBuffer)) {
            switch (format.type) {
                case StringEncodedNumeralType.Meters:
                    result = tmpBuffer[0];
                    break;
                case StringEncodedNumeralType.Pixels:
                    result = tmpBuffer[0] * pixelToMeters;
                    break;
                case StringEncodedNumeralType.Hex:
                case StringEncodedNumeralType.RGBA:
                    result = ColorUtils_1.ColorUtils.getHexFromRgba(tmpBuffer[0], tmpBuffer[1], tmpBuffer[2], tmpBuffer[3]);
                    break;
                case StringEncodedNumeralType.RGB:
                case StringEncodedNumeralType.HSL:
                    result = ColorUtils_1.ColorUtils.getHexFromRgb(tmpBuffer[0], tmpBuffer[1], tmpBuffer[2]);
                    break;
                default:
                    result = tmpBuffer[0];
                    break;
            }
            return true;
        }
        return false;
    };
    exports.StringEncodedNumeralFormats.some(formatMatch);
    return result;
}
exports.parseStringEncodedNumeral = parseStringEncodedNumeral;
/**
 * Parse string encoded color value using all known [[StringEncodedColorFormats]].
 *
 * @param color The string encoded color expression (i.e. '#FFF', 'rgb(255, 0, 0)', etc.).
 * @returns The color parsed or __undefined__ if non of the known representations matches
 * the expression provided in [[color]].
 */
function parseStringEncodedColor(color) {
    const matchedFormat = matchFormat(exports.StringEncodedColorFormats, color, tmpBuffer);
    if (matchedFormat === undefined) {
        return undefined;
    }
    switch (matchedFormat.type) {
        case StringEncodedNumeralType.Hex:
        case StringEncodedNumeralType.RGBA:
            return ColorUtils_1.ColorUtils.getHexFromRgba(tmpBuffer[0], tmpBuffer[1], tmpBuffer[2], tmpBuffer[3]);
        case StringEncodedNumeralType.RGB:
        case StringEncodedNumeralType.HSL:
            return ColorUtils_1.ColorUtils.getHexFromRgb(tmpBuffer[0], tmpBuffer[1], tmpBuffer[2]);
        default:
            return tmpBuffer[0];
    }
}
exports.parseStringEncodedColor = parseStringEncodedColor;
function matchFormat(formats, numeral, result) {
    return formats.find(format => {
        return format.decoder(numeral, result) ? true : false;
    });
}


/***/ }),

/***/ "../harp-datasource-protocol/lib/StyleSetEvaluator.ts":
/*!************************************************************!*\
  !*** ../harp-datasource-protocol/lib/StyleSetEvaluator.ts ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const Expr_1 = __webpack_require__(/*! ./Expr */ "../harp-datasource-protocol/lib/Expr.ts");
const ExprPool_1 = __webpack_require__(/*! ./ExprPool */ "../harp-datasource-protocol/lib/ExprPool.ts");
const InterpolatedProperty_1 = __webpack_require__(/*! ./InterpolatedProperty */ "../harp-datasource-protocol/lib/InterpolatedProperty.ts");
const InterpolatedPropertyDefs_1 = __webpack_require__(/*! ./InterpolatedPropertyDefs */ "../harp-datasource-protocol/lib/InterpolatedPropertyDefs.ts");
const TechniqueDescriptor_1 = __webpack_require__(/*! ./TechniqueDescriptor */ "../harp-datasource-protocol/lib/TechniqueDescriptor.ts");
const Techniques_1 = __webpack_require__(/*! ./Techniques */ "../harp-datasource-protocol/lib/Techniques.ts");
const Theme_1 = __webpack_require__(/*! ./Theme */ "../harp-datasource-protocol/lib/Theme.ts");
const logger = harp_utils_1.LoggerManager.instance.create("StyleSetEvaluator");
const emptyTechniqueDescriptor = TechniqueDescriptor_1.mergeTechniqueDescriptor({});
/**
 * [[StyleConditionClassifier]] searches for usages of `$layer` in `when` conditions
 * associated with styling rules.
 *
 * @hidden
 */
class StyleConditionClassifier {
    classify(style) {
        if (style._whenExpr) {
            const savedStyle = this.switchStyle(style);
            style._whenExpr = style._whenExpr.accept(this, undefined);
            this._style = savedStyle;
        }
    }
    visitNullLiteralExpr(expr, enclosingExpr) {
        return expr;
    }
    visitBooleanLiteralExpr(expr, enclosingExpr) {
        return expr;
    }
    visitNumberLiteralExpr(expr, enclosingExpr) {
        return expr;
    }
    visitStringLiteralExpr(expr, enclosingExpr) {
        return expr;
    }
    visitObjectLiteralExpr(expr, enclosingExpr) {
        return expr;
    }
    visitVarExpr(expr, enclosingExpr) {
        return expr;
    }
    visitHasAttributeExpr(expr, enclosingExpr) {
        return expr;
    }
    visitContainsExpr(expr, enclosingExpr) {
        return expr;
    }
    visitMatchExpr(expr, enclosingExpr) {
        return expr;
    }
    visitCaseExpr(expr, enclosingExpr) {
        return expr;
    }
    visitCallExpr(call, enclosingExpr) {
        if (call.op === "all") {
            // processing of an `["all", e1, e2, ... eN]` expression. In this case
            // search for expressions matching comparison of `$layer` and string literals
            // in the sub expressions.
            const children = call.args
                .map(childExpr => childExpr.accept(this, call))
                .filter(childExpr => childExpr !== undefined);
            return new Expr_1.CallExpr(call.op, children);
        }
        else if (enclosingExpr) {
            // `call` is a direct child expression of an `"all"` operator.
            const matched = this.matchVarStringComparison(call);
            if (matched) {
                if (this._style.layer === undefined && matched.name === "$layer") {
                    // found a subexpression `["==", ["get", "$layer"], "some layer name"]`
                    // enclosed in an `["all", e1...eN]` expression. Remove it from
                    // its parent expression and store the value of the expected $layer in
                    // [[StyleInternalParams]].
                    this._style.layer = matched.value;
                    // return `undefined` to remove this sub expression from its parent.
                    return undefined;
                }
                else if (this._style._geometryType === undefined &&
                    matched.name === "$geometryType") {
                    // found a subexpression `["==", ["get", "$geometryType"], "geometry"]`
                    // enclosed in an `["all", e1...eN]` expression. Remove it from
                    // its parent expression and store the value of the expected $geometryType in
                    // [[StyleInternalParams]].
                    this._style._geometryType = matched.value;
                    // return `undefined` to remove this sub expression from its parent.
                    return undefined;
                }
            }
        }
        return call;
    }
    /**
     * Tests if the given `call` matches the structure ["==", ["get", name], value].
     * If a match is found returns an object containing the `name` and the `value`;
     *
     * @param call The expression to match.
     */
    matchVarStringComparison(call) {
        if (call.op === "==") {
            const left = call.args[0];
            const right = call.args[1];
            if (left instanceof Expr_1.VarExpr && right instanceof Expr_1.StringLiteralExpr) {
                return { name: left.name, value: right.value };
            }
            if (right instanceof Expr_1.VarExpr && left instanceof Expr_1.StringLiteralExpr) {
                return { name: right.name, value: left.value };
            }
        }
        return undefined;
    }
    /**
     * Sets the given `style` as current.
     *
     * @returns The previous `style`.
     */
    switchStyle(style) {
        const saved = this._style;
        this._style = style;
        return saved;
    }
}
class OptimizedSubSetKey {
    constructor(layer, geometryType) {
        this.key = "";
        this.set(layer, geometryType);
    }
    set(layer, geometryType, env) {
        let keyUpdateNeeded = false;
        if (layer === undefined) {
            const envLayer = env !== undefined ? env.lookup("$layer") : undefined;
            layer = typeof envLayer === "string" ? envLayer : undefined;
        }
        if (this.layer !== layer) {
            this.layer = layer;
            keyUpdateNeeded = true;
        }
        if (geometryType === undefined) {
            const envGeometryType = env !== undefined ? env.lookup("$geometryType") : undefined;
            geometryType = typeof envGeometryType === "string" ? envGeometryType : undefined;
        }
        if (this.geometryType !== geometryType) {
            this.geometryType = geometryType;
            keyUpdateNeeded = true;
        }
        if (keyUpdateNeeded) {
            this.updateKey();
        }
        return this;
    }
    updateKey() {
        if (this.layer !== undefined) {
            // tslint:disable-next-line:prefer-conditional-expression
            if (this.geometryType !== undefined) {
                this.key = `${this.layer}:${this.geometryType}`;
            }
            else {
                this.key = `${this.layer}:`;
            }
        }
        else {
            if (this.geometryType !== undefined) {
                this.key = `:${this.geometryType}`;
            }
            else {
                this.key = "all";
            }
        }
        this.cachedStyleSet = undefined;
    }
}
/**
 * Combine data from datasource and apply the rules from a specified theme to show it on the map.
 */
class StyleSetEvaluator {
    constructor(styleSet, definitions) {
        this.m_techniques = [];
        this.m_exprPool = new ExprPool_1.ExprPool();
        this.m_cachedResults = new Map();
        this.m_styleConditionClassifier = new StyleConditionClassifier();
        this.m_subStyleSetCache = new Map();
        this.m_definitionExprCache = new Map();
        this.m_tmpOptimizedSubSetKey = new OptimizedSubSetKey();
        this.m_emptyEnv = new Expr_1.Env();
        this.m_definitions = definitions;
        this.styleSet = resolveReferences(styleSet, definitions);
        computeDefaultRenderOrder(this.styleSet);
        this.compileStyleSet();
    }
    /**
     * Find all techniques that fit the current objects' environment.
     * *The techniques in the resulting array may not be modified* since they are being reused for
     * identical objects.
     *
     * @param env The objects environment, i.e. the attributes that are relevant for its
     * representation.
     * @param layer The optional layer name used to filter techniques.
     * @param geometryType The optional geometryType used to filter techniques.
     */
    getMatchingTechniques(env, layer, geometryType) {
        const result = [];
        this.m_cachedResults.clear();
        const optimizedSubSetKey = this.m_tmpOptimizedSubSetKey;
        optimizedSubSetKey.set(layer, geometryType, env);
        // get the requested $layer and $geometryType, if any.
        this.m_layer = optimizedSubSetKey.layer;
        this.m_geometryType = optimizedSubSetKey.geometryType;
        this.m_zoomLevel = env.lookup("$zoom");
        const searchedStyleSet = this.getOptimizedStyleSet(optimizedSubSetKey);
        for (const currStyle of searchedStyleSet) {
            if (this.processStyle(env, currStyle, result)) {
                break;
            }
        }
        return result;
    }
    /**
     * Check if `styleSet` contains any rule related to `layer`.
     *
     * @param layer name of layer
     */
    wantsLayer(layer) {
        return (this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(layer, undefined)).length > 0);
    }
    /**
     * Check if `styleSet` contains any rule related to particular `[layer, geometryType]` pair.
     *
     * @param layer name of layer
     * @param geometryType type of layer - `point`, `line` or `polygon`
     */
    wantsFeature(layer, geometryType) {
        return (this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(layer, geometryType))
            .length > 0);
    }
    /**
     * Get the expression evaluation cache, for further feature processing.
     *
     * This object is valid until next `getMatchingTechniques` call.
     */
    get expressionEvaluatorCache() {
        return this.m_cachedResults;
    }
    /**
     * Reset array of techniques.
     *
     * Cleans technique array and indices, so it doesn't accumulate accross several decoding runs.
     */
    resetTechniques() {
        for (const techinque of this.m_techniques) {
            techinque._index = undefined;
        }
        this.m_techniques.length = 0;
    }
    /**
     * Get the (current) array of techniques that have been created during decoding.
     */
    get techniques() {
        return this.m_techniques;
    }
    /**
     * Get the (current) array of techniques that have been created during decoding.
     */
    get decodedTechniques() {
        return this.m_techniques.map(makeDecodedTechnique);
    }
    getOptimizedStyleSet(subSetKey) {
        if (subSetKey.cachedStyleSet !== undefined) {
            return subSetKey.cachedStyleSet;
        }
        let optimizedStyleSet = this.m_subStyleSetCache.get(subSetKey.key);
        if (optimizedStyleSet !== undefined) {
            subSetKey.cachedStyleSet = optimizedStyleSet;
            return optimizedStyleSet;
        }
        optimizedStyleSet = this.createPreFilteredStyleSet(subSetKey);
        this.m_subStyleSetCache.set(subSetKey.key, optimizedStyleSet);
        subSetKey.cachedStyleSet = optimizedStyleSet;
        return optimizedStyleSet;
    }
    createPreFilteredStyleSet(subSetKey) {
        const { layer, geometryType } = subSetKey;
        return this.styleSet.filter(style => {
            if (layer !== undefined && style.layer !== undefined && style.layer !== layer) {
                return false;
            }
            if (geometryType !== undefined &&
                style._geometryType !== undefined &&
                style._geometryType !== geometryType) {
                return false;
            }
            return true;
        });
    }
    /**
     * Compile the `when` conditions found when traversting the styling rules.
     */
    compileStyleSet() {
        this.styleSet.forEach(style => this.compileStyle(style));
        // Create optimized styleSets for each `layer` & `geometryType` tuple.
        this.styleSet.forEach(style => {
            this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(style.layer, style._geometryType));
        });
    }
    /**
     * Compile the `when` conditions reachable from the given `style`.
     *
     * @param style The current style.
     */
    compileStyle(style) {
        if (style.when !== undefined) {
            try {
                style._whenExpr = Array.isArray(style.when)
                    ? Expr_1.Expr.fromJSON(style.when, this.m_definitions, this.m_definitionExprCache)
                    : Expr_1.Expr.parse(style.when);
                // search for usages of '$layer' and any other
                // special symbol that can be used to speed up the evaluation
                // of the `when` conditions associated to this `style`.
                this.m_styleConditionClassifier.classify(style);
                if (style._whenExpr !== undefined) {
                    style._whenExpr = style._whenExpr.intern(this.m_exprPool);
                }
                if (Expr_1.isJsonExpr(style.minZoomLevel)) {
                    style._minZoomLevelExpr = Expr_1.Expr.fromJSON(style.minZoomLevel).intern(this.m_exprPool);
                }
                if (Expr_1.isJsonExpr(style.maxZoomLevel)) {
                    style._maxZoomLevelExpr = Expr_1.Expr.fromJSON(style.maxZoomLevel).intern(this.m_exprPool);
                }
            }
            catch (err) {
                logger.log("failed to evaluate expression", JSON.stringify(style.when), "error", String(err));
            }
        }
    }
    /**
     * Process a style (and its sub-styles) hierarchically to look for the technique that fits the
     * current objects' environment. The attributes of the styles are assembled to create a unique
     * technique for every object.
     *
     * @param env The objects environment, i.e. the attributes that are relevant for its
     *            representation.
     * @param style Current style (could also be top of stack).
     * @param result The array of resulting techniques. There may be more than one technique per
     *               object, resulting in multiple graphical objects for representation.
     * @returns `true` if style has been found and processing is finished. `false` if not found, or
     *          more than one technique should be applied.
     */
    processStyle(env, style, result) {
        if (!this.checkZoomLevel(env, style)) {
            return false;
        }
        if (this.m_layer !== undefined &&
            style.layer !== undefined &&
            style.layer !== this.m_layer) {
            return false;
        }
        if (this.m_geometryType !== undefined &&
            style._geometryType !== undefined &&
            style._geometryType !== this.m_geometryType) {
            return false;
        }
        if (style._whenExpr) {
            try {
                if (!style._whenExpr.evaluate(env, Expr_1.ExprScope.Condition, this.m_cachedResults)) {
                    // Stop processing this styling rule. The `when` condition
                    // associated with the current `style` evaluates to false so
                    // no techinque defined by this style should be applied.
                    return false;
                }
            }
            catch (error) {
                logger.error(`failed to evaluate expression '${JSON.stringify(style.when)}': ${error}`);
                return false;
            }
        }
        if (style.technique === undefined) {
            return false;
        }
        // we found a technique!
        if (style.technique !== "none") {
            result.push(this.getTechniqueForStyleMatch(env, style));
        }
        // stop processing if "final" is set
        return style.final === true;
    }
    checkZoomLevel(env, style) {
        if (style.minZoomLevel === undefined && style.maxZoomLevel === undefined) {
            return true;
        }
        const zoomLevel = this.m_zoomLevel;
        if (zoomLevel === undefined) {
            return true;
        }
        if (style.minZoomLevel !== undefined) {
            let minZoomLevel = style.minZoomLevel;
            if (style._minZoomLevelExpr) {
                // the constraint is defined as expression, evaluate it and
                // use its value
                try {
                    minZoomLevel = style._minZoomLevelExpr.evaluate(env, Expr_1.ExprScope.Condition, this.m_cachedResults);
                }
                catch (error) {
                    logger.error(`failed to evaluate expression '${JSON.stringify(style._minZoomLevelExpr)}': ${error}`);
                }
            }
            if (typeof minZoomLevel === "number" && zoomLevel < minZoomLevel) {
                return false;
            }
        }
        if (style.maxZoomLevel !== undefined) {
            let maxZoomLevel = style.maxZoomLevel;
            if (style._maxZoomLevelExpr) {
                try {
                    maxZoomLevel = style._maxZoomLevelExpr.evaluate(env, Expr_1.ExprScope.Condition, this.m_cachedResults);
                }
                catch (error) {
                    logger.error(`failed to evaluate expression '${JSON.stringify(style._maxZoomLevelExpr)}': ${error}`);
                }
            }
            if (typeof maxZoomLevel === "number" && zoomLevel > maxZoomLevel) {
                return false;
            }
        }
        return true;
    }
    getTechniqueForStyleMatch(env, style) {
        this.checkStyleDynamicAttributes(style);
        let technique;
        if (style._dynamicTechniques !== undefined) {
            const dynamicAttributes = this.evaluateTechniqueProperties(style, env);
            const key = this.getDynamicTechniqueKey(style, dynamicAttributes);
            technique = style._dynamicTechniques.get(key);
            if (technique === undefined) {
                technique = this.createTechnique(style, key, dynamicAttributes);
                style._dynamicTechniques.set(key, technique);
            }
        }
        else {
            technique = style._staticTechnique;
            if (technique === undefined) {
                style._staticTechnique = technique = this.createTechnique(style, `${style._styleSetIndex}`, []);
            }
        }
        if (technique._index === undefined) {
            technique._index = this.m_techniques.length;
            this.m_techniques.push(technique);
        }
        return technique;
    }
    getDynamicTechniqueKey(style, dynamicAttributes) {
        const dynamicAttrKey = dynamicAttributes
            .map(([_attrName, attrValue]) => {
            if (attrValue === undefined) {
                return "U";
            }
            else {
                return JSON.stringify(attrValue);
            }
        })
            .join(":");
        return `${style._styleSetIndex}:${dynamicAttrKey}`;
    }
    checkStyleDynamicAttributes(style) {
        if (style._dynamicTechniqueAttributes !== undefined || style.technique === "none") {
            return;
        }
        style._dynamicTechniqueAttributes = [];
        style._dynamicFeatureAttributes = [];
        style._dynamicForwardedAttributes = [];
        style._staticAttributes = [];
        const dynamicFeatureAttributes = style._dynamicFeatureAttributes;
        const dynamicTechniqueAttributes = style._dynamicTechniqueAttributes;
        const dynamicForwardedAttributes = style._dynamicForwardedAttributes;
        const targetStaticAttributes = style._staticAttributes;
        const techniqueDescriptor = Techniques_1.techniqueDescriptors[style.technique] || emptyTechniqueDescriptor;
        const processAttribute = (attrName, attrValue) => {
            if (attrValue === undefined) {
                return;
            }
            if (Expr_1.isJsonExpr(attrValue)) {
                attrValue = Expr_1.Expr.fromJSON(attrValue, this.m_definitions, this.m_definitionExprCache).intern(this.m_exprPool);
            }
            else if (InterpolatedProperty_1.isInterpolatedPropertyDefinition(attrValue)) {
                // found a property using an object-like interpolation definition.
                attrValue = Expr_1.Expr.fromJSON(InterpolatedPropertyDefs_1.interpolatedPropertyDefinitionToJsonExpr(attrValue)).intern(this.m_exprPool);
            }
            if (Expr_1.Expr.isExpr(attrValue)) {
                const deps = attrValue.dependencies();
                if (!deps.zoom && deps.properties.size === 0) {
                    // no data-dependencies detected.
                    attrValue = attrValue.evaluate(this.m_emptyEnv);
                }
            }
            if (Expr_1.Expr.isExpr(attrValue)) {
                let attrScope = techniqueDescriptor.attrScopes[attrName];
                if (attrScope === undefined) {
                    // Use [[AttrScope.TechniqueGeometry]] as default scope for the attribute.
                    attrScope = TechniqueDescriptor_1.AttrScope.TechniqueGeometry;
                }
                const deps = attrValue.dependencies();
                switch (attrScope) {
                    case TechniqueDescriptor_1.AttrScope.FeatureGeometry:
                        dynamicFeatureAttributes.push([attrName, attrValue]);
                        break;
                    case TechniqueDescriptor_1.AttrScope.TechniqueGeometry:
                        dynamicTechniqueAttributes.push([attrName, attrValue]);
                        break;
                    case TechniqueDescriptor_1.AttrScope.TechniqueRendering:
                        if (deps.properties.size === 0) {
                            dynamicForwardedAttributes.push([attrName, attrValue]);
                        }
                        else {
                            dynamicTechniqueAttributes.push([attrName, attrValue]);
                        }
                        break;
                }
            }
            else if (attrValue !== undefined && attrValue !== null) {
                targetStaticAttributes.push([attrName, attrValue]);
            }
        };
        processAttribute("_category", style.category);
        processAttribute("_secondaryCategory", style.secondaryCategory);
        processAttribute("renderOrder", style.renderOrder);
        // TODO: What the heck is that !?
        processAttribute("label", style.labelProperty);
        // line & solid-line secondaryRenderOrder should be generic attr
        // TODO: maybe just warn and force move it to `attr` ?
        processAttribute("secondaryRenderOrder", style.secondaryRenderOrder);
        if (style.attr !== undefined) {
            for (const attrName in style.attr) {
                if (!style.attr.hasOwnProperty(attrName)) {
                    continue;
                }
                processAttribute(attrName, style.attr[attrName]);
            }
        }
        if (dynamicTechniqueAttributes.length > 0) {
            style._dynamicTechniques = new Map();
        }
    }
    evaluateTechniqueProperties(style, env) {
        if (style._dynamicTechniqueAttributes === undefined) {
            return [];
        }
        const instantiationContext = { env };
        return style._dynamicTechniqueAttributes.map(([attrName, attrExpr]) => {
            try {
                if (attrExpr.isDynamic()) {
                    const reducedExpr = attrExpr.instantiate(instantiationContext);
                    return [attrName, reducedExpr];
                }
                const evaluatedValue = attrExpr.evaluate(env, Expr_1.ExprScope.Value, this.m_cachedResults);
                return [attrName, evaluatedValue];
            }
            catch (error) {
                logger.error(`failed to evaluate expression '${attrExpr.toJSON()}': ${error}`);
                return [attrName, null];
            }
        });
    }
    createTechnique(style, key, dynamicAttrs) {
        const technique = {};
        technique.name = style.technique;
        if (style._staticAttributes !== undefined) {
            for (const [attrName, attrValue] of style._staticAttributes) {
                if (attrValue !== null) {
                    technique[attrName] = attrValue;
                }
            }
        }
        for (const [attrName, attrValue] of dynamicAttrs) {
            if (attrValue !== null) {
                technique[attrName] = attrValue;
            }
        }
        if (style._dynamicFeatureAttributes !== undefined) {
            for (const [attrName, attrValue] of style._dynamicFeatureAttributes) {
                technique[attrName] = attrValue;
            }
        }
        if (style._dynamicForwardedAttributes !== undefined) {
            for (const [attrName, attrValue] of style._dynamicForwardedAttributes) {
                // tslint:disable-next-line: prefer-conditional-expression
                if (Expr_1.Expr.isExpr(attrValue)) {
                    technique[attrName] = attrValue.toJSON();
                }
                else {
                    technique[attrName] = attrValue;
                }
            }
        }
        technique._index = this.m_techniques.length;
        technique._styleSetIndex = style._styleSetIndex;
        technique._key = key;
        if (style.styleSet !== undefined) {
            technique._styleSet = style.styleSet;
        }
        this.m_techniques.push(technique);
        return technique;
    }
}
exports.StyleSetEvaluator = StyleSetEvaluator;
function computeDefaultRenderOrder(styleSet) {
    let techniqueRenderOrder = 0;
    let styleSetIndex = 0;
    for (const style of styleSet) {
        style._styleSetIndex = styleSetIndex++;
        if (style.technique !== undefined && style.renderOrder === undefined) {
            style.renderOrder = techniqueRenderOrder++;
        }
    }
}
function resolveReferences(styleSet, definitions) {
    return styleSet.map(style => resolveStyleReferences(style, definitions));
}
function resolveStyleReferences(style, definitions) {
    if (Expr_1.isJsonExpr(style)) {
        if (!Theme_1.isJsonExprReference(style)) {
            throw new Error("invalid expression in this context, only 'ref's are supported");
        }
        // expand and instantiate references to style definitions.
        const definitionName = style[1];
        const def = definitions && definitions[definitionName];
        if (!def) {
            throw new Error(`invalid reference '${definitionName}' - not found`);
        }
        if (!Theme_1.isActualSelectorDefinition(def)) {
            throw new Error(`invalid reference '${definitionName}' - expected style definition`);
        }
        // instantiate the style
        return resolveStyleReferences(def, definitions);
    }
    return Object.assign({}, style);
}
/**
 * Create transferable representation of dynamic technique.
 *
 * As for now, we remove all `Expr` as they are not supported on other side.
 */
function makeDecodedTechnique(technique) {
    const result = {};
    for (const attrName in technique) {
        if (!technique.hasOwnProperty(attrName)) {
            continue;
        }
        let attrValue = technique[attrName];
        if (Expr_1.Expr.isExpr(attrValue)) {
            attrValue = attrValue.toJSON();
        }
        result[attrName] = attrValue;
    }
    return result;
}
exports.makeDecodedTechnique = makeDecodedTechnique;


/***/ }),

/***/ "../harp-datasource-protocol/lib/TechniqueAttr.ts":
/*!********************************************************!*\
  !*** ../harp-datasource-protocol/lib/TechniqueAttr.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const Expr_1 = __webpack_require__(/*! ./Expr */ "../harp-datasource-protocol/lib/Expr.ts");
const InterpolatedProperty_1 = __webpack_require__(/*! ./InterpolatedProperty */ "../harp-datasource-protocol/lib/InterpolatedProperty.ts");
const logger = harp_utils_1.LoggerManager.instance.create("TechniqueAttr");
function evaluateTechniqueAttr(context, attrValue, defaultValue) {
    const env = context instanceof Expr_1.Env ? context : context.env;
    let evaluated;
    if (Expr_1.Expr.isExpr(attrValue)) {
        try {
            evaluated = attrValue.evaluate(env, Expr_1.ExprScope.Dynamic, !(context instanceof Expr_1.Env) ? context.cachedExprResults : undefined);
        }
        catch (error) {
            logger.error(`failed to evaluate expression '${JSON.stringify(attrValue)}': ${error}`);
            evaluated = undefined;
        }
    }
    else if (InterpolatedProperty_1.isInterpolatedProperty(attrValue)) {
        evaluated = InterpolatedProperty_1.getPropertyValue(attrValue, context instanceof Expr_1.Env ? context : context.env);
    }
    else {
        evaluated = attrValue;
    }
    if (evaluated === undefined || evaluated === null) {
        return defaultValue;
    }
    else {
        return evaluated;
    }
}
exports.evaluateTechniqueAttr = evaluateTechniqueAttr;


/***/ }),

/***/ "../harp-datasource-protocol/lib/TechniqueDescriptor.ts":
/*!**************************************************************!*\
  !*** ../harp-datasource-protocol/lib/TechniqueDescriptor.ts ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
var AttrScope;
(function (AttrScope) {
    /**
     * Attributes that affect generation of feature geometry and thus must be resolved at decoding
     * time.
     *
     * They may have huge variancy as they are implemented as vertex attributes or embedded in
     * generated meshes.
     *
     * These attributes are available only in decoding scope.
     */
    AttrScope[AttrScope["FeatureGeometry"] = 0] = "FeatureGeometry";
    /**
     * Attributes that are common to whole group of features drawn with this technique.
     * These attributes affect generated geometry and  thus must be resolved at decoding time.
     *
     * They shouldn't have big variancy and evaluate to at least dozens of values as each
     * combination of these attributes consitute new technique and material.
     *
     * These attributes are available in decoding and rendering scope.
     */
    AttrScope[AttrScope["TechniqueGeometry"] = 1] = "TechniqueGeometry";
    /**
     * Attributes that are common to whole group of features drawn with this technique.
     * Attributes that can be changed in resulting object/material from frame to frame. They are
     * usually implemented as uniforms.
     *
     * These attributes may be available only at rendering scope.
     */
    AttrScope[AttrScope["TechniqueRendering"] = 2] = "TechniqueRendering";
})(AttrScope = exports.AttrScope || (exports.AttrScope = {}));
function mergeTechniqueDescriptor(...descriptors) {
    const result = {
        attrScopes: {}
    };
    for (const descriptor of descriptors) {
        if (descriptor.attrTransparencyColor !== undefined) {
            result.attrTransparencyColor = descriptor.attrTransparencyColor;
        }
        if (descriptor.attrScopes !== undefined) {
            result.attrScopes = Object.assign(Object.assign({}, result.attrScopes), descriptor.attrScopes);
        }
    }
    return result;
}
exports.mergeTechniqueDescriptor = mergeTechniqueDescriptor;


/***/ }),

/***/ "../harp-datasource-protocol/lib/TechniqueParams.ts":
/*!**********************************************************!*\
  !*** ../harp-datasource-protocol/lib/TechniqueParams.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The kind of geometry is used to
 *
 * a) Group objects together, allowing the group to be hidden or displayed.
 *
 * b) Assigning the objects a loading phase. If a [[PhasedTileGeometryManager]] is used, techniques
 *      without a `GeometryKind` may not be processed (at the desired phase).
 *
 * Any string can be used to specify the kind of the technique in a style in the theme file. Is is
 * suggested to specify multiple kinds for specific types of data. For a highway, the following list
 * of kinds is suggested:
 *
 *    ["line", "road", "road:highway"]
 *
 * If it is a tunnel for a highway:
 *
 *    ["line", "road", "road:highway", "tunnel", "road:tunnel", "road:highway:tunnel"]
 *
 * If specified in this way, specific types of data (here: highway roads) can be enabled and/or
 * disabled.
 */
var GeometryKind;
(function (GeometryKind) {
    /**
     * Used in the enabledKinds/disabledKinds filter to match any kind.
     */
    GeometryKind["All"] = "_all_";
    /**
     * Background geometry.
     */
    GeometryKind["Background"] = "background";
    /**
     * Terrain geometry.
     */
    GeometryKind["Terrain"] = "terrain";
    /**
     * Default value for the FillTechnique.
     */
    GeometryKind["Area"] = "area";
    /**
     * Default value for all line techniques.
     */
    GeometryKind["Line"] = "line";
    /**
     * Default value for the FillTechnique.
     */
    GeometryKind["Water"] = "water";
    /**
     * Political borders.
     */
    GeometryKind["Border"] = "border";
    /**
     * Basis for all roads.
     */
    GeometryKind["Road"] = "road";
    /**
     * Default value for the ExtrudedPolygonTechnique.
     */
    GeometryKind["Building"] = "building";
    /**
     * Default value for the TextTechnique, LineMarkerTechnique and the PoiTechnique.
     */
    GeometryKind["Label"] = "label";
    /**
     * Anything that may show up last.
     */
    GeometryKind["Detail"] = "detail";
})(GeometryKind = exports.GeometryKind || (exports.GeometryKind = {}));
/**
 * A set of [[GeometryKind]]s.
 */
class GeometryKindSet extends Set {
    /**
     * Return `true` if the Set is a superset of the set 'subset'.
     */
    isSuperset(subset) {
        for (const elem of subset) {
            if (!this.has(elem)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Return `true` if the Set intersects Set 'set'.
     */
    hasIntersection(set) {
        for (const elem of set) {
            if (this.has(elem)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Return `true` if the Set either intersects Set 'set' (if set is a Set), of has element 'set'
     * if set is not a Set.
     */
    hasOrIntersects(set) {
        if (set instanceof Set) {
            return this.hasIntersection(set);
        }
        return this.has(set);
    }
    /**
     * Return `true` if this set and the array of elements share at least a single element.
     */
    hasOrIntersectsArray(subset) {
        for (const elem of subset) {
            if (this.has(elem)) {
                return true;
            }
        }
        return false;
    }
}
exports.GeometryKindSet = GeometryKindSet;
var TextureCoordinateType;
(function (TextureCoordinateType) {
    /**
     * Texture coordinates are in tile space.
     * SW of the tile will have (0,0) and NE will have (1,1).
     */
    TextureCoordinateType["TileSpace"] = "tile-space";
    /**
     * Texture coordinates are in equirectangular space.
     * (u, v) = ( (longitude+180) / 360, (latitude+90) / 180).
     */
    TextureCoordinateType["EquirectangularSpace"] = "equirectangular-space";
})(TextureCoordinateType = exports.TextureCoordinateType || (exports.TextureCoordinateType = {}));
/**
 * Define the stacking option. Enum values for theme file are in "kebab-case".
 */
var PoiStackMode;
(function (PoiStackMode) {
    /**
     * Show in a stack.
     */
    PoiStackMode["Show"] = "show-in-stack";
    /**
     * Do not show in a stack.
     */
    PoiStackMode["Hide"] = "hide-in-stack";
    /**
     * Show category parent in the stack.
     */
    PoiStackMode["ShowParent"] = "show-parent";
})(PoiStackMode = exports.PoiStackMode || (exports.PoiStackMode = {}));
/**
 * Type guard to check if an object is an instance of `TextureBuffer`.
 */
function isTextureBuffer(object) {
    return object && object.buffer && typeof object.type === "string";
}
exports.isTextureBuffer = isTextureBuffer;


/***/ }),

/***/ "../harp-datasource-protocol/lib/Techniques.ts":
/*!*****************************************************!*\
  !*** ../harp-datasource-protocol/lib/Techniques.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const TechniqueParams_1 = __webpack_require__(/*! ./TechniqueParams */ "../harp-datasource-protocol/lib/TechniqueParams.ts");
const TechniqueDescriptor_1 = __webpack_require__(/*! ./TechniqueDescriptor */ "../harp-datasource-protocol/lib/TechniqueDescriptor.ts");
/**
 * Names of the supported texture properties.
 */
exports.TEXTURE_PROPERTY_KEYS = [
    "map",
    "normalMap",
    "displacementMap",
    "roughnessMap",
    "emissiveMap",
    "alphaMap",
    "metalnessMap",
    "bumpMap"
];
/**
 * Names of the properties controlling transparency.
 */
exports.TRANSPARENCY_PROPERTY_KEYS = ["opacity", "transparent"];
exports.techniqueDescriptors = {};
exports.baseTechniqueParamsDescriptor = {
    // TODO: Choose which techniques should support color with transparency.
    // For now we chosen all, but it maybe not suitable for text or line marker techniques.
    attrTransparencyColor: "color",
    attrScopes: {
        renderOrder: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        renderOrderOffset: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        enabled: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        kind: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        transient: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        fadeFar: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        fadeNear: TechniqueDescriptor_1.AttrScope.TechniqueRendering
    }
};
exports.pointTechniquePropTypes = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, {
    attrScopes: {
        texture: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        enablePicking: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        color: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        transparent: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        opacity: TechniqueDescriptor_1.AttrScope.TechniqueGeometry
    }
});
exports.squaresTechniquePropTypes = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, exports.pointTechniquePropTypes);
exports.techniqueDescriptors.squares = exports.squaresTechniquePropTypes;
exports.circlesTechniquePropTypes = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, exports.pointTechniquePropTypes);
exports.techniqueDescriptors.circles = exports.circlesTechniquePropTypes;
const lineMarkerTechniquePropTypes = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, {
    attrScopes: {
        text: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        label: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        useAbbreviation: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        useIsoCode: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        priority: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        textMinZoomLevel: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        textMaxZoomLevel: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        iconMinZoomLevel: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        iconMaxZoomLevel: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        distanceScale: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        textMayOverlap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        iconMayOverlap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        textReserveSpace: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        iconReserveSpace: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        renderTextDuringMovements: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        alwaysOnTop: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        textIsOptional: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        showOnMap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        stackMode: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        minDistance: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        iconIsOptional: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        iconFadeTime: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        textFadeTime: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        xOffset: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        yOffset: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        iconXOffset: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        iconYOffset: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        iconScale: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        screenHeight: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        screenWidth: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        poiTable: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        poiName: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        poiNameField: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        imageTexture: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        imageTextureField: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        imageTexturePrefix: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        imageTexturePostfix: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        style: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        fontName: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        fontStyle: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        fontVariant: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        rotation: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        tracking: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        leading: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        maxLines: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        lineWidth: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        canvasRotation: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        lineRotation: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        wrappingMode: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        hAlignment: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        vAlignment: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        backgroundColor: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        backgroundSize: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        backgroundOpacity: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        color: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        opacity: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        size: TechniqueDescriptor_1.AttrScope.TechniqueRendering
    }
});
exports.techniqueDescriptors["line-marker"] = lineMarkerTechniquePropTypes;
exports.techniqueDescriptors["labeled-icon"] = lineMarkerTechniquePropTypes;
const polygonalTechniqueDescriptor = {
    attrScopes: {
        polygonOffset: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        polygonOffsetFactor: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        polygonOffsetUnits: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        lineColor: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        lineFadeFar: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        lineFadeNear: TechniqueDescriptor_1.AttrScope.TechniqueRendering
    }
};
exports.solidLineTechniqueDescriptor = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, polygonalTechniqueDescriptor, {
    attrScopes: {
        clipping: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        secondaryRenderOrder: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        color: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        opacity: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        transparent: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        lineWidth: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        secondaryWidth: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        secondaryColor: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        dashSize: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        gapSize: TechniqueDescriptor_1.AttrScope.TechniqueRendering
    }
});
exports.techniqueDescriptors["solid-line"] = exports.solidLineTechniqueDescriptor;
// TODO: Remove deprecated "dashed-line" support in future releases.
exports.techniqueDescriptors["dashed-line"] = exports.solidLineTechniqueDescriptor;
exports.lineTechniqueDescriptor = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, {
    attrScopes: {
        // TODO, check, which are really dynamic !
        color: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        opacity: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        transparent: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        lineWidth: TechniqueDescriptor_1.AttrScope.FeatureGeometry
    }
});
exports.techniqueDescriptors.line = exports.lineTechniqueDescriptor;
const fillTechniqueDescriptor = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, polygonalTechniqueDescriptor, {
    attrScopes: {
        color: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        opacity: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        transparent: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        lineWidth: TechniqueDescriptor_1.AttrScope.TechniqueRendering
    }
});
exports.techniqueDescriptors.fill = fillTechniqueDescriptor;
const standardTechniqueDescriptor = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, {
    attrScopes: {
        color: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        vertexColors: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        wireframe: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        roughness: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        metalness: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        alphaTest: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        depthTest: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        transparent: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        opacity: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        emissive: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        emissiveIntensity: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        refractionRatio: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        map: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        mapProperties: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        normalMap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        normalMapProperties: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        displacementMap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        displacementMapProperties: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        roughnessMap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        roughnessMapProperties: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        emissiveMap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        emissiveMapProperties: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        bumpMap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        bumpMapProperties: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        metalnessMap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        metalnessMapProperties: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        alphaMap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        alphaMapProperties: TechniqueDescriptor_1.AttrScope.TechniqueGeometry
    }
});
exports.techniqueDescriptors.standard = standardTechniqueDescriptor;
const extrudedPolygonTechniqueDescriptor = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, standardTechniqueDescriptor, {
    attrScopes: {
        height: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        floorHeight: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        color: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        defaultColor: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        defaultHeight: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        constantHeight: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        boundaryWalls: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        footprint: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        maxSlope: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        enableDepthPrePass: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        animateExtrusionDuration: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        animateExtrusion: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        opacity: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        transparent: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        lineWidth: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        lineFadeNear: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        lineFadeFar: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        lineColorMix: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        lineColor: TechniqueDescriptor_1.AttrScope.TechniqueRendering
    }
});
exports.techniqueDescriptors["extruded-polygon"] = extrudedPolygonTechniqueDescriptor;
const textTechniqueDescriptor = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, {
    attrScopes: {
        text: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        label: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        useAbbreviation: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        useIsoCode: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        minZoomLevel: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        maxZoomLevel: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        distanceScale: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        mayOverlap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        reserveSpace: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        textFadeTime: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        xOffset: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        yOffset: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        style: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        fontName: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        fontStyle: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        fontVariant: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        rotation: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        tracking: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        leading: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        maxLines: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        lineWidth: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        canvasRotation: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        lineRotation: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        wrappingMode: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        hAlignment: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        vAlignment: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        backgroundColor: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        backgroundSize: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        backgroundOpacity: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        color: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        opacity: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        priority: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        size: TechniqueDescriptor_1.AttrScope.TechniqueRendering
    }
});
exports.techniqueDescriptors.text = textTechniqueDescriptor;
const shaderTechniqueDescriptor = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, {
    attrScopes: {
        primitive: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        params: TechniqueDescriptor_1.AttrScope.TechniqueRendering
    }
});
exports.techniqueDescriptors.shader = shaderTechniqueDescriptor;
/**
 * Type guard to check if an object is an instance of [[CirclesTechnique]].
 */
function isCirclesTechnique(technique) {
    return technique.name === "circles";
}
exports.isCirclesTechnique = isCirclesTechnique;
/**
 * Type guard to check if an object is an instance of [[SquaresTechnique]].
 */
function isSquaresTechnique(technique) {
    return technique.name === "squares";
}
exports.isSquaresTechnique = isSquaresTechnique;
/**
 * Type guard to check if an object is an instance of [[PoiTechnique]].
 */
function isPoiTechnique(technique) {
    return technique.name === "labeled-icon";
}
exports.isPoiTechnique = isPoiTechnique;
/**
 * Type guard to check if an object is an instance of [[LineMarkerTechnique]].
 */
function isLineMarkerTechnique(technique) {
    return technique.name === "line-marker";
}
exports.isLineMarkerTechnique = isLineMarkerTechnique;
/**
 * Type guard to check if an object is an instance of [[LineTechnique]].
 */
function isLineTechnique(technique) {
    return technique.name === "line";
}
exports.isLineTechnique = isLineTechnique;
/**
 * Type guard to check if an object is an instance of [[SolidLineTechnique]].
 */
function isSolidLineTechnique(technique) {
    return technique.name === "solid-line" || technique.name === "dashed-line";
}
exports.isSolidLineTechnique = isSolidLineTechnique;
/**
 * Type guard to check if an object is an instance of [[SolidLineTechnique]] and is a kind that
 * has special dashes.
 * @note Lines with special dashes need line caps to render properly.
 */
function isSpecialDashesLineTechnique(technique) {
    return ((technique.name === "solid-line" || technique.name === "dashed-line") &&
        technique.dashes !== undefined &&
        technique.dashes !== "Square");
}
exports.isSpecialDashesLineTechnique = isSpecialDashesLineTechnique;
/**
 * Type guard to check if an object is an instance of [[SegmentsTechnique]].
 */
function isSegmentsTechnique(technique) {
    return technique.name === "segments";
}
exports.isSegmentsTechnique = isSegmentsTechnique;
/**
 * Type guard to check if an object is an instance of [[BasicExtrudedLineTechnique]]
 * or [[StandardExtrudedLineTechnique]].
 */
function isExtrudedLineTechnique(technique) {
    return technique.name === "extruded-line";
}
exports.isExtrudedLineTechnique = isExtrudedLineTechnique;
/**
 * Type guard to check if an object is an instance of [[BasicExtrudedLineTechnique]].
 */
function isBasicExtrudedLineTechnique(technique) {
    return isExtrudedLineTechnique(technique) && technique.shading === "basic";
}
exports.isBasicExtrudedLineTechnique = isBasicExtrudedLineTechnique;
/**
 * Type guard to check if an object is an instance of [[StandardExtrudedLineTechnique]].
 */
function isStandardExtrudedLineTechnique(technique) {
    return isExtrudedLineTechnique(technique) && technique.shading === "standard";
}
exports.isStandardExtrudedLineTechnique = isStandardExtrudedLineTechnique;
/**
 * Type guard to check if an object is an instance of [[FillTechnique]].
 */
function isFillTechnique(technique) {
    return technique.name === "fill";
}
exports.isFillTechnique = isFillTechnique;
/**
 * Type guard to check if an object is an instance of [[ExtrudedPolygonTechnique]].
 */
function isExtrudedPolygonTechnique(technique) {
    return technique.name === "extruded-polygon";
}
exports.isExtrudedPolygonTechnique = isExtrudedPolygonTechnique;
/**
 * Type guard to check if an object is an instance of [[StandardTechnique]].
 */
function isStandardTechnique(technique) {
    return technique.name === "standard";
}
exports.isStandardTechnique = isStandardTechnique;
/**
 * Type guard to check if an object is an instance of [[TerrainTechnique]].
 */
function isTerrainTechnique(technique) {
    return technique.name === "terrain";
}
exports.isTerrainTechnique = isTerrainTechnique;
/**
 * Type guard to check if an object is an instance of [[TextTechnique]].
 */
function isTextTechnique(technique) {
    return technique.name === "text";
}
exports.isTextTechnique = isTextTechnique;
/**
 * Type guard to check if an object is an instance of [[ShaderTechnique]].
 */
function isShaderTechnique(technique) {
    return technique.name === "shader";
}
exports.isShaderTechnique = isShaderTechnique;
function isLabelRejectionLineTechnique(technique) {
    return technique.name === "label-rejection-line";
}
exports.isLabelRejectionLineTechnique = isLabelRejectionLineTechnique;
/**
 * Check if vertex normals should be generated for this technique (if no normals are in the data).
 * @param technique Technique to check.
 */
function needsVertexNormals(technique) {
    return (isFillTechnique(technique) ||
        isStandardTechnique(technique) ||
        isTerrainTechnique(technique) ||
        isStandardExtrudedLineTechnique(technique));
}
exports.needsVertexNormals = needsVertexNormals;
/**
 * Get the texture coordinate type if the technique supports it.
 */
function textureCoordinateType(technique) {
    if (isStandardTechnique(technique)) {
        return technique.textureCoordinateType;
    }
    else if (isExtrudedPolygonTechnique(technique)) {
        return technique.textureCoordinateType;
    }
    else if (isTerrainTechnique(technique)) {
        return technique.textureCoordinateType;
    }
    else {
        return undefined;
    }
}
exports.textureCoordinateType = textureCoordinateType;
/**
 * Add all the buffers of the technique to the transfer list.
 */
function addBuffersToTransferList(technique, transferList) {
    if (isStandardTechnique(technique) ||
        isExtrudedPolygonTechnique(technique) ||
        isTerrainTechnique(technique)) {
        for (const texturePropertyKey of exports.TEXTURE_PROPERTY_KEYS) {
            const textureProperty = technique[texturePropertyKey];
            if (TechniqueParams_1.isTextureBuffer(textureProperty)) {
                if (textureProperty.buffer instanceof ArrayBuffer) {
                    transferList.push(textureProperty.buffer);
                }
            }
        }
    }
}
exports.addBuffersToTransferList = addBuffersToTransferList;
/**
 * Compose full texture name for given image name with technique specified.
 * Some techniques allows to add prefix/postfix to icons names specified, this
 * function uses technique information to create fully qualified texture name.
 * @param imageName base name of the marker icon.
 * @param technique the technique describing POI or line marker.
 * @returns fully qualified texture name for loading from atlas (without extension).
 */
function composeTechniqueTextureName(imageName, technique) {
    let textureName = imageName;
    if (typeof technique.imageTexturePrefix === "string") {
        textureName = technique.imageTexturePrefix + textureName;
    }
    if (typeof technique.imageTexturePostfix === "string") {
        textureName = textureName + technique.imageTexturePostfix;
    }
    return textureName;
}
exports.composeTechniqueTextureName = composeTechniqueTextureName;


/***/ }),

/***/ "../harp-datasource-protocol/lib/Theme.ts":
/*!************************************************!*\
  !*** ../harp-datasource-protocol/lib/Theme.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Expr_1 = __webpack_require__(/*! ./Expr */ "../harp-datasource-protocol/lib/Expr.ts");
const InterpolatedProperty_1 = __webpack_require__(/*! ./InterpolatedProperty */ "../harp-datasource-protocol/lib/InterpolatedProperty.ts");
/**
 * Checks if the given definition implements the [[BoxedDefinition]] interface.
 */
function isBoxedDefinition(def) {
    const bdef = def;
    return (typeof bdef === "object" &&
        bdef !== null &&
        (typeof bdef.type === "string" || typeof bdef.type === "undefined") &&
        (typeof bdef.value === "string" ||
            typeof bdef.value === "number" ||
            typeof bdef.value === "boolean" ||
            InterpolatedProperty_1.isInterpolatedPropertyDefinition(bdef.value) ||
            Expr_1.isJsonExpr(bdef.value)));
}
exports.isBoxedDefinition = isBoxedDefinition;
function isLiteralDefinition(def) {
    return typeof def === "string" || typeof def === "number" || typeof def === "boolean";
}
exports.isLiteralDefinition = isLiteralDefinition;
/**
 * Checks if the given value is a reference to a definition.
 *
 * @param value The value of a technique property.
 */
function isJsonExprReference(value) {
    return (Array.isArray(value) &&
        value.length === 2 &&
        value[0] === "ref" &&
        typeof value[1] === "string");
}
exports.isJsonExprReference = isJsonExprReference;
function isActualSelectorDefinition(def) {
    const styleDef = def;
    return (typeof styleDef === "object" &&
        styleDef !== null &&
        !Array.isArray(styleDef) &&
        typeof styleDef.technique === "string");
}
exports.isActualSelectorDefinition = isActualSelectorDefinition;


/***/ }),

/***/ "../harp-datasource-protocol/lib/ThemeVisitor.ts":
/*!*******************************************************!*\
  !*** ../harp-datasource-protocol/lib/ThemeVisitor.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Expr_1 = __webpack_require__(/*! ./Expr */ "../harp-datasource-protocol/lib/Expr.ts");
/**
 * The ThemeVisitor visits every style in the theme in a depth-first fashion.
 */
class ThemeVisitor {
    constructor(theme) {
        this.theme = theme;
    }
    /**
     * Applies a function to every style in the theme.
     *
     * @param visitFunc Function to be called with `style` as an argument. Function should return
     *                  `true` to cancel visitation.
     * @returns `true` if function has finished prematurely.
     */
    visitStyles(visitFunc) {
        const visit = (style) => {
            if (Expr_1.isJsonExpr(style)) {
                return false;
            }
            if (visitFunc(style)) {
                return true;
            }
            return false;
        };
        if (this.theme.styles !== undefined) {
            for (const styleSetName in this.theme.styles) {
                if (this.theme.styles[styleSetName] !== undefined) {
                    for (const style of this.theme.styles[styleSetName]) {
                        if (visit(style)) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
}
exports.ThemeVisitor = ThemeVisitor;


/***/ }),

/***/ "../harp-datasource-protocol/lib/ThreeBufferUtils.ts":
/*!***********************************************************!*\
  !*** ../harp-datasource-protocol/lib/ThreeBufferUtils.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const DecodedTile_1 = __webpack_require__(/*! ./DecodedTile */ "../harp-datasource-protocol/lib/DecodedTile.ts");
/**
 * Collection of helper methods to convert
 * {@link https://threejs.org/docs/index.html#api/en/core/BufferGeometry|three.js BufferGeometry}
 * to [[Geometry]] that allows creation and transfering of THREE BufferGeometry in webworkers.
 * See also [[CustomDatasourceExample]].
 */
var ThreeBufferUtils;
(function (ThreeBufferUtils) {
    function getBufferElementType(buffer) {
        if (buffer instanceof Int8Array) {
            return "int8";
        }
        else if (buffer instanceof Uint8Array) {
            return "uint8";
        }
        else if (buffer instanceof Int16Array) {
            return "int16";
        }
        else if (buffer instanceof Uint16Array) {
            return "uint16";
        }
        else if (buffer instanceof Int32Array) {
            return "int32";
        }
        else if (buffer instanceof Uint32Array) {
            return "uint32";
        }
        else if (buffer instanceof Float32Array) {
            return "float";
        }
        throw new Error(`Unsupported buffer type ${name}`);
    }
    ThreeBufferUtils.getBufferElementType = getBufferElementType;
    function fromThreeBufferAttribute(bufferAttribute) {
        const buffer = bufferAttribute.array;
        return {
            name: bufferAttribute.name,
            buffer: buffer.buffer,
            type: getBufferElementType(buffer),
            itemCount: bufferAttribute.itemSize,
            normalized: bufferAttribute.normalized
        };
    }
    ThreeBufferUtils.fromThreeBufferAttribute = fromThreeBufferAttribute;
    function fromThreeInterleavedBufferAttribute(bufferAttribute) {
        throw new Error("Not implemented yet");
    }
    ThreeBufferUtils.fromThreeInterleavedBufferAttribute = fromThreeInterleavedBufferAttribute;
    function fromThreeBufferGeometry(bufferGeometry, techniqueIndex) {
        const vertexAttributes = [];
        const attributeNames = Object.getOwnPropertyNames(bufferGeometry.attributes);
        for (const name of attributeNames) {
            const attribute = bufferGeometry.attributes[name];
            // FIXME: Also support InterleavedBufferAttribute
            const vertexAttribute = fromThreeBufferAttribute(attribute);
            vertexAttribute.name = name;
            vertexAttributes.push(vertexAttribute);
        }
        const index = bufferGeometry.index !== null
            ? fromThreeBufferAttribute(bufferGeometry.index)
            : undefined;
        let count = 0;
        if (index !== undefined) {
            count = bufferGeometry.index === null ? 0 : bufferGeometry.index.count;
        }
        else {
            // If there is no index buffer, try to deduce the count from the position attribute.
            const posAttr = bufferGeometry.attributes.position;
            if (posAttr === undefined) {
                throw new Error("Missing position attibute to deduce item count");
            }
            count = posAttr.count;
        }
        return {
            type: DecodedTile_1.GeometryType.Unspecified,
            vertexAttributes,
            index,
            groups: [{ start: 0, count, technique: techniqueIndex }]
        };
    }
    ThreeBufferUtils.fromThreeBufferGeometry = fromThreeBufferGeometry;
})(ThreeBufferUtils = exports.ThreeBufferUtils || (exports.ThreeBufferUtils = {}));


/***/ }),

/***/ "../harp-datasource-protocol/lib/TileInfo.ts":
/*!***************************************************!*\
  !*** ../harp-datasource-protocol/lib/TileInfo.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const Expr_1 = __webpack_require__(/*! ./Expr */ "../harp-datasource-protocol/lib/Expr.ts");
const StyleSetEvaluator_1 = __webpack_require__(/*! ./StyleSetEvaluator */ "../harp-datasource-protocol/lib/StyleSetEvaluator.ts");
const TechniqueAttr_1 = __webpack_require__(/*! ./TechniqueAttr */ "../harp-datasource-protocol/lib/TechniqueAttr.ts");
const Techniques_1 = __webpack_require__(/*! ./Techniques */ "../harp-datasource-protocol/lib/Techniques.ts");
/**
 * Represents a feature group type for tile info.
 */
var FeatureGroupType;
(function (FeatureGroupType) {
    FeatureGroupType[FeatureGroupType["Point"] = 0] = "Point";
    FeatureGroupType[FeatureGroupType["Line"] = 1] = "Line";
    FeatureGroupType[FeatureGroupType["Polygon"] = 2] = "Polygon";
})(FeatureGroupType = exports.FeatureGroupType || (exports.FeatureGroupType = {}));
/**
 * Minimum estimated size of a JS object.
 */
const MINIMUM_OBJECT_SIZE_ESTIMATION = 100;
/**
 * Structure of arrays containing data for all features of this group. No methods, since the object
 * is being passed as part of ExtendedTileInfo across "process boundaries" to the web worker.
 *
 * Supporting methods in namespace [[ExtendedTileInfo]].
 */
class FeatureGroup {
    /**
     * Construct featureGroup.
     *
     * @param storeExtendedTags Pass `true` to create fields for more OMV tags (`layer`, `class`
     * and `type`).
     */
    constructor(storeExtendedTags, startSize = 5000) {
        /** featureIds */
        this.featureIds = new Array();
        /** number of features */
        this.numFeatures = 0;
        /** number of positions of elements (2 per point) */
        this.numPositions = 0;
        this.featureIds = new Array(startSize);
        this.featureIds.length = startSize;
        this.techniqueIndex = new Array(startSize);
        this.techniqueIndex.length = startSize;
        this.textIndex = new Array(startSize);
        this.textIndex.length = startSize;
        this.positionIndex = new Array(startSize);
        this.positionIndex.length = startSize;
        this.positions = new Array(10 * startSize);
        this.positions.length = 10 * startSize;
        if (storeExtendedTags) {
            this.layerIndex = new Array(startSize);
            this.layerIndex.length = startSize;
            this.classIndex = new Array(startSize);
            this.classIndex.length = startSize;
            this.typeIndex = new Array(startSize);
            this.typeIndex.length = startSize;
        }
    }
    /**
     * Compute size in bytes.
     */
    getNumBytes() {
        return ((this.featureIds.length +
            this.techniqueIndex.length +
            this.textIndex.length +
            this.positionIndex.length +
            this.positions.length +
            (this.layerIndex !== undefined ? this.layerIndex.length : 0) +
            (this.classIndex !== undefined ? this.classIndex.length : 0) +
            (this.typeIndex !== undefined ? this.typeIndex.length : 0)) *
            8);
    }
}
exports.FeatureGroup = FeatureGroup;
/**
 * Structure of arrays containing data for roads. No methods, since the object is being passed as
 * part of [[ExtendedTileInfo]] across "process boundaries" to the web worker.
 */
class LineFeatureGroup extends FeatureGroup {
    constructor() {
        super(...arguments);
        /**
         * An array of object defined by the user. Certain elements may be `undefined` (if this line
         * feature is not a road, or if the object for that feature is undefined).
         */
        this.userData = [];
    }
    /** @override */
    getNumBytes() {
        return (super.getNumBytes() +
            ((this.segmentIds !== undefined ? this.segmentIds.length : 0) +
                (this.segmentStartOffsets !== undefined ? this.segmentStartOffsets.length : 0) +
                (this.segmentEndOffsets !== undefined ? this.segmentEndOffsets.length : 0)) *
                8);
    }
}
exports.LineFeatureGroup = LineFeatureGroup;
/**
 * Structure of arrays containing data for polygons. No methods, since the object is being passed as
 * part of ExtendedTileInfo across "process boundaries" to the web worker.
 *
 * Supporting methods in namespace [[ExtendedTileInfo]].
 *
 * Due to the complexity of the access, there are supporting classes to store and access data in
 * the feature groups. See [[ExtendedTileInfoWriter]] and [[ExtendedTileInfoPolygonAccessor]].
 */
class PolygonFeatureGroup extends FeatureGroup {
    constructor(storeExtendedTags, startSize = 5000) {
        super(storeExtendedTags, startSize);
        /**
         * Number of rings stored in all polygons in tis group. Used to keep size of the
         * arrays.
         */
        this.groupNumRings = 0;
        this.outerRingStartIndex = new Array(startSize);
        this.outerRingStartIndex.length = startSize;
        this.innerRingIsOuterContour = new Array(startSize);
        this.innerRingIsOuterContour.length = startSize;
        this.innerRingStartIndex = new Array(startSize);
        this.innerRingStartIndex.length = startSize;
    }
    /** @override */
    getNumBytes() {
        return (super.getNumBytes() +
            ((this.outerRingStartIndex !== undefined ? this.outerRingStartIndex.length : 0) +
                (this.innerRingIsOuterContour !== undefined
                    ? this.innerRingIsOuterContour.length
                    : 0) +
                (this.innerRingStartIndex !== undefined ? this.innerRingStartIndex.length : 0)) *
                8);
    }
}
exports.PolygonFeatureGroup = PolygonFeatureGroup;
/**
 * Class to hold infos from [[OmvTile]]s. Optimized for fast serialization when being passed from
 * webworker to main thread. No methods, since the object is being passed across "process
 * boundaries" to the web worker.
 *
 * Supporting methods in namespace [[ExtendedTileInfo]].
 *
 * Due to the complexity of the access, there are supporting classes to store and access data in
 * the feature groups. See [[ExtendedTileInfoWriter]] and [[ExtendedTileInfoPolygonAccessor]].
 */
class ExtendedTileInfo {
    constructor(tileKey, storeExtendedTags) {
        this.tileKey = tileKey;
        /**
         * Catalog of strings. Addressed by every features stringIndex.
         */
        this.textCatalog = new Array();
        /**
         * Catalog of techniques. Addressed by every features featureIndex.
         */
        this.techniqueCatalog = new Array();
        /**
         * Used for performance diagnostics.
         */
        this.setupTime = 0;
        /**
         * Size in bytes.
         */
        this.numBytes = 0;
        this.pointGroup = new FeatureGroup(storeExtendedTags);
        this.lineGroup = new LineFeatureGroup(storeExtendedTags);
        this.polygonGroup = new PolygonFeatureGroup(storeExtendedTags);
        if (storeExtendedTags) {
            this.layerCatalog = new Array();
            this.classCatalog = new Array();
            this.typeCatalog = new Array();
        }
    }
    /**
     * Compute the memory footprint caused by objects owned by the `ExtendedTileInfo`.
     */
    getNumBytes() {
        let numBytes = MINIMUM_OBJECT_SIZE_ESTIMATION;
        for (const str of this.textCatalog) {
            numBytes += 2 * str.length;
        }
        numBytes += this.techniqueCatalog.length * MINIMUM_OBJECT_SIZE_ESTIMATION;
        numBytes += this.pointGroup.getNumBytes();
        numBytes += this.lineGroup.getNumBytes();
        numBytes += this.polygonGroup.getNumBytes();
        if (this.layerCatalog !== undefined) {
            for (const str of this.layerCatalog) {
                numBytes += 2 * str.length;
            }
            for (const str of this.classCatalog) {
                numBytes += 2 * str.length;
            }
            for (const str of this.typeCatalog) {
                numBytes += 2 * str.length;
            }
        }
        return numBytes;
    }
}
exports.ExtendedTileInfo = ExtendedTileInfo;
(function (ExtendedTileInfo) {
    function finishFeatureGroup(featureGroup) {
        featureGroup.featureIds.length = featureGroup.numFeatures;
        featureGroup.techniqueIndex.length = featureGroup.numFeatures;
        featureGroup.textIndex.length = featureGroup.numFeatures;
        featureGroup.positionIndex.length = featureGroup.numFeatures;
        featureGroup.positions.length = featureGroup.numPositions;
        if (featureGroup.layerIndex !== undefined) {
            featureGroup.layerIndex.length = featureGroup.numFeatures;
        }
        if (featureGroup.classIndex !== undefined) {
            featureGroup.classIndex.length = featureGroup.numFeatures;
        }
        if (featureGroup.typeIndex !== undefined) {
            featureGroup.typeIndex.length = featureGroup.numFeatures;
        }
    }
    function finishPolygonFeatureGroup(polygonGroup) {
        finishFeatureGroup(polygonGroup);
        polygonGroup.outerRingStartIndex.length = polygonGroup.numFeatures;
        polygonGroup.innerRingIsOuterContour.length = polygonGroup.groupNumRings;
        polygonGroup.innerRingStartIndex.length = polygonGroup.groupNumRings;
    }
    function finishLineFeatureGroup(lineGroup) {
        finishFeatureGroup(lineGroup);
        if (lineGroup.segmentIds !== undefined) {
            lineGroup.segmentIds.length = lineGroup.numFeatures;
            lineGroup.segmentStartOffsets.length = lineGroup.numFeatures;
            lineGroup.segmentEndOffsets.length = lineGroup.numFeatures;
        }
    }
    /**
     * Finalize the tile's features groups.
     */
    function finish(tileInfo) {
        finishFeatureGroup(tileInfo.pointGroup);
        finishLineFeatureGroup(tileInfo.lineGroup);
        finishPolygonFeatureGroup(tileInfo.polygonGroup);
        tileInfo.numBytes = tileInfo.getNumBytes();
    }
    ExtendedTileInfo.finish = finish;
    /**
     * Returns the number of features in this feature group.
     */
    function featureGroupSize(featureGroup) {
        return featureGroup.numFeatures;
    }
    ExtendedTileInfo.featureGroupSize = featureGroupSize;
    /**
     * Check if the feature group is finalized.
     */
    function featureGroupFinished(featureGroup) {
        return featureGroup.numPositions === featureGroup.positions.length;
    }
    ExtendedTileInfo.featureGroupFinished = featureGroupFinished;
    /**
     * Check if the tileInfo is finalized.
     */
    function tileInfoFinished(tileInfo) {
        return (featureGroupFinished(tileInfo.pointGroup) &&
            featureGroupFinished(tileInfo.lineGroup) &&
            featureGroupFinished(tileInfo.polygonGroup));
    }
    ExtendedTileInfo.tileInfoFinished = tileInfoFinished;
    /**
     * Determine the name of (OMV) feature. It implements the special handling required
     * to determine the text content of a feature from its tags, which are passed in as the `env`.
     *
     * @param env Environment containing the tags from the (OMV) feature.
     * @param useAbbreviation `true` to use the abbreviation if available.
     * @param useIsoCode `true` to use the tag "iso_code".
     * @param languages List of languages to use, for example: Specify "en" to use the tag "name_en"
     *                  as the text of the string. Order reflects priority.
     */
    function getFeatureName(env, useAbbreviation, useIsoCode, languages) {
        let name;
        if (useAbbreviation) {
            const abbreviation = env.lookup(`name:short`);
            if (typeof abbreviation === "string" && abbreviation.length > 0) {
                return abbreviation;
            }
        }
        if (useIsoCode) {
            const isoCode = env.lookup(`iso_code`);
            if (typeof isoCode === "string" && isoCode.length > 0) {
                return isoCode;
            }
        }
        if (languages !== undefined) {
            for (const lang of languages) {
                name = env.lookup(`name:${lang}`) || env.lookup(`name_${lang}`);
                if (typeof name === "string" && name.length > 0) {
                    return name;
                }
            }
        }
        name = env.lookup("name");
        if (typeof name === "string") {
            return name;
        }
        return undefined;
    }
    ExtendedTileInfo.getFeatureName = getFeatureName;
    /**
     * Determine the text string of the map feature. It implements the special handling required
     * to determine the text content of a feature from its tags, which are passed in as the `env`.
     *
     * @param feature Feature, including properties from the (OMV) feature.
     * @param technique technique defining how text should be created from feature
     * @param languages List of languages to use, for example: Specify "en" to use the tag "name_en"
     *                  as the text of the string. Order reflects priority.
     */
    function getFeatureText(context, technique, languages) {
        let useAbbreviation;
        let useIsoCode;
        const env = context instanceof Expr_1.Env ? context : context.env;
        if (Techniques_1.isTextTechnique(technique) ||
            Techniques_1.isPoiTechnique(technique) ||
            Techniques_1.isLineMarkerTechnique(technique)) {
            if (technique.text !== undefined) {
                return TechniqueAttr_1.evaluateTechniqueAttr(context, technique.text);
            }
            if (technique.label !== undefined) {
                const name = env.lookup(technique.label);
                return typeof name === "string" ? name : undefined;
            }
            useAbbreviation = technique.useAbbreviation;
            useIsoCode = technique.useIsoCode;
        }
        return getFeatureName(env, useAbbreviation, useIsoCode, languages);
    }
    ExtendedTileInfo.getFeatureText = getFeatureText;
})(ExtendedTileInfo = exports.ExtendedTileInfo || (exports.ExtendedTileInfo = {}));
/**
 * Support class for [[ExtendedTileInfo]]. Assist in filling it with data.
 */
class ExtendedTileInfoWriter {
    /**
     * Create an [[ExtendedTileInfoWriter]] for an [[ExtendedTileInfo]]. Assist in filling the
     * [[ExtendedTileInfo]] with data.
     *
     * @param tileInfo [[ExtendedTileInfo]] to write data to.
     * @param storeExtendedTags Pass `true` if feature data like `layer`, `class`or `type` should
     *          be stored for every feature.
     */
    constructor(tileInfo, storeExtendedTags) {
        this.tileInfo = tileInfo;
        this.storeExtendedTags = storeExtendedTags;
        /** Map to identify which techniques already have been added to the [[ExtendedTileInfo]]. */
        this.techniqueIndexMap = new Map();
        /** Map to identify which strings already have been added to the [[ExtendedTileInfo]]. */
        this.stringMap = new Map();
        /** Map to identify which `layer` names already have been added to the [[ExtendedTileInfo]]. */
        this.layerMap = new Map();
        /** Map to identify which `class` names already have been added to the [[ExtendedTileInfo]]. */
        this.classMap = new Map();
        /** Map to identify which `type` names already have been added to the [[ExtendedTileInfo]]. */
        this.typeMap = new Map();
    }
    /**
     * Adds a [[Technique]] to the catalog of techniques. Individual techniques have a `_index` file
     * which has been created in the [[StyleSetEvaluator]]. This index is required to identify a
     * technique. The `Map` is used to map techniques to already added techniques, or store the
     * technique as new, and add it to the map.
     *
     * @param technique The [[Technique]] to add.
     */
    addTechnique(technique) {
        let infoTileTechniqueIndex = this.techniqueIndexMap.get(technique._index);
        if (infoTileTechniqueIndex !== undefined) {
            return infoTileTechniqueIndex;
        }
        const decodedTechnique = StyleSetEvaluator_1.makeDecodedTechnique(technique);
        infoTileTechniqueIndex = this.tileInfo.techniqueCatalog.length;
        this.techniqueIndexMap.set(decodedTechnique._index, infoTileTechniqueIndex);
        this.tileInfo.techniqueCatalog.push(decodedTechnique);
        return infoTileTechniqueIndex;
    }
    /**
     * Add a feature.
     *
     * @param featureGroup The feature group to add to.
     * @param technique The technique to add.
     * @param env The `env` which is a mix of original OMV feature tags and fields added by the
     *      [[StyleSetEvaluator]]
     * @param featureId The featureId, a number unique for many features (but not all).
     * @param infoTileTechniqueIndex The previously computed index of the technique. Must have been
     *      computed by `addTechnique(technique)`.
     * @param isPolygonGroup `true`for polygons.
     */
    addFeature(featureGroup, env, featureId, featureText, infoTileTechniqueIndex, featureGroupType) {
        // compute name/label of feature
        let stringIndex = -1;
        if (featureText !== undefined && featureText.length > 0) {
            stringIndex = this.addText(featureText);
        }
        // add indices into the arrays.
        featureGroup.featureIds[featureGroup.numFeatures] = featureId;
        featureGroup.techniqueIndex[featureGroup.numFeatures] = infoTileTechniqueIndex;
        featureGroup.textIndex[featureGroup.numFeatures] = stringIndex;
        featureGroup.positionIndex[featureGroup.numFeatures] = featureGroup.numPositions;
        switch (featureGroupType) {
            case FeatureGroupType.Polygon:
                // polygons need the extra fields for polygon rings
                const polygonGroup = featureGroup;
                harp_utils_1.assert(polygonGroup.outerRingStartIndex !== undefined);
                harp_utils_1.assert(polygonGroup.innerRingStartIndex !== undefined);
                harp_utils_1.assert(polygonGroup.innerRingIsOuterContour !== undefined);
                polygonGroup.outerRingStartIndex[featureGroup.numFeatures] =
                    polygonGroup.groupNumRings;
                break;
            case FeatureGroupType.Line:
                featureGroup.userData[featureGroup.numFeatures] = env.entries;
                break;
        }
        // store the extra feature fields
        if (this.storeExtendedTags) {
            featureGroup.layerIndex[featureGroup.numFeatures] = this.addLayer(env.lookup("$layer"));
            featureGroup.classIndex[featureGroup.numFeatures] = this.addClass(env.lookup("class"));
            featureGroup.typeIndex[featureGroup.numFeatures] = this.addType(env.lookup("type"));
        }
        featureGroup.numFeatures++;
    }
    /**
     * Add the X/Y coordinate of the point. Only for point feature groups.
     *
     * @param featureGroup The feature group to add it to.
     * @param x X Position of point.
     * @param y Y Position of point.
     */
    addFeaturePoint(featureGroup, x, y) {
        featureGroup.positions[featureGroup.numPositions++] = x;
        featureGroup.positions[featureGroup.numPositions++] = y;
    }
    /**
     * Add the line points as X/Y coordinates to the line feature.
     *
     * If a line feature has more than one line (rare for HERE data), it should define multiple
     * line features for it.
     *
     * @param featureGroup The feature group to add to. Must be line feature group.
     * @param points The X/Y coordinates of the points.
     */
    addFeaturePoints(featureGroup, points) {
        const n = featureGroup.numPositions;
        const l = points.length;
        const p = featureGroup.positions;
        for (let i = 0; i < l; i++) {
            p[n + i] = points[i];
        }
        featureGroup.numPositions += points.length;
    }
    /**
     * Add the information about road segments to the line feature. Performs lazy initialization of
     * `segmentIds`, `segmentStartOffsets`, and `segmentEndOffsets` members of a
     * [[LineFeatureGroup]] instance.
     *
     * @param featureGroup The line feature group to add information to.
     * @param segmentId Segment id of a feature.
     * @param startOffset Start offset of a feature.
     * @param endOffset End offset of a feature.
     */
    addRoadSegments(featureGroup, segmentId, startOffset, endOffset) {
        if (featureGroup.segmentIds === undefined) {
            featureGroup.segmentIds = new Array();
            featureGroup.segmentStartOffsets = new Array();
            featureGroup.segmentEndOffsets = new Array();
        }
        featureGroup.segmentIds[featureGroup.numFeatures - 1] = segmentId;
        featureGroup.segmentStartOffsets[featureGroup.numFeatures - 1] = startOffset;
        featureGroup.segmentEndOffsets[featureGroup.numFeatures - 1] = endOffset;
    }
    /**
     * Add a single ring to the polygon. Can be called multiple times to add multiple rings to the
     * polygon.
     *
     * @param featureGroup Polygon feature group to add polygon ring to.
     * @param contour The X/Y coordinates of the ring.
     * @param isOuterRing Pass `true`if it is a outer ring, otherwise `false`.
     */
    addRingPoints(featureGroup, contour, isOuterRing) {
        featureGroup.innerRingStartIndex[featureGroup.groupNumRings] = featureGroup.numPositions;
        featureGroup.innerRingIsOuterContour[featureGroup.groupNumRings] = isOuterRing ? 1 : 0;
        featureGroup.groupNumRings++;
        const n = featureGroup.numPositions;
        const l = contour.length;
        const p = featureGroup.positions;
        for (let i = 0; i < l; i++) {
            p[n + i] = contour[i];
        }
        featureGroup.numPositions += contour.length;
    }
    /**
     * Finalize the tile info's feature group.
     */
    finish() {
        ExtendedTileInfo.finish(this.tileInfo);
    }
    addText(name) {
        return this.addStringValue(name, this.tileInfo.textCatalog, this.stringMap);
    }
    addLayer(name) {
        return this.addStringValue(name, this.tileInfo.layerCatalog, this.layerMap);
    }
    addClass(name) {
        return this.addStringValue(name, this.tileInfo.classCatalog, this.classMap);
    }
    addType(name) {
        return this.addStringValue(name, this.tileInfo.typeCatalog, this.typeMap);
    }
    // Add a string to the strings catalog. Returns index into the catalog.
    addStringValue(str, catalog, map) {
        if (str === undefined || str === null) {
            return -1;
        }
        const name = str.toString();
        let i = map.get(name);
        if (i !== undefined) {
            return i;
        }
        i = catalog.length;
        catalog.push(name);
        map.set(name, i);
        return i;
    }
}
exports.ExtendedTileInfoWriter = ExtendedTileInfoWriter;
/**
 * Implementation of [[ExtendedTileInfoPolygonAccessor]].
 */
class ExtendedTileInfoPolygonAccessorImpl {
    constructor() {
        /**
         * Feature's index in the group.
         */
        this.featureIndex = 0;
        /**
         * Indicates where the ring starts.
         */
        this.ringStart = 0;
        /**
         * Number of rings.
         */
        this.numRings = 0;
    }
    /**
     * Setup the accessor for extended [[TileInfo]].
     *
     * @param polygons polygons feature group.
     * @param featureIndex feature's index in the group.
     * @param ringStart where the ring starts.
     * @param numRings number of rings.
     */
    setup(polygons, featureIndex, ringStart, numRings) {
        this.polygons = polygons;
        this.featureIndex = featureIndex;
        this.ringStart = ringStart;
        this.numRings = numRings;
    }
    /**
     * Shut down the accessor and free all references.
     */
    reset() {
        this.polygons = undefined;
        this.featureIndex = 0;
        this.ringStart = 0;
        this.numRings = 0;
    }
    isOuterRing(ringIndex) {
        harp_utils_1.assert(ringIndex >= 0);
        harp_utils_1.assert(ringIndex < this.numRings);
        harp_utils_1.assert(this.polygons !== undefined);
        if (ringIndex < 0 || ringIndex >= this.numRings || this.polygons === undefined) {
            throw new Error("ExtendedTileInfoPolygonAccessor: Invalid ring index");
        }
        return this.polygons.innerRingIsOuterContour[this.ringStart + ringIndex] !== 0;
    }
    getPoints(ringIndex) {
        harp_utils_1.assert(ringIndex >= 0);
        harp_utils_1.assert(ringIndex < this.numRings);
        harp_utils_1.assert(this.polygons !== undefined);
        if (ringIndex < 0 || ringIndex >= this.numRings || this.polygons === undefined) {
            throw new Error("ExtendedTileInfoPolygonAccessor: Invalid ring index");
        }
        // compute the start/size of the points in this ring. All `points` are actually just the
        // indices of a single X/Y coordinate.
        const pointsStart = this.polygons.innerRingStartIndex[this.ringStart + ringIndex];
        let numPointValues;
        if (ringIndex < this.numRings - 1) {
            numPointValues =
                this.polygons.innerRingStartIndex[this.ringStart + ringIndex + 1] - pointsStart;
        }
        else {
            if (this.ringStart + ringIndex < this.polygons.innerRingStartIndex.length - 1) {
                numPointValues =
                    this.polygons.innerRingStartIndex[this.ringStart + ringIndex + 1] - pointsStart;
            }
            else {
                numPointValues = this.polygons.positions.length - pointsStart;
            }
        }
        return {
            points: this.polygons.positions,
            pointsStart,
            numPointValues
        };
    }
}
/**
 * Supporting class for [[ExtendedTileInfo]]. Takes an [[ExtendedTileInfoHandler]] and calls an
 * `accept` for every feature of the [[ExtendedTileInfo]], or just all features of a specified
 * `featureId`.
 */
class ExtendedTileInfoVisitor {
    constructor(tileInfo) {
        this.tileInfo = tileInfo;
    }
    /**
     * Visit all feature in the [[ExtendedTileInfo]]
     *
     * @param handler Let the `handler` visit all features.
     */
    visitAll(handler) {
        this.visitAllPointFeatures(handler);
        this.visitAllLineFeatures(handler);
        this.visitAllPolygonFeatures(handler);
    }
    /**
     * Visit all features of a specified featureId.
     *
     * @param featureId The featureId to visit.
     * @param handler The `handler` to use.
     */
    visitFeature(featureId, handler) {
        let numFeaturesFound = 0;
        const numPointFeatures = this.tileInfo.pointGroup.numFeatures;
        const pointFeatures = this.tileInfo.pointGroup.featureIds;
        for (let i = 0; i < numPointFeatures; i++) {
            if (pointFeatures[i] === featureId) {
                numFeaturesFound++;
                this.visitPointFeature(i, handler);
            }
        }
        const numLineFeatures = this.tileInfo.lineGroup.numFeatures;
        const lineFeatures = this.tileInfo.lineGroup.featureIds;
        for (let i = 0; i < numLineFeatures; i++) {
            if (lineFeatures[i] === featureId) {
                numFeaturesFound++;
                this.visitLineFeature(i, handler);
            }
        }
        const numPolygonFeatures = this.tileInfo.polygonGroup.numFeatures;
        const polygonsFeatures = this.tileInfo.polygonGroup.featureIds;
        for (let i = 0; i < numPolygonFeatures; i++) {
            if (polygonsFeatures[i] === featureId) {
                numFeaturesFound++;
                this.visitPolygonFeature(i, handler);
            }
        }
        return numFeaturesFound;
    }
    /**
     * Visit all `POINT` features.
     *
     * @param handler The `handler` to use.
     */
    visitAllPointFeatures(handler) {
        const numFeatures = this.tileInfo.pointGroup.numFeatures;
        for (let i = 0; i < numFeatures; i++) {
            this.visitPointFeature(i, handler);
        }
    }
    /**
     * Visit all `LINESTRING` features.
     *
     * @param handler The handler to use.
     */
    visitAllLineFeatures(handler) {
        const numFeatures = this.tileInfo.lineGroup.numFeatures;
        for (let i = 0; i < numFeatures; i++) {
            this.visitLineFeature(i, handler);
        }
    }
    /**
     * Visit all `POLYGON` features.
     *
     * @param handler The `handler` to use.
     */
    visitAllPolygonFeatures(handler) {
        const numFeatures = this.tileInfo.polygonGroup.numFeatures;
        for (let i = 0; i < numFeatures; i++) {
            this.visitPolygonFeature(i, handler);
        }
    }
    getTag(featureIndex, index) {
        return index !== undefined && index[featureIndex] >= 0 ? index[featureIndex] : -1;
    }
    /**
     * Call the `handler` on a point feature.
     *
     * @param featureIndex The index of the feature into the feature table.
     * @param handler The `handler` to use.
     */
    visitPointFeature(featureIndex, handler) {
        const tileInfo = this.tileInfo;
        const points = tileInfo.pointGroup;
        const start = points.positionIndex[featureIndex];
        const x = points.positions[start];
        const y = points.positions[start + 1];
        if (!!handler.acceptPoint) {
            handler.acceptPoint(points.featureIds[featureIndex], points.techniqueIndex[featureIndex], x, y, points.textIndex[featureIndex], this.getTag(featureIndex, points.layerIndex), this.getTag(featureIndex, points.classIndex), this.getTag(featureIndex, points.typeIndex));
        }
    }
    /**
     * Call the `handler` on a line feature.
     *
     * @param featureIndex The index of the feature into the feature table.
     * @param handler The `handler` to use.
     */
    visitLineFeature(featureIndex, handler) {
        const tileInfo = this.tileInfo;
        const lines = tileInfo.lineGroup;
        const numFeatures = lines.numFeatures;
        const positionsStart = lines.positionIndex[featureIndex];
        const numPointValues = featureIndex === numFeatures - 1
            ? lines.positions.length - positionsStart
            : lines.positionIndex[featureIndex + 1] - positionsStart;
        let segmentId;
        let startOffset;
        let endOffset;
        if (lines.segmentIds !== undefined) {
            segmentId = lines.segmentIds[featureIndex];
            startOffset = lines.segmentStartOffsets[featureIndex];
            endOffset = lines.segmentEndOffsets[featureIndex];
        }
        if (!!handler.acceptLine) {
            handler.acceptLine(lines.featureIds[featureIndex], lines.techniqueIndex[featureIndex], lines.textIndex[featureIndex], this.getTag(featureIndex, lines.layerIndex), this.getTag(featureIndex, lines.classIndex), this.getTag(featureIndex, lines.typeIndex), tileInfo.lineGroup.positions, positionsStart, numPointValues, segmentId, startOffset, endOffset);
        }
    }
    /**
     * Call the `handler` on a polygon feature.
     *
     * @param featureIndex The index of the feature into the feature table.
     * @param handler The `handler` to use.
     */
    visitPolygonFeature(featureIndex, handler) {
        if (handler.acceptPolygon === undefined) {
            return;
        }
        const tileInfo = this.tileInfo;
        const polygons = tileInfo.polygonGroup;
        const numFeatures = polygons.numFeatures;
        const ringStart = polygons.outerRingStartIndex[featureIndex];
        const numRings = featureIndex === numFeatures - 1
            ? polygons.innerRingStartIndex.length - ringStart
            : polygons.outerRingStartIndex[featureIndex + 1] - ringStart;
        // Use a static instance, so we do not allocate anything here
        ExtendedTileInfoVisitor.polygonAccessor.setup(polygons, featureIndex, ringStart, numRings);
        handler.acceptPolygon(polygons.featureIds[featureIndex], polygons.techniqueIndex[featureIndex], polygons.textIndex[featureIndex], this.getTag(featureIndex, polygons.layerIndex), this.getTag(featureIndex, polygons.classIndex), this.getTag(featureIndex, polygons.typeIndex), ExtendedTileInfoVisitor.polygonAccessor);
        // Free all data references.
        ExtendedTileInfoVisitor.polygonAccessor.reset();
    }
}
exports.ExtendedTileInfoVisitor = ExtendedTileInfoVisitor;
// static instance to work without allocations.
ExtendedTileInfoVisitor.polygonAccessor = new ExtendedTileInfoPolygonAccessorImpl();


/***/ }),

/***/ "../harp-datasource-protocol/lib/WorkerDecoderProtocol.ts":
/*!****************************************************************!*\
  !*** ../harp-datasource-protocol/lib/WorkerDecoderProtocol.ts ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Allows to cancel and prioritize requests inside the requestQueue. Useful to optimize the order of
 * decoding tiles during animations and camera movements.
 *
 * `RequestController` is not extending [[AbortController]], because this is not supported in ES5.
 */
class RequestController {
    /**
     * Creates an instance of `RequestController`.
     *
     * @param {number} priority
     * @param {AbortController} abortController Optional [[AbortController]] used internally, since
     *      [[AbortController]]s should not be subclassed.
     */
    constructor(priority = 0, abortController = new AbortController()) {
        this.priority = priority;
        this.abortController = abortController;
    }
    get signal() {
        return this.abortController.signal;
    }
    /**
     * Invoking this method will set this object's AbortSignal's aborted flag and
     * signal to any observers that the associated activity is to be aborted.
     */
    abort() {
        this.abortController.abort();
    }
}
exports.RequestController = RequestController;
/**
 * Communication protocol with [[ITileDecoder]].
 */
var WorkerDecoderProtocol;
(function (WorkerDecoderProtocol) {
    /**
     * Define possible names of messages exchanged with decoder services within `WebWorker`.
     */
    let DecoderMessageName;
    (function (DecoderMessageName) {
        DecoderMessageName["Configuration"] = "configuration";
    })(DecoderMessageName = WorkerDecoderProtocol.DecoderMessageName || (WorkerDecoderProtocol.DecoderMessageName = {}));
    /**
     * Type guard to check if an object is an instance of `ConfigurationMessage`.
     */
    function isConfigurationMessage(message) {
        return (message &&
            typeof message.service === "string" &&
            typeof message.type === "string" &&
            message.type === DecoderMessageName.Configuration);
    }
    WorkerDecoderProtocol.isConfigurationMessage = isConfigurationMessage;
    /**
     * Define possible names of requests called on decoder services within `WebWorker`.
     */
    let Requests;
    (function (Requests) {
        Requests["DecodeTileRequest"] = "decode-tile-request";
        Requests["TileInfoRequest"] = "tile-info-request";
    })(Requests = WorkerDecoderProtocol.Requests || (WorkerDecoderProtocol.Requests = {}));
    /**
     * Type guard to check if an object is a decoded tile object sent to a worker.
     */
    function isDecodeTileRequest(message) {
        return (message &&
            typeof message.type === "string" &&
            message.type === Requests.DecodeTileRequest);
    }
    WorkerDecoderProtocol.isDecodeTileRequest = isDecodeTileRequest;
    /**
     * Type guard to check if an object is an info tile object sent to a worker.
     */
    function isTileInfoRequest(message) {
        return (message && typeof message.type === "string" && message.type === Requests.TileInfoRequest);
    }
    WorkerDecoderProtocol.isTileInfoRequest = isTileInfoRequest;
})(WorkerDecoderProtocol = exports.WorkerDecoderProtocol || (exports.WorkerDecoderProtocol = {}));


/***/ }),

/***/ "../harp-datasource-protocol/lib/WorkerServiceProtocol.ts":
/*!****************************************************************!*\
  !*** ../harp-datasource-protocol/lib/WorkerServiceProtocol.ts ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Common communication protocol for [[WorkerService]].
 */
var WorkerServiceProtocol;
(function (WorkerServiceProtocol) {
    /**
     * Service id of worker manager ([[WorkerServiceManager]]) used to create/destroy service
     * instances in workers.
     */
    WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID = "worker-service-manager";
    /**
     * Define possible names of messages exchanged with services within `WebWorker`.
     */
    let ServiceMessageName;
    (function (ServiceMessageName) {
        ServiceMessageName["Initialized"] = "initialized";
        ServiceMessageName["Request"] = "request";
        ServiceMessageName["Response"] = "response";
    })(ServiceMessageName = WorkerServiceProtocol.ServiceMessageName || (WorkerServiceProtocol.ServiceMessageName = {}));
    /**
     * Type guard to check if an object is a signal message from worker.
     */
    function isInitializedMessage(message) {
        return (message &&
            typeof message.service === "string" &&
            typeof message.type === "string" &&
            message.type === ServiceMessageName.Initialized);
    }
    WorkerServiceProtocol.isInitializedMessage = isInitializedMessage;
    /**
     * Define possible names of requests called on services within `WebWorker`.
     */
    let Requests;
    (function (Requests) {
        Requests["CreateService"] = "create-service";
        Requests["DestroyService"] = "destroy-service";
    })(Requests = WorkerServiceProtocol.Requests || (WorkerServiceProtocol.Requests = {}));
    /**
     * Test if `error` thrown by [[CreateServiceRequest]] was caused by unknown type of service.
     */
    function isUnknownServiceError(error) {
        return /unknown targetServiceType requested: /.test(error.message);
    }
    WorkerServiceProtocol.isUnknownServiceError = isUnknownServiceError;
    /**
     * Type guard to check if an object is a request message sent to a worker.
     */
    function isRequestMessage(message) {
        return (message &&
            typeof message.service === "string" &&
            typeof message.type === "string" &&
            message.type === ServiceMessageName.Request);
    }
    WorkerServiceProtocol.isRequestMessage = isRequestMessage;
    /**
     * Type guard to check if an object is a request message sent to a worker.
     */
    function isResponseMessage(message) {
        return (message &&
            typeof message.service === "string" &&
            typeof message.type === "string" &&
            message.type === ServiceMessageName.Response);
    }
    WorkerServiceProtocol.isResponseMessage = isResponseMessage;
})(WorkerServiceProtocol = exports.WorkerServiceProtocol || (exports.WorkerServiceProtocol = {}));


/***/ }),

/***/ "../harp-datasource-protocol/lib/WorkerTilerProtocol.ts":
/*!**************************************************************!*\
  !*** ../harp-datasource-protocol/lib/WorkerTilerProtocol.ts ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Communication protocol with [[ITiler]].
 */
var WorkerTilerProtocol;
(function (WorkerTilerProtocol) {
    /**
     * Define possible names of requests called on tiler services within `WebWorker`.
     */
    let Requests;
    (function (Requests) {
        Requests["RegisterIndex"] = "register-index";
        Requests["UpdateIndex"] = "update-index";
        Requests["TileRequest"] = "tile-request";
    })(Requests = WorkerTilerProtocol.Requests || (WorkerTilerProtocol.Requests = {}));
    /**
     * Type guard to check if an object is an index registration request sent to a worker.
     */
    function isRegisterIndexRequest(message) {
        return (message && typeof message.type === "string" && message.type === Requests.RegisterIndex);
    }
    WorkerTilerProtocol.isRegisterIndexRequest = isRegisterIndexRequest;
    /**
     * Type guard to check if an object is an update request for the index registration.
     */
    function isUpdateIndexRequest(message) {
        return message && typeof message.type === "string" && message.type === Requests.UpdateIndex;
    }
    WorkerTilerProtocol.isUpdateIndexRequest = isUpdateIndexRequest;
    /**
     * Type guard to check if an object is a tile request sent to a worker.
     */
    function isTileRequest(message) {
        return message && typeof message.type === "string" && message.type === Requests.TileRequest;
    }
    WorkerTilerProtocol.isTileRequest = isTileRequest;
})(WorkerTilerProtocol = exports.WorkerTilerProtocol || (exports.WorkerTilerProtocol = {}));


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/ArrayOperators.ts":
/*!*******************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/ArrayOperators.ts ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const operators = {
    at: {
        call: (context, call) => {
            const args = call.args;
            const index = context.evaluate(args[0]);
            if (typeof index !== "number") {
                throw new Error(`expected the index of the element to retrieve`);
            }
            const value = context.evaluate(args[1]);
            if (!Array.isArray(value)) {
                throw new Error(`expected an array`);
            }
            return index >= 0 && index < value.length ? value[index] : null;
        }
    }
};
exports.ArrayOperators = operators;


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/CastOperators.ts":
/*!******************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/CastOperators.ts ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const operators = {
    "to-boolean": {
        call: (context, call) => {
            return Boolean(context.evaluate(call.args[0]));
        }
    },
    "to-string": {
        call: (context, call) => {
            return String(context.evaluate(call.args[0]));
        }
    },
    "to-number": {
        call: (context, call) => {
            for (const arg of call.args) {
                const value = Number(context.evaluate(arg));
                if (!isNaN(value)) {
                    return value;
                }
            }
            throw new Error("cannot convert the value to a number");
        }
    }
};
exports.CastOperators = operators;


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/ColorOperators.ts":
/*!*******************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/ColorOperators.ts ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const ColorUtils_1 = __webpack_require__(/*! ../ColorUtils */ "../harp-datasource-protocol/lib/ColorUtils.ts");
const StringEncodedNumeral_1 = __webpack_require__(/*! ../StringEncodedNumeral */ "../harp-datasource-protocol/lib/StringEncodedNumeral.ts");
const operators = {
    alpha: {
        call: (context, call) => {
            let color = context.evaluate(call.args[0]);
            if (typeof color === "string") {
                color = StringEncodedNumeral_1.parseStringEncodedColor(color);
            }
            const alpha = typeof color === "number" ? ColorUtils_1.ColorUtils.getAlphaFromHex(color) : 1;
            return alpha;
        }
    },
    rgba: {
        call: (context, call) => {
            const r = context.evaluate(call.args[0]);
            const g = context.evaluate(call.args[1]);
            const b = context.evaluate(call.args[2]);
            const a = context.evaluate(call.args[3]);
            if (typeof r === "number" &&
                typeof g === "number" &&
                typeof b === "number" &&
                typeof a === "number" &&
                r >= 0 &&
                g >= 0 &&
                b >= 0 &&
                a >= 0 &&
                a <= 1) {
                return rgbaToHex(r, g, b, a);
            }
            throw new Error(`unknown color 'rgba(${r},${g},${b},${a})'`);
        }
    },
    rgb: {
        call: (context, call) => {
            const r = context.evaluate(call.args[0]);
            const g = context.evaluate(call.args[1]);
            const b = context.evaluate(call.args[2]);
            if (typeof r === "number" &&
                typeof g === "number" &&
                typeof b === "number" &&
                r >= 0 &&
                g >= 0 &&
                b >= 0) {
                return rgbToHex(r, g, b);
            }
            throw new Error(`unknown color 'rgb(${r},${g},${b})'`);
        }
    },
    // Hsl operator contains angle modulated to <0, 360> range, percent of
    // saturation and lightness in <0, 100> range, i.e. hsl(360, 100, 100)
    hsl: {
        call: (context, call) => {
            const h = context.evaluate(call.args[0]);
            const s = context.evaluate(call.args[1]);
            const l = context.evaluate(call.args[2]);
            if (typeof h === "number" &&
                typeof s === "number" &&
                typeof l === "number" &&
                h >= 0 &&
                s >= 0 &&
                l >= 0) {
                return hslToHex(h, s, l);
            }
            throw new Error(`unknown color 'hsl(${h},${s}%,${l}%)'`);
        }
    }
};
function rgbaToHex(r, g, b, a) {
    // We decode rgba color channels using custom hex format with transparency.
    return ColorUtils_1.ColorUtils.getHexFromRgba(THREE.Math.clamp(r, 0, 255) / 255, THREE.Math.clamp(g, 0, 255) / 255, THREE.Math.clamp(b, 0, 255) / 255, THREE.Math.clamp(a, 0, 1));
}
function rgbToHex(r, g, b) {
    return ColorUtils_1.ColorUtils.getHexFromRgb(THREE.Math.clamp(r, 0, 255) / 255, THREE.Math.clamp(g, 0, 255) / 255, THREE.Math.clamp(b, 0, 255) / 255);
}
function hslToHex(h, s, l) {
    return ColorUtils_1.ColorUtils.getHexFromHsl(THREE.Math.euclideanModulo(h, 360) / 360, THREE.Math.clamp(s, 0, 100) / 100, THREE.Math.clamp(l, 0, 100) / 100);
}
exports.ColorOperators = operators;


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/ComparisonOperators.ts":
/*!************************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/ComparisonOperators.ts ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
function compare(context, call, strict = false) {
    const left = context.evaluate(call.args[0]);
    const right = context.evaluate(call.args[1]);
    if (!((typeof left === "number" && typeof right === "number") ||
        (typeof left === "string" && typeof right === "string"))) {
        if (strict) {
            throw new Error(`invalid operands '${left}' and '${right}' for operator '${call.op}'`);
        }
    }
    switch (call.op) {
        case "<":
            return left < right;
        case ">":
            return left > right;
        case "<=":
            return left <= right;
        case ">=":
            return left >= right;
        default:
            throw new Error(`invalid comparison operator '${call.op}'`);
    }
}
const operators = {
    "!": {
        call: (context, call) => {
            return !context.evaluate(call.args[0]);
        }
    },
    "==": {
        call: (context, call) => {
            const left = context.evaluate(call.args[0]);
            const right = context.evaluate(call.args[1]);
            return left === right;
        }
    },
    "!=": {
        call: (context, call) => {
            const left = context.evaluate(call.args[0]);
            const right = context.evaluate(call.args[1]);
            return left !== right;
        }
    },
    "<": { call: (context, call) => compare(context, call) },
    ">": { call: (context, call) => compare(context, call) },
    "<=": { call: (context, call) => compare(context, call) },
    ">=": { call: (context, call) => compare(context, call) }
};
exports.ComparisonOperators = operators;


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/FeatureOperators.ts":
/*!*********************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/FeatureOperators.ts ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const operators = {
    "geometry-type": {
        call: (context, call) => {
            const geometryType = context.env.lookup("$geometryType");
            switch (geometryType) {
                case "point":
                    return "Point";
                case "line":
                    return "LineString";
                case "polygon":
                    return "Polygon";
                default:
                    return null;
            }
        }
    }
};
exports.FeatureOperators = operators;


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/FlowOperators.ts":
/*!******************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/FlowOperators.ts ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
function conditionalCast(context, type, args) {
    switch (type) {
        case "boolean":
        case "number":
        case "string":
            for (const childExpr of args) {
                const value = context.evaluate(childExpr);
                if (typeof value === type) {
                    return value;
                }
            }
            throw new Error(`expected a '${type}'`);
        default:
            throw new Error(`invalid type '${type}'`);
    } // switch
}
const operators = {
    all: {
        call: (context, call) => {
            for (const childExpr of call.args) {
                if (!context.evaluate(childExpr)) {
                    return false;
                }
            }
            return true;
        }
    },
    any: {
        call: (context, call) => {
            for (const childExpr of call.args) {
                if (context.evaluate(childExpr)) {
                    return true;
                }
            }
            return false;
        }
    },
    none: {
        call: (context, call) => {
            for (const childExpr of call.args) {
                if (context.evaluate(childExpr)) {
                    return false;
                }
            }
            return true;
        }
    },
    boolean: {
        call: (context, call) => {
            return conditionalCast(context, "boolean", call.args);
        }
    },
    number: {
        call: (context, call) => {
            return conditionalCast(context, "number", call.args);
        }
    },
    string: {
        call: (context, call) => {
            return conditionalCast(context, "string", call.args);
        }
    }
};
exports.FlowOperators = operators;


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/InterpolationOperators.ts":
/*!***************************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/InterpolationOperators.ts ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Expr_1 = __webpack_require__(/*! ../Expr */ "../harp-datasource-protocol/lib/Expr.ts");
const InterpolatedProperty_1 = __webpack_require__(/*! ../InterpolatedProperty */ "../harp-datasource-protocol/lib/InterpolatedProperty.ts");
/**
 * Evaluates the given piecewise function.
 */
function step(context, call) {
    const { args } = call;
    const value = context.evaluate(args[0]);
    if (value === null) {
        // returns the default value of step.
        return context.evaluate(args[1]);
    }
    if (typeof value !== "number") {
        throw new Error(`the input of a 'step' operator must have type 'number'`);
    }
    let first = 1;
    let last = args.length / 2 - 1;
    while (first < last) {
        // tslint:disable-next-line: no-bitwise
        const mid = (first + last) >>> 1;
        const stop = args[mid * 2].value;
        if (value < stop) {
            last = mid - 1;
        }
        else if (value > stop) {
            first = mid + 1;
        }
        else {
            last = mid;
        }
    }
    const result = args[first * 2];
    if (!(result instanceof Expr_1.NumberLiteralExpr)) {
        throw new Error("expected a numeric literal");
    }
    const index = result.value <= value ? first : first - 1;
    return context.evaluate(args[index * 2 + 1]);
}
/**
 * Prepare and validate the "interpolate" call.
 *
 * @param call An [[Expr]] representing an "interpolate" call.
 * @hidden
 */
function prepareInterpolateCallExpr(call) {
    if (call._interpolatedProperty || call._mode !== undefined) {
        return;
    }
    const interpolatorType = call.args[0];
    if (!(interpolatorType instanceof Expr_1.CallExpr)) {
        throw new Error("expected an interpolation type");
    }
    let mode;
    let exponent;
    if (interpolatorType.op === "linear") {
        mode = "Linear";
    }
    else if (interpolatorType.op === "discrete") {
        mode = "Discrete";
    }
    else if (interpolatorType.op === "cubic") {
        mode = "Cubic";
    }
    else if (interpolatorType.op === "exponential") {
        mode = "Exponential";
        const base = interpolatorType.args[0];
        if (!(base instanceof Expr_1.NumberLiteralExpr)) {
            throw new Error("expected the base of the exponential interpolation");
        }
        exponent = base.value;
    }
    else {
        throw new Error("unrecognized interpolation type");
    }
    const input = call.args[1];
    if (!(input instanceof Expr_1.CallExpr)) {
        throw new Error("expected the input of the interpolation");
    }
    if (input.op !== "zoom") {
        throw new Error("only 'zoom' is supported");
    }
    if (call.args.length === 2 || call.args.length % 2) {
        throw new Error("invalid number of samples");
    }
    const stops = [];
    const values = [];
    let isConstantInterpolation = true;
    for (let i = 2; i < call.args.length; i += 2) {
        const stop = call.args[i];
        if (!(stop instanceof Expr_1.NumberLiteralExpr)) {
            throw new Error("expected a numeric literal");
        }
        if (stops.length > 0 && stop.value === stops[stops.length - 1]) {
            stops[stops.length - 1] = stop.value - 0.0000001;
        }
        stops.push(stop.value);
        if (isConstantInterpolation) {
            const value = call.args[i + 1];
            if (value instanceof Expr_1.LiteralExpr) {
                values.push(value.value);
            }
            else {
                isConstantInterpolation = false;
            }
        }
    }
    if (isConstantInterpolation) {
        const result = InterpolatedProperty_1.createInterpolatedProperty({
            interpolation: mode,
            exponent,
            zoomLevels: stops,
            values
        });
        if (!result) {
            throw new Error("failed to create interpolation");
        }
        call._interpolatedProperty = result;
    }
    else {
        call._mode = mode;
        call._exponent = exponent;
        call._stops = stops;
    }
}
/**
 * Classify the given `step` call.
 *
 * This function checks the input of the `step` and ensures that the stops
 * are literals.
 *
 * @param call A call to `["step", ...]`.
 * @hidden
 */
function classifyStepCallExpr(call) {
    if (call._inputIsZoom !== undefined) {
        // nothing to do, the `call` was already classified.
        return;
    }
    if (call.args[0] === undefined) {
        throw new Error("expected the input of the 'step' operator");
    }
    if (call.args.length < 3 || call.args.length % 2) {
        throw new Error("not enough arguments");
    }
    const input = call.args[0];
    // tslint:disable-next-line: prefer-conditional-expression
    if (input instanceof Expr_1.CallExpr && input.op === "zoom") {
        call._inputIsZoom = true;
    }
    else {
        call._inputIsZoom = false;
    }
    // check that the stops are literals.
    for (let i = 2; i < call.args.length; i += 2) {
        const stop = call.args[i];
        if (!(stop instanceof Expr_1.NumberLiteralExpr)) {
            throw new Error("expected a numeric literal");
        }
    }
}
/**
 * Prepares the given call for the dynamic exception.
 * This method collects the stops and
 *
 * @param call A call to `["step", ...]`.
 * @hidden
 */
function prepareStepCallExpr(call) {
    if (call._stops || call._interpolatedProperty) {
        // nothing to do, the `call` was already prepared for execution.
        return;
    }
    // collect the stops of the step call.
    const stops = [Number.MIN_SAFE_INTEGER];
    for (let i = 2; i < call.args.length; i += 2) {
        const stop = call.args[i];
        stops.push(stop.value);
    }
    // collect the values of the step call.
    const values = [];
    let hasConstantValues = true;
    for (let i = 1; hasConstantValues && i < call.args.length; i += 2) {
        const literal = call.args[i];
        if (literal instanceof Expr_1.LiteralExpr) {
            values.push(literal.value);
        }
        else {
            hasConstantValues = false;
        }
    }
    if (hasConstantValues) {
        // all the values of this zoom-based `step` are constant,
        // create an interpolated property and store it together
        // with the call.
        const interpolatedProperty = InterpolatedProperty_1.createInterpolatedProperty({
            interpolation: "Discrete",
            zoomLevels: stops,
            values
        });
        if (interpolatedProperty === undefined) {
            throw new Error("failed to create interpolator");
        }
        call._interpolatedProperty = interpolatedProperty;
    }
    else {
        // the values the `["step"]` call are not constants,
        // cache the `zoomLevels` to avoid recreating input `Array`
        // when instantiating a new [[InterpolatedProperty]].
        call._stops = stops;
    }
}
const operators = {
    interpolate: {
        isDynamicOperator: (call) => {
            return call.args[1] && call.args[1].isDynamic();
        },
        call: (context, call) => {
            prepareInterpolateCallExpr(call);
            if (context.scope !== Expr_1.ExprScope.Dynamic) {
                return call;
            }
            let interpolatedProperty = call._interpolatedProperty;
            if (!interpolatedProperty) {
                const values = [];
                for (let i = 2; i < call.args.length; i += 2) {
                    const value = context.evaluate(call.args[i + 1]);
                    values.push(value);
                }
                interpolatedProperty = InterpolatedProperty_1.createInterpolatedProperty({
                    interpolation: call._mode,
                    exponent: call._exponent,
                    zoomLevels: call._stops,
                    values
                });
                if (interpolatedProperty === undefined) {
                    throw new Error("failed to create interpolator");
                }
            }
            return InterpolatedProperty_1.evaluateInterpolatedProperty(interpolatedProperty, context.env);
        }
    },
    step: {
        isDynamicOperator: (call) => {
            return call.args[0] && call.args[0].isDynamic();
        },
        call: (context, call) => {
            classifyStepCallExpr(call);
            if (context.scope === Expr_1.ExprScope.Value) {
                return call;
            }
            if (context.scope === Expr_1.ExprScope.Condition || call._inputIsZoom === false) {
                return step(context, call);
            }
            prepareStepCallExpr(call);
            let interpolatedProperty = call._interpolatedProperty;
            if (!interpolatedProperty) {
                // the values of the interpolation are not literals,
                // evaluate the sub expressions and combine them
                // with the constant stops computed when preparing this call.
                const values = [];
                for (let i = 1; i < call.args.length; i += 2) {
                    const value = context.evaluate(call.args[i]);
                    values.push(value);
                }
                interpolatedProperty = InterpolatedProperty_1.createInterpolatedProperty({
                    interpolation: "Discrete",
                    zoomLevels: call._stops,
                    values
                });
                if (interpolatedProperty === undefined) {
                    throw new Error("failed to create interpolator");
                }
            }
            return InterpolatedProperty_1.evaluateInterpolatedProperty(interpolatedProperty, context.env);
        }
    }
};
exports.InterpolationOperators = operators;


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/MapOperators.ts":
/*!*****************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/MapOperators.ts ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Expr_1 = __webpack_require__(/*! ../Expr */ "../harp-datasource-protocol/lib/Expr.ts");
const operators = {
    "ppi-scale": {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            const scaleFactor = call.args[1] ? context.evaluate(call.args[1]) : 1;
            return value * scaleFactor;
        }
    },
    "world-ppi-scale": {
        isDynamicOperator: () => {
            return true;
        },
        call: (context, call) => {
            const pixels = context.evaluate(call.args[0]);
            const scaleFactor = call.args[1] ? context.evaluate(call.args[1]) : 1;
            const zoom = context.env.lookup("$zoom");
            const zoomWidth = Math.pow(2, 17) / Math.pow(2, zoom);
            const v = pixels * zoomWidth * scaleFactor;
            return v;
        }
    },
    "world-discrete-ppi-scale": {
        isDynamicOperator: () => {
            return true;
        },
        call: (context, call) => {
            const pixels = context.evaluate(call.args[0]);
            const scaleFactor = call.args[1] ? context.evaluate(call.args[1]) : 1;
            const zoom = context.env.lookup("$zoom");
            const zoomWidthDiscrete = Math.pow(2, 17.8) / Math.pow(2, Math.floor(zoom));
            const v = pixels * zoomWidthDiscrete * scaleFactor;
            return v;
        }
    },
    ppi: {
        call: (context) => {
            const ppi = context.env.lookup("$ppi");
            if (typeof ppi === "number") {
                return ppi;
            }
            return 72;
        }
    },
    zoom: {
        isDynamicOperator: () => {
            return true;
        },
        call: (context) => {
            if (context.scope === Expr_1.ExprScope.Condition) {
                const zoom = context.env.lookup("$zoom");
                if (zoom !== undefined) {
                    return zoom;
                }
                throw new Error("failed to get the zoom level.");
            }
            // direct usages of 'zoom' outside technique filter conditions
            // and interpolations are not allowed.
            throw new Error("invalid usage of the 'zoom' operator.");
        }
    }
};
exports.MapOperators = operators;


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/MathOperators.ts":
/*!******************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/MathOperators.ts ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const operators = {
    "^": {
        call: (context, call) => {
            const a = context.evaluate(call.args[0]);
            const b = context.evaluate(call.args[1]);
            if (typeof a !== "number" || typeof b !== "number") {
                // tslint:disable-next-line: max-line-length
                throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '^'`);
            }
            return Math.pow(a, b);
        }
    },
    "-": {
        call: (context, call) => {
            if (call.args.length === 1) {
                const value = context.evaluate(call.args[0]);
                if (typeof value !== "number") {
                    throw new Error(`ìnvalid operand '${typeof value} for operator '-'`);
                }
                return -value;
            }
            const a = context.evaluate(call.args[0]);
            const b = context.evaluate(call.args[1]);
            if (typeof a !== "number" || typeof b !== "number") {
                throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '-'`);
            }
            return a - b;
        }
    },
    "/": {
        call: (context, call) => {
            const a = context.evaluate(call.args[0]);
            const b = context.evaluate(call.args[1]);
            if (typeof a !== "number" || typeof b !== "number") {
                // tslint:disable-next-line: max-line-length
                throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '/'`);
            }
            return a / b;
        }
    },
    "%": {
        call: (context, call) => {
            const a = context.evaluate(call.args[0]);
            const b = context.evaluate(call.args[1]);
            if (typeof a !== "number" || typeof b !== "number") {
                // tslint:disable-next-line: max-line-length
                throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '%'`);
            }
            return a % b;
        }
    },
    "+": {
        call: (context, call) => {
            return call.args.reduce((a, b) => Number(a) + Number(context.evaluate(b)), 0);
        }
    },
    "*": {
        call: (context, call) => {
            return call.args.reduce((a, b) => Number(a) * Number(context.evaluate(b)), 1);
        }
    },
    abs: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'abs'`);
            }
            return Math.abs(value);
        }
    },
    acos: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'acos'`);
            }
            return Math.acos(value);
        }
    },
    asin: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'asin'`);
            }
            return Math.asin(value);
        }
    },
    atan: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'atan'`);
            }
            return Math.atan(value);
        }
    },
    ceil: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'ceil'`);
            }
            return Math.ceil(value);
        }
    },
    cos: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'cos'`);
            }
            return Math.cos(value);
        }
    },
    e: {
        call: () => {
            return Math.E;
        }
    },
    floor: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'floor'`);
            }
            return Math.floor(value);
        }
    },
    ln: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'ln'`);
            }
            return Math.log(value);
        }
    },
    ln2: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'ln2'`);
            }
            return Math.log2(value);
        }
    },
    log10: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'log10'`);
            }
            return Math.log10(value);
        }
    },
    max: {
        call: (context, call) => {
            return Math.max(...call.args.map(v => Number(context.evaluate(v))));
        }
    },
    min: {
        call: (context, call) => {
            return Math.min(...call.args.map(v => Number(context.evaluate(v))));
        }
    },
    /**
     * Clamp numeric value to given range, inclusive.
     *
     * Synopsis:
     * ```
     * ["clamp", v: number, min: number, max: number]`
     * ```
     */
    clamp: {
        call: (context, call) => {
            const v = context.evaluate(call.args[0]);
            const min = context.evaluate(call.args[1]);
            const max = context.evaluate(call.args[2]);
            if (typeof v !== "number" || typeof min !== "number" || typeof max !== "number") {
                throw new Error(`invalid operands '${v}', ${min}, ${max} for operator 'clamp'`);
            }
            return THREE.Math.clamp(v, min, max);
        }
    },
    pi: {
        call: () => {
            return Math.PI;
        }
    },
    round: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'round'`);
            }
            return Math.round(value);
        }
    },
    sin: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'sin'`);
            }
            return Math.sin(value);
        }
    },
    sqrt: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'sqrt'`);
            }
            return Math.sqrt(value);
        }
    },
    tan: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'tan'`);
            }
            return Math.tan(value);
        }
    }
};
exports.MathOperators = operators;


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/MiscOperators.ts":
/*!******************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/MiscOperators.ts ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const operators = {
    length: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (Array.isArray(value) || typeof value === "string") {
                return value.length;
            }
            throw new Error(`invalid operand '${value}' for operator 'length'`);
        }
    },
    coalesce: {
        call: (context, call) => {
            for (const childExpr of call.args) {
                const value = context.evaluate(childExpr);
                if (value !== null) {
                    return value;
                }
            }
            return null;
        }
    }
};
exports.MiscOperators = operators;


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/ObjectOperators.ts":
/*!********************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/ObjectOperators.ts ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const hasOwnProperty = Object.prototype.hasOwnProperty;
var LookupMode;
(function (LookupMode) {
    LookupMode[LookupMode["get"] = 0] = "get";
    LookupMode[LookupMode["has"] = 1] = "has";
})(LookupMode || (LookupMode = {}));
function lookupMember(context, args, lookupMode) {
    const memberName = context.evaluate(args[0]);
    if (typeof memberName !== "string") {
        throw new Error(`expected the name of an attribute`);
    }
    const object = context.evaluate(args[1]);
    if (object && typeof object === "object" && hasOwnProperty.call(object, memberName)) {
        return lookupMode === LookupMode.get ? object[memberName] : true;
    }
    return lookupMode === LookupMode.get ? null : false;
}
const operators = {
    get: {
        call: (context, call) => lookupMember(context, call.args, LookupMode.get)
    },
    has: {
        call: (context, call) => lookupMember(context, call.args, LookupMode.has)
    }
};
exports.ObjectOperators = operators;


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/StringOperators.ts":
/*!********************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/StringOperators.ts ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const operators = {
    concat: {
        call: (context, call) => {
            return "".concat(...call.args.map(a => String(context.evaluate(a))));
        }
    },
    downcase: {
        call: (context, call) => {
            return String(context.evaluate(call.args[0])).toLocaleLowerCase();
        }
    },
    upcase: {
        call: (context, call) => {
            return String(context.evaluate(call.args[0])).toLocaleUpperCase();
        }
    },
    "~=": {
        call: (context, call) => {
            const left = context.evaluate(call.args[0]);
            const right = context.evaluate(call.args[1]);
            if (typeof left === "string" && typeof right === "string") {
                return left.indexOf(right) !== -1;
            }
            return false;
        }
    },
    "^=": {
        call: (context, call) => {
            const left = context.evaluate(call.args[0]);
            const right = context.evaluate(call.args[1]);
            if (typeof left === "string" && typeof right === "string") {
                return left.startsWith(right);
            }
            return false;
        }
    },
    "$=": {
        call: (context, call) => {
            const left = context.evaluate(call.args[0]);
            const right = context.evaluate(call.args[1]);
            if (typeof left === "string" && typeof right === "string") {
                return left.endsWith(right);
            }
            return false;
        }
    }
};
exports.StringOperators = operators;


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/TypeOperators.ts":
/*!******************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/TypeOperators.ts ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const operators = {
    typeof: {
        call: (context, call) => {
            return typeof context.evaluate(call.args[0]);
        }
    }
};
exports.TypeOperators = operators;


/***/ }),

/***/ "../harp-debug-datasource/index.ts":
/*!*****************************************!*\
  !*** ../harp-debug-datasource/index.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/DebugTileDataSource */ "../harp-debug-datasource/lib/DebugTileDataSource.ts"));


/***/ }),

/***/ "../harp-debug-datasource/lib/DebugTileDataSource.ts":
/*!***********************************************************!*\
  !*** ../harp-debug-datasource/lib/DebugTileDataSource.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.js");
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "../harp-text-canvas/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const debugMaterial = new THREE.LineBasicMaterial({
    color: 0xff0000,
    linewidth: 1,
    depthTest: false
});
// Set maximum priority.
const PRIORITY_ALWAYS = Number.MAX_SAFE_INTEGER;
// Size/scale of text showing the tiles key
const TEXT_SCALE = 0.8;
class DebugTile extends harp_mapview_1.Tile {
    constructor(dataSource, tileKey) {
        super(dataSource, tileKey);
        this.geometry = new THREE.Geometry();
        this.m_labelPositions = new THREE.BufferAttribute(new Float32Array(3), 3);
        this.m_textRenderStyle = new harp_text_canvas_1.TextRenderStyle({
            fontSize: {
                unit: harp_text_canvas_1.FontUnit.Pixel,
                size: 16,
                backgroundSize: 0
            },
            color: new THREE.Color("#ff0000")
        });
        const tilingScheme = dataSource.getTilingScheme();
        const worldBox = tilingScheme.boundingBoxGenerator.getWorldBox(tileKey);
        const projection = tilingScheme.projection;
        const geoCoordinates = [
            projection.unprojectPoint(new THREE.Vector3(worldBox.min.x, worldBox.min.y, 0)),
            projection.unprojectPoint(new THREE.Vector3(worldBox.max.x, worldBox.min.y, 0)),
            projection.unprojectPoint(new THREE.Vector3(worldBox.max.x, worldBox.max.y, 0)),
            projection.unprojectPoint(new THREE.Vector3(worldBox.min.x, worldBox.max.y, 0))
        ];
        const middlePoint = new THREE.Vector3();
        geoCoordinates.forEach(geoPoint => {
            const pt = new THREE.Vector3();
            this.projection.projectPoint(geoPoint, pt);
            pt.sub(this.center);
            this.geometry.vertices.push(pt);
            middlePoint.add(pt);
        });
        middlePoint.divideScalar(geoCoordinates.length);
        const lineObject = new THREE.Line(this.geometry, debugMaterial);
        lineObject.renderOrder = PRIORITY_ALWAYS;
        this.objects.push(lineObject);
        this.m_labelPositions.setXYZ(0, 0, 0, 0);
        const textPosition = new THREE.Vector3();
        if (this.projection.type === harp_geoutils_1.ProjectionType.Planar) {
            // place the text position at north/west for planar projections.
            textPosition.copy(this.geometry.vertices[3]);
            textPosition.multiplyScalar(0.95);
            this.m_textLayoutStyle = new harp_text_canvas_1.TextLayoutStyle({
                verticalAlignment: harp_text_canvas_1.VerticalAlignment.Below,
                horizontalAlignment: harp_text_canvas_1.HorizontalAlignment.Left
            });
        }
        else {
            textPosition.copy(middlePoint);
            this.m_textLayoutStyle = new harp_text_canvas_1.TextLayoutStyle({
                verticalAlignment: harp_text_canvas_1.VerticalAlignment.Center,
                horizontalAlignment: harp_text_canvas_1.HorizontalAlignment.Center
            });
        }
        const text = `${tileKey.mortonCode()} (${tileKey.row}, ${tileKey.column}, ${tileKey.level})`;
        textPosition.add(this.center);
        const textElement = new harp_mapview_1.TextElement(text, textPosition, this.m_textRenderStyle, this.m_textLayoutStyle, PRIORITY_ALWAYS, TEXT_SCALE);
        textElement.mayOverlap = true;
        textElement.reserveSpace = false;
        textElement.alwaysOnTop = true;
        textElement.ignoreDistance = true;
        this.addTextElement(textElement);
    }
}
exports.DebugTile = DebugTile;
class DebugTileDataSource extends harp_mapview_1.DataSource {
    constructor(m_tilingScheme, name = "debug", maxDbgZoomLevel = 20) {
        super(name, undefined, 1, 20, -1);
        this.m_tilingScheme = m_tilingScheme;
        this.maxDbgZoomLevel = maxDbgZoomLevel;
        this.cacheable = true;
    }
    /** @override */
    getTilingScheme() {
        return this.m_tilingScheme;
    }
    /** @override */
    getTile(tileKey) {
        const tile = new DebugTile(this, tileKey);
        return tile;
    }
    /** @override */
    canGetTile(zoomLevel, tileKey) {
        if (tileKey.level > this.maxDbgZoomLevel) {
            return false;
        }
        return super.canGetTile(zoomLevel, tileKey);
    }
}
exports.DebugTileDataSource = DebugTileDataSource;


/***/ }),

/***/ "../harp-features-datasource/index.ts":
/*!********************************************!*\
  !*** ../harp-features-datasource/index.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/Features */ "../harp-features-datasource/lib/Features.ts"));
__export(__webpack_require__(/*! ./lib/FeaturesDataSource */ "../harp-features-datasource/lib/FeaturesDataSource.ts"));


/***/ }),

/***/ "../harp-features-datasource/lib/Features.ts":
/*!***************************************************!*\
  !*** ../harp-features-datasource/lib/Features.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Base class to create features.
 */
class MapViewFeature {
    /**
     * Builds a new `MapViewFeature`.
     *
     * @param coordinates The GeoJson geometry.
     * @param style The style to render the geometry.
     */
    constructor(coordinates, properties) {
        this.coordinates = coordinates;
        this.properties = properties;
        /**
         * The type of the feature. The extended class should initialize this value. It defaults to
         * "Point" in order to avoid allowing `null` or `undefined`.
         */
        this.type = "Point";
        /**
         * A string identifying this feature.
         */
        this.uuid = THREE.Math.generateUUID();
    }
}
exports.MapViewFeature = MapViewFeature;
class MapViewLineFeature extends MapViewFeature {
    constructor(coordinates, properties) {
        super(coordinates, properties);
        this.coordinates = coordinates;
        this.properties = properties;
        /** @override */
        this.type = "LineString";
    }
}
exports.MapViewLineFeature = MapViewLineFeature;
class MapViewMultiLineFeature extends MapViewFeature {
    constructor(coordinates, properties) {
        super(coordinates, properties);
        this.coordinates = coordinates;
        this.properties = properties;
        /** @override */
        this.type = "MultiLineString";
    }
}
exports.MapViewMultiLineFeature = MapViewMultiLineFeature;
class MapViewPolygonFeature extends MapViewFeature {
    constructor(coordinates, properties) {
        super(coordinates, properties);
        this.coordinates = coordinates;
        this.properties = properties;
        /** @override */
        this.type = "Polygon";
    }
}
exports.MapViewPolygonFeature = MapViewPolygonFeature;
class MapViewMultiPolygonFeature extends MapViewFeature {
    constructor(coordinates, properties) {
        super(coordinates, properties);
        this.coordinates = coordinates;
        this.properties = properties;
        /** @override */
        this.type = "MultiPolygon";
    }
}
exports.MapViewMultiPolygonFeature = MapViewMultiPolygonFeature;
class MapViewPointFeature extends MapViewFeature {
    constructor(coordinates, properties) {
        super(coordinates, properties);
        this.coordinates = coordinates;
        this.properties = properties;
        /** @override */
        this.type = "Point";
    }
}
exports.MapViewPointFeature = MapViewPointFeature;
class MapViewMultiPointFeature extends MapViewFeature {
    constructor(coordinates, properties) {
        super(coordinates, properties);
        this.coordinates = coordinates;
        this.properties = properties;
        /** @override */
        this.type = "MultiPoint";
    }
}
exports.MapViewMultiPointFeature = MapViewMultiPointFeature;


/***/ }),

/***/ "../harp-features-datasource/lib/FeaturesDataSource.ts":
/*!*************************************************************!*\
  !*** ../harp-features-datasource/lib/FeaturesDataSource.ts ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_geojson_datasource_1 = __webpack_require__(/*! @here/harp-geojson-datasource */ "../harp-geojson-datasource/index.ts");
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_omv_datasource_1 = __webpack_require__(/*! @here/harp-omv-datasource */ "../harp-omv-datasource/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const logger = harp_utils_1.LoggerManager.instance.create("FeaturesDataSource");
const NAME = "user-features-datasource";
const DEFAULT_GEOJSON = {
    type: "FeatureCollection",
    features: []
};
/**
 * [[DataSource]] implementation to use for the addition of custom features.
 */
class FeaturesDataSource extends harp_omv_datasource_1.OmvDataSource {
    /**
     * Builds a `FeaturesDataSource`.
     *
     * @param options specify custom options using [[FeatureDataSourceOptions]] interface.
     */
    constructor(options) {
        super(Object.assign(Object.assign({}, options), { dataProvider: new harp_geojson_datasource_1.GeoJsonDataProvider(NAME, DEFAULT_GEOJSON, options) }));
        this.m_isAttached = false;
        this.m_featureCollection = this.emptyGeojson();
        if (options !== undefined) {
            if (options.features !== undefined) {
                this.add(...options.features);
            }
            if (options.geojson !== undefined) {
                this.setFromGeojson(options.geojson);
            }
        }
    }
    /**
     * This method allows to directly add a GeoJSON without using [[MapViewFeature]] instances. It
     * also overwrites existing features in this data source. To add a GeoJSON without overwriting
     * the data source, one should loop through it to create [[MapViewFeature]] and add them with
     * the `add` method.
     *
     * @param geojson A javascript object matching the GeoJSON specification.
     */
    setFromGeojson(geojson) {
        if (geojson.type === "FeatureCollection") {
            this.m_featureCollection = geojson;
        }
        else if (geojson.type === "Feature") {
            this.m_featureCollection = this.emptyGeojson();
            this.m_featureCollection.features.push(geojson);
        }
        else if (geojson.type === "GeometryCollection") {
            this.m_featureCollection = this.emptyGeojson();
            for (const geometry of geojson.geometries) {
                this.m_featureCollection.features.push({
                    type: "Feature",
                    geometry
                });
            }
        }
        else {
            throw new TypeError("The provided object is not a valid GeoJSON object.");
        }
        this.update();
        return this;
    }
    /**
     * Adds a custom feature in the datasource.
     *
     * @param features The features to add in the datasource.
     */
    add(...features) {
        for (const feature of features) {
            this.addFeature(feature);
        }
        this.update();
        return this;
    }
    /**
     * Removes a custom feature in the datasource.
     *
     * @param features The features to add in the datasource.
     */
    remove(...features) {
        for (const feature of features) {
            this.removeFeature(feature);
        }
        this.update();
        return this;
    }
    /**
     * Removes all the custom features in this `FeaturesDataSource`.
     */
    clear() {
        this.m_featureCollection = this.emptyGeojson();
        this.update();
    }
    /** @override */
    async connect() {
        await super.connect();
        if (this.m_featureCollection.features.length > 0) {
            await this.update();
        }
    }
    /**
     * Override [[DataSource.attach]] to know if we're really connected to [[MapView]].
     * @param mapView
     * @override
     */
    attach(mapView) {
        super.attach(mapView);
        this.m_isAttached = true;
    }
    /**
     * Override [[DataSource.detach]] to know if we're really connected to [[MapView]].
     * @param mapView
     * @override
     */
    detach(mapView) {
        super.detach(mapView);
        this.m_isAttached = false;
    }
    /**
     * Get [[GeoBox]] containing all the points in datasource.
     *
     * Returns undefined if there were no features added to this DS.
     */
    getGeoBox() {
        let result;
        const addPoint = (geoJsonCoords) => {
            // NOTE: GeoJson coordinates are in [longitute, latitute] order!
            const coords = new harp_geoutils_1.GeoCoordinates(geoJsonCoords[1], geoJsonCoords[0]);
            if (result === undefined) {
                result = new harp_geoutils_1.GeoBox(coords, coords.clone());
            }
            else {
                result.growToContain(coords);
            }
        };
        for (const feature of this.m_featureCollection.features) {
            switch (feature.geometry.type) {
                case "Point":
                    addPoint(feature.geometry.coordinates);
                    break;
                case "MultiPoint":
                case "LineString":
                    feature.geometry.coordinates.forEach(addPoint);
                    break;
                case "MultiLineString":
                case "Polygon":
                    feature.geometry.coordinates.forEach(segment => segment.forEach(addPoint));
                    break;
                case "MultiPolygon":
                    feature.geometry.coordinates.forEach(polygon => polygon.forEach(segment => segment.forEach(addPoint)));
                    break;
            }
        }
        return result;
    }
    addFeature(feature) {
        // Check if the feature is not already in there.
        const hasFeature = this.m_featureCollection.features.some(_feature => _feature.properties.__mapViewUuid === feature.uuid);
        if (hasFeature) {
            return;
        }
        // Create a GeoJson feature from the feature coordinates and push it.
        const geometry = {
            type: feature.type,
            coordinates: feature.coordinates
        };
        const geojsonFeature = {
            type: "Feature",
            geometry,
            properties: Object.assign(Object.assign({}, feature.properties), { __mapViewUuid: feature.uuid })
        };
        this.m_featureCollection.features.push(geojsonFeature);
    }
    removeFeature(feature) {
        // Remove geojson feature from the root FeatureCollection.
        const index = this.m_featureCollection.features.findIndex(_feature => _feature.properties.__mapViewUuid === feature.uuid);
        if (index === -1) {
            return;
        }
        this.m_featureCollection.features.splice(index, 1);
    }
    async update() {
        const dataProvider = this.dataProvider();
        if (!this.m_isAttached || !dataProvider.ready()) {
            return;
        }
        try {
            await dataProvider.updateInput(this.m_featureCollection);
            if (this.m_isAttached) {
                this.mapView.markTilesDirty(this);
            }
        }
        catch (error) {
            // We use `update` in sync API, so there's no-one to react to errors so log them.
            logger.error(`[${this.name}]: failed to update tile index`, error);
        }
    }
    emptyGeojson() {
        return {
            features: [],
            type: "FeatureCollection"
        };
    }
}
exports.FeaturesDataSource = FeaturesDataSource;


/***/ }),

/***/ "../harp-fetch/index.web.ts":
/*!**********************************!*\
  !*** ../harp-fetch/index.web.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });


/***/ }),

/***/ "../harp-geojson-datasource/index.ts":
/*!*******************************************!*\
  !*** ../harp-geojson-datasource/index.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/GeoJsonDataSource */ "../harp-geojson-datasource/lib/GeoJsonDataSource.ts"));
__export(__webpack_require__(/*! ./lib/GeoJsonDataProvider */ "../harp-geojson-datasource/lib/GeoJsonDataProvider.ts"));


/***/ }),

/***/ "../harp-geojson-datasource/lib/GeoJsonDataProvider.ts":
/*!*************************************************************!*\
  !*** ../harp-geojson-datasource/lib/GeoJsonDataProvider.ts ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
__webpack_require__(/*! @here/harp-fetch */ "../harp-fetch/index.web.ts");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const logger = harp_utils_1.LoggerManager.instance.create("GeoJsonDataProvider");
let missingTilerServiceInfoEmitted = false;
/**
 * GeoJson [[DataProvider]]. Automatically handles tiling and simplification of static GeoJson.
 */
class GeoJsonDataProvider {
    /**
     * Constructs a new `GeoJsonDataProvider`.
     *
     * @param name Name to be used to reference this `DataProvider`
     * @param input URL of the GeoJSON, or a GeoJSON.
     * @param options Optional
     * @returns New `GeoJsonDataProvider`.
     */
    constructor(name, input, options) {
        this.name = name;
        this.input = input;
        this.m_registered = false;
        this.m_tiler =
            (options && options.tiler) ||
                harp_mapview_1.ConcurrentTilerFacade.getTiler("omv-tiler", options && options.workerTilerUrl);
    }
    async connect() {
        try {
            await this.m_tiler.connect();
        }
        catch (error) {
            if (harp_datasource_protocol_1.WorkerServiceProtocol.isUnknownServiceError(error) &&
                !missingTilerServiceInfoEmitted) {
                logger.info("Unable to start GeoJson tiler service in worker. Use " +
                    " 'OmvTilerService.start();' in decoder script.");
                missingTilerServiceInfoEmitted = true;
            }
            throw error;
        }
        await this.m_tiler.registerIndex(this.name, this.input);
        this.m_registered = true;
    }
    updateInput(input) {
        this.input = input;
        this.m_tiler.updateIndex(this.name, this.input);
    }
    ready() {
        return this.m_registered;
    }
    async getTile(tileKey) {
        return this.m_tiler.getTile(this.name, tileKey);
    }
}
exports.GeoJsonDataProvider = GeoJsonDataProvider;


/***/ }),

/***/ "../harp-geojson-datasource/lib/GeoJsonDataSource.ts":
/*!***********************************************************!*\
  !*** ../harp-geojson-datasource/lib/GeoJsonDataSource.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_mapview_decoder_1 = __webpack_require__(/*! @here/harp-mapview-decoder */ "../harp-mapview-decoder/index.ts");
const GeoJsonTile_1 = __webpack_require__(/*! ./GeoJsonTile */ "../harp-geojson-datasource/lib/GeoJsonTile.ts");
/**
 * `GeoJsonDataSource` is used for the visualization of geometric objects provided in the GeoJSON
 * format. To be able to render GeoJSON data, a `GeoJsonDataSource` instance must be added to the
 * [[MapView]] instance.
 *
 * @example <caption><b>Example usage of GeoJsonDataSource:</b></caption>
 * <pre>
 * const geoJsonDataSource = new GeoJsonDataSource({
 *    dataStore: {
 *       dataProvider: new XYZDataProvider({baseUrl, spaceId, token})
 *    }
 * });
 *
 * mapView.addDataSource(geoJsonDataSource);
 * // Show geoJSON data on specific tile
 * geoJsonDataSource.selectTile(geoJsonDataTile, mapView.projection);
 * </pre>
 */
class GeoJsonDataSource extends harp_mapview_decoder_1.TileDataSource {
    /**
     * Default constructor.
     *
     * @param params Data source configuration's parameters.
     */
    constructor(params) {
        super(new harp_mapview_decoder_1.TileFactory(GeoJsonTile_1.GeoJsonTile), {
            styleSetName: params.styleSetName || "geojson",
            name: params.name,
            tilingScheme: harp_geoutils_1.webMercatorTilingScheme,
            dataProvider: params.dataProvider,
            concurrentDecoderServiceName: "geojson-tile-decoder",
            storageLevelOffset: -1
        });
        this.params = params;
    }
    /** @override */
    async connect() {
        await super.connect();
        await this.decoder.connect();
    }
}
exports.GeoJsonDataSource = GeoJsonDataSource;


/***/ }),

/***/ "../harp-geojson-datasource/lib/GeoJsonTile.ts":
/*!*****************************************************!*\
  !*** ../harp-geojson-datasource/lib/GeoJsonTile.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.js");
const TileGeometryCreator_1 = __webpack_require__(/*! @here/harp-mapview/lib/geometry/TileGeometryCreator */ "../harp-mapview/lib/geometry/TileGeometryCreator.ts");
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "../harp-text-canvas/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
/**
 * It contains default values for the labeled icons
 */
const DEFAULT_LABELED_ICON = {
    priority: 1000,
    size: 16,
    xOffset: 0.0,
    yOffset: 0.0,
    mayOverlap: false,
    reserveSpace: true,
    alwaysOnTop: true,
    textIsOptional: true,
    iconIsOptional: false,
    iconMayOverlap: false,
    renderTextDuringMovements: true,
    textReserveSpace: true,
    imageTextureName: "location",
    label: "",
    featureId: 0
};
/**
 * The `GeoJsonTile` class is used to create objects from decoded GeoJSON data. Instances of
 * `GeoJsonTile` are created by [[GeoJsonDataSource.getTile]] and used by [[MapView]] to add tile
 * objects to the scene.
 */
class GeoJsonTile extends harp_mapview_1.Tile {
    /**
     * Tiles render at all zoom levels. This method stores the zoom level in order to know how to
     * scale the lines's width.
     *
     * @param zoomLevel zoom level.
     * @returns always returns `true`
     * @override
     */
    willRender(zoomLevel) {
        if (this.m_currentZoomLevel !== zoomLevel) {
            this.m_currentZoomLevel = zoomLevel;
        }
        return true;
    }
    /**
     * For unit testing.
     * TODO: find a better solution and/or get rid of window in this class at all.
     */
    getWindow() {
        return window;
    }
    /**
     * Given a decode tile, it adds labeled icons to it. This method overrides the
     * `createTextElements` in the [[Tile]] class.
     *
     * @param decodedTile The decoded tile received by the [[GeoJsonDecoder]].
     */
    createTextElements(decodedTile, env) {
        const tileGeometryCreator = TileGeometryCreator_1.TileGeometryCreator.instance;
        const worldOffsetX = this.computeWorldOffsetX();
        if (decodedTile.poiGeometries !== undefined) {
            for (const geometry of decodedTile.poiGeometries) {
                const techniqueIndex = geometry.technique;
                const technique = decodedTile.techniques[techniqueIndex];
                if (harp_datasource_protocol_1.isPoiTechnique(technique)) {
                    this.addPois(geometry, technique, env, worldOffsetX);
                }
            }
        }
        if (decodedTile.textGeometries !== undefined) {
            for (const geometry of decodedTile.textGeometries) {
                const techniqueIndex = geometry.technique;
                const technique = decodedTile.techniques[techniqueIndex];
                if (harp_datasource_protocol_1.isTextTechnique(technique)) {
                    this.addTexts(geometry, technique, worldOffsetX);
                }
            }
        }
        if (decodedTile.textPathGeometries !== undefined) {
            this.preparedTextPaths = tileGeometryCreator.prepareTextPaths(decodedTile.textPathGeometries, decodedTile);
            for (const textPath of this.preparedTextPaths) {
                const techniqueIndex = textPath.technique;
                const technique = decodedTile.techniques[techniqueIndex];
                if (harp_datasource_protocol_1.isTextTechnique(technique)) {
                    this.addTextPaths(textPath, technique, worldOffsetX);
                }
            }
        }
        // HARP-7419: TODO, support tile.pathGeometries, not currently needed, but may be needed
        // in future, should be simple, something like
        /*if(decodedTile.pathGeometries) {
            tile.addBlockingElement...
        }
        */
    }
    /**
     * Calls `addTextPath` for each TextPath.
     *
     * @param geometry The TextPath geometry.
     * @param technique Text technique.
     */
    addTextPaths(geometry, technique, worldOffsetX) {
        const path = [];
        for (let i = 0; i < geometry.path.length; i += 3) {
            path.push(new THREE.Vector3(geometry.path[i] + worldOffsetX, geometry.path[i + 1], geometry.path[i + 2]));
        }
        const properties = geometry.objInfos !== undefined ? geometry.objInfos : undefined;
        this.addTextPath(path, geometry.text, technique, properties);
    }
    /**
     * Add a label available for mouse picking at the given path.
     *
     * @param path Path of the text path.
     * @param text Text of the path.
     * @param technique Technique in use.
     * @param geojsonProperties Properties defined by the user.
     */
    addTextPath(path, text, technique, geojsonProperties) {
        const priority = technique.priority === undefined ? DEFAULT_LABELED_ICON.priority : technique.priority;
        const xOffset = technique.xOffset === undefined ? DEFAULT_LABELED_ICON.xOffset : technique.xOffset;
        const yOffset = technique.yOffset === undefined ? DEFAULT_LABELED_ICON.yOffset : technique.yOffset;
        const featureId = DEFAULT_LABELED_ICON.featureId;
        const styleCache = this.mapView.textElementsRenderer.styleCache;
        const textElement = new harp_mapview_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(text), path, styleCache.getRenderStyle(this, technique), styleCache.getLayoutStyle(this, technique), harp_datasource_protocol_1.getPropertyValue(priority, this.mapView.env), xOffset, yOffset, featureId);
        // Set the userData of the TextElement to the geojsonProperties, then it will be available
        // for picking.
        if (geojsonProperties !== undefined) {
            textElement.userData = geojsonProperties;
        }
        const mayOverlap = technique.mayOverlap === undefined
            ? DEFAULT_LABELED_ICON.iconMayOverlap
            : technique.mayOverlap;
        const reserveSpace = technique.reserveSpace === undefined
            ? DEFAULT_LABELED_ICON.textReserveSpace
            : technique.reserveSpace;
        const distanceScale = harp_mapview_1.DEFAULT_TEXT_DISTANCE_SCALE;
        textElement.mayOverlap = mayOverlap;
        textElement.reserveSpace = reserveSpace;
        textElement.distanceScale = distanceScale;
        this.addUserTextElement(textElement);
    }
    /**
     * Calls `addText` on each vertex of the geometry.
     *
     * @param geometry The Text geometry.
     * @param technique Text technique.
     */
    addTexts(geometry, technique, worldOffsetX) {
        const attribute = harp_mapview_1.getBufferAttribute(geometry.positions);
        for (let index = 0; index < attribute.count; index++) {
            const currentVertexCache = new THREE.Vector3(attribute.getX(index) + worldOffsetX, attribute.getY(index), attribute.getZ(index));
            const properties = geometry.objInfos !== undefined ? geometry.objInfos[index] : undefined;
            const text = geometry.stringCatalog[index];
            this.addText(currentVertexCache, text, technique, properties);
        }
    }
    /**
     * Add a label available for mouse picking at the given position.
     *
     * @param position position of the labeled Icon, in world coordinate.
     * @param text Text of the path.
     * @param technique Technique in use.
     * @param geojsonProperties Properties defined by the user.
     */
    addText(position, text, technique, geojsonProperties) {
        const priority = technique.priority === undefined ? DEFAULT_LABELED_ICON.priority : technique.priority;
        const xOffset = technique.xOffset === undefined ? DEFAULT_LABELED_ICON.xOffset : technique.xOffset;
        const yOffset = technique.yOffset === undefined ? DEFAULT_LABELED_ICON.yOffset : technique.yOffset;
        const featureId = DEFAULT_LABELED_ICON.featureId;
        const styleCache = this.mapView.textElementsRenderer.styleCache;
        const textElement = new harp_mapview_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(text), position, styleCache.getRenderStyle(this, technique), styleCache.getLayoutStyle(this, technique), harp_datasource_protocol_1.getPropertyValue(priority, this.mapView.env), xOffset, yOffset, featureId);
        // Set the userData of the TextElement to the geojsonProperties, then it will be available
        // for picking.
        if (geojsonProperties !== undefined) {
            textElement.userData = geojsonProperties;
        }
        const mayOverlap = technique.mayOverlap === undefined
            ? DEFAULT_LABELED_ICON.iconMayOverlap
            : technique.mayOverlap;
        const distanceScale = harp_mapview_1.DEFAULT_TEXT_DISTANCE_SCALE;
        textElement.mayOverlap = mayOverlap;
        textElement.reserveSpace = false;
        textElement.distanceScale = distanceScale;
        this.addUserTextElement(textElement);
    }
    /**
     * Calls `addPoi` on each vertex of the geometry.
     *
     * @param geometry The POI geometry.
     * @param technique POI technique.
     */
    addPois(geometry, technique, env, worldOffsetX) {
        const attribute = harp_mapview_1.getBufferAttribute(geometry.positions);
        const currentVertexCache = new THREE.Vector3();
        for (let index = 0; index < attribute.count; index++) {
            currentVertexCache.set(attribute.getX(index) + worldOffsetX, attribute.getY(index), attribute.getZ(index));
            const properties = geometry.objInfos !== undefined ? geometry.objInfos[index] : undefined;
            this.addPoi(currentVertexCache, technique, env, properties);
        }
    }
    /**
     * Add a POI available for mouse picking at the given position.
     *
     * @param position position of the labeled Icon, in world coordinate.
     * @param technique Technique in use.
     * @param geojsonProperties Properties defined by the user.
     */
    addPoi(position, technique, env, geojsonProperties) {
        const label = DEFAULT_LABELED_ICON.label;
        const priority = technique.priority === undefined ? DEFAULT_LABELED_ICON.priority : technique.priority;
        const xOffset = harp_datasource_protocol_1.getPropertyValue(technique.xOffset, env);
        const yOffset = harp_datasource_protocol_1.getPropertyValue(technique.yOffset, env);
        const featureId = DEFAULT_LABELED_ICON.featureId;
        const styleCache = this.mapView.textElementsRenderer.styleCache;
        const textElement = new harp_mapview_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(label), position, styleCache.getRenderStyle(this, technique), styleCache.getLayoutStyle(this, technique), harp_datasource_protocol_1.getPropertyValue(priority, env), xOffset === undefined ? DEFAULT_LABELED_ICON.xOffset : xOffset, yOffset === undefined ? DEFAULT_LABELED_ICON.yOffset : yOffset, featureId);
        // Set the userData of the TextElement to the geojsonProperties, then it will be available
        // for picking.
        if (geojsonProperties !== undefined) {
            textElement.userData = geojsonProperties;
        }
        const mayOverlap = technique.iconMayOverlap === undefined
            ? DEFAULT_LABELED_ICON.iconMayOverlap
            : technique.iconMayOverlap;
        const reserveSpace = technique.iconReserveSpace === undefined
            ? DEFAULT_LABELED_ICON.textReserveSpace
            : technique.iconReserveSpace;
        const distanceScale = harp_mapview_1.DEFAULT_TEXT_DISTANCE_SCALE;
        const alwaysOnTop = technique.alwaysOnTop === undefined
            ? DEFAULT_LABELED_ICON.alwaysOnTop
            : technique.alwaysOnTop;
        textElement.mayOverlap = mayOverlap;
        textElement.reserveSpace = reserveSpace;
        textElement.distanceScale = distanceScale;
        textElement.alwaysOnTop = alwaysOnTop;
        const textIsOptional = technique.textIsOptional === undefined
            ? DEFAULT_LABELED_ICON.textIsOptional
            : technique.textIsOptional;
        const iconIsOptional = technique.iconIsOptional === undefined
            ? DEFAULT_LABELED_ICON.iconIsOptional
            : technique.iconIsOptional;
        const renderTextDuringMovements = technique.renderTextDuringMovements === undefined
            ? DEFAULT_LABELED_ICON.renderTextDuringMovements
            : technique.renderTextDuringMovements;
        const imageTextureName = technique.imageTexture !== undefined
            ? technique.imageTexture
            : DEFAULT_LABELED_ICON.imageTextureName;
        textElement.poiInfo = {
            technique,
            imageTextureName,
            textElement,
            textIsOptional,
            iconIsOptional,
            renderTextDuringMovements,
            mayOverlap,
            reserveSpace,
            featureId
        };
        this.addUserTextElement(textElement);
    }
}
exports.GeoJsonTile = GeoJsonTile;
GeoJsonTile.POINT_MARKER_SIZE = 128;


/***/ }),

/***/ "../harp-geometry/lib/SphericalGeometrySubdivisionModifier.ts":
/*!********************************************************************!*\
  !*** ../harp-geometry/lib/SphericalGeometrySubdivisionModifier.ts ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const three_1 = __webpack_require__(/*! three */ "three");
const SubdivisionModifier_1 = __webpack_require__(/*! ./SubdivisionModifier */ "../harp-geometry/lib/SubdivisionModifier.ts");
const VERTEX_POSITION_CACHE = [new three_1.Vector3(), new three_1.Vector3(), new three_1.Vector3()];
/**
 * The [[SphericalGeometrySubdivisionModifier]] subdivides triangle mesh geometries positioned
 * on the surface of a sphere centered at `(0, 0, 0)`.
 */
class SphericalGeometrySubdivisionModifier extends SubdivisionModifier_1.SubdivisionModifier {
    /**
     * Constructs a new [[SphericalGeometrySubdivisionModifier]].
     *
     * @param angle The maximum angle in radians between two vertices and the origin.
     * @param projection The projection that defines the world space of this geometry.
     */
    constructor(angle, projection = harp_geoutils_1.sphereProjection) {
        super();
        this.angle = angle;
        this.projection = projection;
    }
    /** @override */
    shouldSplitTriangle(a, b, c) {
        const aa = harp_geoutils_1.sphereProjection.reprojectPoint(this.projection, a, VERTEX_POSITION_CACHE[0]);
        const bb = harp_geoutils_1.sphereProjection.reprojectPoint(this.projection, b, VERTEX_POSITION_CACHE[1]);
        const cc = harp_geoutils_1.sphereProjection.reprojectPoint(this.projection, c, VERTEX_POSITION_CACHE[2]);
        const alpha = aa.angleTo(bb);
        const beta = bb.angleTo(cc);
        const gamma = cc.angleTo(aa);
        // find the maximum angle
        const m = Math.max(alpha, Math.max(beta, gamma));
        // split the triangle if needed.
        if (m < this.angle) {
            return undefined;
        }
        if (m === alpha) {
            return 0;
        }
        else if (m === beta) {
            return 1;
        }
        else if (m === gamma) {
            return 2;
        }
        throw new Error("failed to split triangle");
    }
}
exports.SphericalGeometrySubdivisionModifier = SphericalGeometrySubdivisionModifier;


/***/ }),

/***/ "../harp-geometry/lib/SubdivisionModifier.ts":
/*!***************************************************!*\
  !*** ../harp-geometry/lib/SubdivisionModifier.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const three_1 = __webpack_require__(/*! three */ "three");
const tmpVectorA = new three_1.Vector3();
const tmpVectorB = new three_1.Vector3();
const tmpVectorC = new three_1.Vector3();
/**
 * The [[SubdivisionModifier]] subdivides triangle mesh geometries.
 */
class SubdivisionModifier {
    /**
     * Constructs a new [[SubdivisionModifier]].
     */
    constructor() {
        // nothing to do
    }
    /**
     * Subdivides the faces of the given [[THREE.BufferGeometry]].
     *
     * This method modifies (in-place) the vertices and the faces of the geometry.
     * Please note that only the vertex position and their UV coordinates are subdivided.
     * Normals, vertex colors and other attributes are left unmodified.
     *
     * @param geometry The [[THREE.BufferGeometry]] to subdivide.
     */
    modify(geometry) {
        const positionAttr = geometry.getAttribute("position");
        const position = Array.from(positionAttr.array);
        const uvAttr = geometry.getAttribute("uv");
        const uv = uvAttr !== undefined ? Array.from(uvAttr.array) : undefined;
        const edgeAttr = geometry.getAttribute("edge");
        const edge = edgeAttr !== undefined ? Array.from(edgeAttr.array) : undefined;
        const wallAttr = geometry.getAttribute("wall");
        const wall = wallAttr !== undefined ? Array.from(wallAttr.array) : undefined;
        const indexAttr = geometry.getIndex();
        const indices = Array.from(indexAttr.array);
        // A cache containing the indices of the vertices added
        // when subdiving the faces of the geometry.
        const cache = new Map();
        /**
         * Returns the index of the vertex positioned in the middle of the given vertices.
         */
        function middleVertex(i, j) {
            // Build a unique `key` for the pair of indices `(i, j)`.
            const key = `${Math.min(i, j)}_${Math.max(i, j)}`;
            const h = cache.get(key);
            if (h !== undefined) {
                // Nothing to do, a vertex in the middle of (i, j) was already created.
                return h;
            }
            // The position of the new vertex.
            tmpVectorA.set(position[i * 3], position[i * 3 + 1], position[i * 3 + 2]);
            tmpVectorB.set(position[j * 3], position[j * 3 + 1], position[j * 3 + 2]);
            tmpVectorC.lerpVectors(tmpVectorA, tmpVectorB, 0.5);
            // The index of the new vertex.
            const index = position.length / 3;
            position.push(...tmpVectorC.toArray());
            // Cache the position of the new vertex.
            cache.set(key, index);
            // The uvs of the new vertex.
            if (uv !== undefined) {
                tmpVectorA.set(uv[i * 2], uv[i * 2 + 1], 0);
                tmpVectorB.set(uv[j * 2], uv[j * 2 + 1], 0);
                tmpVectorC.lerpVectors(tmpVectorA, tmpVectorB, 0.5);
                uv.push(tmpVectorC.x, tmpVectorC.y);
            }
            // The edge and wall attributes of the new vertex.
            // If a new vertex has been introduced between i and j, connect the elements
            // accordingly.
            if (edge !== undefined) {
                if (edge[i] === j) {
                    edge.push(j);
                    edge[i] = index;
                }
                else if (edge[j] === i) {
                    edge.push(i);
                    edge[j] = index;
                }
                else {
                    edge.push(-1);
                }
            }
            if (wall !== undefined) {
                if (wall[i] === j) {
                    wall.push(j);
                    wall[i] = index;
                }
                else if (wall[j] === i) {
                    wall.push(i);
                    wall[j] = index;
                }
                else {
                    wall.push(-1);
                }
            }
            return index;
        }
        const newIndices = [];
        while (indices.length >= 3) {
            const v0 = indices.shift();
            const v1 = indices.shift();
            const v2 = indices.shift();
            tmpVectorA.set(position[v0 * 3], position[v0 * 3 + 1], position[v0 * 3 + 2]);
            tmpVectorB.set(position[v1 * 3], position[v1 * 3 + 1], position[v1 * 3 + 2]);
            tmpVectorC.set(position[v2 * 3], position[v2 * 3 + 1], position[v2 * 3 + 2]);
            const edgeToSplit = this.shouldSplitTriangle(tmpVectorA, tmpVectorB, tmpVectorC);
            switch (edgeToSplit) {
                case 0: {
                    const v3 = middleVertex(v0, v1);
                    indices.push(v0, v3, v2, v3, v1, v2);
                    break;
                }
                case 1: {
                    const v3 = middleVertex(v1, v2);
                    indices.push(v0, v1, v3, v0, v3, v2);
                    break;
                }
                case 2: {
                    const v3 = middleVertex(v2, v0);
                    indices.push(v0, v1, v3, v3, v1, v2);
                    break;
                }
                case undefined: {
                    newIndices.push(v0, v1, v2);
                    break;
                }
                default:
                    throw new Error("failed to subdivide the given geometry");
            }
        }
        positionAttr.array = new Float32Array(position);
        positionAttr.count = position.length / positionAttr.itemSize;
        positionAttr.needsUpdate = true;
        geometry.setIndex(newIndices);
        if (uv !== undefined) {
            uvAttr.array = new Float32Array(uv);
            uvAttr.count = uv.length / uvAttr.itemSize;
            uvAttr.needsUpdate = true;
        }
        if (edge !== undefined) {
            edgeAttr.array = new Float32Array(edge);
            edgeAttr.count = edge.length / edgeAttr.itemSize;
            edgeAttr.needsUpdate = true;
        }
        return geometry;
    }
}
exports.SubdivisionModifier = SubdivisionModifier;


/***/ }),

/***/ "../harp-geoutils/index.ts":
/*!*********************************!*\
  !*** ../harp-geoutils/index.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/coordinates/GeoBox */ "../harp-geoutils/lib/coordinates/GeoBox.ts"));
__export(__webpack_require__(/*! ./lib/coordinates/GeoCoordinatesLike */ "../harp-geoutils/lib/coordinates/GeoCoordinatesLike.ts"));
__export(__webpack_require__(/*! ./lib/coordinates/GeoCoordinates */ "../harp-geoutils/lib/coordinates/GeoCoordinates.ts"));
__export(__webpack_require__(/*! ./lib/coordinates/GeoPointLike */ "../harp-geoutils/lib/coordinates/GeoPointLike.ts"));
__export(__webpack_require__(/*! ./lib/coordinates/LatLngLike */ "../harp-geoutils/lib/coordinates/LatLngLike.ts"));
__export(__webpack_require__(/*! ./lib/projection/EarthConstants */ "../harp-geoutils/lib/projection/EarthConstants.ts"));
__export(__webpack_require__(/*! ./lib/projection/EquirectangularProjection */ "../harp-geoutils/lib/projection/EquirectangularProjection.ts"));
__export(__webpack_require__(/*! ./lib/projection/IdentityProjection */ "../harp-geoutils/lib/projection/IdentityProjection.ts"));
__export(__webpack_require__(/*! ./lib/projection/Projection */ "../harp-geoutils/lib/projection/Projection.ts"));
__export(__webpack_require__(/*! ./lib/projection/MercatorProjection */ "../harp-geoutils/lib/projection/MercatorProjection.ts"));
__export(__webpack_require__(/*! ./lib/projection/TransverseMercatorProjection */ "../harp-geoutils/lib/projection/TransverseMercatorProjection.ts"));
__export(__webpack_require__(/*! ./lib/projection/SphereProjection */ "../harp-geoutils/lib/projection/SphereProjection.ts"));
__export(__webpack_require__(/*! ./lib/tiling/FlatTileBoundingBoxGenerator */ "../harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.ts"));
__export(__webpack_require__(/*! ./lib/tiling/HalfQuadTreeSubdivisionScheme */ "../harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.ts"));
__export(__webpack_require__(/*! ./lib/tiling/QuadTreeSubdivisionScheme */ "../harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.ts"));
__export(__webpack_require__(/*! ./lib/tiling/QuadTree */ "../harp-geoutils/lib/tiling/QuadTree.ts"));
__export(__webpack_require__(/*! ./lib/tiling/SubTiles */ "../harp-geoutils/lib/tiling/SubTiles.ts"));
__export(__webpack_require__(/*! ./lib/tiling/TileKey */ "../harp-geoutils/lib/tiling/TileKey.ts"));
__export(__webpack_require__(/*! ./lib/tiling/TileKeyUtils */ "../harp-geoutils/lib/tiling/TileKeyUtils.ts"));
__export(__webpack_require__(/*! ./lib/tiling/TileTreeTraverse */ "../harp-geoutils/lib/tiling/TileTreeTraverse.ts"));
__export(__webpack_require__(/*! ./lib/tiling/TilingScheme */ "../harp-geoutils/lib/tiling/TilingScheme.ts"));
__export(__webpack_require__(/*! ./lib/tiling/HereTilingScheme */ "../harp-geoutils/lib/tiling/HereTilingScheme.ts"));
__export(__webpack_require__(/*! ./lib/tiling/WebMercatorTilingScheme */ "../harp-geoutils/lib/tiling/WebMercatorTilingScheme.ts"));
__export(__webpack_require__(/*! ./lib/tiling/MercatorTilingScheme */ "../harp-geoutils/lib/tiling/MercatorTilingScheme.ts"));
__export(__webpack_require__(/*! ./lib/tiling/PolarTilingScheme */ "../harp-geoutils/lib/tiling/PolarTilingScheme.ts"));
__export(__webpack_require__(/*! ./lib/math/Vector3Like */ "../harp-geoutils/lib/math/Vector3Like.ts"));
__export(__webpack_require__(/*! ./lib/math/Box3Like */ "../harp-geoutils/lib/math/Box3Like.ts"));
__export(__webpack_require__(/*! ./lib/math/OrientedBox3Like */ "../harp-geoutils/lib/math/OrientedBox3Like.ts"));
__export(__webpack_require__(/*! ./lib/math/MathUtils */ "../harp-geoutils/lib/math/MathUtils.ts"));
__export(__webpack_require__(/*! ./lib/math/TransformLike */ "../harp-geoutils/lib/math/TransformLike.ts"));
__export(__webpack_require__(/*! ./lib/math/OrientedBox3 */ "../harp-geoutils/lib/math/OrientedBox3.ts"));


/***/ }),

/***/ "../harp-geoutils/lib/coordinates/GeoBox.ts":
/*!**************************************************!*\
  !*** ../harp-geoutils/lib/coordinates/GeoBox.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const GeoCoordinates_1 = __webpack_require__(/*! ./GeoCoordinates */ "../harp-geoutils/lib/coordinates/GeoCoordinates.ts");
const THREE = __webpack_require__(/*! three */ "three");
/**
 * `GeoBox` is used to represent a bounding box in geo coordinates.
 */
class GeoBox {
    /**
     * Constructs a new `GeoBox` with the given geo coordinates.
     *
     * @param southWest The south west position in geo coordinates.
     * @param northEast The north east position in geo coordinates.
     */
    constructor(southWest, northEast) {
        this.southWest = southWest;
        this.northEast = northEast;
    }
    /**
     * Returns a `GeoBox` with the given geo coordinates.
     *
     * @param southWest The south west position in geo coordinates.
     * @param northEast The north east position in geo coordinates.
     */
    static fromCoordinates(southWest, northEast) {
        return new GeoBox(southWest, northEast);
    }
    /**
     * Returns the minimum altitude or `undefined`.
     */
    get minAltitude() {
        if (this.southWest.altitude === undefined || this.northEast.altitude === undefined) {
            return undefined;
        }
        return Math.min(this.southWest.altitude, this.northEast.altitude);
    }
    /**
     * Returns the maximum altitude or `undefined`.
     */
    get maxAltitude() {
        if (this.southWest.altitude === undefined || this.northEast.altitude === undefined) {
            return undefined;
        }
        return Math.max(this.southWest.altitude, this.northEast.altitude);
    }
    /**
     * Returns the south latitude in degrees of this `GeoBox`.
     */
    get south() {
        return this.southWest.latitude;
    }
    /**
     * Returns the north altitude in degrees of this `GeoBox`.
     */
    get north() {
        return this.northEast.latitude;
    }
    /**
     * Returns the west longitude in degrees of this `GeoBox`.
     */
    get west() {
        return this.southWest.longitude;
    }
    /**
     * Returns the east longitude in degrees of this `GeoBox`.
     */
    get east() {
        return this.northEast.longitude;
    }
    /**
     * Returns the center of this `GeoBox`.
     */
    get center() {
        const latitude = (this.south + this.north) * 0.5;
        const { west, east } = this;
        const { minAltitude, altitudeSpan } = this;
        let altitude;
        if (minAltitude !== undefined && altitudeSpan !== undefined) {
            altitude = minAltitude + altitudeSpan * 0.5;
        }
        if (west < east) {
            return new GeoCoordinates_1.GeoCoordinates(latitude, (west + east) * 0.5, altitude);
        }
        let longitude = (360 + east + west) * 0.5;
        if (longitude > 360) {
            longitude -= 360;
        }
        return new GeoCoordinates_1.GeoCoordinates(latitude, longitude, altitude);
    }
    /**
     * Returns the latitude span in radians.
     */
    get latitudeSpanInRadians() {
        return THREE.Math.degToRad(this.latitudeSpan);
    }
    /**
     * Returns the longitude span in radians.
     */
    get longitudeSpanInRadians() {
        return THREE.Math.degToRad(this.longitudeSpan);
    }
    /**
     * Returns the latitude span in degrees.
     */
    get latitudeSpan() {
        return this.north - this.south;
    }
    get altitudeSpan() {
        if (this.maxAltitude === undefined || this.minAltitude === undefined) {
            return undefined;
        }
        return this.maxAltitude - this.minAltitude;
    }
    /**
     * Returns the longitude span in degrees.
     */
    get longitudeSpan() {
        let width = this.northEast.longitude - this.southWest.longitude;
        if (width < 0) {
            width += 360;
        }
        return width;
    }
    /**
     * Returns the latitude span in degrees.
     * @deprecated Use [[latitudeSpan]] instead.
     */
    get latitudeSpanInDegrees() {
        return this.latitudeSpan;
    }
    /**
     * Returns the longitude span in degrees.
     * @deprecated Use [[longitudeSpan]] instead.
     */
    get longitudeSpanInDegrees() {
        return this.longitudeSpan;
    }
    /**
     * Returns `true` if the given geo coordinates are contained in this `GeoBox`.
     *
     * @param point The geo coordinates.
     */
    contains(point) {
        if (point.altitude === undefined ||
            this.minAltitude === undefined ||
            this.maxAltitude === undefined) {
            return this.containsHelper(point);
        }
        const isFlat = this.minAltitude === this.maxAltitude;
        const isSameAltitude = this.minAltitude === point.altitude;
        const isWithinAltitudeRange = this.minAltitude <= point.altitude && this.maxAltitude > point.altitude;
        // If box is flat, we should check the altitude and containment,
        // otherwise we should check also altitude difference where we consider
        // point to be inside if alt is from [m_minAltitude, m_maxAltitude) range!
        if (isFlat ? isSameAltitude : isWithinAltitudeRange) {
            return this.containsHelper(point);
        }
        return false;
    }
    /**
     * Clones this `GeoBox` instance.
     */
    clone() {
        return new GeoBox(this.southWest, this.northEast);
    }
    /**
     * Update the bounding box by considering a given point.
     *
     * @param point The point that may expand the bounding box.
     */
    growToContain(point) {
        this.southWest.latitude = Math.min(this.southWest.latitude, point.latitude);
        this.southWest.longitude = Math.min(this.southWest.longitude, point.longitude);
        this.southWest.altitude =
            this.southWest.altitude !== undefined && point.altitude !== undefined
                ? Math.min(this.southWest.altitude, point.altitude)
                : this.southWest.altitude !== undefined
                    ? this.southWest.altitude
                    : point.altitude !== undefined
                        ? point.altitude
                        : undefined;
        this.northEast.latitude = Math.max(this.northEast.latitude, point.latitude);
        this.northEast.longitude = Math.max(this.northEast.longitude, point.longitude);
        this.northEast.altitude =
            this.northEast.altitude !== undefined && point.altitude !== undefined
                ? Math.max(this.northEast.altitude, point.altitude)
                : this.northEast.altitude !== undefined
                    ? this.northEast.altitude
                    : point.altitude !== undefined
                        ? point.altitude
                        : undefined;
    }
    containsHelper(point) {
        if (point.latitude < this.southWest.latitude || point.latitude >= this.northEast.latitude) {
            return false;
        }
        const { west, east } = this;
        if (east > west) {
            return point.longitude >= west && point.longitude < east;
        }
        return point.longitude > east || point.longitude <= west;
    }
}
exports.GeoBox = GeoBox;


/***/ }),

/***/ "../harp-geoutils/lib/coordinates/GeoCoordinates.ts":
/*!**********************************************************!*\
  !*** ../harp-geoutils/lib/coordinates/GeoCoordinates.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const GeoCoordinatesLike_1 = __webpack_require__(/*! ./GeoCoordinatesLike */ "../harp-geoutils/lib/coordinates/GeoCoordinatesLike.ts");
const GeoPointLike_1 = __webpack_require__(/*! ./GeoPointLike */ "../harp-geoutils/lib/coordinates/GeoPointLike.ts");
const LatLngLike_1 = __webpack_require__(/*! ./LatLngLike */ "../harp-geoutils/lib/coordinates/LatLngLike.ts");
const THREE = __webpack_require__(/*! three */ "three");
/**
 * `GeoCoordinates` is used to represent geo positions.
 */
class GeoCoordinates {
    /**
     * Creates a `GeoCoordinates` from the given latitude, longitude, and optional altitude.
     *
     * @param latitude Latitude in degrees.
     * @param longitude Longitude in degrees.
     * @param altitude Altitude in meters.
     */
    constructor(latitude, longitude, altitude) {
        this.latitude = latitude;
        this.longitude = longitude;
        this.altitude = altitude;
    }
    /**
     * Returns a `GeoCoordinates` from the given latitude, longitude, and optional altitude.
     *
     * @param latitude Latitude in degrees.
     * @param longitude Longitude in degrees.
     * @param altitude Altitude in meters.
     */
    static fromDegrees(latitude, longitude, altitude) {
        return new GeoCoordinates(latitude, longitude, altitude);
    }
    /**
     * Returns a `GeoCoordinates` from the given latitude, longitude, and optional altitude.
     *
     * @param latitude Latitude in radians.
     * @param longitude Longitude in radians.
     * @param altitude Altitude in meters.
     */
    static fromRadians(latitude, longitude, altitude) {
        return new GeoCoordinates(THREE.Math.radToDeg(latitude), THREE.Math.radToDeg(longitude), altitude);
    }
    /**
     * Creates a [[GeoCoordinates]] from a [[LatLngLike]] literal.
     * ```typescript
     * const center = { lat: 53.3, lng: 13.4 };
     * mapView.geoCenter = GeoCoordinates.fromLatLng(center);
     * ```
     * @param latLng A [[LatLngLike]] object literal.
     */
    static fromLatLng(latLng) {
        return new GeoCoordinates(latLng.lat, latLng.lng);
    }
    /**
     * Creates a [[GeoCoordinates]] from a [[GeoPointLike]] tuple.
     *
     * Example:
     * ```typescript
     * mapView.geoCenter = GeoCoordinates.fromGeoPoint([longitude, latitude]);
     *
     * let geoCoords: number[] = ...;
     *
     * if (isGeoPointLike(geoCoords)) {
     *     const p = GeoCoordinates.fromGeoPoint(geoCoords);
     * }
     * ```
     * @param geoPoint An [[Array]] of at least two elements following the order
     * longitude, latitude, altitude.
     */
    static fromGeoPoint(geoPoint) {
        return new GeoCoordinates(geoPoint[1], geoPoint[0], geoPoint[2]);
    }
    /**
     * Creates a [[GeoCoordinates]] from different types of geo coordinate objects.
     *
     * Example:
     * ```typescript
     * const fromGeoPointLike = GeoCoordinates.fromObject([longitude, latitude]);
     * const fromGeoCoordinateLike = GeoCoordinates.fromObject({ longitude, latitude });
     * const fromGeoCoordinate = GeoCoordinates.fromObject(new GeoCoordinates(latitude, longitude));
     * const fromLatLngLike = GeoCoordinates.fromObject({ lat: latitude , lng: longitude });
     * ```
     *
     * @param geoPoint Either [[GeoPointLike]], [[GeoCoordinatesLike]]
     * or [[LatLngLike]] object literal.
     */
    static fromObject(geoPoint) {
        if (GeoPointLike_1.isGeoPointLike(geoPoint)) {
            return GeoCoordinates.fromGeoPoint(geoPoint);
        }
        else if (GeoCoordinatesLike_1.isGeoCoordinatesLike(geoPoint)) {
            return GeoCoordinates.fromDegrees(geoPoint.latitude, geoPoint.longitude, geoPoint.altitude);
        }
        else if (LatLngLike_1.isLatLngLike(geoPoint)) {
            return GeoCoordinates.fromDegrees(geoPoint.lat, geoPoint.lng);
        }
        throw new Error("Invalid input coordinate format.");
    }
    /**
     * Returns the latitude in radians.
     */
    get latitudeInRadians() {
        return THREE.Math.degToRad(this.latitude);
    }
    /**
     * Returns the longitude in radians.
     */
    get longitudeInRadians() {
        return THREE.Math.degToRad(this.longitude);
    }
    /**
     * Returns the latitude in degrees.
     * @deprecated Use the [[latitude]] property instead.
     */
    get latitudeInDegrees() {
        return this.latitude;
    } // compat api
    /**
     * Returns the longitude in degrees.
     * @deprecated Use the [[longitude]] property instead.
     */
    get longitudeInDegrees() {
        return this.longitude;
    } // compat api
    /**
     * The latitude in the degrees.
     */
    get lat() {
        return this.latitude;
    }
    /**
     * The longitude in the degrees.
     */
    get lng() {
        return this.longitude;
    }
    /**
     * Returns `true` if this `GeoCoordinates` is valid; returns `false` otherwise.
     */
    isValid() {
        return !isNaN(this.latitude) && !isNaN(this.longitude);
    }
    /**
     * Returns the normalized `GeoCoordinates`.
     */
    normalized() {
        let { latitude, longitude } = this;
        if (isNaN(latitude) || isNaN(longitude)) {
            return this;
        }
        if (latitude > 90) {
            let wrapped = (latitude + 90) % 360;
            if (wrapped >= 180) {
                longitude += 180;
                wrapped = 360 - wrapped;
            }
            latitude = wrapped - 90;
        }
        if (latitude < -90) {
            let wrapped = (latitude - 90) % 360;
            if (wrapped <= -180) {
                longitude += 180;
                wrapped = -360 - wrapped;
            }
            latitude = wrapped + 90;
        }
        if (longitude < -180 || longitude > 180) {
            const sign = Math.sign(longitude);
            longitude = (((longitude % 360) + 180 * sign) % 360) - 180 * sign;
        }
        if (latitude === this.latitude && longitude === this.longitude) {
            return this;
        }
        return new GeoCoordinates(latitude, longitude, this.altitude);
    }
    /**
     * Returns `true` if this `GeoCoordinates` is equal to the other.
     *
     * @param other GeoCoordinatesLike to compare to.
     */
    equals(other) {
        return (this.latitude === other.latitude &&
            this.longitude === other.longitude &&
            this.altitude === other.altitude);
    }
    /**
     * Copy values from the other.
     *
     * @param other GeoCoordinatesLike to copy all values from.
     */
    copy(other) {
        this.latitude = other.latitude;
        this.longitude = other.longitude;
        this.altitude = other.altitude;
        return this;
    }
    /**
     * Clones this `GeoCoordinates`.
     * @deprecated
     */
    clone() {
        return new GeoCoordinates(this.latitude, this.longitude, this.altitude);
    }
    /**
     * Returns this [[GeoCoordinates]] as [[LatLngLike]] literal.
     */
    toLatLng() {
        return { lat: this.latitude, lng: this.longitude };
    }
    /**
     * Converts this [[GeoCoordinates]] to a [[GeoPointLike]].
     */
    toGeoPoint() {
        return this.altitude !== undefined
            ? [this.longitude, this.latitude, this.altitude]
            : [this.longitude, this.latitude];
    }
}
exports.GeoCoordinates = GeoCoordinates;


/***/ }),

/***/ "../harp-geoutils/lib/coordinates/GeoCoordinatesLike.ts":
/*!**************************************************************!*\
  !*** ../harp-geoutils/lib/coordinates/GeoCoordinatesLike.ts ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Type guard to assert that `object` conforms to [[GeoCoordinatesLike]] data interface.
 */
function isGeoCoordinatesLike(object) {
    return (object &&
        typeof object.latitude === "number" &&
        typeof object.longitude === "number" &&
        (typeof object.altitude === "number" || typeof object.altitude === "undefined"));
}
exports.isGeoCoordinatesLike = isGeoCoordinatesLike;


/***/ }),

/***/ "../harp-geoutils/lib/coordinates/GeoPointLike.ts":
/*!********************************************************!*\
  !*** ../harp-geoutils/lib/coordinates/GeoPointLike.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Type guard to assert that `object` conforms to [[GeoPointLike]] interface.
 */
function isGeoPointLike(geoPoint) {
    if (Array.isArray(geoPoint)) {
        const [longitude, latitude, altitude] = geoPoint;
        return (typeof longitude === "number" &&
            typeof latitude === "number" &&
            (altitude === undefined || typeof altitude === "number"));
    }
    return false;
}
exports.isGeoPointLike = isGeoPointLike;


/***/ }),

/***/ "../harp-geoutils/lib/coordinates/LatLngLike.ts":
/*!******************************************************!*\
  !*** ../harp-geoutils/lib/coordinates/LatLngLike.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Type guard to assert that `object` conforms to [[LatLngLike]] interface.
 */
function isLatLngLike(object) {
    return object && typeof object.lat === "number" && typeof object.lng === "number";
}
exports.isLatLngLike = isLatLngLike;


/***/ }),

/***/ "../harp-geoutils/lib/math/Box3Like.ts":
/*!*********************************************!*\
  !*** ../harp-geoutils/lib/math/Box3Like.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns true if the given object implements the [[Box3Like]] interface.
 *
 * @param object A valid object.
 */
function isBox3Like(object) {
    const box3 = object;
    return box3.min !== undefined && box3.max !== undefined;
}
exports.isBox3Like = isBox3Like;


/***/ }),

/***/ "../harp-geoutils/lib/math/MathUtils.ts":
/*!**********************************************!*\
  !*** ../harp-geoutils/lib/math/MathUtils.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
var MathUtils;
(function (MathUtils) {
    /**
     * Creates a new empty bounding box.
     * @deprecated
     */
    function newEmptyBox3() {
        return {
            min: { x: Infinity, y: Infinity, z: Infinity },
            max: { x: -Infinity, y: -Infinity, z: -Infinity }
        };
    }
    MathUtils.newEmptyBox3 = newEmptyBox3;
    /**
     * Set the components of the given [Vector3Like] instance.
     *
     * @param x The x component.
     * @param y The y component.
     * @param z The z component.
     * @param v The [Vector3Like]
     */
    function newVector3(x, y, z, v) {
        if (v === undefined) {
            return { x, y, z };
        }
        v.x = x;
        v.y = y;
        v.z = z;
        return v;
    }
    MathUtils.newVector3 = newVector3;
    /**
     * Converts an angle measured in degrees to an equivalent value in radians.
     *
     * @param degrees Value in degrees.
     * @returns Value in radians.
     * @deprecated
     */
    MathUtils.degToRad = THREE.Math.degToRad;
    /**
     * Converts an angle measured in radians to an equivalent value in degrees.
     *
     * @param degrees Value in radians.
     * @returns Value in degrees.
     * @deprecated
     */
    MathUtils.radToDeg = THREE.Math.radToDeg;
    /**
     * Ensures that input value fits in a given range.
     *
     * @param value The value to be clamped.
     * @param min Minimum value.
     * @param max Maximum value.
     * @returns Clamped value.
     * @deprecated
     */
    MathUtils.clamp = THREE.Math.clamp;
    /**
     * Normalize angle in degrees to range `[0, 360)`.
     *
     * @param a Angle in degrees.
     * @returns Angle in degrees in range `[0, 360)`.
     */
    function normalizeAngleDeg(a) {
        a = a % 360;
        if (a < 0) {
            a = a + 360;
        }
        return a;
    }
    MathUtils.normalizeAngleDeg = normalizeAngleDeg;
    /**
     * Return the minimal delta between angles `a` and `b` given in degrees.
     *
     * Equivalent to `a - b` in coordinate space with exception vector direction can be reversed
     * that if `abs(a-b) > 180` because trip is shorter in 'other' direction.
     *
     * Useful when interpolating between `b` and `a` in angle space.
     *
     * @param a Start angle in degrees.
     * @param b End angle in degrees.
     * @returns Angle that that satisfies condition `a - b - d = 0` in angle space.
     */
    function angleDistanceDeg(a, b) {
        a = normalizeAngleDeg(a);
        b = normalizeAngleDeg(b);
        const d = a - b;
        if (d > 180) {
            return d - 360;
        }
        else if (d <= -180) {
            return d + 360;
        }
        else {
            return d;
        }
    }
    MathUtils.angleDistanceDeg = angleDistanceDeg;
    /**
     * Interpolate linearly between two angles given in degrees.
     *
     * @param p0 Angle from in degrees
     * @param p1 Angle to in degrees
     * @param t Interpolation factor (alpha), in range `0-1`.
     */
    function interpolateAnglesDeg(p0, p1, t) {
        // hand crafted version,
        // see stack for maybe better versions:
        //    https://stackoverflow.com/questions/2708476/rotation-interpolation
        const d = angleDistanceDeg(p1, p0);
        const r = (p0 + d * t) % 360;
        return r;
    }
    MathUtils.interpolateAnglesDeg = interpolateAnglesDeg;
})(MathUtils = exports.MathUtils || (exports.MathUtils = {}));


/***/ }),

/***/ "../harp-geoutils/lib/math/OrientedBox3.ts":
/*!*************************************************!*\
  !*** ../harp-geoutils/lib/math/OrientedBox3.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const three_1 = __webpack_require__(/*! three */ "three");
class OrientedBox3 {
    /**
     * Creates a new `OrientedBox3`.
     *
     * @hideconstructor
     */
    constructor(position, rotationMatrix, extents) {
        /**
         * The position of the center of this `OrientedBox3`.
         */
        this.position = new three_1.Vector3();
        /**
         * The x-axis of this `OrientedBox3`.
         */
        this.xAxis = new three_1.Vector3(1, 0, 0);
        /**
         * The y-axis of this `OrientedBox3`.
         */
        this.yAxis = new three_1.Vector3(0, 1, 0);
        /**
         * The z-axis of this `OrientedBox3`.
         */
        this.zAxis = new three_1.Vector3(0, 0, 1);
        /**
         * The extents of this `OrientedBox3`.
         */
        this.extents = new three_1.Vector3();
        if (position !== undefined) {
            this.position.copy(position);
        }
        if (rotationMatrix !== undefined) {
            rotationMatrix.extractBasis(this.xAxis, this.yAxis, this.zAxis);
        }
        if (extents !== undefined) {
            this.extents.copy(extents);
        }
    }
    /**
     * Create a copy of this [[OrientedBoundingBox]].
     */
    clone() {
        const newBox = new OrientedBox3();
        newBox.copy(this);
        return newBox;
    }
    /**
     * Copies the values of `other` to this [[OrientedBox3]].
     * @param other The other [[OrientedBox3]] to copy.
     */
    copy(other) {
        this.position.copy(other.position);
        this.xAxis.copy(other.xAxis);
        this.yAxis.copy(other.yAxis);
        this.zAxis.copy(other.zAxis);
        this.extents.copy(other.extents);
    }
    /**
     * Gets the center position of this [[OrientedBox3]].
     *
     * @param center The returned center position.
     */
    getCenter(center = new three_1.Vector3()) {
        return center.copy(this.position);
    }
    /**
     * Gets the size of this [[OrientedBox3]].
     *
     * @param size The returned size.
     */
    getSize(size = new three_1.Vector3()) {
        return size.copy(this.extents).multiplyScalar(2);
    }
    /**
     * Gets the orientation matrix of this `OrientedBox3`.
     * @param matrix The output orientation matrix.
     */
    getRotationMatrix(matrix = new three_1.Matrix4()) {
        return matrix.makeBasis(this.xAxis, this.yAxis, this.zAxis);
    }
    /**
     * Checks intersection with the given `THREE.Frustum` or array of `THREE.Plane`s.
     *
     * @param frustumOrPlanes Frustum or array of planes.
     */
    intersects(frustumOrPlanes) {
        const planes = Array.isArray(frustumOrPlanes)
            ? frustumOrPlanes
            : frustumOrPlanes.planes;
        for (const plane of planes) {
            const r = Math.abs(plane.normal.dot(this.xAxis) * this.extents.x) +
                Math.abs(plane.normal.dot(this.yAxis) * this.extents.y) +
                Math.abs(plane.normal.dot(this.zAxis) * this.extents.z);
            const d = plane.distanceToPoint(this.position);
            if (d + r < 0) {
                return false;
            }
        }
        return true;
    }
    /**
     * Returns true if this [[OrientedBox3]] contains the given point.
     *
     * @param point A valid point.
     */
    contains(point) {
        const dx = point.x - this.position.x;
        const dy = point.y - this.position.y;
        const dz = point.z - this.position.z;
        const x = Math.abs(dx * this.xAxis.x + dy * this.xAxis.y + dz * this.xAxis.z);
        const y = Math.abs(dx * this.yAxis.x + dy * this.yAxis.y + dz * this.yAxis.z);
        const z = Math.abs(dx * this.zAxis.x + dy * this.zAxis.y + dz * this.zAxis.z);
        if (x > this.extents.x || y > this.extents.y || z > this.extents.z) {
            return false;
        }
        return true;
    }
    /**
     * Returns the distance from this [[OrientedBox3]] and the given `point`.
     *
     * @param point A point.
     */
    distanceToPoint(point) {
        return Math.sqrt(this.distanceToPointSquared(point));
    }
    /**
     * Returns the squared distance from this [[OrientedBox3]] and the given `point`.
     *
     * @param point A point.
     */
    distanceToPointSquared(point) {
        const d = new three_1.Vector3();
        d.subVectors(point, this.position);
        const lengths = [d.dot(this.xAxis), d.dot(this.yAxis), d.dot(this.zAxis)];
        let result = 0;
        for (let i = 0; i < 3; ++i) {
            const length = lengths[i];
            const extent = this.extents.getComponent(i);
            if (length < -extent) {
                const dd = extent + length;
                result += dd * dd;
            }
            else if (length > extent) {
                const dd = length - extent;
                result += dd * dd;
            }
        }
        return result;
    }
}
exports.OrientedBox3 = OrientedBox3;


/***/ }),

/***/ "../harp-geoutils/lib/math/OrientedBox3Like.ts":
/*!*****************************************************!*\
  !*** ../harp-geoutils/lib/math/OrientedBox3Like.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns true if the given object implements the interface [[OrientedBox3Like]].
 *
 * @param object The object.
 */
function isOrientedBox3Like(object) {
    const obb = object;
    return (obb.position !== undefined &&
        obb.xAxis !== undefined &&
        obb.yAxis !== undefined &&
        obb.zAxis !== undefined &&
        obb.extents !== undefined);
}
exports.isOrientedBox3Like = isOrientedBox3Like;


/***/ }),

/***/ "../harp-geoutils/lib/math/TransformLike.ts":
/*!**************************************************!*\
  !*** ../harp-geoutils/lib/math/TransformLike.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns true if the given object implements the interface [[TransformLike]].
 *
 * @param object The object.
 */
function isTransformLike(object) {
    const transform = object;
    return (transform.position !== undefined &&
        transform.xAxis !== undefined &&
        transform.yAxis !== undefined &&
        transform.zAxis !== undefined);
}
exports.isTransformLike = isTransformLike;


/***/ }),

/***/ "../harp-geoutils/lib/math/Vector3Like.ts":
/*!************************************************!*\
  !*** ../harp-geoutils/lib/math/Vector3Like.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
function isVector3Like(v) {
    return v && typeof v.x === "number" && typeof v.y === "number" && typeof v.z === "number";
}
exports.isVector3Like = isVector3Like;


/***/ }),

/***/ "../harp-geoutils/lib/projection/EarthConstants.ts":
/*!*********************************************************!*\
  !*** ../harp-geoutils/lib/projection/EarthConstants.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
class EarthConstants {
}
exports.EarthConstants = EarthConstants;
/** The equatorial circumference in meters. */
EarthConstants.EQUATORIAL_CIRCUMFERENCE = 40075016.6855784861531768177614;
/** The equatorial radius in meters. */
EarthConstants.EQUATORIAL_RADIUS = 6378137.0;
/** The lowest point on earth (Dead Sea) in meters. */
EarthConstants.MIN_ELEVATION = -433.0;
/** The highest point on earth (Mt. Everest) in meters. */
EarthConstants.MAX_ELEVATION = 8848.0;
/** The highest artificial structure (building) on earth, Burj Khalifa tower in Dubai */
EarthConstants.MAX_BUILDING_HEIGHT = 828;


/***/ }),

/***/ "../harp-geoutils/lib/projection/EquirectangularProjection.ts":
/*!********************************************************************!*\
  !*** ../harp-geoutils/lib/projection/EquirectangularProjection.ts ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const GeoBox_1 = __webpack_require__(/*! ../coordinates/GeoBox */ "../harp-geoutils/lib/coordinates/GeoBox.ts");
const GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ "../harp-geoutils/lib/coordinates/GeoCoordinates.ts");
const Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ "../harp-geoutils/lib/math/Box3Like.ts");
const MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ "../harp-geoutils/lib/math/MathUtils.ts");
const OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ "../harp-geoutils/lib/math/OrientedBox3Like.ts");
const EarthConstants_1 = __webpack_require__(/*! ./EarthConstants */ "../harp-geoutils/lib/projection/EarthConstants.ts");
const Projection_1 = __webpack_require__(/*! ./Projection */ "../harp-geoutils/lib/projection/Projection.ts");
const THREE = __webpack_require__(/*! three */ "three");
class EquirectangularProjection extends Projection_1.Projection {
    constructor() {
        super(...arguments);
        /** @override */
        this.type = Projection_1.ProjectionType.Planar;
    }
    /** @override */
    getScaleFactor(_worldPoint) {
        return 1;
    }
    /** @override */
    worldExtent(minAltitude, maxAltitude, result) {
        if (!result) {
            result = MathUtils_1.MathUtils.newEmptyBox3();
        }
        result.min.x = 0.0;
        result.min.y = 0.0;
        result.min.z = minAltitude;
        result.max.x = this.unitScale;
        result.max.y = this.unitScale / 2;
        result.max.z = maxAltitude;
        return result;
    }
    /** @override */
    projectPoint(geoPoint, result) {
        if (result === undefined) {
            /*
             * The following tslint:disable is due to the fact that the [[WorldCoordinates]]
             * might be a concrete class which is not available at runtime.
             * Consider the following example:
             *
             *  const x: THREE.Vector3 = new THREE.Vector3(0,0,0);
             *  const result = EquirectangularProjection.projectPoint<THREE.Vector3>(x);
             *
             * Note: type of `result` is Vector3Like and not as expected: THREE.Vector3!
             */
            // tslint:disable-next-line:no-object-literal-type-assertion
            result = { x: 0, y: 0, z: 0 };
        }
        result.x =
            (THREE.Math.degToRad(geoPoint.longitude) + Math.PI) *
                EquirectangularProjection.geoToWorldScale *
                this.unitScale;
        result.y =
            (THREE.Math.degToRad(geoPoint.latitude) + Math.PI * 0.5) *
                EquirectangularProjection.geoToWorldScale *
                this.unitScale;
        result.z = geoPoint.altitude || 0;
        return result;
    }
    /** @override */
    unprojectPoint(worldPoint) {
        const geoPoint = GeoCoordinates_1.GeoCoordinates.fromRadians((worldPoint.y * EquirectangularProjection.worldToGeoScale) / this.unitScale -
            Math.PI * 0.5, (worldPoint.x * EquirectangularProjection.worldToGeoScale) / this.unitScale - Math.PI, worldPoint.z);
        return geoPoint;
    }
    /** @override */
    unprojectAltitude(worldPoint) {
        return worldPoint.z;
    }
    /** @override */
    projectBox(geoBox, result) {
        const worldCenter = this.projectPoint(new GeoCoordinates_1.GeoCoordinates(geoBox.center.latitude, geoBox.center.longitude, 0));
        const { latitudeSpanInRadians, longitudeSpanInRadians, altitudeSpan } = geoBox;
        const sizeX = longitudeSpanInRadians * EquirectangularProjection.geoToWorldScale;
        const sizeY = latitudeSpanInRadians * EquirectangularProjection.geoToWorldScale;
        if (!result) {
            result = MathUtils_1.MathUtils.newEmptyBox3();
        }
        if (Box3Like_1.isBox3Like(result)) {
            result.min.x = worldCenter.x - sizeX * 0.5 * this.unitScale;
            result.min.y = worldCenter.y - sizeY * 0.5 * this.unitScale;
            result.max.x = worldCenter.x + sizeX * 0.5 * this.unitScale;
            result.max.y = worldCenter.y + sizeY * 0.5 * this.unitScale;
            if (altitudeSpan !== undefined) {
                result.min.z = worldCenter.z - altitudeSpan * 0.5;
                result.max.z = worldCenter.z + altitudeSpan * 0.5;
            }
            else {
                result.min.z = 0;
                result.max.z = 0;
            }
        }
        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {
            MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
            MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);
            MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);
            result.position.x = worldCenter.x;
            result.position.y = worldCenter.y;
            result.position.z = worldCenter.z;
            result.extents.x = sizeX * 0.5 * this.unitScale;
            result.extents.y = sizeY * 0.5 * this.unitScale;
            result.extents.z = Math.max(Number.EPSILON, (altitudeSpan || 0) * 0.5);
        }
        return result;
    }
    /** @override */
    unprojectBox(worldBox) {
        const minGeo = this.unprojectPoint(worldBox.min);
        const maxGeo = this.unprojectPoint(worldBox.max);
        return GeoBox_1.GeoBox.fromCoordinates(minGeo, maxGeo);
    }
    /** @override */
    groundDistance(worldPoint) {
        return worldPoint.z;
    }
    /** @override */
    scalePointToSurface(worldPoint) {
        worldPoint.z = 0;
        return worldPoint;
    }
    /** @override */
    surfaceNormal(_worldPoint, normal) {
        if (normal === undefined) {
            normal = { x: 0, y: 0, z: 1 };
        }
        else {
            normal.x = 0;
            normal.y = 0;
            normal.z = 1;
        }
        return normal;
    }
}
EquirectangularProjection.geoToWorldScale = 1.0 / (2.0 * Math.PI);
EquirectangularProjection.worldToGeoScale = (2.0 * Math.PI) / 1.0;
/**
 * Equirectangular [[Projection]] used to convert geo coordinates to unit coordinates and vice
 * versa.
 */
exports.normalizedEquirectangularProjection = new EquirectangularProjection(1);
/**
 * Equirectangular [[Projection]] used to convert geo coordinates to world coordinates and vice
 * versa.
 */
exports.equirectangularProjection = new EquirectangularProjection(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE);


/***/ }),

/***/ "../harp-geoutils/lib/projection/IdentityProjection.ts":
/*!*************************************************************!*\
  !*** ../harp-geoutils/lib/projection/IdentityProjection.ts ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const GeoBox_1 = __webpack_require__(/*! ../coordinates/GeoBox */ "../harp-geoutils/lib/coordinates/GeoBox.ts");
const GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ "../harp-geoutils/lib/coordinates/GeoCoordinates.ts");
const Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ "../harp-geoutils/lib/math/Box3Like.ts");
const MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ "../harp-geoutils/lib/math/MathUtils.ts");
const OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ "../harp-geoutils/lib/math/OrientedBox3Like.ts");
const Projection_1 = __webpack_require__(/*! ./Projection */ "../harp-geoutils/lib/projection/Projection.ts");
const THREE = __webpack_require__(/*! three */ "three");
class IdentityProjection extends Projection_1.Projection {
    constructor() {
        super(...arguments);
        /** @override */
        this.type = Projection_1.ProjectionType.Planar;
    }
    /** @override */
    getScaleFactor(_worldPoint) {
        return 1;
    }
    /** @override */
    worldExtent(minAltitude, maxAltitude, result) {
        if (!result) {
            result = MathUtils_1.MathUtils.newEmptyBox3();
        }
        result.min.x = -Math.PI;
        result.min.y = -Math.PI * 0.5;
        result.min.z = minAltitude;
        result.max.x = Math.PI;
        result.max.y = Math.PI * 0.5;
        result.max.z = maxAltitude;
        return result;
    }
    /** @override */
    projectPoint(geoPoint, result) {
        if (!result) {
            // tslint:disable-next-line:no-object-literal-type-assertion
            result = { x: 0, y: 0, z: 0 };
        }
        result.x = THREE.Math.degToRad(geoPoint.longitude);
        result.y = THREE.Math.degToRad(geoPoint.latitude);
        result.z = geoPoint.altitude || 0;
        return result;
    }
    /** @override */
    unprojectPoint(worldPoint) {
        const geoPoint = GeoCoordinates_1.GeoCoordinates.fromRadians(worldPoint.y, worldPoint.x, worldPoint.z);
        return geoPoint;
    }
    /** @override */
    unprojectAltitude(worldPoint) {
        return worldPoint.z;
    }
    /** @override */
    projectBox(geoBox, result) {
        if (!result) {
            result = MathUtils_1.MathUtils.newEmptyBox3();
        }
        const min = this.projectPoint(new GeoCoordinates_1.GeoCoordinates(geoBox.south, geoBox.west, geoBox.minAltitude));
        const max = this.projectPoint(new GeoCoordinates_1.GeoCoordinates(geoBox.north, geoBox.east, geoBox.maxAltitude));
        if (Box3Like_1.isBox3Like(result)) {
            result.min.x = min.x;
            result.min.y = min.y;
            result.min.z = min.z;
            result.max.x = max.x;
            result.max.y = max.y;
            result.max.z = max.z;
        }
        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {
            MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
            MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);
            MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);
            result.position.x = (min.x + max.x) * 0.5;
            result.position.y = (min.y + max.y) * 0.5;
            result.position.z = (min.z + max.z) * 0.5;
            result.extents.x = (max.x - min.x) * 0.5;
            result.extents.y = (max.y - min.y) * 0.5;
            result.extents.z = Math.max(Number.EPSILON, (max.z - min.z) * 0.5);
        }
        return result;
    }
    /** @override */
    unprojectBox(worldBox) {
        const minGeo = this.unprojectPoint(worldBox.min);
        const maxGeo = this.unprojectPoint(worldBox.max);
        return GeoBox_1.GeoBox.fromCoordinates(minGeo, maxGeo);
    }
    /** @override */
    groundDistance(worldPoint) {
        return worldPoint.z;
    }
    /** @override */
    scalePointToSurface(worldPoint) {
        worldPoint.z = 0;
        return worldPoint;
    }
    /** @override */
    surfaceNormal(_worldPoint, normal) {
        if (normal === undefined) {
            normal = { x: 0, y: 0, z: 1 };
        }
        else {
            normal.x = 0;
            normal.y = 0;
            normal.z = 1;
        }
        return normal;
    }
}
/**
 * Identity [[Projection]] used to convert geo coordinates to unit coordinates and vice versa.
 */
exports.identityProjection = new IdentityProjection(1);


/***/ }),

/***/ "../harp-geoutils/lib/projection/MercatorProjection.ts":
/*!*************************************************************!*\
  !*** ../harp-geoutils/lib/projection/MercatorProjection.ts ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const GeoBox_1 = __webpack_require__(/*! ../coordinates/GeoBox */ "../harp-geoutils/lib/coordinates/GeoBox.ts");
const GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ "../harp-geoutils/lib/coordinates/GeoCoordinates.ts");
const Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ "../harp-geoutils/lib/math/Box3Like.ts");
const MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ "../harp-geoutils/lib/math/MathUtils.ts");
const OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ "../harp-geoutils/lib/math/OrientedBox3Like.ts");
const EarthConstants_1 = __webpack_require__(/*! ./EarthConstants */ "../harp-geoutils/lib/projection/EarthConstants.ts");
const Projection_1 = __webpack_require__(/*! ./Projection */ "../harp-geoutils/lib/projection/Projection.ts");
class MercatorProjection extends Projection_1.Projection {
    constructor() {
        super(...arguments);
        /** @override */
        this.type = Projection_1.ProjectionType.Planar;
    }
    static clamp(val, min, max) {
        return Math.min(Math.max(min, val), max);
    }
    static latitudeClamp(latitude) {
        return MercatorProjection.clamp(latitude, -MercatorConstants.MAXIMUM_LATITUDE, MercatorConstants.MAXIMUM_LATITUDE);
    }
    static latitudeProject(latitude) {
        return Math.log(Math.tan(Math.PI * 0.25 + latitude * 0.5)) / Math.PI;
    }
    static latitudeClampProject(latitude) {
        return MercatorProjection.latitudeProject(MercatorProjection.latitudeClamp(latitude));
    }
    static unprojectLatitude(y) {
        return 2.0 * Math.atan(Math.exp(Math.PI * y)) - Math.PI * 0.5;
    }
    /** @override */
    getScaleFactor(worldPoint) {
        return Math.cosh(2 * Math.PI * (worldPoint.y / this.unitScale - 0.5));
    }
    /** @override */
    worldExtent(minAltitude, maxAltitude, result) {
        if (!result) {
            result = MathUtils_1.MathUtils.newEmptyBox3();
        }
        result.min.x = 0;
        result.min.y = 0;
        result.min.z = minAltitude;
        result.max.x = this.unitScale;
        result.max.y = this.unitScale;
        result.max.z = maxAltitude;
        return result;
    }
    /** @override */
    projectPoint(geoPointLike, result) {
        let geoPoint;
        if (geoPointLike instanceof GeoCoordinates_1.GeoCoordinates) {
            geoPoint = geoPointLike;
        }
        else {
            geoPoint = new GeoCoordinates_1.GeoCoordinates(geoPointLike.latitude, geoPointLike.longitude, geoPointLike.altitude);
        }
        if (!result) {
            // tslint:disable-next-line:no-object-literal-type-assertion
            result = { x: 0, y: 0, z: 0 };
        }
        result.x = ((geoPoint.longitude + 180) / 360) * this.unitScale;
        result.y =
            (MercatorProjection.latitudeClampProject(geoPoint.latitudeInRadians) * 0.5 + 0.5) *
                this.unitScale;
        result.z = geoPoint.altitude || 0;
        return result;
    }
    /** @override */
    unprojectPoint(worldPoint) {
        const geoPoint = GeoCoordinates_1.GeoCoordinates.fromRadians(MercatorProjection.unprojectLatitude((worldPoint.y / this.unitScale - 0.5) * 2.0), (worldPoint.x / this.unitScale) * 2 * Math.PI - Math.PI, worldPoint.z);
        return geoPoint;
    }
    /** @override */
    unprojectAltitude(worldPoint) {
        return worldPoint.z;
    }
    /** @override */
    projectBox(geoBox, result) {
        const worldCenter = this.projectPoint(geoBox.center);
        const worldNorth = (MercatorProjection.latitudeClampProject(geoBox.northEast.latitudeInRadians) * 0.5 +
            0.5) *
            this.unitScale;
        const worldSouth = (MercatorProjection.latitudeClampProject(geoBox.southWest.latitudeInRadians) * 0.5 +
            0.5) *
            this.unitScale;
        const worldYCenter = (worldNorth + worldSouth) * 0.5;
        worldCenter.y = worldYCenter;
        const latitudeSpan = worldNorth - worldSouth;
        const longitudeSpan = (geoBox.longitudeSpan / 360) * this.unitScale;
        if (!result) {
            result = MathUtils_1.MathUtils.newEmptyBox3();
        }
        if (Box3Like_1.isBox3Like(result)) {
            result.min.x = worldCenter.x - longitudeSpan * 0.5;
            result.min.y = worldCenter.y - latitudeSpan * 0.5;
            result.max.x = worldCenter.x + longitudeSpan * 0.5;
            result.max.y = worldCenter.y + latitudeSpan * 0.5;
            const altitudeSpan = geoBox.altitudeSpan;
            if (altitudeSpan !== undefined) {
                result.min.z = worldCenter.z - altitudeSpan * 0.5;
                result.max.z = worldCenter.z + altitudeSpan * 0.5;
            }
            else {
                result.min.z = 0;
                result.max.z = 0;
            }
        }
        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {
            MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
            MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);
            MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);
            result.position.x = worldCenter.x;
            result.position.y = worldCenter.y;
            result.position.z = worldCenter.z;
            result.extents.x = longitudeSpan * 0.5;
            result.extents.y = latitudeSpan * 0.5;
            result.extents.z = Math.max(Number.EPSILON, (geoBox.altitudeSpan || 0) * 0.5);
        }
        else {
            throw new Error("invalid bounding box");
        }
        return result;
    }
    /** @override */
    unprojectBox(worldBox) {
        const minGeo = this.unprojectPoint(worldBox.min);
        const maxGeo = this.unprojectPoint(worldBox.max);
        const geoBox = GeoBox_1.GeoBox.fromCoordinates(minGeo, maxGeo);
        return geoBox;
    }
    /** @override */
    groundDistance(worldPoint) {
        return worldPoint.z;
    }
    /** @override */
    scalePointToSurface(worldPoint) {
        worldPoint.z = 0;
        return worldPoint;
    }
    /** @override */
    surfaceNormal(_worldPoint, normal) {
        if (normal === undefined) {
            normal = { x: 0, y: 0, z: 1 };
        }
        else {
            normal.x = 0;
            normal.y = 0;
            normal.z = 1;
        }
        return normal;
    }
    /** @override */
    reprojectPoint(sourceProjection, worldPos, result) {
        // this implementation of [[reprojectPoint]] supports both
        // [[WebMercatorProjection]] and [[MercatorProjection]]. The only
        // difference betweeen these two variants of WEB Mercator
        // is in the orientation of the Y axis, so we just flip Y coordinates
        // when reprojecting between them.
        if (sourceProjection !== this &&
            (sourceProjection === exports.webMercatorProjection || sourceProjection === exports.mercatorProjection)) {
            if (result === undefined) {
                // tslint:disable-next-line: no-object-literal-type-assertion
                result = {};
            }
            result.x = worldPos.x;
            result.y = this.unitScale - worldPos.y;
            result.z = worldPos.z;
            return result;
        }
        return super.reprojectPoint(sourceProjection, worldPos, result);
    }
}
class WebMercatorProjection extends MercatorProjection {
    /** @override */
    projectPoint(geoPointLike, result) {
        let geoPoint;
        if (geoPointLike instanceof GeoCoordinates_1.GeoCoordinates) {
            geoPoint = geoPointLike;
        }
        else {
            geoPoint = new GeoCoordinates_1.GeoCoordinates(geoPointLike.latitude, geoPointLike.longitude, geoPointLike.altitude);
        }
        /*
         * The following tslint:disable is due to the fact that the [[WorldCoordinates]]
         * might be a concrete class which is not available at runtime.
         * Consider the following example:
         *
         *  const x: THREE.Vector3 = new THREE.Vector3(0,0,0);
         *  const result = EquirectangularProjection.projectPoint<THREE.Vector3>(x);
         *
         * Note: type of `result` is Vector3Like and not as expected: THREE.Vector3!
         */
        if (!result) {
            // tslint:disable-next-line:no-object-literal-type-assertion
            result = { x: 0, y: 0, z: 0 };
        }
        result.x = ((geoPoint.longitude + 180) / 360) * this.unitScale;
        const sy = Math.sin(MercatorProjection.latitudeClamp(geoPoint.latitudeInRadians));
        result.y = (0.5 - Math.log((1 + sy) / (1 - sy)) / (4 * Math.PI)) * this.unitScale;
        result.z = geoPoint.altitude || 0;
        return result;
    }
    /** @override */
    unprojectPoint(worldPoint) {
        const x = worldPoint.x / this.unitScale - 0.5;
        const y = 0.5 - worldPoint.y / this.unitScale;
        const longitude = 360 * x;
        const latitude = 90 - (360 * Math.atan(Math.exp(-y * 2 * Math.PI))) / Math.PI;
        return new GeoCoordinates_1.GeoCoordinates(latitude, longitude, worldPoint.z);
    }
    /** @override */
    projectBox(geoBox, result) {
        const r = super.projectBox(geoBox, result);
        if (Box3Like_1.isBox3Like(r)) {
            // Invert the y axis for web mercator, this means that max => min & min => max
            const maxY = r.max.y;
            r.max.y = this.unitScale - r.min.y;
            r.min.y = this.unitScale - maxY;
        }
        else if (OrientedBox3Like_1.isOrientedBox3Like(r)) {
            MathUtils_1.MathUtils.newVector3(1, 0, 0, r.xAxis);
            MathUtils_1.MathUtils.newVector3(0, -1, 0, r.yAxis);
            MathUtils_1.MathUtils.newVector3(0, 0, -1, r.zAxis);
            r.position.y = this.unitScale - r.position.y;
        }
        return r;
    }
    /** @override */
    unprojectBox(worldBox) {
        const minGeo = this.unprojectPoint(worldBox.min);
        const maxGeo = this.unprojectPoint(worldBox.max);
        const geoBox = new GeoBox_1.GeoBox(new GeoCoordinates_1.GeoCoordinates(maxGeo.latitude, minGeo.longitude, minGeo.altitude), new GeoCoordinates_1.GeoCoordinates(minGeo.latitude, maxGeo.longitude, maxGeo.altitude));
        return geoBox;
    }
    /** @override */
    surfaceNormal(_worldPoint, normal) {
        if (normal === undefined) {
            normal = { x: 0, y: 0, z: -1 };
        }
        else {
            normal.x = 0;
            normal.y = 0;
            normal.z = -1;
        }
        return normal;
    }
    /** @override */
    localTangentSpace(geoPoint, result) {
        this.projectPoint(geoPoint, result.position);
        MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
        MathUtils_1.MathUtils.newVector3(0, -1, 0, result.yAxis);
        MathUtils_1.MathUtils.newVector3(0, 0, -1, result.zAxis);
        return result;
    }
}
class MercatorConstants {
}
exports.MercatorConstants = MercatorConstants;
// Math.atan(Math.sinh(Math.PI))
MercatorConstants.MAXIMUM_LATITUDE = 1.4844222297453323;
/**
 * Mercator [[Projection]] used to convert geo coordinates to world coordinates and vice versa.
 */
exports.mercatorProjection = new MercatorProjection(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE);
/**
 * Web Mercator [[Projection]] used to convert geo coordinates to world coordinates and vice versa.
 */
exports.webMercatorProjection = new WebMercatorProjection(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE);


/***/ }),

/***/ "../harp-geoutils/lib/projection/Projection.ts":
/*!*****************************************************!*\
  !*** ../harp-geoutils/lib/projection/Projection.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ "../harp-geoutils/lib/math/MathUtils.ts");
/**
 * The type of projection.
 */
var ProjectionType;
(function (ProjectionType) {
    /**
     * A type of [Projection] with zero curvature.
     */
    ProjectionType[ProjectionType["Planar"] = 0] = "Planar";
    /**
     * A spherical [Projection].
     */
    ProjectionType[ProjectionType["Spherical"] = 1] = "Spherical";
})(ProjectionType = exports.ProjectionType || (exports.ProjectionType = {}));
/**
 * `Projection` is used to convert positions from geo coordinates to world coordinates and vice
 * versa.
 */
class Projection {
    /**
     * Constructs the Projection
     *
     * @param unitScale How to transform the projected coordinates to world units.
     */
    constructor(unitScale) {
        this.unitScale = unitScale;
        //Prevent empty constructor error.
    }
    /**
     * Gets the [[TransformLike]] of the local tangent space at the given geo coordinates.
     *
     * @param geoPoint The geo coordinates.
     * @param result The [[TransformLike]].
     */
    localTangentSpace(geoPoint, result) {
        this.projectPoint(geoPoint, result.position);
        MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
        MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);
        MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);
        return result;
    }
    /**
     * Reproject a world position from the given source [[Projection]].
     * Implementations should be aware of worldPos and result may be one object
     *
     * @param sourceProjection The source projection.
     * @param worldPos A valid position in the world space defined by the source projection.
     * @param result The resulting position reprojected using this [[Projection]].
     * @hidden
     */
    reprojectPoint(sourceProjection, worldPos, result) {
        if (sourceProjection === this) {
            if (result === undefined) {
                return { x: worldPos.x, y: worldPos.y, z: worldPos.z };
            }
            result.x = worldPos.x;
            result.y = worldPos.y;
            result.z = worldPos.z;
            return result;
        }
        return this.projectPoint(sourceProjection.unprojectPoint(worldPos), result);
    }
}
exports.Projection = Projection;


/***/ }),

/***/ "../harp-geoutils/lib/projection/SphereProjection.ts":
/*!***********************************************************!*\
  !*** ../harp-geoutils/lib/projection/SphereProjection.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ "../harp-geoutils/lib/coordinates/GeoCoordinates.ts");
const Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ "../harp-geoutils/lib/math/Box3Like.ts");
const MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ "../harp-geoutils/lib/math/MathUtils.ts");
const OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ "../harp-geoutils/lib/math/OrientedBox3Like.ts");
const EarthConstants_1 = __webpack_require__(/*! ./EarthConstants */ "../harp-geoutils/lib/projection/EarthConstants.ts");
const MercatorProjection_1 = __webpack_require__(/*! ./MercatorProjection */ "../harp-geoutils/lib/projection/MercatorProjection.ts");
const Projection_1 = __webpack_require__(/*! ./Projection */ "../harp-geoutils/lib/projection/Projection.ts");
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Transforms the given vector using the provided basis.
 */
function apply(xAxis, yAxis, zAxis, v) {
    const x = xAxis.x * v.x + yAxis.x * v.y + zAxis.x * v.z;
    const y = xAxis.y * v.x + yAxis.y * v.y + zAxis.y * v.z;
    const z = xAxis.z * v.x + yAxis.z * v.y + zAxis.z * v.z;
    v.x = x;
    v.y = y;
    v.z = z;
    return v;
}
/**
 * Returns the quadrants for the given longitude. The quadrant is defined as:
 *  - quadrant(+Math.PI * -1.0) = 0
 *  - quadrant(+Math.PI * -0.5) = 1
 *  - quadrant(+Math.PI *  0.0) = 2
 *  - quadrant(+Math.PI *  0.5) = 3
 *  - quadrant(+Math.PI *  1.0) = 4
 *
 * @param longitude The longitude in radians.
 */
function getLongitudeQuadrant(longitude) {
    const oneOverPI = 1 / Math.PI;
    const quadrantIndex = Math.floor(2 * (longitude * oneOverPI + 1));
    return THREE.Math.clamp(quadrantIndex, 0, 4);
}
function lengthOfVector3(worldPoint) {
    const d = Math.sqrt(worldPoint.x * worldPoint.x + worldPoint.y * worldPoint.y + worldPoint.z * worldPoint.z);
    return d;
}
/**
 * Creates a Box3 enclosing the geobox.
 *
 * @param geoBox Ghe given geobox
 * @param worldBox The resulting axis aligned bounding box.
 */
function makeBox3(geoBox, worldBox, unitScale) {
    const halfEquatorialRadius = (unitScale + (geoBox.maxAltitude || 0)) * 0.5;
    const minLongitude = THREE.Math.degToRad(geoBox.west);
    const maxLongitude = THREE.Math.degToRad(geoBox.east);
    const minLongitudeQuadrant = getLongitudeQuadrant(minLongitude);
    const maxLongitudeQuadrant = getLongitudeQuadrant(maxLongitude);
    let xMin = Math.cos(minLongitude);
    let xMax = xMin;
    let yMin = Math.sin(minLongitude);
    let yMax = yMin;
    for (let quadrantIndex = minLongitudeQuadrant + 1; quadrantIndex <= maxLongitudeQuadrant; quadrantIndex++) {
        // tslint:disable-next-line: no-bitwise
        const x = ((quadrantIndex + 1) & 1) * ((quadrantIndex & 2) - 1);
        xMin = Math.min(x, xMin);
        xMax = Math.max(x, xMax);
        // tslint:disable-next-line: no-bitwise
        const y = (quadrantIndex & 1) * ((quadrantIndex & 2) - 1);
        yMin = Math.min(y, yMin);
        yMax = Math.max(y, yMax);
    }
    const cosMaxLongitude = Math.cos(maxLongitude);
    xMin = Math.min(cosMaxLongitude, xMin);
    xMax = Math.max(cosMaxLongitude, xMax);
    const sinMaxLongitude = Math.sin(maxLongitude);
    yMin = Math.min(sinMaxLongitude, yMin);
    yMax = Math.max(sinMaxLongitude, yMax);
    const xCenter = (xMax + xMin) * halfEquatorialRadius;
    const xExtent = (xMax - xMin) * halfEquatorialRadius;
    const yCenter = (yMax + yMin) * halfEquatorialRadius;
    const yExtent = (yMax - yMin) * halfEquatorialRadius;
    // Calculate Z boundaries.
    const minLatitude = THREE.Math.degToRad(geoBox.south);
    const maxLatutide = THREE.Math.degToRad(geoBox.north);
    const zMax = Math.sin(maxLatutide);
    const zMin = Math.sin(minLatitude);
    const zCenter = (zMax + zMin) * halfEquatorialRadius;
    const zExtent = (zMax - zMin) * halfEquatorialRadius;
    worldBox.min.x = xCenter - xExtent;
    worldBox.min.y = yCenter - yExtent;
    worldBox.min.z = zCenter - zExtent;
    worldBox.max.x = xCenter + xExtent;
    worldBox.max.y = yCenter + yExtent;
    worldBox.max.z = zCenter + zExtent;
    return worldBox;
}
/**
 * Computes the spherical projection of the given geo coordinates.
 *
 * @param geoPoint The geo coordinates.
 * @param worldpoint The resulting world coordinates.
 */
function project(geoPoint, worldpoint, unitScale) {
    const radius = unitScale + (geoPoint.altitude || 0);
    const latitude = THREE.Math.degToRad(geoPoint.latitude);
    const longitude = THREE.Math.degToRad(geoPoint.longitude);
    const cosLatitude = Math.cos(latitude);
    worldpoint.x = radius * cosLatitude * Math.cos(longitude);
    worldpoint.y = radius * cosLatitude * Math.sin(longitude);
    worldpoint.z = radius * Math.sin(latitude);
    return worldpoint;
}
class SphereProjection extends Projection_1.Projection {
    constructor() {
        super(...arguments);
        /** @override */
        this.type = Projection_1.ProjectionType.Spherical;
    }
    /** @override */
    worldExtent(_minElevation, maxElevation, result = MathUtils_1.MathUtils.newEmptyBox3()) {
        const radius = this.unitScale + maxElevation;
        result.min.x = -radius;
        result.min.y = -radius;
        result.min.z = -radius;
        result.max.x = radius;
        result.max.y = radius;
        result.max.z = radius;
        return result;
    }
    /** @override */
    projectPoint(geoPoint, result = MathUtils_1.MathUtils.newVector3(0, 0, 0)) {
        return project(geoPoint, result, this.unitScale);
    }
    /** @override */
    unprojectPoint(point) {
        const parallelRadiusSq = point.x * point.x + point.y * point.y;
        const parallelRadius = Math.sqrt(parallelRadiusSq);
        const v = point.z / parallelRadius;
        if (isNaN(v)) {
            return GeoCoordinates_1.GeoCoordinates.fromRadians(0, 0, -this.unitScale);
        }
        const radius = Math.sqrt(parallelRadiusSq + point.z * point.z);
        return GeoCoordinates_1.GeoCoordinates.fromRadians(Math.atan(v), Math.atan2(point.y, point.x), radius - this.unitScale);
    }
    /** @override */
    unprojectAltitude(point) {
        const parallelRadiusSq = point.x * point.x + point.y * point.y + point.z * point.z;
        return Math.sqrt(parallelRadiusSq) - EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS;
    }
    /** @override */
    projectBox(geoBox, result = MathUtils_1.MathUtils.newEmptyBox3()) {
        if (Box3Like_1.isBox3Like(result)) {
            return makeBox3(geoBox, result, this.unitScale);
        }
        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {
            if (geoBox.longitudeSpan >= 90) {
                const bounds = makeBox3(geoBox, MathUtils_1.MathUtils.newEmptyBox3(), this.unitScale);
                MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
                MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);
                MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);
                result.position.x = (bounds.max.x + bounds.min.x) * 0.5;
                result.position.y = (bounds.max.y + bounds.min.y) * 0.5;
                result.position.z = (bounds.max.z + bounds.min.z) * 0.5;
                result.extents.x = (bounds.max.x - bounds.min.x) * 0.5;
                result.extents.y = (bounds.max.y - bounds.min.y) * 0.5;
                result.extents.z = (bounds.max.z - bounds.min.z) * 0.5;
                return result;
            }
            const { south, west, north, east, center: mid } = geoBox;
            const midX = mid.longitude;
            const midY = mid.latitude;
            const cosSouth = Math.cos(THREE.Math.degToRad(south));
            const sinSouth = Math.sin(THREE.Math.degToRad(south));
            const cosWest = Math.cos(THREE.Math.degToRad(west));
            const sinWest = Math.sin(THREE.Math.degToRad(west));
            const cosNorth = Math.cos(THREE.Math.degToRad(north));
            const sinNorth = Math.sin(THREE.Math.degToRad(north));
            const cosEast = Math.cos(THREE.Math.degToRad(east));
            const sinEast = Math.sin(THREE.Math.degToRad(east));
            const cosMidX = Math.cos(THREE.Math.degToRad(midX));
            const sinMidX = Math.sin(THREE.Math.degToRad(midX));
            const cosMidY = Math.cos(THREE.Math.degToRad(midY));
            const sinMidY = Math.sin(THREE.Math.degToRad(midY));
            // Build the orientation of the OBB using the normal vector and its partial derivates.
            // the sperical coordinates of the mid point of the geobox.
            MathUtils_1.MathUtils.newVector3(cosMidX * cosMidY, sinMidX * cosMidY, sinMidY, result.zAxis);
            // the partial derivates of the normal vector.
            MathUtils_1.MathUtils.newVector3(-sinMidX, cosMidX, 0, result.xAxis);
            MathUtils_1.MathUtils.newVector3(-cosMidX * sinMidY, -sinMidX * sinMidY, cosMidY, result.yAxis);
            let width;
            let minY;
            let maxY;
            if (south >= 0) {
                // abs(dot(southWest - southEast, xAxis))
                width = Math.abs(cosSouth * (cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest)));
                // dot(south, yAxis)
                minY = cosMidY * sinSouth - sinMidY * cosSouth;
                // dot(northEast, zAxis)
                maxY =
                    cosMidY * sinNorth -
                        sinMidY * cosNorth * (cosMidX * cosEast + sinMidX * sinEast);
            }
            else {
                if (north <= 0) {
                    // abs(dot(northWest - northEast, xAxis))
                    width = Math.abs(cosNorth * (cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest)));
                    // dot(north, yAxis)
                    maxY = cosMidY * sinNorth - sinMidY * cosNorth;
                }
                else {
                    // abs(dot(west - east, xAxis))
                    width = Math.abs(cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest));
                    // dot(northEast, yAxis)
                    maxY =
                        cosMidY * sinNorth -
                            sinMidY * cosNorth * (sinMidX * sinEast + cosMidX * cosEast);
                }
                // dot(southEast, yAxis)
                minY =
                    cosMidY * sinSouth -
                        sinMidY * cosSouth * (cosMidX * cosEast + sinMidX * sinEast);
            }
            const rMax = (this.unitScale + (geoBox.maxAltitude || 0)) * 0.5;
            const rMin = (this.unitScale + (geoBox.minAltitude || 0)) * 0.5;
            // min(dot(southEast, zAxis), dot(northEast, zAxis))
            const d = cosMidY * (cosMidX * cosEast + sinMidX * sinEast);
            const minZ = Math.min(cosNorth * d + sinNorth * sinMidY, cosSouth * d + sinSouth * sinMidY);
            MathUtils_1.MathUtils.newVector3(width * rMax, (maxY - minY) * rMax, rMax - minZ * rMin, result.extents);
            MathUtils_1.MathUtils.newVector3(0, (minY + maxY) * rMax, rMax + rMax, result.position);
            apply(result.xAxis, result.yAxis, result.zAxis, result.position);
            result.position.x = result.position.x - result.zAxis.x * result.extents.z;
            result.position.y = result.position.y - result.zAxis.y * result.extents.z;
            result.position.z = result.position.z - result.zAxis.z * result.extents.z;
            return result;
        }
        throw new Error("Invalid bounding box");
    }
    /** @override */
    unprojectBox(_worldBox) {
        throw new Error("Method not implemented.");
    }
    /** @override */
    getScaleFactor(_worldPoint) {
        return 1;
    }
    /** @override */
    groundDistance(worldPoint) {
        return lengthOfVector3(worldPoint) - this.unitScale;
    }
    /** @override */
    scalePointToSurface(worldPoint) {
        const scale = this.unitScale / (lengthOfVector3(worldPoint) || 1);
        worldPoint.x *= scale;
        worldPoint.y *= scale;
        worldPoint.z *= scale;
        return worldPoint;
    }
    /** @override */
    surfaceNormal(worldPoint, normal) {
        if (normal === undefined) {
            normal = { x: 0, y: 0, z: 0 };
        }
        const scale = 1 / (lengthOfVector3(worldPoint) || 1);
        normal.x = worldPoint.x * scale;
        normal.y = worldPoint.y * scale;
        normal.z = worldPoint.z * scale;
        return normal;
    }
    /** @override */
    reprojectPoint(sourceProjection, worldPos, result) {
        if (sourceProjection === MercatorProjection_1.mercatorProjection || sourceProjection === MercatorProjection_1.webMercatorProjection) {
            const { x, y, z } = worldPos;
            const r = this.unitScale;
            const mx = x / r - Math.PI;
            const my = y / r - Math.PI;
            const w = Math.exp(my);
            const d = w * w;
            const gx = (2 * w) / (d + 1);
            const gy = (d - 1) / (d + 1);
            const scale = r + z;
            if (result === undefined) {
                // tslint:disable-next-line: no-object-literal-type-assertion
                result = {};
            }
            result.x = Math.cos(mx) * gx * scale;
            result.y = Math.sin(mx) * gx * scale;
            result.z = gy * scale;
            if (sourceProjection === MercatorProjection_1.webMercatorProjection) {
                result.z = -result.z;
            }
            return result;
        }
        return super.reprojectPoint(sourceProjection, worldPos, result);
    }
    /** @override */
    localTangentSpace(geoPoint, result) {
        const latitude = THREE.Math.degToRad(geoPoint.latitude);
        const longitude = THREE.Math.degToRad(geoPoint.longitude);
        const cosLongitude = Math.cos(longitude);
        const sinLongitude = Math.sin(longitude);
        const cosLatitude = Math.cos(latitude);
        const sinLatitude = Math.sin(latitude);
        MathUtils_1.MathUtils.newVector3(cosLongitude * cosLatitude, sinLongitude * cosLatitude, sinLatitude, result.zAxis);
        MathUtils_1.MathUtils.newVector3(-sinLongitude, cosLongitude, 0, result.xAxis);
        MathUtils_1.MathUtils.newVector3(-cosLongitude * sinLatitude, -sinLongitude * sinLatitude, cosLatitude, result.yAxis);
        this.projectPoint(geoPoint, result.position);
        return result;
    }
}
exports.sphereProjection = new SphereProjection(EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS);


/***/ }),

/***/ "../harp-geoutils/lib/projection/TransverseMercatorProjection.ts":
/*!***********************************************************************!*\
  !*** ../harp-geoutils/lib/projection/TransverseMercatorProjection.ts ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const GeoBox_1 = __webpack_require__(/*! ../coordinates/GeoBox */ "../harp-geoutils/lib/coordinates/GeoBox.ts");
const GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ "../harp-geoutils/lib/coordinates/GeoCoordinates.ts");
const Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ "../harp-geoutils/lib/math/Box3Like.ts");
const MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ "../harp-geoutils/lib/math/MathUtils.ts");
const OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ "../harp-geoutils/lib/math/OrientedBox3Like.ts");
const EarthConstants_1 = __webpack_require__(/*! ./EarthConstants */ "../harp-geoutils/lib/projection/EarthConstants.ts");
const Projection_1 = __webpack_require__(/*! ./Projection */ "../harp-geoutils/lib/projection/Projection.ts");
/**
 *
 * https://en.wikipedia.org/wiki/Transverse_Mercator_projection
 * http://mathworld.wolfram.com/MercatorProjection.html
 *
 */
class TransverseMercatorProjection extends Projection_1.Projection {
    constructor(unitScale) {
        super(unitScale);
        this.unitScale = unitScale;
        /** @override */
        this.type = Projection_1.ProjectionType.Planar;
        this.m_phi0 = 0;
        this.m_lambda0 = 0;
    }
    /**
     * Like in regular Mercator projection, there are two points on sphere
     * with radius about 5 degrees, that is out of projected space.
     *
     *
     * in regular Mercator these points are:
     *     (90, any), (-90, any)
     *
     * and in transverse Mercator:
     *     (0, 90), (0, -90)
     *
     * So, in transverse we need to compute distnce to poles, and clamp if
     * radius is exceeded
     */
    static clampGeoPoint(geoPoint, _unitScale) {
        const lat = geoPoint.latitude;
        const lon = geoPoint.longitude;
        const r = TransverseMercatorUtils.POLE_RADIUS;
        const rsq = TransverseMercatorUtils.POLE_RADIUS_SQ;
        const nearestQuarter = Math.round(lon / 90);
        const deltaLon = nearestQuarter * 90 - lon;
        if (nearestQuarter % 2 === 0 || Math.abs(deltaLon) > r) {
            return geoPoint;
        }
        const deltaLat = lat - 0;
        const distanceToPoleSq = deltaLon * deltaLon + deltaLat * deltaLat;
        if (distanceToPoleSq < rsq) {
            const distanceToPole = Math.sqrt(distanceToPoleSq);
            const scale = (r - distanceToPole) / distanceToPole;
            // const quarter = ((nearestQuarter % 4) + 4) % 4;
            // const dir = quarter === 1 ? -1 : quarter === 3 ? 1 : 0;
            const dir = 1;
            const offsetLon = deltaLon === 0 && deltaLat === 0 ? r * dir : deltaLon;
            return new GeoCoordinates_1.GeoCoordinates(lat + deltaLat * scale, lon + offsetLon * scale);
        }
        return geoPoint;
    }
    /** @override */
    getScaleFactor(worldPoint) {
        return Math.cosh((worldPoint.x / this.unitScale - 0.5) * 2 * Math.PI);
    }
    /** @override */
    worldExtent(minAltitude, maxAltitude, result) {
        if (!result) {
            result = MathUtils_1.MathUtils.newEmptyBox3();
        }
        result.min.x = 0;
        result.min.y = 0;
        result.min.z = minAltitude;
        result.max.x = this.unitScale;
        result.max.y = this.unitScale;
        result.max.z = maxAltitude;
        return result;
    }
    /** @override */
    projectPoint(geoPoint, result) {
        if (!result) {
            // tslint:disable-next-line:no-object-literal-type-assertion
            result = { x: 0, y: 0, z: 0 };
        }
        const clamped = TransverseMercatorProjection.clampGeoPoint(geoPoint, this.unitScale);
        const normalLon = clamped.longitude / 360 + 0.5;
        const offset = normalLon === 1 ? 0 : Math.floor(normalLon);
        const phi = MathUtils_1.MathUtils.degToRad(clamped.latitude);
        const lambda = MathUtils_1.MathUtils.degToRad(clamped.longitude - offset * 360) - this.m_lambda0;
        const B = Math.cos(phi) * Math.sin(lambda);
        // result.x = 1/2 * Math.log((1 + B) / (1 - B));
        result.x = Math.atanh(B);
        result.y = Math.atan2(Math.tan(phi), Math.cos(lambda)) - this.m_phi0;
        const outScale = 0.5 / Math.PI;
        result.x = this.unitScale * (MathUtils_1.MathUtils.clamp(result.x * outScale + 0.5, 0, 1) + offset);
        result.y = this.unitScale * MathUtils_1.MathUtils.clamp(result.y * outScale + 0.5, 0, 1);
        result.z = geoPoint.altitude || 0;
        return result;
    }
    /** @override */
    unprojectPoint(worldPoint) {
        const tau = Math.PI * 2;
        const nx = worldPoint.x / this.unitScale;
        const ny = worldPoint.y / this.unitScale;
        const offset = nx === 1 ? 0 : Math.floor(nx);
        const x = tau * (nx - 0.5 - offset);
        const y = tau * (ny - 0.5);
        const z = worldPoint.z || 0;
        const D = y + this.m_phi0;
        const phi = Math.asin(Math.sin(D) / Math.cosh(x));
        const lambda = this.m_lambda0 + Math.atan2(Math.sinh(x), Math.cos(D)) + offset * tau;
        const geoPoint = GeoCoordinates_1.GeoCoordinates.fromRadians(phi, lambda, z);
        return geoPoint;
    }
    /** @override */
    projectBox(geoBox, result) {
        const { north, south, east, west } = geoBox;
        const pointsToCheck = [
            geoBox.center,
            geoBox.northEast,
            geoBox.southWest,
            new GeoCoordinates_1.GeoCoordinates(south, east),
            new GeoCoordinates_1.GeoCoordinates(north, west)
        ];
        const E = TransverseMercatorUtils.POLE_EDGE_DEG;
        const containsWestCut = west < -90 && east > -90;
        const containsEastCut = west < 90 && east > 90;
        const containsCenterX = west < 0 && east > 0;
        const containsCenterY = west < E && east > -E && north > 0 && south < 0;
        if (containsWestCut) {
            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(north, -90));
            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(south, -90));
        }
        if (containsEastCut) {
            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(north, 90));
            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(south, 90));
        }
        if (containsCenterX) {
            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(north, 0));
            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(south, 0));
        }
        if (containsCenterY) {
            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(0, west));
            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(0, east));
        }
        TransverseMercatorUtils.alignLatitude(pointsToCheck, pointsToCheck[0]);
        const projected = pointsToCheck.map(p => this.projectPoint(p));
        const vx = projected.map(p => p.x);
        const vy = projected.map(p => p.y);
        const vz = projected.map(p => p.z);
        const minX = Math.min(...vx);
        const minY = Math.min(...vy);
        const minZ = Math.min(...vz);
        const maxX = Math.max(...vx);
        const maxY = Math.max(...vy);
        const maxZ = Math.max(...vz);
        if (!result) {
            result = MathUtils_1.MathUtils.newEmptyBox3();
        }
        if (Box3Like_1.isBox3Like(result)) {
            result.min.x = minX;
            result.min.y = minY;
            result.min.z = minZ;
            result.max.x = maxX;
            result.max.y = maxY;
            result.max.z = maxZ;
        }
        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {
            MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
            MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);
            MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);
            result.position.x = (minX + maxX) / 2;
            result.position.y = (minY + maxY) / 2;
            result.position.z = (minZ + maxZ) / 2;
            result.extents.x = (maxX - minX) / 2;
            result.extents.y = (maxY - minY) / 2;
            result.extents.z = (maxZ - minZ) / 2;
        }
        else {
            throw new Error("invalid bounding box");
        }
        return result;
    }
    /**
     * There are 8 sub-regions on entire projection space
     * where both longitude and latitude preserve direction.
     * If bounding box hits more than one region, it should be splitted
     * into sub-boxes by regions, (un)projected and then united again.
     *
     *
     * directions in form [latitude / longitude]:
     *    1 ┌─────────|─────────┐
     *      │ dr / dl | dl / ul │
     * 0.75 ----------|----------
     *      │ ur / dr | ul / ur │
     * 0.5  ----------|----------
     *      │ ul / ur | ur / dr │
     * 0.25 ----------|----------
     *      │ dl / ul | dr / dl │
     *      └─────────|─────────┘
     *     0         0.5        1
     *     @override
     */
    unprojectBox(worldBox) {
        const s = this.unitScale;
        const min = worldBox.min;
        const max = worldBox.max;
        const pointsToCheck = [
            { x: (min.x + max.x) / 2, y: (min.y + max.y) / 2, z: 0 },
            min,
            max,
            { x: min.x, y: max.y, z: 0 },
            { x: max.x, y: min.y, z: 0 }
        ];
        const center = 0.5 * s;
        const lowerQ = 0.25 * s;
        const upperQ = 0.75 * s;
        const containsCenterX = min.x < center && max.x > center;
        const containsCenterY = min.y < center && max.y > center;
        const containsLowerQY = min.y < lowerQ && max.y > lowerQ;
        const containsUpperQY = min.y < upperQ && max.y > upperQ;
        if (containsCenterY) {
            pointsToCheck.push({ x: min.x, y: center, z: 0 });
            pointsToCheck.push({ x: max.x, y: center, z: 0 });
            if (containsCenterX) {
                pointsToCheck.push({ x: center, y: center, z: 0 });
            }
        }
        if (containsLowerQY) {
            pointsToCheck.push({ x: min.x, y: lowerQ, z: 0 });
            pointsToCheck.push({ x: max.x, y: lowerQ, z: 0 });
            if (containsCenterX) {
                pointsToCheck.push({ x: center, y: lowerQ, z: 0 });
            }
        }
        if (containsUpperQY) {
            pointsToCheck.push({ x: min.x, y: upperQ, z: 0 });
            pointsToCheck.push({ x: max.x, y: upperQ, z: 0 });
            if (containsCenterX) {
                pointsToCheck.push({ x: center, y: upperQ, z: 0 });
            }
        }
        const geoPoints = pointsToCheck.map(p => this.unprojectPoint(p));
        TransverseMercatorUtils.alignLongitude(geoPoints, geoPoints[0]);
        const latitudes = geoPoints.map(g => g.latitude);
        const longitudes = geoPoints.filter(g => Math.abs(g.latitude) < 90).map(g => g.longitude);
        const altitudes = geoPoints.map(g => g.altitude || 0);
        const minGeo = new GeoCoordinates_1.GeoCoordinates(Math.min(...latitudes), Math.min(...longitudes), Math.min(...altitudes));
        const maxGeo = new GeoCoordinates_1.GeoCoordinates(Math.max(...latitudes), Math.max(...longitudes), Math.max(...altitudes));
        const geoBox = GeoBox_1.GeoBox.fromCoordinates(minGeo, maxGeo);
        return geoBox;
    }
    /** @override */
    unprojectAltitude(worldPoint) {
        return worldPoint.z;
    }
    /** @override */
    groundDistance(worldPoint) {
        return worldPoint.z;
    }
    /** @override */
    scalePointToSurface(worldPoint) {
        worldPoint.z = 0;
        return worldPoint;
    }
    /** @override */
    surfaceNormal(_worldPoint, normal) {
        if (normal === undefined) {
            normal = { x: 0, y: 0, z: -1 };
        }
        else {
            normal.x = 0;
            normal.y = 0;
            normal.z = -1;
        }
        return normal;
    }
}
class TransverseMercatorUtils {
    /**
     * There are two regions on projected space that have same geo coordinates,
     * it's the entire lines   { x: [0..1], y: 0 } and { x: [0..1], y: 1 }
     * they both have geo coordinates of   (0, [-90..+90])
     * and should be aligned somehow to fall into first or second region
     * to make proper bounding boxes, tile bounds, etc.
     */
    static alignLatitude(points, referencePoint) {
        const EPSILON = 1e-9;
        for (const point of points) {
            if (point.latitude === 0) {
                point.latitude = referencePoint.latitude * EPSILON;
            }
        }
    }
    /**
     * There are two regions on projected plane,
     * { x: 0.5, y: [0..0.25] }    and    { x: 0.5, y: [0.75..1] }
     * that represent longitude edge where -180 and +180 met.
     * Points falling in this regions should be aligned to get proper boxes etc.
     */
    static alignLongitude(points, referencePoint) {
        const bad = referencePoint.longitude < 0 ? 180 : -180;
        const good = referencePoint.longitude < 0 ? -180 : 180;
        for (const point of points) {
            if (point.longitude === bad) {
                point.longitude = good;
            }
        }
    }
}
exports.TransverseMercatorUtils = TransverseMercatorUtils;
TransverseMercatorUtils.POLE_EDGE = 1.4844222297453323;
TransverseMercatorUtils.POLE_EDGE_DEG = MathUtils_1.MathUtils.radToDeg(TransverseMercatorUtils.POLE_EDGE);
TransverseMercatorUtils.POLE_RADIUS = 90 - TransverseMercatorUtils.POLE_EDGE_DEG;
TransverseMercatorUtils.POLE_RADIUS_SQ = Math.pow(TransverseMercatorUtils.POLE_RADIUS, 2);
/**
 * Transverse Mercator [[Projection]] used to convert geo coordinates to world coordinates
 * and vice versa.
 */
exports.transverseMercatorProjection = new TransverseMercatorProjection(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE);


/***/ }),

/***/ "../harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.ts":
/*!*******************************************************************!*\
  !*** ../harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.ts ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ "../harp-geoutils/lib/math/MathUtils.ts");
/**
 * `FlatTileBoundingBoxGenerator` generates bounding boxes in world and geo coordinates for a given
 * TilingScheme.
 */
class FlatTileBoundingBoxGenerator {
    /**
     * Creates a new `FlatTileBoundingBoxGenerator` that can generate bounding boxes for the given
     * TilingScheme.
     *
     * @param tilingScheme The [[TilingScheme]] used to compute bounding boxes.
     * @param minElevation The minimum elevation in meters.
     * @param maxElevation The maximum elevation in meters.
     */
    constructor(tilingScheme, minElevation = 0, maxElevation = 0) {
        this.tilingScheme = tilingScheme;
        this.minElevation = minElevation;
        this.maxElevation = maxElevation;
        this.m_tilingScheme = tilingScheme;
        this.m_worldBox = tilingScheme.projection.worldExtent(minElevation, maxElevation);
        const { min, max } = this.m_worldBox;
        this.m_worldDimensions = { x: max.x - min.x, y: max.y - min.y, z: max.z - min.z };
    }
    /**
     * Returns the [[Projection]] of the [[TilingScheme]].
     */
    get projection() {
        return this.m_tilingScheme.projection;
    }
    /**
     * Returns the [[SubdivisionScheme]] of the [[TilingScheme]].
     */
    get subdivisionScheme() {
        return this.m_tilingScheme.subdivisionScheme;
    }
    /**
     * Returns the bounding box in world coordinates of the given [[TileKey]].
     *
     * Example:
     * ```typescript
     * const worldBounds = new THREE.Box3();
     * generator.getWorldBox(geoBox, worldBounds);
     * console.log(worldBounds.getCenter());
     * ```
     *
     * @param tileKey The TileKey.
     * @param result The optional object used to store the resulting bounding box in world
     * coordinates.
     */
    getWorldBox(tileKey, result) {
        const level = tileKey.level;
        const levelDimensionX = this.subdivisionScheme.getLevelDimensionX(level);
        const levelDimensionY = this.subdivisionScheme.getLevelDimensionY(level);
        const sizeX = this.m_worldDimensions.x / levelDimensionX;
        const sizeY = this.m_worldDimensions.y / levelDimensionY;
        const originX = this.m_worldBox.min.x + sizeX * tileKey.column;
        const originY = this.m_worldBox.min.y + sizeY * tileKey.row;
        if (!result) {
            result = MathUtils_1.MathUtils.newEmptyBox3();
        }
        result.min.x = originX;
        result.min.y = originY;
        result.min.z = this.m_worldBox.min.z;
        result.max.x = originX + sizeX;
        result.max.y = originY + sizeY;
        result.max.z = this.m_worldBox.max.z;
        return result;
    }
    /**
     * Returns the bounding box in geo coordinates for the given [[TileKey]].
     *
     * Example:
     * ```typescript
     * const geoBox = generator.getGeoBox(worldBounds);
     * console.log(geoBox.center);
     * ```
     *
     * @param tileKey The [[TileKey]].
     */
    getGeoBox(tileKey) {
        const worldBox = this.getWorldBox(tileKey);
        return this.projection.unprojectBox(worldBox);
    }
}
exports.FlatTileBoundingBoxGenerator = FlatTileBoundingBoxGenerator;


/***/ }),

/***/ "../harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.ts":
/*!********************************************************************!*\
  !*** ../harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.ts ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
class HalfQuadTreeSubdivisionScheme {
    getSubdivisionX() {
        return 2;
    }
    getSubdivisionY(level) {
        return level === 0 ? 1 : 2;
    }
    getLevelDimensionX(level) {
        // tslint:disable-next-line:no-bitwise
        return 1 << level;
    }
    getLevelDimensionY(level) {
        // tslint:disable-next-line:no-bitwise
        return level !== 0 ? 1 << (level - 1) : 1;
    }
}
/**
 * A [[SubdivisionScheme]] used to represent half quadtrees. This particular subdivision scheme is
 * used by the HERE tiling scheme.
 */
exports.halfQuadTreeSubdivisionScheme = new HalfQuadTreeSubdivisionScheme();


/***/ }),

/***/ "../harp-geoutils/lib/tiling/HereTilingScheme.ts":
/*!*******************************************************!*\
  !*** ../harp-geoutils/lib/tiling/HereTilingScheme.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const EquirectangularProjection_1 = __webpack_require__(/*! ../projection/EquirectangularProjection */ "../harp-geoutils/lib/projection/EquirectangularProjection.ts");
const HalfQuadTreeSubdivisionScheme_1 = __webpack_require__(/*! ./HalfQuadTreeSubdivisionScheme */ "../harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.ts");
const TilingScheme_1 = __webpack_require__(/*! ./TilingScheme */ "../harp-geoutils/lib/tiling/TilingScheme.ts");
/**
 * [[TilingScheme]] used by most of the data published by HERE.
 *
 * The `hereTilingScheme` features a half quadtree subdivision scheme and an equirectangular
 * projection.
 */
exports.hereTilingScheme = new TilingScheme_1.TilingScheme(HalfQuadTreeSubdivisionScheme_1.halfQuadTreeSubdivisionScheme, EquirectangularProjection_1.normalizedEquirectangularProjection);


/***/ }),

/***/ "../harp-geoutils/lib/tiling/MercatorTilingScheme.ts":
/*!***********************************************************!*\
  !*** ../harp-geoutils/lib/tiling/MercatorTilingScheme.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const MercatorProjection_1 = __webpack_require__(/*! ../projection/MercatorProjection */ "../harp-geoutils/lib/projection/MercatorProjection.ts");
const QuadTreeSubdivisionScheme_1 = __webpack_require__(/*! ./QuadTreeSubdivisionScheme */ "../harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.ts");
const TilingScheme_1 = __webpack_require__(/*! ./TilingScheme */ "../harp-geoutils/lib/tiling/TilingScheme.ts");
/**
 * The [[TilingScheme]] used by the HERE web tiles.
 *
 * The `mercatorTilingScheme` features a quadtree subdivision scheme and a Mercator projection.
 */
exports.mercatorTilingScheme = new TilingScheme_1.TilingScheme(QuadTreeSubdivisionScheme_1.quadTreeSubdivisionScheme, MercatorProjection_1.mercatorProjection);


/***/ }),

/***/ "../harp-geoutils/lib/tiling/PolarTilingScheme.ts":
/*!********************************************************!*\
  !*** ../harp-geoutils/lib/tiling/PolarTilingScheme.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const TransverseMercatorProjection_1 = __webpack_require__(/*! ../projection/TransverseMercatorProjection */ "../harp-geoutils/lib/projection/TransverseMercatorProjection.ts");
const QuadTreeSubdivisionScheme_1 = __webpack_require__(/*! ./QuadTreeSubdivisionScheme */ "../harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.ts");
const TilingScheme_1 = __webpack_require__(/*! ./TilingScheme */ "../harp-geoutils/lib/tiling/TilingScheme.ts");
/**
 * A [[TilingScheme]] featuring quadtree subdivision scheme and
 * transverse Mercator projection.
 */
exports.polarTilingScheme = new TilingScheme_1.TilingScheme(QuadTreeSubdivisionScheme_1.quadTreeSubdivisionScheme, TransverseMercatorProjection_1.transverseMercatorProjection);


/***/ }),

/***/ "../harp-geoutils/lib/tiling/QuadTree.ts":
/*!***********************************************!*\
  !*** ../harp-geoutils/lib/tiling/QuadTree.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const TileKey_1 = __webpack_require__(/*! ./TileKey */ "../harp-geoutils/lib/tiling/TileKey.ts");
/**
 * A class used to represent a quadtree.
 */
class QuadTree {
    /**
     * Constructs a new `QuadTree` for the given [[TilingScheme]].
     *
     * Example:
     * ```typescript
     * const quadTree = new QuadTree(hereTilingScheme);
     * const geoBox = quadTree.getGeoBox(tileKey);
     * console.log(geoBox.center);
     * ```
     *
     * @param tilingScheme The TilingScheme used by this `QuadTree`.
     */
    constructor(tilingScheme) {
        this.tilingScheme = tilingScheme;
    }
    /**
     * Visits this `QuadTree` and invoke the given accept method with the current [[TileKey]] and
     * its bounding box in geo coordinates.
     *
     * Example:
     * ```typescript
     * const geoPos = new GeoCoordinates(latitude, longitude);
     * const quadTree = new QuadTree(hereTilingScheme);
     * quadTree.visit((tileKey, geoBox) => {
     *     if (geoBox.contains(geoPos)) {
     *         console.log("tile", tileKey, "contains", geoPos);
     *         return tileKey.level < 14; // stop visiting the quadtree if the level is >= 14.
     *     }
     *     return false; // stop visiting the quadtree,
     *                   // the tile's geoBox doesn't contain the given coordinates.
     * });
     * ```
     *
     * @param accept A function that takes a [[TileKey]] and its bounding box in geo coordinates and
     * returns `true` if the visit of the `QuadTree` should continue; otherwise `false`.
     */
    visit(accept) {
        this.visitTileKey(TileKey_1.TileKey.fromRowColumnLevel(0, 0, 0), accept);
    }
    /**
     * Visits the subtree starting from the given tile.
     *
     * @param tileKey The root of the subtree that should be visited.
     * @param accept A function that takes a [[TileKey]] and its bounding box in geo coordinates and
     * returns `true` if the visit of the `QuadTree` should continue; otherwise `false`.
     */
    visitTileKey(tileKey, accept) {
        const geoBox = this.tilingScheme.getGeoBox(tileKey);
        if (!accept(tileKey, geoBox)) {
            return;
        }
        for (const subTileKey of this.tilingScheme.getSubTileKeys(tileKey)) {
            this.visitTileKey(subTileKey, accept);
        }
    }
}
exports.QuadTree = QuadTree;


/***/ }),

/***/ "../harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.ts":
/*!****************************************************************!*\
  !*** ../harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.ts ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
class QuadTreeSubdivisionScheme {
    getSubdivisionX() {
        return 2;
    }
    getSubdivisionY() {
        return 2;
    }
    getLevelDimensionX(level) {
        // tslint:disable-next-line:no-bitwise
        return 1 << level;
    }
    getLevelDimensionY(level) {
        // tslint:disable-next-line:no-bitwise
        return 1 << level;
    }
}
/**
 * [[SubdivisionScheme]] representing a quadtree.
 */
exports.quadTreeSubdivisionScheme = new QuadTreeSubdivisionScheme();


/***/ }),

/***/ "../harp-geoutils/lib/tiling/SubTiles.ts":
/*!***********************************************!*\
  !*** ../harp-geoutils/lib/tiling/SubTiles.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const TileKey_1 = __webpack_require__(/*! ./TileKey */ "../harp-geoutils/lib/tiling/TileKey.ts");
class SubTiles {
    constructor(tileKey, sizeX, sizeY) {
        this.tileKey = tileKey;
        this.sizeX = sizeX;
        this.sizeY = sizeY;
    }
    [Symbol.iterator]() {
        return this.sizeX === 2 && this.sizeY === 2
            ? SubTiles.ZCurveIterator(this.tileKey)
            : SubTiles.RowColumnIterator(this.tileKey, this.sizeX, this.sizeY);
    }
}
exports.SubTiles = SubTiles;
(function (SubTiles) {
    function* RowColumnIterator(parentKey, sizeX, sizeY) {
        for (let y = 0; y < sizeY; y++) {
            for (let x = 0; x < sizeX; x++) {
                yield TileKey_1.TileKey.fromRowColumnLevel(parentKey.row * sizeY + y, parentKey.column * sizeX + x, parentKey.level + 1);
            }
        }
    }
    SubTiles.RowColumnIterator = RowColumnIterator;
    function* ZCurveIterator(parentKey) {
        // tslint:disable:no-bitwise
        for (let i = 0; i < 4; i++) {
            yield TileKey_1.TileKey.fromRowColumnLevel((parentKey.row << 1) | (i >> 1), (parentKey.column << 1) | (i & 1), parentKey.level + 1);
        }
        // tslint:enableno-bitwise
    }
    SubTiles.ZCurveIterator = ZCurveIterator;
})(SubTiles = exports.SubTiles || (exports.SubTiles = {}));


/***/ }),

/***/ "../harp-geoutils/lib/tiling/TileKey.ts":
/*!**********************************************!*\
  !*** ../harp-geoutils/lib/tiling/TileKey.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/** @hidden */
const powerOfTwo = [
    0x1,
    0x2,
    0x4,
    0x8,
    0x10,
    0x20,
    0x40,
    0x80,
    0x100,
    0x200,
    0x400,
    0x800,
    0x1000,
    0x2000,
    0x4000,
    0x8000,
    0x10000,
    0x20000,
    0x40000,
    0x80000,
    0x100000,
    0x200000,
    0x400000,
    0x800000,
    0x1000000,
    0x2000000,
    0x4000000,
    0x8000000,
    0x10000000,
    0x20000000,
    0x40000000,
    0x80000000,
    0x100000000,
    0x200000000,
    0x400000000,
    0x800000000,
    0x1000000000,
    0x2000000000,
    0x4000000000,
    0x8000000000,
    0x10000000000,
    0x20000000000,
    0x40000000000,
    0x80000000000,
    0x100000000000,
    0x200000000000,
    0x400000000000,
    0x800000000000,
    0x1000000000000,
    0x2000000000000,
    0x4000000000000,
    0x8000000000000,
    0x10000000000000 // Math.pow(2, 52), highest bit that can be set correctly.
];
/**
 * The `TileKey` instances are used to address a tile in a quadtree.
 *
 * A tile key is defined by a row, a column, and a level. The tree has a root at level 0, with one
 * single tile. On every level, each tile is divided into four children (therefore the name
 * quadtree).
 *
 * Within each [[level]], any particular tile is addressed with [[row]] and [[column]]. The number
 * of rows and columns in each level is 2 to the power of the level. This means: On level 0, only
 * one tile exists, [[columnsAtLevel]]() and [[rowsAtLevel]]() are both 1. On level 1, 4 tiles
 * exist, in 2 rows and 2 columns. On level 2 we have 16 tiles, in 4 rows and 4 columns. And so on.
 *
 * A tile key is usually created using [[fromRowColumnLevel]]() method.
 *
 * `TileKey` instances are immutable, all members return new instances of `TileKey` and do not
 * modify the original object.
 *
 * Utility functions like [[parent]](), [[changedLevelBy]](), and [[changedLevelTo]]() allow for
 * easy vertical navigation of the tree. The number of available rows and columns in the tile's
 * level is given with [[rowCount]]() and [[columnCount]]().
 *
 * Tile keys can be created from and converted into various alternative formats:
 *
 *  - [[toQuadKey]]() / [[fromQuadKey]]() - string representation 4-based
 *  - [[toHereTile]]() / [[fromHereTile]]() - string representation 10-based
 *  - [[mortonCode]]() / [[fromMortonCode]]() - number representation
 *
 * Note - as JavaScript's number type can hold 53 bits in its mantissa, only levels up to 26 can be
 * represented in the number representation returned by [[mortonCode]]().
 */
class TileKey {
    /**
     * Constructs a new immutable instance of a `TileKey`.
     *
     * For the better readability, [[TileKey.fromRowColumnLevel]] should be preferred.
     *
     * Note - row and column must not be greater than the maximum rows/columns for the given level.
     *
     * @param row Represents the row in the quadtree.
     * @param column Represents the column in the quadtree.
     * @param level Represents the level in the quadtree.
     */
    constructor(row, column, level) {
        this.row = row;
        this.column = column;
        this.level = level;
    }
    /**
     * Creates a tile key.
     *
     * @param row The requested row. Must be less than 2 to the power of level.
     * @param column The requested column. Must be less than 2 to the power of level.
     * @param level The requested level.
     */
    static fromRowColumnLevel(row, column, level) {
        return new TileKey(row, column, level);
    }
    /**
     * Creates a tile key from a quad string.
     *
     * The quad string can be created with [[toQuadKey]].
     *
     * @param quadkey The quadkey to convert.
     * @returns A new instance of `TileKey`.
     */
    static fromQuadKey(quadkey) {
        const level = quadkey.length;
        let row = 0;
        let column = 0;
        // tslint:disable:no-bitwise
        for (let i = 0; i < quadkey.length; ++i) {
            const mask = 1 << i;
            const d = parseInt(quadkey.charAt(level - i - 1), 10);
            if (d & 0x1) {
                column |= mask;
            }
            if (d & 0x2) {
                row |= mask;
            }
        }
        // tslint:enable:no-bitwise
        return TileKey.fromRowColumnLevel(row, column, level);
    }
    /**
     * Creates a tile key from a numeric Morton code representation.
     *
     * You can convert a tile key into a numeric Morton code with [[mortonCode]].
     *
     * @param quadKey64 The Morton code to be converted.
     * @returns A new instance of [[TileKey]].
     */
    static fromMortonCode(quadKey64) {
        let level = 0;
        let row = 0;
        let column = 0;
        let quadKey = quadKey64;
        // tslint:disable:no-bitwise
        while (quadKey > 1) {
            const mask = 1 << level;
            if (quadKey & 0x1) {
                column |= mask;
            }
            if (quadKey & 0x2) {
                row |= mask;
            }
            level++;
            quadKey = (quadKey - (quadKey & 0x3)) / 4;
        }
        // tslint:enable:no-bitwise
        const result = TileKey.fromRowColumnLevel(row, column, level);
        result.m_mortonCode = quadKey64;
        return result;
    }
    /**
     * Creates a tile key from a heretile code string.
     *
     * The string can be created with [[toHereTile]].
     *
     * @param quadkey64 The string representation of the HERE tile key.
     * @returns A new instance of `TileKey`.
     */
    static fromHereTile(quadkey64) {
        const result = TileKey.fromMortonCode(parseInt(quadkey64, 10));
        result.m_hereTile = quadkey64;
        return result;
    }
    /**
     * Returns the number of available columns at a given level.
     *
     * This is 2 to the power of the level.
     *
     * @param level The level for which to return the number of columns.
     * @returns The available columns at the given level.
     */
    static columnsAtLevel(level) {
        return Math.pow(2, level);
    }
    /**
     * Returns the number of available rows at a given level.
     *
     * This is 2 to the power of the level.
     *
     * @param level The level for which to return the number of rows.
     * @returns The available rows at the given level.
     */
    static rowsAtLevel(level) {
        return Math.pow(2, level);
    }
    /**
     * Returns the closest matching `TileKey` in a cartesian coordinate system.
     *
     * @param level The level for the tile key.
     * @param coordX The X coordinate.
     * @param coordY The Y coordinate.
     * @param totalWidth The maximum X coordinate.
     * @param totalHeight The maximum Y coordinate.
     * @returns A new tile key at the given level that includes the given coordinates.
     */
    static atCoords(level, coordX, coordY, totalWidth, totalHeight) {
        return TileKey.fromRowColumnLevel(Math.floor(coordY / (totalHeight / TileKey.rowsAtLevel(level))), Math.floor(coordX / (totalWidth / TileKey.columnsAtLevel(level))), level);
    }
    /**
     * Computes the Morton code of the parent tile key of the given Morton code.
     *
     * Note: The parent key of the root key is the root key itself.
     *
     * @param mortonCode A Morton code, for example, obtained from [[mortonCode]].
     * @returns The Morton code of the parent tile.
     */
    static parentMortonCode(mortonCode) {
        return Math.floor(mortonCode / 4);
    }
    /**
     * Returns a tile key representing the parent of the tile addressed by this tile key.
     *
     * Throws an exception is this tile is already the root.
     */
    parent() {
        if (this.level === 0) {
            throw new Error("Cannot get the parent of the root tile key");
        }
        // tslint:disable-next-line:no-bitwise
        return TileKey.fromRowColumnLevel(this.row >>> 1, this.column >>> 1, this.level - 1);
    }
    /**
     * Returns a new tile key at a level that differs from this tile's level by delta.
     *
     * Equivalent to `changedLevelTo(level() + delta)`.
     *
     * Note - root key is returned if `delta` is smaller than the level of this tile key.
     *
     * @param delta The numeric difference between the current level and the requested level.
     */
    changedLevelBy(delta) {
        const level = Math.max(0, this.level + delta);
        let row = this.row;
        let column = this.column;
        // tslint:disable:no-bitwise
        if (delta >= 0) {
            row <<= delta;
            column <<= delta;
        }
        else {
            row >>>= -delta;
            column >>>= -delta;
        }
        // tslint:enable:no-bitwise
        return TileKey.fromRowColumnLevel(row, column, level);
    }
    /**
     * Returns a new tile key at the requested level.
     *
     * If the requested level is smaller than the tile's level, then the key of an ancestor of this
     * tile is returned. If the requested level is larger than the tile's level, then the key of
     * first child or grandchild of this tile is returned, for example, the child with the lowest
     * row and column number. If the requested level equals this tile's level, then the tile key
     * itself is returned. If the requested level is negative, the root tile key is returned.
     *
     * @param level The requested level.
     */
    changedLevelTo(level) {
        return this.changedLevelBy(level - this.level);
    }
    /**
     * Converts the tile key to a numeric code representation.
     *
     * You can create a tile key from a numeric Morton code with [[fromMortonCode]].
     *
     * Note - only levels <= 26 are supported.
     */
    mortonCode() {
        if (this.m_mortonCode === undefined) {
            let column = this.column;
            let row = this.row;
            // tslint:disable:no-bitwise
            let result = powerOfTwo[this.level << 1];
            for (let i = 0; i < this.level; ++i) {
                if (column & 0x1) {
                    result += powerOfTwo[2 * i];
                }
                if (row & 0x1) {
                    result += powerOfTwo[2 * i + 1];
                }
                column >>>= 1;
                row >>>= 1;
            }
            // tslint:enable:no-bitwise
            this.m_mortonCode = result;
        }
        return this.m_mortonCode;
    }
    /**
     * Converts the tile key into a string for using in REST API calls.
     *
     * The string is a quadkey Morton code representation as a string.
     *
     * You can convert back from a quadkey string with [[fromHereTile]].
     */
    toHereTile() {
        if (this.m_hereTile === undefined) {
            this.m_hereTile = this.mortonCode().toString();
        }
        return this.m_hereTile;
    }
    /**
     * Converts the tile key into a string for using in REST API calls.
     *
     * If the tile is the root tile, the quadkey is '-'. Otherwise the string is a number to the
     * base of 4, but without the leading 1, with the following properties:
     *  1. the number of digits equals the level.
     *  2. removing the last digit gives the parent tile's quadkey string, i.e. appending 0,1,2,3
     *     to a quadkey string gives the tiles's children.
     *
     * You can convert back from a quadkey string with [[fromQuadKey]].
     */
    toQuadKey() {
        let result = "";
        // tslint:disable:no-bitwise
        for (let i = this.level; i > 0; --i) {
            const mask = 1 << (i - 1);
            const col = (this.column & mask) !== 0;
            const row = (this.row & mask) !== 0;
            if (col && row) {
                result += "3";
            }
            else if (row) {
                result += "2";
            }
            else if (col) {
                result += "1";
            }
            else {
                result += "0";
            }
        }
        // tslint:enable:no-bitwise
        return result;
    }
    /**
     * Equality operator.
     *
     * @param qnr The tile key to compare to.
     * @returns `true` if this tile key has identical row, column and level, `false` otherwise.
     */
    equals(qnr) {
        return this.row === qnr.row && this.column === qnr.column && this.level === qnr.level;
    }
    /**
     * Returns the absolute quadkey that is constructed from its sub quadkey.
     *
     * @param sub The sub key.
     * @returns The absolute tile key in the quadtree.
     */
    addedSubKey(sub) {
        const subQuad = TileKey.fromQuadKey(sub.length === 0 ? "-" : sub);
        const child = this.changedLevelBy(subQuad.level);
        return TileKey.fromRowColumnLevel(child.row + subQuad.row, child.column + subQuad.column, child.level);
    }
    /**
     * Returns the absolute quadkey that is constructed from its sub HERE tile key.
     *
     * @param sub The sub HERE key.
     * @returns The absolute tile key in the quadtree.
     */
    addedSubHereTile(sub) {
        const subQuad = TileKey.fromHereTile(sub);
        const child = this.changedLevelBy(subQuad.level);
        return TileKey.fromRowColumnLevel(child.row + subQuad.row, child.column + subQuad.column, child.level);
    }
    /**
     * Returns a sub quadkey that is relative to its parent.
     *
     * This function can be used to generate sub keys that are relative to a parent that is delta
     * levels up in the quadtree.
     *
     * This function can be used to create shortened keys for quads on lower levels if the parent is
     * known.
     *
     * Note - the sub quadkeys fit in a 16-bit unsigned integer if the `delta` is smaller than 8. If
     * `delta` is smaller than 16, the sub quadkey fits into an unsigned 32-bit integer.
     *
     * Deltas larger than 16 are not supported.
     *
     * @param delta The number of levels relative to its parent quadkey. Must be greater or equal to
     * 0 and smaller than 16.
     * @returns The quadkey relative to its parent that is `delta` levels up the tree.
     */
    getSubHereTile(delta) {
        const key = this.mortonCode();
        // tslint:disable-next-line:no-bitwise
        const msb = 1 << (delta * 2);
        const mask = msb - 1;
        // tslint:disable-next-line:no-bitwise
        const result = (key & mask) | msb;
        return result.toString();
    }
    /**
     * Returns the number of available rows in the tile's [[level]].
     *
     * This is 2 to the power of the level.
     */
    rowCount() {
        return TileKey.rowsAtLevel(this.level);
    }
    /**
     * Returns the number of available columns in the tile's [[level]].
     *
     * This is 2 to the power of the level.
     */
    columnCount() {
        return TileKey.columnsAtLevel(this.level);
    }
}
exports.TileKey = TileKey;


/***/ }),

/***/ "../harp-geoutils/lib/tiling/TileKeyUtils.ts":
/*!***************************************************!*\
  !*** ../harp-geoutils/lib/tiling/TileKeyUtils.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ "../harp-geoutils/lib/coordinates/GeoCoordinates.ts");
const TileKey_1 = __webpack_require__(/*! ./TileKey */ "../harp-geoutils/lib/tiling/TileKey.ts");
class TileKeyUtils {
    static geoCoordinatesToTileKey(tilingScheme, geoPoint, level) {
        const projection = tilingScheme.projection;
        const worldPoint = projection.projectPoint(geoPoint);
        return this.worldCoordinatesToTileKey(tilingScheme, worldPoint, level);
    }
    static worldCoordinatesToTileKey(tilingScheme, worldPoint, level) {
        const projection = tilingScheme.projection;
        const subdivisionScheme = tilingScheme.subdivisionScheme;
        const cx = subdivisionScheme.getLevelDimensionX(level);
        const cy = subdivisionScheme.getLevelDimensionY(level);
        const { min, max } = projection.worldExtent(0, 0);
        const worldSizeX = max.x - min.x;
        const worldSizeY = max.y - min.y;
        if (worldPoint.x < min.x || worldPoint.x > max.x) {
            return null;
        }
        if (worldPoint.y < min.y || worldPoint.y > max.y) {
            return null;
        }
        const column = Math.min(cx - 1, Math.floor((cx * (worldPoint.x - min.x)) / worldSizeX));
        const row = Math.min(cy - 1, Math.floor((cy * (worldPoint.y - min.y)) / worldSizeY));
        return TileKey_1.TileKey.fromRowColumnLevel(row, column, level);
    }
    static geoRectangleToTileKeys(tilingScheme, geoBox, level) {
        const wrap = (value, lower, upper) => {
            if (value < lower) {
                return upper - ((lower - value) % (upper - lower));
            }
            return lower + ((value - lower) % (upper - lower));
        };
        const clamp = (x, minVal, maxVal) => {
            return Math.min(Math.max(x, minVal), maxVal);
        };
        // Clamp at the poles and wrap around the international date line.
        const southWestLongitude = wrap(geoBox.southWest.longitudeInRadians, -Math.PI, Math.PI);
        const southWestLatitude = clamp(geoBox.southWest.latitudeInRadians, -(Math.PI * 0.5), Math.PI * 0.5);
        const northEastLongitude = wrap(geoBox.northEast.longitudeInRadians, -Math.PI, Math.PI);
        const northEastLatitude = clamp(geoBox.northEast.latitudeInRadians, -(Math.PI * 0.5), Math.PI * 0.5);
        const minTileKey = TileKeyUtils.geoCoordinatesToTileKey(tilingScheme, GeoCoordinates_1.GeoCoordinates.fromRadians(southWestLatitude, southWestLongitude), level);
        const maxTileKey = TileKeyUtils.geoCoordinatesToTileKey(tilingScheme, GeoCoordinates_1.GeoCoordinates.fromRadians(northEastLatitude, northEastLongitude), level);
        const columnCount = tilingScheme.subdivisionScheme.getLevelDimensionX(level);
        if (!minTileKey || !maxTileKey) {
            throw new Error("Invalid coordinates");
        }
        const minColumn = minTileKey.column;
        let maxColumn = maxTileKey.column;
        // wrap around case
        if (southWestLongitude > northEastLongitude) {
            if (maxColumn !== minColumn) {
                maxColumn += columnCount;
            }
            else {
                // do not duplicate
                maxColumn += columnCount - 1;
            }
        }
        const minRow = Math.min(minTileKey.row, maxTileKey.row);
        const maxRow = Math.max(minTileKey.row, maxTileKey.row);
        const keys = new Array();
        for (let row = minRow; row <= maxRow; ++row) {
            for (let column = minColumn; column <= maxColumn; ++column) {
                keys.push(TileKey_1.TileKey.fromRowColumnLevel(row, column % columnCount, level));
            }
        }
        return keys;
    }
}
exports.TileKeyUtils = TileKeyUtils;


/***/ }),

/***/ "../harp-geoutils/lib/tiling/TileTreeTraverse.ts":
/*!*******************************************************!*\
  !*** ../harp-geoutils/lib/tiling/TileTreeTraverse.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const SubTiles_1 = __webpack_require__(/*! ./SubTiles */ "../harp-geoutils/lib/tiling/SubTiles.ts");
class TileTreeTraverse {
    constructor(subdivisionScheme) {
        this.m_subdivisionScheme = subdivisionScheme;
    }
    subTiles(tileKey) {
        const divX = this.m_subdivisionScheme.getSubdivisionX(tileKey.level);
        const divY = this.m_subdivisionScheme.getSubdivisionY(tileKey.level);
        return new SubTiles_1.SubTiles(tileKey, divX, divY);
    }
}
exports.TileTreeTraverse = TileTreeTraverse;


/***/ }),

/***/ "../harp-geoutils/lib/tiling/TilingScheme.ts":
/*!***************************************************!*\
  !*** ../harp-geoutils/lib/tiling/TilingScheme.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const FlatTileBoundingBoxGenerator_1 = __webpack_require__(/*! ./FlatTileBoundingBoxGenerator */ "../harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.ts");
const TileKeyUtils_1 = __webpack_require__(/*! ./TileKeyUtils */ "../harp-geoutils/lib/tiling/TileKeyUtils.ts");
const TileTreeTraverse_1 = __webpack_require__(/*! ./TileTreeTraverse */ "../harp-geoutils/lib/tiling/TileTreeTraverse.ts");
/**
 * The `TilingScheme` represents how the data is tiled.
 */
class TilingScheme {
    /**
     * Constructs a new `TilingScheme` with the given subdivision scheme and projection.
     *
     * @param subdivisionScheme The subdivision scheme used by this `TilingScheme`.
     * @param projection The projection used by this `TilingScheme`.
     */
    constructor(subdivisionScheme, projection) {
        this.subdivisionScheme = subdivisionScheme;
        this.projection = projection;
        this.boundingBoxGenerator = new FlatTileBoundingBoxGenerator_1.FlatTileBoundingBoxGenerator(this);
        this.tileTreeTraverse = new TileTreeTraverse_1.TileTreeTraverse(subdivisionScheme);
    }
    /**
     * Returns the sub tile keys of the given tile.
     *
     * @param tileKey The [[TileKey]].
     * @returns The list of the sub tile keys.
     */
    getSubTileKeys(tileKey) {
        return this.tileTreeTraverse.subTiles(tileKey);
    }
    /**
     * Gets the [[TileKey]] from the given geo position and level.
     *
     * @param geoPoint The position in geo coordinates.
     * @param level The level of the resulting `TileKey`.
     */
    getTileKey(geoPoint, level) {
        return TileKeyUtils_1.TileKeyUtils.geoCoordinatesToTileKey(this, geoPoint, level);
    }
    /**
     * Gets the list of [[TileKey]]s contained in the given [[GeoBox]].
     *
     * @param geoBox The bounding box in geo coordinates.
     * @param level The level of the resulting `TileKey`.
     */
    getTileKeys(geoBox, level) {
        return TileKeyUtils_1.TileKeyUtils.geoRectangleToTileKeys(this, geoBox, level);
    }
    /**
     * Returns the bounding box in geo coordinates for the given [[TileKey]].
     *
     * @param tileKey The `TileKey`.
     */
    getGeoBox(tileKey) {
        return this.boundingBoxGenerator.getGeoBox(tileKey);
    }
    /**
     * Returns the bounding box in world coordinates.
     *
     * @param tileKey The `TileKey`.
     * @param result The optional object that will contain the resulting bounding box.
     */
    getWorldBox(tileKey, result) {
        return this.boundingBoxGenerator.getWorldBox(tileKey, result);
    }
}
exports.TilingScheme = TilingScheme;


/***/ }),

/***/ "../harp-geoutils/lib/tiling/WebMercatorTilingScheme.ts":
/*!**************************************************************!*\
  !*** ../harp-geoutils/lib/tiling/WebMercatorTilingScheme.ts ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const MercatorProjection_1 = __webpack_require__(/*! ../projection/MercatorProjection */ "../harp-geoutils/lib/projection/MercatorProjection.ts");
const QuadTreeSubdivisionScheme_1 = __webpack_require__(/*! ./QuadTreeSubdivisionScheme */ "../harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.ts");
const TilingScheme_1 = __webpack_require__(/*! ./TilingScheme */ "../harp-geoutils/lib/tiling/TilingScheme.ts");
/**
 * A [[TilingScheme]] featuring quadtree subdivision scheme and web Mercator projection.
 */
exports.webMercatorTilingScheme = new TilingScheme_1.TilingScheme(QuadTreeSubdivisionScheme_1.quadTreeSubdivisionScheme, MercatorProjection_1.webMercatorProjection);


/***/ }),

/***/ "../harp-lines/index.ts":
/*!******************************!*\
  !*** ../harp-lines/index.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/Lines */ "../harp-lines/lib/Lines.ts"));
__export(__webpack_require__(/*! ./lib/TriangulateLines */ "../harp-lines/lib/TriangulateLines.ts"));
__export(__webpack_require__(/*! ./lib/HighPrecisionLines */ "../harp-lines/lib/HighPrecisionLines.ts"));
__export(__webpack_require__(/*! ./lib/HighPrecisionUtils */ "../harp-lines/lib/HighPrecisionUtils.ts"));


/***/ }),

/***/ "../harp-lines/lib/HighPrecisionLines.ts":
/*!***********************************************!*\
  !*** ../harp-lines/lib/HighPrecisionLines.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const HighPrecisionUtils_1 = __webpack_require__(/*! ./HighPrecisionUtils */ "../harp-lines/lib/HighPrecisionUtils.ts");
/**
 * Class used to render high-precision wireframe lines.
 */
class HighPrecisionWireFrameLine extends THREE.Line {
    /**
     * Creates a `HighPrecisionWireFrameLine` object.
     *
     * @param geometry [[BufferGeometry]] used to render this object.
     * @param material [[HighPrecisionLineMaterial]] used to render this object.
     *     instances.
     * @param positions Array of 2D/3D positions.
     * @param color Color of the rendered line.
     * @param opacity Opacity of the rendered line.
     */
    constructor(geometry, material, positions, color, opacity) {
        super(geometry === undefined ? new THREE.BufferGeometry() : geometry, material);
        if (material === undefined) {
            material = new harp_materials_1.HighPrecisionLineMaterial({
                color: color ? color : harp_materials_1.HighPrecisionLineMaterial.DEFAULT_COLOR,
                opacity: opacity !== undefined ? opacity : harp_materials_1.HighPrecisionLineMaterial.DEFAULT_OPACITY
            });
        }
        this.matrixWorldInverse = new THREE.Matrix4();
        if (positions) {
            this.setPositions(positions);
        }
    }
    get bufferGeometry() {
        return this.geometry;
    }
    get shaderMaterial() {
        return this.material;
    }
    setPositions(positions) {
        HighPrecisionUtils_1.HighPrecisionUtils.setPositions(this, positions);
    }
    setupForRendering() {
        this.onBeforeRender = (_renderer, _scene, camera, _geometry, _material, _group) => {
            HighPrecisionUtils_1.HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);
        };
    }
    updateMatrixWorld(force) {
        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;
        super.updateMatrixWorld(force);
        if (doUpdateMatrixWorldInverse) {
            this.matrixWorldInverse.getInverse(this.matrixWorld);
        }
    }
}
exports.HighPrecisionWireFrameLine = HighPrecisionWireFrameLine;
/**
 * Class used to render high-precision lines.
 */
class HighPrecisionLine extends THREE.Mesh {
    /**
     * Creates a `HighPrecisionLine` object.
     *
     * @param geometry [[BufferGeometry]] used to render this object.
     * @param material [[HighPrecisionLineMaterial]] used to render this object.
     *     instances.
     * @param positions Array of 2D/3D positions.
     * @param color Color of the rendered line.
     * @param opacity Opacity of the rendered line.
     */
    constructor(geometry, material, positions, color, opacity) {
        super(geometry === undefined ? new THREE.BufferGeometry() : geometry, material);
        if (material === undefined) {
            material = new harp_materials_1.HighPrecisionLineMaterial({
                color: color ? color : harp_materials_1.HighPrecisionLineMaterial.DEFAULT_COLOR,
                opacity: opacity !== undefined ? opacity : harp_materials_1.HighPrecisionLineMaterial.DEFAULT_OPACITY
            });
        }
        this.matrixWorldInverse = new THREE.Matrix4();
        if (positions) {
            this.setPositions(positions);
        }
    }
    get bufferGeometry() {
        return this.geometry;
    }
    get shaderMaterial() {
        return this.material;
    }
    setPositions(positions) {
        HighPrecisionUtils_1.HighPrecisionUtils.setPositions(this, positions);
    }
    setupForRendering() {
        this.onBeforeRender = (_renderer, _scene, camera, _geometry, _material, _group) => {
            HighPrecisionUtils_1.HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);
        };
    }
    updateMatrixWorld(force) {
        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;
        super.updateMatrixWorld(force);
        if (doUpdateMatrixWorldInverse) {
            this.matrixWorldInverse.getInverse(this.matrixWorld);
        }
    }
}
exports.HighPrecisionLine = HighPrecisionLine;


/***/ }),

/***/ "../harp-lines/lib/HighPrecisionPoints.ts":
/*!************************************************!*\
  !*** ../harp-lines/lib/HighPrecisionPoints.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const HighPrecisionUtils_1 = __webpack_require__(/*! ./HighPrecisionUtils */ "../harp-lines/lib/HighPrecisionUtils.ts");
/**
 * Class used to render high-precision points.
 */
class HighPrecisionPoints extends THREE.Points {
    /**
     * Creates a `HighPrecisionPoints` object.
     *
     * @param geometry [[BufferGeometry]] used to render this object.
     * @param material [[HighPrecisionLineMaterial]] used to render this object.
     *     instances.
     * @param positions Array of 2D/3D positions.
     * @param color Color of the rendered point.
     * @param opacity Opacity of the rendered point.
     */
    constructor(geometry, material, positions, color, opacity) {
        if (material === undefined) {
            material = new harp_materials_1.HighPrecisionPointMaterial({
                color: color ? color : harp_materials_1.HighPrecisionPointMaterial.DEFAULT_COLOR,
                opacity: opacity !== undefined ? opacity : 1
            });
        }
        super(geometry === undefined ? new THREE.BufferGeometry() : geometry, material);
        this.matrixWorldInverse = new THREE.Matrix4();
        if (positions) {
            this.setPositions(positions);
        }
    }
    get bufferGeometry() {
        return this.geometry;
    }
    /**
     * Clears the [[BufferGeometry]] used to render this point.
     */
    clearGeometry() {
        return (this.geometry = new THREE.BufferGeometry());
    }
    get shaderMaterial() {
        return this.material;
    }
    setPositions(positions) {
        HighPrecisionUtils_1.HighPrecisionUtils.setPositions(this, positions);
    }
    setupForRendering() {
        if (this.material.isHighPrecisionPointsMaterial &&
            this.dimensionality !== undefined) {
            this.material.setDimensionality(this.dimensionality);
        }
        this.onBeforeRender = (_renderer, _scene, camera, _geometry, _material, _group) => {
            HighPrecisionUtils_1.HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);
        };
    }
    updateMatrixWorld(force) {
        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;
        super.updateMatrixWorld(force);
        if (doUpdateMatrixWorldInverse) {
            this.matrixWorldInverse.getInverse(this.matrixWorld);
        }
    }
}
exports.HighPrecisionPoints = HighPrecisionPoints;


/***/ }),

/***/ "../harp-lines/lib/HighPrecisionUtils.ts":
/*!***********************************************!*\
  !*** ../harp-lines/lib/HighPrecisionUtils.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const three_1 = __webpack_require__(/*! three */ "three");
const HPL = __webpack_require__(/*! ./HighPrecisionLines */ "../harp-lines/lib/HighPrecisionLines.ts");
const HPP = __webpack_require__(/*! ./HighPrecisionPoints */ "../harp-lines/lib/HighPrecisionPoints.ts");
const TriangulateLines_1 = __webpack_require__(/*! ./TriangulateLines */ "../harp-lines/lib/TriangulateLines.ts");
var HighPrecisionUtils;
(function (HighPrecisionUtils) {
    /**
     * Extract the `float` parts of all vector members, Making this a `Vector3` of `float`.
     * precision.
     *
     * @param v
     */
    function doubleToFloatVec(v) {
        return new three_1.Vector3(Math.fround(v.x), Math.fround(v.y), Math.fround(v.z));
    }
    HighPrecisionUtils.doubleToFloatVec = doubleToFloatVec;
    /**
     * Convert a `Vector3` to `float` (in place!) Returns the minor float vector, which is the
     * difference of the double elements and their float counterparts.
     *
     * @param v Vector3 to convert to float IN-PLACE!
     */
    function makeFloatVec(v) {
        const majorX = Math.fround(v.x);
        const majorY = Math.fround(v.y);
        const majorZ = Math.fround(v.z);
        const minorVec = new three_1.Vector3(v.x - majorX, v.y - majorY, v.z - majorZ);
        v.x = Math.fround(majorX);
        v.y = Math.fround(majorY);
        v.z = Math.fround(majorZ);
        return minorVec;
    }
    HighPrecisionUtils.makeFloatVec = makeFloatVec;
    /**
     * Calculate high-precision camera position used in vertex shader of high-precision materials.
     *
     * @param camera Camera used to get the high-precision position.
     * @param objectInverseWorldMatrix Inverse World Matrix of the rendered [[HighPrecisionObject]].
     */
    function createHighPrecisionCameraPos(camera, objectInverseWorldMatrix) {
        const _projScreenMatrix = new three_1.Matrix4().copy(camera.projectionMatrix);
        const mvp = _projScreenMatrix.multiply(camera.matrixWorldInverse);
        const eyePos = new three_1.Vector3(0, 0, 0).applyMatrix4(objectInverseWorldMatrix);
        // split the double float vector into hi and lo parts
        const eyePosFloat = doubleToFloatVec(eyePos);
        const eyePosLo = doubleToFloatVec(eyePos.sub(eyePosFloat));
        return {
            viewProjection: mvp,
            eyePosHi: eyePosFloat,
            eyePosLo
        };
    }
    HighPrecisionUtils.createHighPrecisionCameraPos = createHighPrecisionCameraPos;
    /**
     * Updates the high-precision uniform data of a material used to render a
     * [[HighPrecisionObject]].
     *
     * @param object [[HighPrecisionObject]] used for rendering.
     * @param camera Camera used to get the high-precision position.
     * @param shaderMaterial Material which uniforms will be updated.
     */
    function updateHpUniforms(object, camera, shaderMaterial) {
        const highPrecisionCameraInfo = createHighPrecisionCameraPos(camera, object.matrixWorldInverse);
        const mvp = highPrecisionCameraInfo.viewProjection;
        if (shaderMaterial !== undefined && shaderMaterial.isMaterial) {
            if (shaderMaterial.uniforms &&
                shaderMaterial.uniforms.u_mvp &&
                shaderMaterial.uniforms.u_eyepos &&
                shaderMaterial.uniforms.u_eyepos_lowpart) {
                shaderMaterial.uniforms.u_mvp.value = new Float32Array(mvp.elements);
                shaderMaterial.uniforms.u_eyepos.value = new Float32Array(highPrecisionCameraInfo.eyePosHi.toArray());
                shaderMaterial.uniforms.u_eyepos_lowpart.value = new Float32Array(highPrecisionCameraInfo.eyePosLo.toArray());
            }
            else {
                throw Error("High pecision material has missing uniforms");
            }
        }
        else {
            throw Error("High pecision line has no high precision material");
        }
    }
    HighPrecisionUtils.updateHpUniforms = updateHpUniforms;
    /**
     * Assembles the necessary attribute buffers needed to render [[HighPrecisionObject]].
     *
     * @param positions Array of positions.
     */
    function createAttributes(positions) {
        if (positions.length > 0) {
            const v = positions[0];
            if (v === undefined || v === null) {
                throw Error("Empty element in positions");
            }
            const positionVec = new Array();
            const positionVecLow = new Array();
            const addHPValue = (...values) => {
                for (const value of values) {
                    const major = Math.fround(value);
                    positionVecLow.push(value - major);
                    positionVec.push(major);
                }
            };
            const addHPVector = (vec) => {
                addHPValue(vec.x, vec.y, vec.z);
            };
            const vAny = v;
            if (vAny.z !== undefined) {
                positions.forEach(vec => {
                    addHPVector(vec);
                });
            }
            else {
                if (positionVec.length % 3 !== 0) {
                    throw Error("Positions must be 3D, not 2D");
                }
                positions.forEach((n) => {
                    addHPValue(n);
                });
            }
            return {
                positionHigh: new three_1.Float32BufferAttribute(positionVec, 3),
                positionLow: new three_1.Float32BufferAttribute(positionVecLow, 3)
            };
        }
        else {
            return {
                positionHigh: new three_1.Float32BufferAttribute([], 3),
                positionLow: new three_1.Float32BufferAttribute([], 3)
            };
        }
    }
    HighPrecisionUtils.createAttributes = createAttributes;
    /**
     * Assembles an interleaved buffer containing the position attribute data for a
     * [[HighPrecisionObject]].
     *
     * @param positions Array of positions.
     * @param stride Stride of the elements in the `positions` array.
     * @param positionOffset Offset into the `positions` array.
     */
    function addInterleavedAttributes3(positions, stride, positionOffset = 0) {
        const newPositions = new Array();
        const end = positions.length;
        for (let i = 0; i < end; i += stride) {
            for (let j = 0; j < positionOffset; j++) {
                newPositions.push(positions[i + j]);
            }
            const x = positions[i + positionOffset];
            const y = positions[i + positionOffset + 1];
            const z = positions[i + positionOffset + 2];
            const majorX = Math.fround(x);
            const minorX = x - majorX;
            const majorY = Math.fround(y);
            const minorY = y - majorY;
            const majorZ = Math.fround(z);
            const minorZ = z - majorZ;
            // insert values in interleaved buffer
            newPositions.push(majorX, majorY, majorZ, minorX, minorY, minorZ);
            for (let j = positionOffset + 3; j < stride; j++) {
                newPositions.push(positions[i + j]);
            }
        }
        return newPositions;
    }
    HighPrecisionUtils.addInterleavedAttributes3 = addInterleavedAttributes3;
    /**
     * Adds the high-precision position attribute data to a [[HighPrecisionObject]].
     *
     * @param object [[HighPrecisionObject]] which position attribute will be set.
     * @param positions Array of positions.
     */
    function setPositions(object, positions) {
        const attributes = createAttributes(positions);
        object.bufferGeometry.setAttribute("position", attributes.positionHigh);
        object.bufferGeometry.setAttribute("positionLow", attributes.positionLow);
        return attributes.positionHigh.itemSize;
    }
    HighPrecisionUtils.setPositions = setPositions;
    /**
     * Convert positions from `Array<Vector3>` to `Array<number>`.
     *
     * @param positions Array of positions.
     */
    function convertPositions(positions) {
        if (positions.length <= 0) {
            return { positions: [] };
        }
        const v = positions[0];
        if (v === undefined || v === null) {
            throw Error("Empty element in positions");
        }
        const vAny = v;
        if (vAny.y === undefined && vAny.z === undefined) {
            return { positions: positions };
        }
        const returnPositions = new Array();
        positions.forEach(vec => {
            returnPositions.push(vec.x, vec.y, vec.z);
        });
        return { positions: returnPositions };
    }
    HighPrecisionUtils.convertPositions = convertPositions;
    /**
     * Creates a [[HighPrecisionLine]] or [[HighPrecisionWireFrameLine]] object.
     *
     * @param linePositions Array of 2D/3D positions.
     * @param params Parameters used to configure the created [[HighPrecisionObject]].
     */
    function createLine(linePositions, params) {
        const lineWidth = params.lineWidth !== undefined ? params.lineWidth : 5;
        const addCircles = params.addCircles !== undefined ? params.addCircles : false;
        const wireFrame = params.wireFrame !== undefined ? params.wireFrame : false;
        const positions = [];
        const indices = [];
        TriangulateLines_1.triangulateLine(linePositions, lineWidth, positions, indices, addCircles);
        const hpLineGeometry = new three_1.BufferGeometry();
        const hpPositions = addInterleavedAttributes3(positions, 3);
        const buffer = new three_1.InterleavedBuffer(new Float32Array(hpPositions), 6);
        const positionAttribute = new three_1.InterleavedBufferAttribute(buffer, 3, 0, false);
        const positionLowAttribute = new three_1.InterleavedBufferAttribute(buffer, 3, 3, false);
        hpLineGeometry.setAttribute("position", positionAttribute);
        hpLineGeometry.setAttribute("positionLow", positionLowAttribute);
        hpLineGeometry.setIndex(new three_1.BufferAttribute(new Uint32Array(indices), 1));
        const hpSolidMaterial = new harp_materials_1.HighPrecisionLineMaterial(params);
        const lineObject = wireFrame
            ? new HPL.HighPrecisionWireFrameLine(hpLineGeometry, hpSolidMaterial)
            : new HPL.HighPrecisionLine(hpLineGeometry, hpSolidMaterial);
        lineObject.setupForRendering();
        return lineObject;
    }
    HighPrecisionUtils.createLine = createLine;
    /**
     * Creates a group of [[HighPrecisionPoints]].
     *
     * @param pointPositions Array of 2D/3D positions.
     * @param materialParameters Parameters used to configure the material used to render the
     * created [[HighPrecisionPoints]].
     */
    function createPoints(pointPositions, materialParameters) {
        const indices = [];
        // tslint:disable-next-line:prefer-for-of - pointPositions doesn't have iterable interface
        for (let i = 0; i < pointPositions.length; i++) {
            indices.push(indices.length / 3);
        }
        const hpPointsGeometry = new three_1.BufferGeometry();
        const hpPointsMaterial = harp_materials_1.isHighPrecisionPointMaterial(materialParameters)
            ? materialParameters
            : new harp_materials_1.HighPrecisionPointMaterial(materialParameters);
        const pointsObject = new HPP.HighPrecisionPoints(hpPointsGeometry, hpPointsMaterial);
        setPositions(pointsObject, pointPositions);
        pointsObject.setupForRendering();
        return pointsObject;
    }
    HighPrecisionUtils.createPoints = createPoints;
})(HighPrecisionUtils = exports.HighPrecisionUtils || (exports.HighPrecisionUtils = {}));


/***/ }),

/***/ "../harp-lines/lib/Lines.ts":
/*!**********************************!*\
  !*** ../harp-lines/lib/Lines.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const THREE = __webpack_require__(/*! three */ "three");
// Preallocate temp variables used during line generation.
const tmpV = new THREE.Vector3();
const tmpNormal = new THREE.Vector3();
const tmpTangent0 = new THREE.Vector3();
const tmpTangent1 = new THREE.Vector3();
const tmpBitangent = new THREE.Vector3();
const SEGMENT_OFFSET = 0.1;
/**
 * Declares all the vertex attributes used for rendering a line using the [[SolidLineMaterial]].
 */
/** Base line vertex attributes. */
const LINE_VERTEX_ATTRIBUTES = {
    attributes: [
        // The "extrusionCoord" is a vec4 which represents:
        // xy: Extrusion coordinates
        // sign(xy): Extrusion direction
        // z: Line length
        { name: "extrusionCoord", itemSize: 3, offset: 0 },
        { name: "position", itemSize: 3, offset: 3 },
        { name: "tangent", itemSize: 3, offset: 6 },
        { name: "bitangent", itemSize: 4, offset: 9 }
    ],
    stride: 13
};
/** Optional normal and uv coordinates. */
const NORMAL_UV_VERTEX_ATTRIBUTES = {
    attributes: [
        { name: "uv", itemSize: 2, offset: LINE_VERTEX_ATTRIBUTES.stride },
        { name: "normal", itemSize: 3, offset: LINE_VERTEX_ATTRIBUTES.stride + 2 }
    ],
    stride: 5
};
/** Base line vertex attributes plus normals and uv coordinates. */
const LINE_VERTEX_ATTRIBUTES_NUV = {
    attributes: [...LINE_VERTEX_ATTRIBUTES.attributes, ...NORMAL_UV_VERTEX_ATTRIBUTES.attributes],
    stride: LINE_VERTEX_ATTRIBUTES.stride + NORMAL_UV_VERTEX_ATTRIBUTES.stride
};
/**
 * Declares all the vertex attributes used for rendering a line using the
 * [[HighPrecisionLineMaterial]].
 */
const HP_LINE_VERTEX_ATTRIBUTES = {
    attributes: [
        { name: "extrusionCoord", itemSize: 2, offset: 0 },
        { name: "position", itemSize: 3, offset: 2 },
        { name: "positionLow", itemSize: 3, offset: 5 },
        { name: "tangent", itemSize: 3, offset: 8 },
        { name: "bitangent", itemSize: 4, offset: 11 }
    ],
    stride: 15
};
/** High precision line vertex attributes plus normals and uv coordinates. */
const HP_LINE_VERTEX_ATTRIBUTES_NUV = {
    attributes: [
        ...HP_LINE_VERTEX_ATTRIBUTES.attributes,
        ...NORMAL_UV_VERTEX_ATTRIBUTES.attributes
    ],
    stride: HP_LINE_VERTEX_ATTRIBUTES.stride + NORMAL_UV_VERTEX_ATTRIBUTES.stride
};
/**
 * Class that holds the vertex and index attributes for a [[Lines]] object.
 */
class LineGeometry {
    constructor() {
        this.vertices = [];
        this.vertexColors = [];
        this.indices = [];
    }
}
exports.LineGeometry = LineGeometry;
function getVertexDescriptor(hasNormalsAndUvs, highPrecision) {
    if (highPrecision) {
        return hasNormalsAndUvs ? HP_LINE_VERTEX_ATTRIBUTES_NUV : HP_LINE_VERTEX_ATTRIBUTES;
    }
    else {
        return hasNormalsAndUvs ? LINE_VERTEX_ATTRIBUTES_NUV : LINE_VERTEX_ATTRIBUTES;
    }
}
/**
 * Creates a [[LineGeometry]] object out of a polyline.
 *
 * @param center Center of the polyline.
 * @param polyline Array of `numbers` describing a polyline.
 * @param offsets Array of `numbers` representing line segment offsets.
 * @param uvs Array of `numbers` representing texture coordinates.
 * @param colors Array of `numbers` describing a polyline's colors.
 * @param geometry [[LineGeometry]] object used to store the vertex and index attributes.
 * @param highPrecision If `true` will create high-precision vertex information.
 */
function createLineGeometry(center, polyline, projection, offsets, uvs, colors, geometry = new LineGeometry(), highPrecision = false) {
    if (polyline.length === 0) {
        return geometry;
    }
    const stride = getVertexDescriptor(uvs !== undefined, highPrecision).stride;
    const pointCount = polyline.length / 3;
    const segments = new Array(pointCount);
    const tangents = new Array(polyline.length - 3);
    const baseVertex = geometry.vertices.length / stride;
    const hasSegmentOffsets = offsets !== undefined && offsets.length > 0;
    const hasTexCoords = uvs !== undefined && uvs.length > 0;
    const vertexColors = colors !== undefined && colors.length && polyline.length;
    harp_utils_1.assert(!hasSegmentOffsets || offsets.length === pointCount);
    harp_utils_1.assert(!hasTexCoords || uvs.length / 2 === pointCount);
    harp_utils_1.assert(!vertexColors || colors.length === polyline.length);
    // Compute segments and tangents.
    let sum = SEGMENT_OFFSET;
    segments[0] = sum;
    for (let i = 0; i < pointCount - 1; ++i) {
        let sqrLength = 0;
        for (let j = 0; j < 3; ++j) {
            const d = polyline[(i + 1) * 3 + j] - polyline[i * 3 + j];
            tangents[i * 3 + j] = d;
            sqrLength += d * d;
        }
        const len = Math.sqrt(sqrLength);
        sum = sum + len;
        segments[i + 1] = sum;
    }
    const lineCoverage = hasSegmentOffsets
        ? Math.abs(offsets[offsets.length - 1] - offsets[0])
        : 1.0;
    const lineLength = segments[segments.length - 1] / lineCoverage;
    // Override the segments if offsets are explicitly provided.
    if (hasSegmentOffsets) {
        for (let i = 0; i < pointCount; ++i) {
            segments[i] = offsets[i] * lineLength + SEGMENT_OFFSET;
        }
    }
    // Check if we're working with a closed line.
    let isClosed = true;
    for (let j = 0; j < 3; ++j) {
        isClosed = isClosed && polyline[j] === polyline[polyline.length - 3 + j];
    }
    const tmpVertices = [];
    const addVertexPair = (i, T1, T2, segment, extrusionCoord) => {
        tmpVertices.length = 0;
        // Store the segment and extrusionCoord attributes.
        geometry.vertices.push(segment, extrusionCoord * -1, lineLength);
        tmpVertices.push(segment, extrusionCoord * 1, lineLength);
        // Store the position attribute (component-dependant).
        for (let j = 0; j < 3; ++j) {
            if (!highPrecision) {
                geometry.vertices.push(polyline[i * 3 + j]);
                tmpVertices.push(polyline[i * 3 + j]);
            }
            else {
                const highComp = Math.fround(polyline[i * 3 + j]);
                const lowComp = polyline[i * 3 + j] - highComp;
                geometry.vertices.push(highComp, lowComp);
                tmpVertices.push(highComp, lowComp);
            }
            tmpNormal.setComponent(j, polyline[i * 3 + j]);
        }
        // Store the bitangent attribute (component-dependant).
        for (let j = 0; j < 3; ++j) {
            tmpTangent0.setComponent(j, tangents[T1 + j]);
            tmpTangent1.setComponent(j, tangents[T2 + j]);
        }
        tmpTangent0.normalize();
        geometry.vertices.push(tmpTangent0.x, tmpTangent0.y, tmpTangent0.z);
        tmpVertices.push(tmpTangent0.x, tmpTangent0.y, tmpTangent0.z);
        tmpNormal.add(center); // tmpNormal contains world position
        projection.surfaceNormal(tmpNormal, tmpNormal);
        const angle = computeBitangent(tmpNormal, tmpTangent0, tmpTangent1.normalize(), tmpBitangent);
        geometry.vertices.push(tmpBitangent.x, tmpBitangent.y, tmpBitangent.z, angle);
        tmpVertices.push(tmpBitangent.x, tmpBitangent.y, tmpBitangent.z, angle);
        if (hasTexCoords) {
            // uvs
            geometry.vertices.push(uvs[i * 2], uvs[i * 2 + 1]);
            tmpVertices.push(uvs[i * 2], uvs[i * 2 + 1]);
            // normals
            geometry.vertices.push(tmpNormal.x, tmpNormal.y, tmpNormal.z);
            tmpVertices.push(tmpNormal.x, tmpNormal.y, tmpNormal.z);
        }
        geometry.vertices.push(...tmpVertices);
        // Add vertex colors (if supplied).
        if (vertexColors) {
            geometry.vertexColors.push(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);
            geometry.vertexColors.push(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);
        }
    };
    for (let i = 0; i < pointCount; ++i) {
        // Retrieve the per-point tangents.
        const T1 = isClosed && i === 0 ? tangents.length - 3 : Math.max(0, i - 1) * 3;
        const T2 = isClosed && i === pointCount - 1 ? 0 : Math.min(i * 3, tangents.length - 3);
        // Process v0 and v1.
        if (i > 0) {
            addVertexPair(i, T1, T2, segments[i - 1], segments[i]);
        }
        // Process v2 and v3.
        if (i + 1 < pointCount) {
            addVertexPair(i, T1, T2, segments[Math.min(i, segments.length - 1)] * -1, segments[Math.min(i + 1, segments.length - 1)]);
        }
    }
    // Store the triangle indices in the final index buffer.
    for (let i = 0; i < pointCount - 1; ++i) {
        const base = baseVertex + i * 4;
        geometry.indices.push(base, base + 1, base + 2, base + 2, base + 1, base + 3);
    }
    return geometry;
}
exports.createLineGeometry = createLineGeometry;
/**
 * Creates a [[LineGeometry]] object out of a polyline.
 *
 * @param polyline Array of `numbers` describing a polyline.
 * @param colors Array of `numbers` describing a polyline's colors.
 * @param geometry [[LineGeometry]] object used to store the vertex and index attributes.
 */
function createSimpleLineGeometry(polyline, colors, geometry = new LineGeometry()) {
    if (polyline.length === 0) {
        return geometry;
    }
    const pointCount = polyline.length / 3;
    let index = geometry.vertices.length / 3;
    const vertexColors = colors !== undefined && colors.length && polyline.length;
    for (let i = 0; i < pointCount; ++i, index++) {
        if (i > 0) {
            geometry.indices.push(index);
        }
        if (i < pointCount - 1) {
            geometry.indices.push(index);
        }
        for (let j = 0; j < 3; ++j) {
            geometry.vertices.push(polyline[i * 3 + j]);
            if (vertexColors) {
                geometry.vertexColors.push(colors[i * 3 + j]);
            }
        }
    }
    return geometry;
}
exports.createSimpleLineGeometry = createSimpleLineGeometry;
/**
 * Class used to render groups (or batches) of width-variable lines (in the same tile).
 */
class LineGroup {
    constructor(hasNormalsAndUvs = false, highPrecision = false, isSimple = false) {
        this.hasNormalsAndUvs = hasNormalsAndUvs;
        this.highPrecision = highPrecision;
        this.isSimple = isSimple;
        this.m_geometry = new LineGeometry();
    }
    /**
     * Adds all the attribute data needed to a [[BufferGeometry]] object for rendering `Lines`.
     *
     * @param vertices Array of vertex attributes.
     * @param colors Array of vertex colors.
     * @param indices Array of vertex indices.
     * @param geometry [[BufferGeometry]] object which will store all the `Lines` attribute data.
     * @param hasNormalsAnUvs Whether vertices have normal and uv coordinates as attributes.
     * @param highPrecision If `true` will create high-precision vertex information.
     * @param isSimple `true` to create simple (nonsolid, nonextruded) lines. Defaults to `false`.
     */
    static createGeometry(vertices, colors, indices, geometry, hasNormalsAndUvs = false, highPrecision = false, isSimple = false) {
        if (isSimple) {
            geometry.setAttribute("position", new THREE.BufferAttribute(new Float32Array(vertices), 3));
            if (colors.length === vertices.length) {
                geometry.setAttribute("color", new THREE.BufferAttribute(new Float32Array(colors), 3));
            }
            geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));
            return geometry;
        }
        else {
            const vertexDescriptor = getVertexDescriptor(hasNormalsAndUvs, highPrecision);
            const buffer = new THREE.InterleavedBuffer(new Float32Array(vertices), vertexDescriptor.stride);
            vertexDescriptor.attributes.forEach(descr => {
                const attribute = new THREE.InterleavedBufferAttribute(buffer, descr.itemSize, descr.offset, false);
                geometry.setAttribute(descr.name, attribute);
            });
            if (colors.length === vertices.length) {
                geometry.setAttribute("color", new THREE.BufferAttribute(new Float32Array(colors), 3));
            }
            geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));
            return geometry;
        }
    }
    /**
     * Clears the list of line strips.
     */
    clear() {
        this.m_geometry.vertices = [];
        this.m_geometry.vertexColors = [];
        this.m_geometry.indices = [];
    }
    /**
     * Add the given points to this line group.
     *
     * @param center World center of the provided points.
     * @param points Sequence of (x,y,z) coordinates.
     * @param offsets Sequence of line segment offsets.
     * @param uvs Sequence of (u,v) texture coordinates.
     * @param colors Sequence of (r,g,b) color components.
     */
    add(center, points, projection, offsets, uvs, colors) {
        if (!this.isSimple) {
            harp_utils_1.assert(!this.hasNormalsAndUvs || uvs !== undefined);
            createLineGeometry(center, points, projection, offsets, uvs, colors, this.m_geometry, this.highPrecision);
        }
        else {
            createSimpleLineGeometry(points, colors, this.m_geometry);
        }
        return this;
    }
    /**
     * Returns the list of vertices.
     */
    get vertices() {
        return this.m_geometry.vertices;
    }
    /**
     * Returns the list of vertex colors.
     */
    get vertexColors() {
        return this.m_geometry.vertexColors;
    }
    /**
     * Returns the list of indices.
     */
    get indices() {
        return this.m_geometry.indices;
    }
    /**
     * Returns the list of [[VertexAttributeDescriptor]]s.
     */
    get vertexAttributes() {
        return getVertexDescriptor(this.hasNormalsAndUvs, this.highPrecision).attributes;
    }
    /**
     * Returns the vertex attribute stride.
     */
    get stride() {
        return getVertexDescriptor(this.hasNormalsAndUvs, this.highPrecision).stride;
    }
    /**
     * Creates a three.js geometry.
     */
    createGeometry(geometry) {
        if (geometry === undefined) {
            geometry = new THREE.BufferGeometry();
        }
        return LineGroup.createGeometry(this.m_geometry.vertices, this.m_geometry.vertexColors, this.m_geometry.indices, geometry, this.hasNormalsAndUvs, this.highPrecision);
    }
}
exports.LineGroup = LineGroup;
function computeBitangent(n, t0, t1, bt) {
    let angle = 0;
    if (!t0.equals(t1)) {
        angle = Math.acos(t0.dot(t1)) * Math.sign(n.dot(tmpV.copy(t0).cross(t1)));
        if (Number.isNaN(angle)) {
            angle = 0;
        }
    }
    bt.copy(t0)
        .add(t1)
        .normalize()
        .cross(n)
        .normalize();
    return angle;
}


/***/ }),

/***/ "../harp-lines/lib/TriangulateLines.ts":
/*!*********************************************!*\
  !*** ../harp-lines/lib/TriangulateLines.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const UNIT_Z = new THREE.Vector3(0, 0, 1);
const POINTS = [0, 1, 2, 1, 3, 2];
const BEVEL_POINTS = [0, 1, 3, 3, 1, 2, 0, 3, 4, 5, 4, 3];
const SECTORS_IN_CIRCLE = 8;
const STEP = Math.PI / SECTORS_IN_CIRCLE;
/**
 * Adds a half-circle geometry to original line
 *
 * @param x The line end X (used as circle center X)
 * @param y The line end Y (used as circle center Y)
 * @param lineAngle The cap incline angle
 * @param radius The cap (circle) radius
 * @param vertices The input vertex buffer (cap vertices are added there)
 * @param indices The input index buffer (cap indices are is added there)
 */
function addCircle(x, y, lineAngle, radius, vertices, indices) {
    const baseVertex = vertices.length / 3;
    // Add cap center to vertices directly (it doesn't need rotation)
    vertices.push(x, y, 0);
    for (let i = 0; i < SECTORS_IN_CIRCLE + 1; ++i) {
        const angle = STEP * i + Math.PI / 2 + lineAngle; // Start angle is -90deg
        vertices.push(x + radius * Math.cos(angle), y + radius * Math.sin(angle), 0);
        indices.push(baseVertex, baseVertex + i + 1, baseVertex + ((i + 1) % (SECTORS_IN_CIRCLE + 1)) + 1);
    }
}
/**
 * Returns the number of points in circle used for caps.
 *
 * @param lineWidth Width of line.
 */
// tslint:disable-next-line:no-unused-variable
function numCirclePoints(lineWidth) {
    return SECTORS_IN_CIRCLE + 1;
}
exports.numCirclePoints = numCirclePoints;
/**
 * Create a triangle mesh from the given polyline.
 *
 * @param points Sequence of (x,y,z) coordinates.
 * @param width The width of the extruded line.
 * @param vertices The output vertex buffer.
 * @param indices The output index buffer.
 * @param startWithCircle `true` if the line should start will a circle.
 * @param endWithCircle `true` if the line should end with a circle.
 */
function triangulateLine(points, width, vertices, indices, startWithCircle = true, endWithCircle = startWithCircle) {
    if (points.length < 3) {
        return;
    }
    // This vector is used for computing cap angle
    const angleVec = new THREE.Vector2();
    if (startWithCircle) {
        // Define lineAngle as (direction - origin) vector angle to X axis
        const lineAngle = points.length !== 3
            ? angleVec.set(points[3] - points[0], points[4] - points[1]).angle()
            : 0;
        addCircle(points[0], points[1], lineAngle, width, vertices, indices);
    }
    const baseVertex = vertices.length / 3;
    // bt = Bitangent (i.e. extrusion vector)
    const prevBt = new THREE.Vector3();
    const p = new THREE.Vector3(); // current point
    const n = new THREE.Vector3(); // next point
    const bt = new THREE.Vector3();
    const averageBt = new THREE.Vector3();
    const p0 = new THREE.Vector3();
    const p1 = new THREE.Vector3();
    const p2 = new THREE.Vector3();
    const p3 = new THREE.Vector3();
    const N = points.length / 3;
    let vertexOffset = 0;
    for (let i = 0; i < N; ++i) {
        let useBevel = false;
        p.set(points[i * 3], points[i * 3 + 1], points[i * 3 + 2]);
        if (i + 1 < N) {
            n.set(points[(i + 1) * 3], points[(i + 1) * 3 + 1], points[(i + 1) * 3 + 2]);
            bt.copy(n)
                .sub(p)
                .normalize()
                .cross(UNIT_Z);
            averageBt.copy(bt);
            if (i > 0) {
                averageBt.add(prevBt).multiplyScalar(1.0 - 0.5 * bt.dot(prevBt));
                useBevel = prevBt.angleTo(bt) > Math.PI / 2;
                if (useBevel) {
                    const inclineWidth = width / Math.cos(bt.angleTo(prevBt) / 2);
                    p0.copy(bt)
                        .add(prevBt)
                        .normalize()
                        .multiplyScalar(-inclineWidth)
                        .add(p);
                    p1.copy(prevBt)
                        .multiplyScalar(width)
                        .add(p);
                    // p2 is used for "miter" connections
                    p2.copy(bt)
                        .add(prevBt)
                        .normalize()
                        .multiplyScalar(inclineWidth)
                        .add(p);
                    p3.copy(bt)
                        .multiplyScalar(width)
                        .add(p);
                }
            }
            if (useBevel) {
                vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z, p2.x, p2.y, p2.z, p3.x, p3.y, p3.z);
            }
            else {
                p0.copy(averageBt)
                    .multiplyScalar(-width)
                    .add(p);
                p1.copy(averageBt)
                    .multiplyScalar(width)
                    .add(p);
                vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);
            }
            prevBt.copy(bt);
        }
        else {
            p0.copy(prevBt)
                .multiplyScalar(-width)
                .add(p);
            p1.copy(prevBt)
                .multiplyScalar(width)
                .add(p);
            vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);
        }
        if (i !== N - 1) {
            (useBevel ? BEVEL_POINTS : POINTS).forEach(o => indices.push(baseVertex + vertexOffset + o));
            vertexOffset += useBevel ? 4 : 2;
        }
    }
    if (endWithCircle) {
        const lineAngle = points.length !== 2
            ? angleVec
                .set(points[(N - 3) * 3] - points[(N - 2) * 3], points[(N - 3) * 3 + 1] - points[(N - 2) * 3 + 1])
                .angle()
            : Math.PI;
        addCircle(points[(N - 2) * 3], points[(N - 2) * 3 + 1], lineAngle, width, vertices, indices);
    }
}
exports.triangulateLine = triangulateLine;
/**
 * Reconstruct the original points of a line from the vertices of the triangulated line.
 *
 * @param inBuffer Buffer with vertices.
 * @param startOffset Start index, will differ from `0` if the line has caps.
 * @returns Buffer containing the original points of the triangulated line.
 */
function reconstructLine(inBuffer, startOffset) {
    const outBuffer = new Float32Array(inBuffer.length / 2);
    for (let i = startOffset * 3, i2 = i * 2; i < outBuffer.length; i += 3, i2 += 6) {
        outBuffer[i] = inBuffer[i2] + (inBuffer[i2 + 3] - inBuffer[i2]) * 0.5;
        outBuffer[i + 1] = inBuffer[i2 + 1] + (inBuffer[i2 + 3 + 1] - inBuffer[i2 + 1]) * 0.5;
        outBuffer[i + 2] = inBuffer[i2 + 2] + (inBuffer[i2 + 3 + 2] - inBuffer[i2 + 2]) * 0.5;
    }
    return outBuffer;
}
exports.reconstructLine = reconstructLine;
/**
 * Extract the line width from a triangulated line.
 *
 * @param inBuffer Array of vertex elements of a triangulated line.
 * @param startIndex Start index, will differ from `0` if the line has caps.
 */
function reconstructLineWidth(inBuffer, startIndex) {
    const xd = inBuffer[startIndex * 2 + 3] - inBuffer[startIndex * 2];
    const yd = inBuffer[startIndex * 2 + 3 + 1] - inBuffer[startIndex * 2 + 1];
    const zd = inBuffer[startIndex * 2 + 3 + 2] - inBuffer[startIndex * 2 + 2];
    return Math.sqrt(xd * xd + yd * yd + zd * zd) * 0.5;
}
exports.reconstructLineWidth = reconstructLineWidth;


/***/ }),

/***/ "../harp-lrucache/index.ts":
/*!*********************************!*\
  !*** ../harp-lrucache/index.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/LRUCache */ "../harp-lrucache/lib/LRUCache.ts"));


/***/ }),

/***/ "../harp-lrucache/lib/LRUCache.ts":
/*!****************************************!*\
  !*** ../harp-lrucache/lib/LRUCache.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
/** @hidden */
class Entry {
    constructor(key, value, size, newer, older) {
        this.key = key;
        this.value = value;
        this.size = size;
        this.newer = newer;
        this.older = older;
    }
}
exports.Entry = Entry;
/**
 * Fixed size cache that evicts its entries in least-recently-used order when it overflows.
 * Modeled after standard JavaScript `Map` otherwise.
 */
class LRUCache {
    /**
     * Creates a new instance of `LRUCache`.
     *
     * The optional [[sizeFunction]] can be used to fine tune the memory consumption of all cached
     * elements, thus [[cacheCapacity]] means then memory used (in MBs). Otherwise, if
     * [[sizeFunction]] is not specified, the [[cacheCapacity]] accounts for the maximum
     * number of elements stored.
     *
     * @param cacheCapacity Number used to configure the maximum cache size, may express
     * number of entries or memory consumed in megabytes depending on [[sizeFunction]].
     * @param sizeFunction A function determining the size per element.
     */
    constructor(cacheCapacity, sizeFunction = () => 1) {
        this.m_size = 0;
        /**
         * The internal map object that keeps the key-value pairs and their order.
         */
        this.m_map = new Map();
        /**
         * The newest entry, i.e. the most recently used item.
         */
        this.m_newest = null;
        /**
         * The oldest entry, i.e. the least recently used item.
         */
        this.m_oldest = null;
        this.m_capacity = cacheCapacity;
        this.m_sizeFunction = sizeFunction;
    }
    /**
     * Iterates over all items from the most recently used item to the least recently used one.
     *
     * **Note**: Results are undefined if the entire cache is modified during iteration. You may
     * although modify the current element in [[callbackfn]] function.
     *
     * @param callbackfn The callback to call for each item.
     * @param thisArg Optional this argument for the callback.
     */
    forEach(callbackfn, thisArg) {
        let entry = this.m_newest;
        while (entry !== null) {
            const older = entry.older;
            callbackfn.call(thisArg, entry.value, entry.key, this);
            entry = older;
        }
    }
    /**
     * The size of the cache, i.e. the sum of all the sizes of all the objects in the cache.
     *
     * @returns The size of the cache.
     */
    get size() {
        return this.m_size;
    }
    /**
     * Returns the maximum capacity of the cache, i.e. the maximum number of elements this cache
     * can contain or the total amount of memory that may be consumed by cache if element size
     * function was specified in cache c-tor.
     *
     * @returns The capacity of the cache.
     */
    get capacity() {
        return this.m_capacity;
    }
    /**
     * @deprecated - DO NOT USE. Will be removed in future versions.
     *
     * Returns the internal map object that keeps the key-value pairs and their order.
     *
     * @returns The internal map object.
     */
    get map() {
        // ### TODO - remove me. Cache must not expose its internal object,
        // modifications to it are fatal for the internal state machine.
        return this.m_map;
    }
    /**
     * Returns the newest entry in the cache.
     *
     * @returns Newest entry in the cache.
     */
    get newest() {
        return this.m_newest;
    }
    /**
     * Returns the oldest entry in the cache.
     *
     * Note: Does not promote the oldest item as most recently used item.
     *
     * @returns Oldest entry in the cache.
     */
    get oldest() {
        return this.m_oldest;
    }
    /**
     * Resets the capacity of this cache. If `newCapacity` is smaller than the current cache size,
     * all items will be evicted until the cache shrinks to `newCapacity`.
     *
     * @param newCapacity The new capacity of this cache.
     */
    setCapacity(newCapacity) {
        this.m_capacity = newCapacity;
        this.evict();
    }
    /**
     * Resets the cache capacity and function used to measure the element size.
     *
     * @param newCapacity The new capacity masured in units returned from [[sizeMeasure]] funtion.
     * @param sizeMeasure Function that defines the size of element, if you want to measure
     * number of elements only always return 1 from this function (default), you may also
     * specify own function that measures entries by memory consumed, nubmer of sub-elements, etc.
     */
    setCapacityAndMeasure(newCapacity, sizeMeasure = () => 1) {
        this.m_capacity = newCapacity;
        this.m_sizeFunction = sizeMeasure;
        this.shrinkToCapacity();
    }
    /**
     * Updates the size of all elements in this cache. If their aggregated size is larger than the
     * capacity, items will be evicted until the cache shrinks to fit the capacity.
     */
    shrinkToCapacity() {
        let size = 0;
        const sizeFunction = this.m_sizeFunction;
        let entry = this.m_newest;
        while (entry !== null) {
            const entrySize = sizeFunction(entry.value);
            entry.size = entrySize;
            size += entrySize;
            entry = entry.older;
        }
        this.m_size = size;
        this.evict();
    }
    /**
     * Inserts or updates a key/value pair in the cache.
     *
     * If the key already existed in the cache, it will be updated and promoted to the most recently
     * used item.
     *
     * If the key didn't exist in the cache, it will be inserted as most recently used item. An
     * eviction of the least recently used item takes place if the cache exceeded its capacity.
     *
     * @param key The key for the key-value pair to insert or update.
     * @param value The value for the key-value pair to insert or update.
     */
    set(key, value) {
        const valueSize = this.m_sizeFunction(value);
        let entry = this.m_map.get(key);
        if (entry !== undefined) {
            this.m_size = this.m_size - entry.size + valueSize;
            entry.value = value;
            entry.size = valueSize;
            this.promoteEntry(entry);
            this.evict();
        }
        else {
            if (valueSize > this.m_capacity) {
                return; // single item too big to cache
            }
            entry = new Entry(key, value, valueSize, null, null);
            if (this.m_map.size === 0) {
                this.m_newest = this.m_oldest = entry;
            }
            else {
                harp_utils_1.assert(this.m_newest !== null);
                const newest = this.m_newest;
                entry.older = this.m_newest;
                newest.newer = entry;
                this.m_newest = entry;
            }
            this.m_map.set(key, entry);
            this.m_size += valueSize;
            this.evict();
        }
    }
    /**
     * Looks up key in the cache and returns the associated value.
     *
     * @param key The key to look up.
     * @returns The associated value, or `undefined` if the key-value pair is not in the cache.
     */
    get(key) {
        const entry = this.m_map.get(key);
        if (entry === undefined) {
            return undefined;
        }
        this.promoteEntry(entry);
        return entry.value;
    }
    /**
     * Test if a key/value pair is in the cache.
     *
     * @param key The key to look up.
     * @returns `true` if the key-value pair is in the cache, `false` otherwise.
     */
    has(key) {
        return this.m_map.has(key);
    }
    /**
     * Clears the cache and removes all stored key-value pairs.
     *
     * Does not call the eviction callback. Use [[evictAll]] to clear the cache and call the
     * eviction callback.
     */
    clear() {
        this.m_newest = this.m_oldest = null;
        this.m_size = 0;
        this.m_map.clear();
    }
    /**
     * Evicts all items from the cache, calling the eviction callback on each item.
     *
     * Use [[clear]] to remove all items without calling the eviction callback.
     */
    evictAll() {
        const cb = this.evictionCallback;
        if (cb !== undefined) {
            this.forEach((value, key) => cb(key, value));
        }
        this.clear();
    }
    /**
     * Evict selected elements from the cache using [[selector]] function.
     *
     * @param selector The function for selecting elements for eviction.
     * @param thisArg Optional _this_ object reference.
     */
    evictSelected(selector, thisArg) {
        const cb = this.evictionCallback;
        let entry = this.m_newest;
        while (entry !== null) {
            const entryOlder = entry.older;
            if (selector.call(thisArg, entry.value, entry.key)) {
                if (cb !== undefined) {
                    cb(entry.key, entry.value);
                }
                this.deleteEntry(entry);
                this.m_map.delete(entry.key);
            }
            entry = entryOlder;
        }
    }
    /**
     * Explicitly removes a key-value pair from the cache.
     *
     * **Note**: This is an explicit removal, thus, the eviction callback will not be called.
     *
     * @param key The key of the key-value pair to delete.
     * @returns `true` if the key-value pair existed and was deleted, `false` otherwise.
     */
    delete(key) {
        const entry = this.m_map.get(key);
        if (entry === undefined) {
            return false;
        }
        this.deleteEntry(entry);
        return this.m_map.delete(key);
    }
    evict() {
        while (this.m_oldest !== null && this.m_size > this.m_capacity) {
            const evicted = this.evictOldest();
            if (evicted === undefined) {
                return;
            }
        }
    }
    evictOldest() {
        harp_utils_1.assert(this.m_oldest !== null);
        const oldest = this.m_oldest;
        harp_utils_1.assert(oldest.older === null);
        let itemToRemove = oldest;
        if (this.canEvict !== undefined) {
            while (!this.canEvict(itemToRemove.key, itemToRemove.value)) {
                if (itemToRemove.newer === null) {
                    return undefined;
                }
                itemToRemove = itemToRemove.newer;
            }
        }
        if (itemToRemove === oldest) {
            this.m_oldest = itemToRemove.newer;
            if (itemToRemove.newer !== null) {
                harp_utils_1.assert(itemToRemove.newer.older === itemToRemove);
                itemToRemove.newer.older = null;
            }
        }
        else {
            if (itemToRemove.newer !== null) {
                harp_utils_1.assert(itemToRemove.newer.older === itemToRemove);
                itemToRemove.newer.older = itemToRemove.older;
                if (itemToRemove.older !== null) {
                    itemToRemove.older.newer = itemToRemove.newer;
                }
            }
            else {
                return undefined;
            }
        }
        const isOk = this.m_map.delete(itemToRemove.key);
        harp_utils_1.assert(isOk === true);
        if (isOk && this.evictionCallback !== undefined) {
            this.evictionCallback(itemToRemove.key, itemToRemove.value);
        }
        this.m_size -= itemToRemove.size;
        return itemToRemove;
    }
    deleteEntry(entry) {
        if (entry === this.m_newest) {
            this.m_newest = entry.older;
        }
        else if (entry.newer) {
            entry.newer.older = entry.older;
        }
        else {
            harp_utils_1.assert(false);
        }
        if (entry === this.m_oldest) {
            this.m_oldest = entry.newer;
        }
        else if (entry.older) {
            entry.older.newer = entry.newer;
        }
        else {
            harp_utils_1.assert(false);
        }
        this.m_size -= entry.size;
    }
    promoteEntry(entry) {
        if (entry === this.m_newest) {
            return;
        } // already newest, nothing to do
        // re-link newer and older items
        if (entry.newer) {
            harp_utils_1.assert(entry.newer.older === entry);
            entry.newer.older = entry.older;
        }
        if (entry.older) {
            harp_utils_1.assert(entry.older.newer === entry);
            entry.older.newer = entry.newer;
        }
        if (entry === this.m_oldest) {
            this.m_oldest = entry.newer;
        }
        // re-link ourselves
        entry.newer = null;
        entry.older = this.m_newest;
        // finally, set ourselves as the newest entry
        harp_utils_1.assert(this.m_newest !== null);
        const newest = this.m_newest;
        harp_utils_1.assert(newest.newer === null);
        newest.newer = entry;
        this.m_newest = entry;
    }
}
exports.LRUCache = LRUCache;


/***/ }),

/***/ "../harp-map-controls/lib/MapControls.ts":
/*!***********************************************!*\
  !*** ../harp-map-controls/lib/MapControls.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const geoUtils = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.js");
const THREE = __webpack_require__(/*! three */ "three");
const utils = __webpack_require__(/*! ./Utils */ "../harp-map-controls/lib/Utils.ts");
var State;
(function (State) {
    State[State["NONE"] = 0] = "NONE";
    State[State["PAN"] = 1] = "PAN";
    State[State["ROTATE"] = 2] = "ROTATE";
    State[State["ORBIT"] = 3] = "ORBIT";
    State[State["TOUCH"] = 4] = "TOUCH";
})(State || (State = {}));
var TiltState;
(function (TiltState) {
    TiltState[TiltState["Tilted"] = 0] = "Tilted";
    TiltState[TiltState["Down"] = 1] = "Down";
})(TiltState = exports.TiltState || (exports.TiltState = {}));
/**
 * Map interaction events' names.
 */
var EventNames;
(function (EventNames) {
    EventNames["Update"] = "update";
    EventNames["BeginInteraction"] = "begin-interaction";
    EventNames["EndInteraction"] = "end-interaction";
})(EventNames = exports.EventNames || (exports.EventNames = {}));
// cast needed to workaround wrong three.js typings.
const MAPCONTROL_EVENT = { type: EventNames.Update };
const MAPCONTROL_EVENT_BEGIN_INTERACTION = {
    type: EventNames.BeginInteraction
};
const MAPCONTROL_EVENT_END_INTERACTION = {
    type: EventNames.EndInteraction
};
/**
 * The number of user's inputs to consider for panning inertia, to reduce erratic inputs.
 */
const USER_INPUTS_TO_CONSIDER = 5;
/**
 * The default maximum for the camera tilt. This value avoids seeing the horizon.
 */
const DEFAULT_MAX_TILT_ANGLE = Math.PI / 4;
/**
 * Epsilon value to rule out when a number can be considered 0.
 */
const EPSILON = 0.01;
/**
 * Maximum duration between start and end touch events to define a finger tap.
 */
const MAX_TAP_DURATION = 120;
/**
 * This map control provides basic map-related building blocks to interact with the map. It also
 * provides a default way of handling user input. Currently we support basic mouse interaction and
 * touch input interaction.
 *
 * Mouse interaction:
 *  - Left mouse button + move = Panning the map.
 *  - Right mouse button + move = Orbits the camera around the focus point.
 *  - Middle mouse button + move = Rotating the view. Up down movement changes the pitch. Left/right
 *    movement changes the yaw.
 *  - Mouse wheel = Zooms up and down by one zoom level, zooms on target.
 *
 * Touch interaction:
 *  - One finger = Panning the map.
 *  - Two fingers = Scale, rotate and panning the map.
 *  - Three fingers = Orbiting the map. Up down movements influences the current orbit altitude.
 *    Left/right changes the azimuth.
 */
class MapControls extends THREE.EventDispatcher {
    /**
     * Constructs a new `MapControls` object.
     *
     * @param mapView [[MapView]] this controller modifies.Z
     */
    constructor(mapView) {
        super();
        this.mapView = mapView;
        /**
         * This factor will be applied to the delta of the current mouse pointer position and the last
         * mouse pointer position: The result then will be used as an offset for the rotation then.
         * Default value is `0.1`.
         */
        this.rotationMouseDeltaFactor = 0.1;
        /**
         * This factor will be applied to the delta of the current mouse pointer position and the last
         * mouse pointer position: The result then will be used as an offset to orbit the camera.
         * Default value is `0.1`.
         */
        this.orbitingMouseDeltaFactor = 0.1;
        /**
         * This factor will be applied to the delta of the current touch pointer position and the last
         * touch pointer position: The result then will be used as an offset to orbit the camera.
         * Default value is `0.1`.
         */
        this.orbitingTouchDeltaFactor = 0.1;
        /**
         * Set to `true` to enable input handling through this map control, `false` to disable input
         * handling. Even when disabling input handling, you can manually use the public functions to
         * change the view to the current map.
         */
        this.enabled = true;
        /**
         * Set to `true` to enable orbiting and tilting through these controls, `false` otherwise.
         */
        this.tiltEnabled = true;
        /**
         * Set to `true` to enable rotation through this map control, `false` to disable rotation.
         */
        this.rotateEnabled = true;
        /**
         * Set to `true` to enable an inertia dampening on zooming and panning. `false` cancels inertia.
         */
        this.inertiaEnabled = true;
        /**
         * Inertia damping duration for the zoom, in seconds.
         */
        this.zoomInertiaDampingDuration = 0.5;
        /**
         * Inertia damping duration for the panning, in seconds.
         */
        this.panInertiaDampingDuration = 1.0;
        /**
         * Duration in seconds of the camera animation when the tilt button is clicked. Independent of
         * inertia.
         */
        this.tiltToggleDuration = 0.5;
        /**
         * Camera tilt to the target when tilting from the `toggleTilt` public method.
         */
        this.tiltAngle = Math.PI / 4;
        /**
         * Duration of the animation to reset the camera to looking north, in seconds. Independent of
         * inertia.
         */
        this.northResetAnimationDuration = 1.5;
        /**
         * Determines the zoom level delta for single mouse wheel movement. So after each mouse wheel
         * movement the current zoom level will be added or subtracted by this value. The default value
         * is `0.2` - this means that every 5th mouse wheel movement you will cross a zoom level.
         *
         * **Note**: To reverse the zoom direction, you can provide a negative value.
         */
        this.zoomLevelDeltaOnMouseWheel = 0.2;
        /**
         * Zoom level delta when using the UI controls.
         */
        this.zoomLevelDeltaOnControl = 1.0;
        /**
         * Determines the minimum zoom level we can zoom to.
         */
        this.minZoomLevel = 0;
        /**
         * Determines the maximum zoom level we can zoom to.
         */
        this.maxZoomLevel = 20;
        /**
         * Determines the minimum camera height in meter.
         */
        this.minCameraHeight = 3;
        /**
         * Zoom level delta to apply when double clicking or double tapping. `0` disables the feature.
         */
        this.zoomLevelDeltaOnDoubleClick = 1.0;
        /**
         * Double click uses the OS delay through the double click event. Tapping is implemented locally
         * here in `MapControls` with this duration setting the maximum delay to define a double tap.
         * The value is in seconds. `300ms` is picked as the default value as jQuery does.
         */
        this.doubleTapTime = 0.3;
        this.m_currentViewDirection = new THREE.Vector3();
        this.m_lastMousePosition = new THREE.Vector2(0, 0);
        this.m_mouseDelta = new THREE.Vector2(0, 0);
        this.m_needsRenderLastFrame = true;
        // Internal variables for animating panning (planar + spherical panning).
        this.m_panIsAnimated = false;
        this.m_panDistanceFrameDelta = new THREE.Vector3();
        this.m_panAnimationTime = 0;
        this.m_panAnimationStartTime = 0;
        this.m_lastAveragedPanDistanceOrAngle = 0;
        this.m_currentInertialPanningSpeed = 0;
        this.m_lastPanVector = new THREE.Vector3();
        this.m_rotateGlobeQuaternion = new THREE.Quaternion();
        this.m_lastRotateGlobeAxis = new THREE.Vector3();
        this.m_lastRotateGlobeAngle = 0;
        this.m_lastRotateGlobeFromVector = new THREE.Vector3();
        this.m_recentPanDistancesOrAngles = [
            0,
            0,
            0,
            0,
            0
        ];
        this.m_currentPanDistanceOrAngleIndex = 0;
        // Internal variables for animating zoom.
        this.m_zoomIsAnimated = false;
        this.m_zoomDeltaRequested = 0;
        this.m_zoomTargetNormalizedCoordinates = new THREE.Vector2();
        this.m_zoomAnimationTime = 0;
        this.m_zoomAnimationStartTime = 0;
        this.m_startZoom = 0;
        // Internal variables for animating tilt.
        this.m_tiltIsAnimated = false;
        this.m_tiltRequested = undefined;
        this.m_tiltAnimationTime = 0;
        this.m_tiltAnimationStartTime = 0;
        this.m_startTilt = 0;
        this.m_state = State.NONE;
        this.m_tmpVector2 = new THREE.Vector2();
        this.m_tmpVector3 = new THREE.Vector3();
        // Internal variables for animating double tap.
        this.m_tapStartTime = 0;
        this.m_lastSingleTapTime = 0;
        this.m_fingerMoved = false;
        this.m_isDoubleTap = false;
        // Internal variables for animating the movement resetting the north.
        this.m_resetNorthStartTime = 0;
        this.m_resetNorthIsAnimated = false;
        this.m_resetNorthAnimationDuration = 0;
        this.m_currentAzimuth = 0;
        this.m_lastAzimuth = 0;
        this.m_startAzimuth = 0;
        /**
         * Determines the maximum angle the camera can tilt to. It is defined in radians.
         */
        this.m_maxTiltAngle = DEFAULT_MAX_TILT_ANGLE;
        this.m_touchState = {
            touches: [],
            currentRotation: 0,
            initialRotation: 0
        };
        /**
         * Destroy this `MapControls` instance.
         *
         * Unregisters all global event handlers used. This is method should be called when you stop
         * using `MapControls`.
         */
        this.dispose = () => {
            // replaced with real code in bindInputEvents
        };
        this.camera = mapView.camera;
        this.domElement = mapView.renderer.domElement;
        this.maxZoomLevel = mapView.maxZoomLevel;
        this.minZoomLevel = mapView.minZoomLevel;
        this.minCameraHeight = mapView.minCameraHeight;
        this.bindInputEvents(this.domElement);
        this.handleZoom = this.handleZoom.bind(this);
        this.handlePan = this.handlePan.bind(this);
        this.tilt = this.tilt.bind(this);
        this.resetNorth = this.resetNorth.bind(this);
        this.assignZoomAfterTouchZoomRender = this.assignZoomAfterTouchZoomRender.bind(this);
    }
    /**
     * Creates MapControls object and attaches it specified [[MapView]].
     *
     * @param mapView - [[MapView]] object to which MapControls should be attached to.
     */
    static create(mapView) {
        return new MapControls(mapView);
    }
    /**
     * Current viewing angles yaw/pitch/roll in degrees.
     */
    get attitude() {
        const attitude = harp_mapview_1.MapViewUtils.extractAttitude(this.mapView, this.camera);
        return {
            yaw: THREE.Math.radToDeg(attitude.yaw),
            pitch: THREE.Math.radToDeg(attitude.pitch),
            roll: THREE.Math.radToDeg(attitude.roll)
        };
    }
    /**
     * Moves the camera along the view direction in meters.
     * A positive value will move the camera further away from the point where the camera looks at.
     * A negative value will move the camera near to the point where the camera looks at.
     *
     * @param amount Amount to move along the view direction in meters.
     */
    moveAlongTheViewDirection(amount) {
        if (amount === 0) {
            return;
        }
        this.camera.getWorldDirection(this.m_currentViewDirection);
        let maxDistance = harp_mapview_1.MapViewUtils.calculateDistanceToGroundFromZoomLevel(this.mapView, this.mapView.minZoomLevel);
        let minDistance = harp_mapview_1.MapViewUtils.calculateDistanceToGroundFromZoomLevel(this.mapView, this.mapView.maxZoomLevel);
        this.m_currentViewDirection.multiplyScalar(amount);
        if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {
            const distance = THREE.Math.clamp(this.camera.position.z + this.m_currentViewDirection.z, minDistance, maxDistance);
            this.camera.position.z = distance;
        }
        else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {
            const zOnVertical = Math.cos(this.camera.position.angleTo(this.m_currentViewDirection)) *
                this.m_currentViewDirection.length();
            minDistance += geoUtils.EarthConstants.EQUATORIAL_RADIUS;
            maxDistance += geoUtils.EarthConstants.EQUATORIAL_RADIUS;
            const distance = THREE.Math.clamp(this.camera.position.length() + zOnVertical, minDistance, maxDistance);
            this.camera.position.setLength(distance);
        }
        // In sphere, we may have to also orbit the camera around the position located at the
        // center of the screen, in order to limit the tilt to `maxTiltAngle`, as we change
        // this tilt by changing the camera's height above.
        if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical &&
            this.m_maxTiltAngle !== undefined) {
            // Use pre-calculated camera target, otherwise we could get it via:
            // centerScreenTarget = MapViewUtils.getTargetPositionFromCamera(camera, projection)
            // and convert to geo-coordinates via:
            // this.mapView.projection.unprojectPoint(centerScreenTarget)
            const tilt = harp_mapview_1.MapViewUtils.extractSphericalCoordinatesFromLocation(this.mapView, this.camera, this.mapView.target).tilt;
            const deltaTilt = tilt - this.m_maxTiltAngle;
            if (deltaTilt > 0) {
                harp_mapview_1.MapViewUtils.orbitFocusPoint(this.mapView, 0, deltaTilt, this.m_maxTiltAngle);
            }
        }
        this.updateMapView();
        this.mapView.addEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.assignZoomAfterTouchZoomRender);
    }
    /**
     * Reset the camera to looking north, in an orbiting movement around the target point instead
     * of changing the yaw (which would be the camera rotating on itself).
     */
    pointToNorth() {
        // Use pre-calculated target coordinates, otherwise we could call utility method to evaluate
        // geo-coordinates here:
        // targetGeoCoords = MapViewUtils.getTargetCoordinatesFromCamera(camera, projection)
        this.m_startAzimuth =
            Math.PI +
                harp_mapview_1.MapViewUtils.extractSphericalCoordinatesFromLocation(this.mapView, this.camera, this.mapView.target).azimuth;
        // Wrap between -PI and PI.
        this.m_startAzimuth = Math.atan2(Math.sin(this.m_startAzimuth), Math.cos(this.m_startAzimuth));
        if (this.m_startAzimuth === 0) {
            return;
        }
        this.stopExistingAnimations();
        this.m_resetNorthAnimationDuration = this.northResetAnimationDuration;
        this.m_currentAzimuth = this.m_startAzimuth;
        this.m_resetNorthStartTime = performance.now();
        this.resetNorth();
    }
    /**
     * Zooms and moves the map in such a way that the given target position remains at the same
     * position after the zoom.
     *
     * @param targetPositionOnScreenXinNDC Target x position in NDC space.
     * @param targetPositionOnScreenYinNDC Target y position in NDC space.
     */
    zoomOnTargetPosition(targetPositionOnScreenXinNDC, targetPositionOnScreenYinNDC, zoomLevel) {
        harp_mapview_1.MapViewUtils.zoomOnTargetPosition(this.mapView, targetPositionOnScreenXinNDC, targetPositionOnScreenYinNDC, zoomLevel, this.m_maxTiltAngle);
    }
    /**
     * Zooms to the desired location by the provided value.
     *
     * @param zoomLevel Zoom level.
     * @param screenTarget Zoom target on screen.
     */
    setZoomLevel(zoomLevel, screenTarget = { x: 0, y: 0 }) {
        if (this.enabled === false) {
            return;
        }
        this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);
        // Register the zoom request
        this.m_startZoom = this.currentZoom;
        this.m_zoomDeltaRequested = zoomLevel - this.zoomLevelTargeted;
        this.stopExistingAnimations();
        // Assign the new animation start time.
        this.m_zoomAnimationStartTime = performance.now();
        this.m_zoomTargetNormalizedCoordinates.set(screenTarget.x, screenTarget.y);
        this.handleZoom();
        this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);
    }
    /**
     * Toggles the camera tilt between 0 (looking down) and the value at `this.tiltAngle`.
     */
    toggleTilt() {
        this.stopExistingAnimations();
        this.m_startTilt = this.currentTilt;
        const aimTilt = this.m_startTilt < EPSILON;
        this.m_tiltRequested = aimTilt ? this.tiltAngle : 0;
        this.m_tiltState = aimTilt ? TiltState.Tilted : TiltState.Down;
        this.m_tiltAnimationStartTime = performance.now();
        this.tilt();
    }
    /**
     * Set the camera height.
     */
    set cameraHeight(height) {
        //Set the cameras height according to the given zoom level.
        this.camera.position.setZ(height);
        this.camera.matrixWorldNeedsUpdate = true;
    }
    /**
     * Get the current camera height.
     */
    get cameraHeight() {
        // ### Sync with the way geoviz is computing the zoom level.
        return this.mapView.camera.position.z;
    }
    /**
     * Set camera max tilt angle. The value is clamped between 0 and 90 degrees. In sphere
     * projection, at runtime, the value is also clamped so that the camera does not look above the
     * horizon.
     *
     * @param angle Angle in degrees.
     */
    set maxTiltAngle(angle) {
        this.m_maxTiltAngle = Math.max(0, Math.min(90, THREE.Math.degToRad(angle)));
    }
    /**
     * Get the camera max tilt angle in degrees.
     */
    get maxTiltAngle() {
        return THREE.Math.radToDeg(this.m_maxTiltAngle);
    }
    /**
     * Get the zoom level targeted by `MapControls`. Useful when inertia is on, to add incremented
     * values to the target instead of getting the random zoomLevel value during the interpolation.
     */
    get zoomLevelTargeted() {
        return this.m_targetedZoom === undefined ? this.currentZoom : this.m_targetedZoom;
    }
    /**
     * Handy getter to know if the view is in the process of looking down or not.
     */
    get tiltState() {
        if (this.m_tiltState === undefined) {
            this.m_tiltState =
                this.currentTilt < EPSILON || this.m_tiltState === TiltState.Down
                    ? TiltState.Tilted
                    : TiltState.Down;
        }
        return this.m_tiltState;
    }
    set currentZoom(zoom) {
        this.m_currentZoom = zoom;
    }
    get currentZoom() {
        return this.m_currentZoom !== undefined ? this.m_currentZoom : this.mapView.zoomLevel;
    }
    set currentTilt(tilt) {
        this.m_currentTilt = tilt;
    }
    get currentTilt() {
        return harp_mapview_1.MapViewUtils.extractCameraTilt(this.mapView.camera, this.mapView.projection);
    }
    get targetedTilt() {
        return this.m_targetedTilt === undefined
            ? this.m_currentTilt === undefined
                ? this.currentTilt
                : this.m_currentTilt
            : this.m_targetedTilt;
    }
    assignZoomAfterTouchZoomRender() {
        this.m_currentZoom = this.mapView.zoomLevel;
        this.m_targetedZoom = this.mapView.zoomLevel;
        this.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.assignZoomAfterTouchZoomRender);
    }
    stopExistingAnimations() {
        this.stopResetNorth();
        this.stopZoom();
        this.stopPan();
        this.stopTilt();
    }
    resetNorth() {
        const currentTime = performance.now();
        const animationTime = (currentTime - this.m_resetNorthStartTime) / 1000;
        if (this.inertiaEnabled) {
            if (!this.m_resetNorthIsAnimated) {
                this.m_resetNorthIsAnimated = true;
                this.mapView.addEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.resetNorth);
            }
            const resetNorthFinished = animationTime > this.m_resetNorthAnimationDuration;
            if (resetNorthFinished) {
                if (this.m_needsRenderLastFrame) {
                    this.m_needsRenderLastFrame = false;
                    this.stopResetNorth();
                }
            }
            else {
                this.m_needsRenderLastFrame = true;
            }
        }
        this.m_lastAzimuth = this.m_currentAzimuth;
        this.m_currentAzimuth = this.inertiaEnabled
            ? this.easeOutCubic(this.m_startAzimuth, 0, Math.min(1, animationTime / this.m_resetNorthAnimationDuration))
            : 0;
        const deltaAzimuth = this.m_currentAzimuth - this.m_lastAzimuth;
        harp_mapview_1.MapViewUtils.orbitFocusPoint(this.mapView, THREE.Math.radToDeg(deltaAzimuth), 0, this.m_maxTiltAngle);
        this.updateMapView();
    }
    stopResetNorth() {
        this.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.resetNorth);
        this.m_resetNorthIsAnimated = false;
    }
    tilt() {
        if (this.m_tiltRequested !== undefined) {
            this.m_targetedTilt = Math.max(Math.min(this.m_tiltRequested, this.maxTiltAngle), 0);
            this.m_tiltRequested = undefined;
        }
        if (this.inertiaEnabled) {
            if (!this.m_tiltIsAnimated) {
                this.m_tiltIsAnimated = true;
                this.mapView.addEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.tilt);
            }
            const currentTime = performance.now();
            this.m_tiltAnimationTime = (currentTime - this.m_tiltAnimationStartTime) / 1000;
            const tiltFinished = this.m_tiltAnimationTime > this.tiltToggleDuration;
            if (tiltFinished) {
                if (this.m_needsRenderLastFrame) {
                    this.m_needsRenderLastFrame = false;
                    this.m_tiltAnimationTime = this.tiltToggleDuration;
                    this.stopTilt();
                }
            }
            else {
                this.m_needsRenderLastFrame = true;
            }
        }
        this.m_currentTilt = this.inertiaEnabled
            ? this.easeOutCubic(this.m_startTilt, this.targetedTilt, Math.min(1, this.m_tiltAnimationTime / this.tiltToggleDuration))
            : this.targetedTilt;
        const initialTilt = this.currentTilt;
        const deltaAngle = this.m_currentTilt - initialTilt;
        const oldCameraDistance = this.mapView.camera.position.z / Math.cos(initialTilt);
        const newHeight = Math.cos(initialTilt) * oldCameraDistance;
        harp_mapview_1.MapViewUtils.orbitFocusPoint(this.mapView, newHeight - this.camera.position.z, THREE.Math.radToDeg(deltaAngle), this.m_maxTiltAngle);
        this.updateMapView();
    }
    stopTilt() {
        this.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.tilt);
        this.m_tiltIsAnimated = false;
        this.m_targetedTilt = this.m_currentTilt = undefined;
    }
    easeOutCubic(startValue, endValue, time) {
        return startValue + (endValue - startValue) * (--time * time * time + 1);
    }
    handleZoom() {
        if (this.m_zoomDeltaRequested !== 0) {
            this.m_targetedZoom = Math.max(Math.min(this.zoomLevelTargeted + this.m_zoomDeltaRequested, this.maxZoomLevel), this.minZoomLevel);
            this.m_zoomDeltaRequested = 0;
        }
        if (this.inertiaEnabled && this.zoomInertiaDampingDuration > 0) {
            if (!this.m_zoomIsAnimated) {
                this.m_zoomIsAnimated = true;
                this.mapView.addEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.handleZoom);
            }
            const currentTime = performance.now();
            this.m_zoomAnimationTime = (currentTime - this.m_zoomAnimationStartTime) / 1000;
            const zoomFinished = this.m_zoomAnimationTime > this.zoomInertiaDampingDuration;
            if (zoomFinished) {
                if (this.m_needsRenderLastFrame) {
                    this.m_needsRenderLastFrame = false;
                    this.m_zoomAnimationTime = this.zoomInertiaDampingDuration;
                    this.stopZoom();
                }
            }
            else {
                this.m_needsRenderLastFrame = true;
            }
        }
        this.currentZoom =
            !this.inertiaEnabled || Math.abs(this.zoomLevelTargeted - this.m_startZoom) < EPSILON
                ? this.zoomLevelTargeted
                : this.easeOutCubic(this.m_startZoom, this.zoomLevelTargeted, Math.min(1, this.m_zoomAnimationTime / this.zoomInertiaDampingDuration));
        harp_mapview_1.MapViewUtils.zoomOnTargetPosition(this.mapView, this.m_zoomTargetNormalizedCoordinates.x, this.m_zoomTargetNormalizedCoordinates.y, this.currentZoom, this.m_maxTiltAngle);
        this.updateMapView();
    }
    stopZoom() {
        this.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.handleZoom);
        this.m_zoomIsAnimated = false;
    }
    /**
     * Method to flip crêpes.
     */
    handlePan() {
        if (this.m_state === State.NONE && this.m_lastAveragedPanDistanceOrAngle === 0) {
            return;
        }
        if (this.inertiaEnabled && !this.m_panIsAnimated) {
            this.m_panIsAnimated = true;
            this.mapView.addEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.handlePan);
        }
        const applyInertia = this.inertiaEnabled &&
            this.panInertiaDampingDuration > 0 &&
            this.m_state === State.NONE &&
            this.m_lastAveragedPanDistanceOrAngle > 0;
        if (applyInertia) {
            const currentTime = performance.now();
            this.m_panAnimationTime = (currentTime - this.m_panAnimationStartTime) / 1000;
            const panFinished = this.m_panAnimationTime > this.panInertiaDampingDuration;
            if (panFinished) {
                if (this.m_needsRenderLastFrame) {
                    this.m_needsRenderLastFrame = false;
                    this.m_panAnimationTime = this.panInertiaDampingDuration;
                    this.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.handlePan);
                    this.m_panIsAnimated = false;
                }
            }
            else {
                this.m_needsRenderLastFrame = true;
            }
            const animationTime = this.m_panAnimationTime / this.panInertiaDampingDuration;
            this.m_currentInertialPanningSpeed = this.easeOutCubic(this.m_lastAveragedPanDistanceOrAngle, 0, Math.min(1, animationTime));
            if (this.m_currentInertialPanningSpeed === 0) {
                this.m_lastAveragedPanDistanceOrAngle = 0;
            }
            if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {
                this.m_panDistanceFrameDelta
                    .copy(this.m_lastPanVector)
                    .setLength(this.m_currentInertialPanningSpeed);
            }
            else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {
                this.m_rotateGlobeQuaternion
                    .setFromAxisAngle(this.m_lastRotateGlobeAxis, this.m_currentInertialPanningSpeed)
                    .normalize();
            }
        }
        else {
            let panDistanceOrAngle = 0;
            if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {
                panDistanceOrAngle = this.m_lastPanVector
                    .copy(this.m_panDistanceFrameDelta)
                    .length();
            }
            else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {
                panDistanceOrAngle = this.m_lastRotateGlobeAngle;
                this.m_rotateGlobeQuaternion.setFromAxisAngle(this.m_lastRotateGlobeAxis, this.m_lastRotateGlobeAngle);
                this.m_rotateGlobeQuaternion.normalize();
            }
            this.m_currentPanDistanceOrAngleIndex =
                (this.m_currentPanDistanceOrAngleIndex + 1) % USER_INPUTS_TO_CONSIDER;
            this.m_recentPanDistancesOrAngles[this.m_currentPanDistanceOrAngleIndex] = panDistanceOrAngle;
            this.m_lastAveragedPanDistanceOrAngle =
                this.m_recentPanDistancesOrAngles.reduce((a, b) => a + b) / USER_INPUTS_TO_CONSIDER;
        }
        if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {
            harp_mapview_1.MapViewUtils.panCameraAboveFlatMap(this.mapView, this.m_panDistanceFrameDelta.x, this.m_panDistanceFrameDelta.y);
        }
        else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {
            harp_mapview_1.MapViewUtils.panCameraAroundGlobe(this.mapView, this.m_lastRotateGlobeFromVector, this.m_tmpVector3
                .copy(this.m_lastRotateGlobeFromVector)
                .applyQuaternion(this.m_rotateGlobeQuaternion));
        }
        if (!applyInertia) {
            this.m_panDistanceFrameDelta.set(0, 0, 0);
            this.m_lastRotateGlobeAngle = 0;
        }
        this.updateMapView();
    }
    stopPan() {
        this.m_panDistanceFrameDelta.set(0, 0, 0);
        this.m_lastAveragedPanDistanceOrAngle = 0;
    }
    bindInputEvents(domElement) {
        const onContextMenu = this.contextMenu.bind(this);
        const onMouseDown = this.mouseDown.bind(this);
        const onMouseWheel = this.mouseWheel.bind(this);
        const onTouchStart = this.touchStart.bind(this);
        const onTouchEnd = this.touchEnd.bind(this);
        const onTouchMove = this.touchMove.bind(this);
        const onMouseDoubleClick = this.mouseDoubleClick.bind(this);
        domElement.addEventListener("dblclick", onMouseDoubleClick, false);
        domElement.addEventListener("contextmenu", onContextMenu, false);
        domElement.addEventListener("mousedown", onMouseDown, false);
        domElement.addEventListener("wheel", onMouseWheel, false);
        domElement.addEventListener("touchstart", onTouchStart, false);
        domElement.addEventListener("touchend", onTouchEnd, false);
        domElement.addEventListener("touchmove", onTouchMove, false);
        this.dispose = () => {
            domElement.removeEventListener("dblclick", onMouseDoubleClick, false);
            domElement.removeEventListener("contextmenu", onContextMenu, false);
            domElement.removeEventListener("mousedown", onMouseDown, false);
            domElement.removeEventListener("wheel", onMouseWheel, false);
            domElement.removeEventListener("touchstart", onTouchStart, false);
            domElement.removeEventListener("touchend", onTouchEnd, false);
            domElement.removeEventListener("touchmove", onTouchMove, false);
        };
    }
    updateMapView() {
        this.dispatchEvent(MAPCONTROL_EVENT);
        this.mapView.update();
    }
    mouseDoubleClick(e) {
        if (this.enabled === false) {
            return;
        }
        this.zoomOnDoubleClickOrTap(e.clientX, e.clientY);
    }
    mouseDown(event) {
        if (this.enabled === false) {
            return;
        }
        if (event.shiftKey || event.ctrlKey) {
            return;
        }
        event.stopPropagation();
        if (this.m_state !== State.NONE) {
            return;
        }
        if (event.button === 0) {
            this.m_state = State.PAN;
        }
        else if (event.button === 1) {
            this.m_state = State.ROTATE;
        }
        else if (event.button === 2 && this.tiltEnabled) {
            this.m_state = State.ORBIT;
        }
        else {
            return;
        }
        this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);
        this.m_lastMousePosition.setX(event.clientX);
        this.m_lastMousePosition.setY(event.clientY);
        const onMouseMove = this.mouseMove.bind(this);
        const onMouseUp = this.mouseUp.bind(this);
        window.addEventListener("mousemove", onMouseMove, false);
        window.addEventListener("mouseup", onMouseUp, false);
        this.m_cleanupMouseEventListeners = () => {
            window.removeEventListener("mousemove", onMouseMove);
            window.removeEventListener("mouseup", onMouseUp);
        };
    }
    mouseMove(event) {
        if (this.enabled === false) {
            return;
        }
        this.m_mouseDelta.set(event.clientX - this.m_lastMousePosition.x, event.clientY - this.m_lastMousePosition.y);
        if (this.m_state === State.PAN) {
            const vectors = this.getWorldPositionWithElevation(this.m_lastMousePosition.x, this.m_lastMousePosition.y, event.clientX, event.clientY);
            if (vectors === undefined) {
                return;
            }
            const { fromWorld, toWorld } = vectors;
            this.panFromTo(fromWorld, toWorld);
        }
        else if (this.m_state === State.ROTATE) {
            this.stopExistingAnimations();
            harp_mapview_1.MapViewUtils.rotate(this.mapView, -this.rotationMouseDeltaFactor * this.m_mouseDelta.x, this.rotationMouseDeltaFactor * this.m_mouseDelta.y, this.m_maxTiltAngle);
        }
        else if (this.m_state === State.ORBIT) {
            this.stopExistingAnimations();
            harp_mapview_1.MapViewUtils.orbitFocusPoint(this.mapView, this.orbitingMouseDeltaFactor * this.m_mouseDelta.x, -this.orbitingMouseDeltaFactor * this.m_mouseDelta.y, this.m_maxTiltAngle);
        }
        this.m_lastMousePosition.set(event.clientX, event.clientY);
        this.m_zoomAnimationStartTime = performance.now();
        this.updateMapView();
        event.preventDefault();
        event.stopPropagation();
    }
    mouseUp(event) {
        if (this.enabled === false) {
            return;
        }
        this.updateMapView();
        event.preventDefault();
        event.stopPropagation();
        this.m_state = State.NONE;
        if (this.m_cleanupMouseEventListeners) {
            this.m_cleanupMouseEventListeners();
        }
        this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);
    }
    mouseWheel(event) {
        const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);
        const screenTarget = utils.calculateNormalizedDeviceCoordinates(event.offsetX, event.offsetY, width, height);
        this.setZoomLevel(this.zoomLevelTargeted + this.zoomLevelDeltaOnMouseWheel * (event.deltaY > 0 ? -1 : 1), screenTarget);
        event.preventDefault();
        event.stopPropagation();
    }
    /**
     * Calculates the angle of the vector, which is formed by two touch points in world space
     * against the X axis in world space on the map. The resulting angle is in radians and between
     * `-PI` and `PI`.
     */
    updateCurrentRotation() {
        if (this.m_touchState.touches.length < 2 ||
            this.m_touchState.touches[1].currentWorldPosition.length() === 0 ||
            this.m_touchState.touches[0].currentWorldPosition.length() === 0) {
            return;
        }
        let x = 0;
        let y = 0;
        if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {
            // Planar uses world space coordinates to return the angle of the vector between the two
            // fingers' locations from the north direction.
            x =
                this.m_touchState.touches[1].currentWorldPosition.x -
                    this.m_touchState.touches[0].currentWorldPosition.x;
            y =
                this.m_touchState.touches[1].currentWorldPosition.y -
                    this.m_touchState.touches[0].currentWorldPosition.y;
        }
        else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {
            // Globe uses screen space coordinates, as the 3d coordinate system cannot define a
            // reference rotation scalar for the vector between the two fingers' locations.
            x =
                this.m_touchState.touches[1].currentTouchPoint.x -
                    this.m_touchState.touches[0].currentTouchPoint.x;
            // Below the subtraction is inverted, because the Y coordinate in screen space in HTML
            // has its origin at the top and increases downwards.
            y =
                this.m_touchState.touches[0].currentTouchPoint.y -
                    this.m_touchState.touches[1].currentTouchPoint.y;
            this.m_touchState.initialRotation = this.m_touchState.currentRotation;
        }
        this.m_touchState.currentRotation = Math.atan2(y, x);
    }
    /**
     * Calculates the difference of the current distance of two touch points against their initial
     * distance in world space.
     */
    calculatePinchDistanceInWorldSpace() {
        if (this.m_touchState.touches.length < 2) {
            return 0;
        }
        const previousDistance = this.m_tmpVector3
            .subVectors(this.m_touchState.touches[0].initialWorldPosition, this.m_touchState.touches[1].initialWorldPosition)
            .length();
        const currentDistance = this.m_tmpVector3
            .subVectors(this.m_touchState.touches[0].currentWorldPosition, this.m_touchState.touches[1].currentWorldPosition)
            .length();
        return currentDistance - previousDistance;
    }
    convertTouchPoint(touch, oldTouchState) {
        const newTouchPoint = new THREE.Vector2(touch.pageX, touch.pageY);
        if (oldTouchState !== undefined) {
            const oldTouchPoint = oldTouchState.currentTouchPoint;
            const vectors = this.getWorldPositionWithElevation(oldTouchPoint.x, oldTouchPoint.y, newTouchPoint.x, newTouchPoint.y);
            const toWorld = vectors === undefined ? new THREE.Vector3() : vectors.toWorld;
            // Unless the user is tilting, considering a finger losing the surface as a touchEnd
            // event. Inertia will get triggered.
            if (toWorld.length() === 0 &&
                !(this.m_touchState.touches.length === 3 && this.tiltEnabled)) {
                this.setTouchState([]);
                this.m_state = State.NONE;
                this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);
                return;
            }
            if (this.m_state !== State.TOUCH) {
                this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);
            }
            this.m_state = State.TOUCH;
            return {
                currentTouchPoint: newTouchPoint,
                lastTouchPoint: newTouchPoint,
                currentWorldPosition: toWorld,
                initialWorldPosition: toWorld
            };
        }
        else {
            const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);
            const to = utils.calculateNormalizedDeviceCoordinates(newTouchPoint.x, newTouchPoint.y, width, height);
            const result = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, to.x, to.y);
            const toWorld = result === null ? new THREE.Vector3() : result;
            // Unless the user is tilting, considering a finger losing the surface as a touchEnd
            // event. Inertia will get triggered.
            if (toWorld.length() === 0 &&
                !(this.m_touchState.touches.length === 3 && this.tiltEnabled)) {
                this.setTouchState([]);
                this.m_state = State.NONE;
                this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);
                return;
            }
            if (this.m_state !== State.TOUCH) {
                this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);
            }
            this.m_state = State.TOUCH;
            return {
                currentTouchPoint: newTouchPoint,
                lastTouchPoint: newTouchPoint,
                currentWorldPosition: toWorld,
                initialWorldPosition: toWorld
            };
        }
    }
    setTouchState(touches) {
        this.m_touchState.touches = [];
        // TouchList doesn't conform to iterator interface so we cannot use 'for of'
        // tslint:disable-next-line:prefer-for-of
        for (let i = 0; i < touches.length; ++i) {
            const touchState = this.convertTouchPoint(touches[i]);
            if (touchState !== undefined) {
                this.m_touchState.touches.push(touchState);
            }
        }
        if (this.m_touchState.touches.length !== 0) {
            this.updateCurrentRotation();
            this.m_touchState.initialRotation = this.m_touchState.currentRotation;
        }
    }
    updateTouches(touches) {
        const length = Math.min(touches.length, this.m_touchState.touches.length);
        for (let i = 0; i < length; ++i) {
            const oldTouchState = this.m_touchState.touches[i];
            const newTouchState = this.convertTouchPoint(touches[i], oldTouchState);
            if (newTouchState !== undefined && oldTouchState !== undefined) {
                newTouchState.initialWorldPosition = oldTouchState.initialWorldPosition;
                newTouchState.lastTouchPoint = oldTouchState.currentTouchPoint;
                this.m_touchState.touches[i] = newTouchState;
            }
        }
    }
    zoomOnDoubleClickOrTap(x, y) {
        if (this.zoomLevelDeltaOnDoubleClick === 0) {
            return;
        }
        const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);
        const ndcCoords = utils.calculateNormalizedDeviceCoordinates(x, y, width, height);
        this.setZoomLevel(this.currentZoom + this.zoomLevelDeltaOnDoubleClick, ndcCoords);
    }
    touchStart(event) {
        if (this.enabled === false) {
            return;
        }
        this.m_tapStartTime = performance.now();
        this.m_fingerMoved = false;
        this.m_state = State.TOUCH;
        this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);
        this.setTouchState(event.touches);
        this.updateTouches(event.touches);
        event.preventDefault();
        event.stopPropagation();
    }
    touchMove(event) {
        if (this.enabled === false) {
            return;
        }
        this.m_fingerMoved = true;
        this.updateTouches(event.touches);
        if (this.m_touchState.touches.length <= 2 && this.m_touchState.touches[0] !== undefined) {
            this.panFromTo(this.m_touchState.touches[0].initialWorldPosition, this.m_touchState.touches[0].currentWorldPosition);
        }
        if (this.m_touchState.touches.length === 2) {
            const pinchDistance = this.calculatePinchDistanceInWorldSpace();
            if (Math.abs(pinchDistance) < EPSILON) {
                return;
            }
            this.updateCurrentRotation();
            const deltaRotation = this.m_touchState.currentRotation - this.m_touchState.initialRotation;
            this.stopExistingAnimations();
            harp_mapview_1.MapViewUtils.rotate(this.mapView, THREE.Math.radToDeg(deltaRotation));
            this.moveAlongTheViewDirection(pinchDistance);
        }
        // Tilting
        if (this.m_touchState.touches.length === 3 && this.tiltEnabled) {
            const firstTouch = this.m_touchState.touches[0];
            const diff = this.m_tmpVector2.subVectors(firstTouch.currentTouchPoint, firstTouch.lastTouchPoint);
            this.stopExistingAnimations();
            harp_mapview_1.MapViewUtils.orbitFocusPoint(this.mapView, this.orbitingTouchDeltaFactor * diff.x, -this.orbitingTouchDeltaFactor * diff.y, this.m_maxTiltAngle);
        }
        this.m_zoomAnimationStartTime = performance.now();
        this.updateMapView();
        event.preventDefault();
        event.stopPropagation();
    }
    touchEnd(event) {
        if (this.enabled === false) {
            return;
        }
        this.m_state = State.NONE;
        this.handleDoubleTap();
        this.setTouchState(event.touches);
        this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);
        this.updateMapView();
        event.preventDefault();
        event.stopPropagation();
    }
    handleDoubleTap() {
        // Continue only if no touchmove happened.
        if (this.m_fingerMoved) {
            return;
        }
        const now = performance.now();
        const tapDuration = now - this.m_tapStartTime;
        // Continue only if proper tap.
        if (tapDuration > MAX_TAP_DURATION) {
            return;
        }
        // Continue only if this is the second valid tap.
        if (!this.m_isDoubleTap) {
            this.m_isDoubleTap = true;
            this.m_lastSingleTapTime = now;
            return;
        }
        // Continue only if the delay between the two taps is short enough.
        if (now - this.m_lastSingleTapTime > this.doubleTapTime * 1000) {
            // If too long, restart double tap validator too.
            this.m_isDoubleTap = false;
            return;
        }
        this.zoomOnDoubleClickOrTap(this.m_touchState.touches[0].currentTouchPoint.x, this.m_touchState.touches[0].currentTouchPoint.y);
        // Prevent a string of X valid taps and only consider pairs.
        this.m_isDoubleTap = false;
    }
    contextMenu(event) {
        event.preventDefault();
    }
    getWorldPositionWithElevation(fromX, fromY, toX, toY) {
        const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);
        const from = utils.calculateNormalizedDeviceCoordinates(fromX, fromY, width, height);
        const to = utils.calculateNormalizedDeviceCoordinates(toX, toY, width, height);
        let toWorld;
        let fromWorld;
        let elevationProviderResult;
        if (this.mapView.elevationProvider !== undefined) {
            elevationProviderResult = this.mapView.elevationProvider.rayCast(fromX, fromY);
        }
        if (elevationProviderResult === undefined) {
            fromWorld = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, from.x, from.y);
            toWorld = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, to.x, to.y);
        }
        else {
            fromWorld = elevationProviderResult;
            const fromGeoAltitude = this.mapView.projection.unprojectAltitude(fromWorld);
            // We can ensure that points under the mouse stay there by projecting the to point onto
            // a plane with the altitude based on the initial point.
            toWorld = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, to.x, to.y, fromGeoAltitude);
        }
        if (fromWorld === null || toWorld === null) {
            return;
        }
        return { fromWorld, toWorld };
    }
    panFromTo(fromWorld, toWorld) {
        this.stopExistingAnimations();
        // Assign the new animation start time.
        this.m_panAnimationStartTime = performance.now();
        if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {
            this.m_panDistanceFrameDelta.subVectors(fromWorld, toWorld);
        }
        else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {
            this.m_lastRotateGlobeFromVector.copy(fromWorld);
            this.m_lastRotateGlobeAxis.crossVectors(fromWorld, toWorld).normalize();
            this.m_lastRotateGlobeAngle = fromWorld.angleTo(toWorld);
            // When fromWorld and toWorld are too close, there is a risk of getting an NaN
            // value. The following ensures that the controls don't break.
            if (isNaN(this.m_lastRotateGlobeAngle)) {
                this.m_lastRotateGlobeAngle = 0;
            }
        }
        this.handlePan();
    }
}
exports.MapControls = MapControls;


/***/ }),

/***/ "../harp-map-controls/lib/MapControlsUI.ts":
/*!*************************************************!*\
  !*** ../harp-map-controls/lib/MapControlsUI.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.js");
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Base class to handle UI overlay elements.
 */
class MapControlsUI {
    /**
     * Constructor of the UI.
     *
     * @param controls Controls referencing a [[MapView]].
     */
    constructor(controls, options = {}) {
        this.controls = controls;
        /**
         * The DOM node containing the UI.
         */
        this.domElement = document.createElement("div");
        this.m_buttonsElement = document.createElement("div");
        /**
         * Displays zoom level if [[MapControlsUIOptions.zoomLevel]] is defined.
         */
        this.m_zoomLevelElement = null;
        /**
         * Displays zoom level if [[MapControlsUIOptions.projectionSwitch]] is defined.
         */
        this.m_projectionSwitchElement = null;
        this.m_onMapViewRenderEvent = () => {
            if (this.m_zoomLevelElement === null) {
                return;
            }
            const zoom = this.controls.zoomLevelTargeted.toFixed(1);
            if (this.m_zoomLevelElement.tagName === "INPUT") {
                this.m_zoomLevelElement.value = zoom;
            }
            else {
                this.m_zoomLevelElement.innerHTML = zoom;
            }
        };
        this.m_onWindowClick = (event) => {
            const input = this.m_zoomLevelElement;
            if (!event ||
                !event.target ||
                !event.target.contains ||
                event.target === input ||
                event.target.contains(input)) {
                return;
            }
            input.blur();
        };
        // Empty element to dynamically align the controls vertically, depending on which buttons
        // are enabled. Avoids unreliable style computations in the script.
        const verticalAligner = document.createElement("span");
        verticalAligner.className = "harp-gl_v-align";
        this.domElement.appendChild(verticalAligner);
        // This element will receive the controls and ensure the vertical alignment in the CSS.
        this.m_buttonsElement = document.createElement("div");
        this.m_buttonsElement.className = "harp-gl_v-aligned";
        this.domElement.appendChild(this.m_buttonsElement);
        const zoomInButton = document.createElement("button");
        zoomInButton.innerText = "+";
        zoomInButton.className = "harp-gl_controls_button-top";
        zoomInButton.classList.add("harp-gl_controls-button");
        const zoomOutButton = document.createElement("button");
        zoomOutButton.innerText = "-";
        zoomOutButton.className = "harp-gl_controls_button-bottom";
        zoomOutButton.classList.add("harp-gl_controls-button");
        const tiltButton = document.createElement("button");
        tiltButton.innerText = "3D";
        tiltButton.id = "harp-gl_controls_tilt-button-ui";
        tiltButton.title = "Toggle tilt";
        tiltButton.classList.add("harp-gl_controls-button");
        tiltButton.classList.add("harp-gl_controls_button-bottom");
        const compassButton = document.createElement("button");
        compassButton.id = "harp-gl_controls-button_compass";
        compassButton.title = "Reset North";
        compassButton.classList.add("harp-gl_controls-button");
        compassButton.classList.add("harp-gl_controls_button-top");
        const compass = document.createElement("span");
        compass.id = "harp-gl_controls_compass";
        compassButton.appendChild(compass);
        // Optional zoom level displaying
        if (options.zoomLevel === "show") {
            this.m_zoomLevelElement = document.createElement("div");
            controls.mapView.addEventListener(harp_mapview_1.MapViewEventNames.Render, this.m_onMapViewRenderEvent);
        }
        else if (options.zoomLevel === "input") {
            const input = document.createElement("input");
            input.type = "number";
            input.step = "0.1"; // Avoids messages in the UI on hovering, when a tenth value exists.
            controls.mapView.addEventListener(harp_mapview_1.MapViewEventNames.Render, this.m_onMapViewRenderEvent);
            const updateZoom = (event) => {
                controls.setZoomLevel(parseFloat(input.value));
                event.preventDefault();
            };
            input.addEventListener("blur", updateZoom);
            input.addEventListener("keypress", event => {
                if (event.key === "Enter") {
                    updateZoom(event);
                }
            });
            window.addEventListener("click", this.m_onWindowClick);
            this.m_zoomLevelElement = input;
        }
        if (options.projectionSwitch) {
            const switcher = document.createElement("button");
            switcher.id = "harp-gl_controls_switch_projection";
            switcher.classList.add("harp-gl_controls-button");
            const getTitle = () => {
                return `Switch to ${this.controls.mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical
                    ? "flat"
                    : "globe"} projection`;
            };
            switcher.title = getTitle();
            const globeSVG = getGlobeSVG();
            const flatMapSVG = getFlatMapSVG();
            switcher.innerHTML =
                this.controls.mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical
                    ? flatMapSVG
                    : globeSVG;
            switcher.addEventListener("click", () => {
                this.controls.mapView.projection =
                    this.controls.mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical
                        ? harp_geoutils_1.mercatorProjection
                        : harp_geoutils_1.sphereProjection;
                switcher.title = getTitle();
                switcher.innerHTML =
                    this.controls.mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical
                        ? flatMapSVG
                        : globeSVG;
            });
            this.m_projectionSwitchElement = switcher;
        }
        this.m_buttonsElement.appendChild(zoomInButton);
        if (this.m_zoomLevelElement !== null) {
            this.m_buttonsElement.appendChild(this.m_zoomLevelElement);
        }
        this.m_buttonsElement.appendChild(zoomOutButton);
        this.m_buttonsElement.appendChild(compassButton);
        this.m_buttonsElement.appendChild(tiltButton);
        if (this.m_projectionSwitchElement !== null) {
            this.m_buttonsElement.appendChild(this.m_projectionSwitchElement);
        }
        zoomInButton.addEventListener("click", event => {
            const zoomLevel = controls.zoomLevelTargeted + controls.zoomLevelDeltaOnControl;
            controls.setZoomLevel(zoomLevel);
        });
        zoomOutButton.addEventListener("click", event => {
            const zoomLevel = controls.zoomLevelTargeted - controls.zoomLevelDeltaOnControl;
            controls.setZoomLevel(zoomLevel);
        });
        tiltButton.addEventListener("click", event => {
            controls.toggleTilt();
        });
        compassButton.addEventListener("click", event => {
            controls.pointToNorth();
        });
        controls.mapView.addEventListener(harp_mapview_1.MapViewEventNames.AfterRender, () => {
            compass.style.transform = `rotate(${THREE.Math.radToDeg(harp_mapview_1.MapViewUtils.extractAttitude(controls.mapView, controls.mapView.camera).yaw)}deg)`;
        });
        this.domElement.className = "harp-gl_controls";
        if (this.m_zoomLevelElement !== null) {
            this.m_zoomLevelElement.classList.add("harp-gl_controls_zoom-level");
        }
        if (options.disableDefaultStyle !== true) {
            this.initStyle();
            this.domElement.style.cssText = `
                position: absolute;
                right: 5px;
                top: 0;
                height: 100%; /* Vertical alignment is done dynamically, in the rest of the CSS. */
                pointer-events: none; /* Allows to click the map even though height is 100%. */
            `;
        }
        return this;
    }
    /**
     * Destroy this [[MapControlsUI]] instance. Unregisters all event handlers used. This method
     * should be called when you stop using [[MapControlsUI]].
     */
    dispose() {
        if (this.m_zoomLevelElement !== null && this.m_zoomLevelElement.tagName === "INPUT") {
            window.removeEventListener("click", this.m_onWindowClick);
        }
        this.controls.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.Render, this.m_onMapViewRenderEvent);
        this.domElement.remove();
    }
    initStyle() {
        if (document.getElementById("here-harp-controls.map-controls-ui-styles") !== null) {
            return;
        }
        const style = document.createElement("style");
        style.id = "here-harp-controls.map-controls-ui-styles";
        style.appendChild(document.createTextNode(getTextStyle()));
        document.head.appendChild(style);
    }
}
exports.MapControlsUI = MapControlsUI;
function getTextStyle() {
    return `
        /* CSS trick to align another div dynamically. */
        .harp-gl_v-align{
            height: 100%;
            display: inline-block;
            vertical-align: middle;
        }
        /* The target element to align vertically with vertical-align. */
        .harp-gl_v-aligned{
            pointer-events: all;
            vertical-align: middle;
            display: inline-block;
        }
        .harp-gl_controls-button {
            display: block;
            background-color: #272d37;
            width: 40px;
            height: 40px;
            font-size: 22px;
            font-weight: bold;
            outline: none;
            margin:0;
            border: none;
            color: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            border-radius: 4px;
            box-shadow: 0px 0px 5px 0 hsl(220, 4%, 40%);
            transition: all 0.1s;
            padding: 0 0 1px 1px;
            user-select: none;
            position:relative;
        }
        #harp-gl_controls_tilt-button-ui {
            font-size: 16px;
        }
        .harp-gl_controls-button:active {
            background-color: #37afaa;
            color: #eee;
        }
        .harp-gl_controls-button:focus {
            outline:none;
        }
        .harp-gl_controls_button-top{
            margin-bottom:0;
            border-bottom-right-radius:0;
            border-bottom-left-radius:0;
        }
        .harp-gl_controls_button-bottom{
            margin-top:1px;
            border-top-right-radius:0;
            border-top-left-radius:0;
        }
        .harp-gl_controls_zoom-level {
            display: block;
            background-color: #fff;
            width: 40px;
            height: 20px;
            font-size: 12px;
            font-weight: bold;
            outline: none;
            border: none;
            color: #555;
            opacity: 0.87;
            box-shadow: 0px 0px 4px #aaa;
            padding: 2px 0 0;
            text-align: center;
            user-select: text;
        }
        input.harp-gl_controls_zoom-level::-webkit-outer-spin-button,
        input.harp-gl_controls_zoom-level::-webkit-inner-spin-button {
            /* display: none; <- Crashes Chrome on hover */
            -webkit-appearance: none;
            margin: 0; /* <-- Apparently some margin are still there even though it's hidden */
        }
        input.harp-gl_controls_zoom-level[type=number] {
            -moz-appearance:textfield; /* Firefox */
        }
        #harp-gl_controls-button_compass{
            margin: 5px 0 0 0;
        }
        #harp-gl_controls_compass{
            pointer-events:none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            margin:0
        }
        #harp-gl_controls_compass::after{
            content: " ";
            position:absolute;
            left:50%;
            margin-left:-3px;
            top:50%;
            margin-top: -18px;
            border:solid 3px rgba(0,0,0,0);
            border-bottom:solid 15px #a34f2e;
        }
        #harp-gl_controls_compass::before{
            content: " ";
            position:absolute;
            left:50%;
            margin-left:-3px;
            top:50%;
            margin-top:0px;
            border:solid 3px rgba(0,0,0,0);
            border-top:solid 15px #eee;
        }
        #harp-gl_controls_switch_projection{
            margin-top:5px;
        }
        .harp-gl_controls_switch_svg{
            width: 25px;
            height: 25px;
            stroke: #d4d5d7;
            fill: #d4d5d7;
        }
    `;
}
// tslint:disable:max-line-length
function getFlatMapSVG() {
    return `
    <svg style="margin-top:5px;" class="harp-gl_controls_switch_svg" width="25" height="25" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg">
        <rect id="svg_1" stroke-width="2" height="13.51524" width="18.35821" y="5.80349" x="3.21307" fill="none"/>
        <path id="svg_14" d="m9.52018,7.71815l1.2357,-0.0032l-0.61945,1.18258l-0.61625,-1.17938z"/>
        <path id="svg_15" d="m4.11409,7.32396l3.65718,-0.0032l0.28156,2.13991l-2.59042,1.57678l0.50682,1.80203l2.25254,0.8447l-0.90101,2.0836l0.28157,2.25254l-3.26619,-3.04093l0.67576,-2.02728l-0.61945,-1.97097l-1.01364,-3.15356l0.73528,-0.50362z"/>
        <path id="svg_17" d="m13.23688,7.4929l2.02409,-0.0032l0.78839,1.29521l2.47779,-1.35152l2.75936,0.78839l0,1.57678l-0.73208,0.61945l-0.28157,1.97097c0,0 -0.67256,0.8479 -0.72888,0.90422c-0.05631,0.05631 0.28157,1.06996 0.33788,1.18258c0.05631,0.11263 -1.68941,-1.35152 -1.6926,-1.35472c-0.0032,-0.0032 -0.16574,1.29841 -0.16894,1.29521c-0.0032,-0.0032 -1.57358,-1.34832 -1.57678,-1.35152c-0.0032,-0.0032 -0.72888,0.67896 -0.73208,0.67576c-0.0032,-0.0032 -0.8415,-0.67256 -0.8447,-0.67576c-0.0032,-0.0032 0.73528,2.0868 0.79159,2.0868c0.05631,0 -0.50682,3.20987 -0.51002,3.20667c-0.0032,-0.0032 -1.2357,-0.16574 -1.34832,-0.16574c-0.11263,0 -0.95733,-1.52046 -0.90102,-1.57678c0.05631,-0.05631 0,-1.80203 -0.0032,-1.80523c-0.0032,-0.0032 -1.40464,-0.33468 -1.40784,-0.33788c-0.0032,-0.0032 -0.05311,-1.74252 -0.05631,-1.74572c-0.0032,-0.0032 1.18578,-0.8415 1.18258,-0.8447c-0.0032,-0.0032 1.69261,-0.16574 1.74892,-0.16574c0.05631,0 1.2389,-1.06996 1.2357,-1.07316c-0.0032,-0.0032 -1.91146,-0.10943 -1.91466,-0.11263c-0.0032,-0.0032 -1.96777,0.17214 -1.97097,0.16894c-0.0032,-0.0032 1.52366,-3.20667 1.52366,-3.20667z"/>
    </svg>`;
}
function getGlobeSVG() {
    return `
    <svg style="margin-top:5px;" stroke-width="2" class="harp-gl_controls_switch_svg" width="50" height="50" viewBox="0 0 25 25" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg">
        <ellipse ry="9.79855" rx="4.56139" id="svg_6" cy="11.99798" cx="11.99798" fill="none"/>
        <line id="svg_8" y2="8.16866" x2="21.12086" y1="8.16866" x1="3.10044"/>
        <line id="svg_9" y2="16.10887" x2="21.0645" y1="16.10887" x1="3.04409"/>
        <ellipse id="svg_11" ry="9.79855" rx="9.82671" cy="11.94167" cx="12.02614" fill="none"/>
    </svg>`;
}


/***/ }),

/***/ "../harp-map-controls/lib/Utils.ts":
/*!*****************************************!*\
  !*** ../harp-map-controls/lib/Utils.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const three_1 = __webpack_require__(/*! three */ "three");
/**
 * Transforms the given point in screen space into NDC space by taking the given screen dimension
 * into account.
 *
 * @param screenCoordinateX X coordinate in screen space.
 * @param screenCoordinateY Y coordinate in screen space.
 * @param screenSizeX Width of the reference screen size.
 * @param screenSizeY Height of the reference screen size.
 */
function calculateNormalizedDeviceCoordinates(screenCoordinateX, screenCoordinateY, screenSizeX, screenSizeY) {
    return new three_1.Vector2((screenCoordinateX / screenSizeX) * 2 - 1, -((screenCoordinateY / screenSizeY) * 2) + 1);
}
exports.calculateNormalizedDeviceCoordinates = calculateNormalizedDeviceCoordinates;
/**
 * Returns the direction vector that is described by the given azimuth and altitude.
 *
 * @param azimuth Azimuth in radians.
 * @param altitude Altitude in radians.
 */
function azimuthAltitudeToDirection(azimuth, altitude) {
    azimuth = azimuth;
    altitude = altitude;
    //Shamelessly copied from Jan ;)
    const result = new three_1.Vector3();
    const cosAltitude = Math.cos(altitude);
    result.setX(Math.sin(azimuth) * cosAltitude);
    result.setY(Math.cos(azimuth) * cosAltitude);
    result.setZ(Math.sin(altitude));
    return result;
}
exports.azimuthAltitudeToDirection = azimuthAltitudeToDirection;
/**
 * Safely parses decimal value into `number`.
 *
 * Safely falls back to default value for `null`, `undefined`, `NaN`, empty strings, and strings
 * with characters other than digits.
 *
 * @param text Number as a text to be parsed.
 * @param fallback Default value, which is returned if `text` doesn't represent a valid number.
 */
function safeParseDecimalInt(text, fallback) {
    if (text === null || text === undefined || text === "") {
        return fallback;
    }
    if (!text.match(integerRe)) {
        return fallback;
    }
    const result = Number.parseInt(text, 10);
    if (isNaN(result)) {
        return fallback;
    }
    return result;
}
exports.safeParseDecimalInt = safeParseDecimalInt;
const integerRe = /^\d+$/;
/**
 * Extracts the CSS width and height of the given canvas if available, or width and height of the
 * canvas otherwise.
 *
 * @param canvas The canvas.
 */
function getWidthAndHeightFromCanvas(canvas) {
    return {
        //use clientWidth and clientHeight to support HiDPI devices
        width: safeParseDecimalInt(canvas.style.width, canvas.clientWidth),
        height: safeParseDecimalInt(canvas.style.height, canvas.clientHeight)
    };
}
exports.getWidthAndHeightFromCanvas = getWidthAndHeightFromCanvas;


/***/ }),

/***/ "../harp-mapview-decoder/index.ts":
/*!****************************************!*\
  !*** ../harp-mapview-decoder/index.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/TileDataSource */ "../harp-mapview-decoder/lib/TileDataSource.ts"));
__export(__webpack_require__(/*! ./lib/TileLoader */ "../harp-mapview-decoder/lib/TileLoader.ts"));


/***/ }),

/***/ "../harp-mapview-decoder/lib/TileDataSource.ts":
/*!*****************************************************!*\
  !*** ../harp-mapview-decoder/lib/TileDataSource.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const TileLoader_1 = __webpack_require__(/*! ./TileLoader */ "../harp-mapview-decoder/lib/TileLoader.ts");
/**
 * Templated factory class to create instances of [[Tile]].
 */
class TileFactory {
    /**
     * Initialize the factory using the constructor of the element to be called when a [[Tile]] is
     * created.
     *
     * @param m_modelConstructor Constructor of (subclass of) [[Tile]].
     */
    constructor(m_modelConstructor) {
        this.m_modelConstructor = m_modelConstructor;
    }
    /**
     * Create an instance of (subclass of) [[Tile]]. The required parameters are passed as arguments
     * to the constructor of [[Tile]].
     *
     * @param dataSource [[Datasource]] this class belongs to.
     * @param tileKey Quadtree address of the [[Tile]].
     */
    create(dataSource, tileKey) {
        return new this.m_modelConstructor(dataSource, tileKey);
    }
}
exports.TileFactory = TileFactory;
/**
 * Common base class for the typical [[DataSource]] which uses an [[ITileDecoder]] to decode the
 * tile content asynchronously. The decoder can be passed in as an option, or a default
 * asynchronous one is generated.
 */
class TileDataSource extends harp_mapview_1.DataSource {
    /**
     * Set up the `TileDataSource`.
     *
     * @param m_tileFactory Factory to create the [[Tile]] instances.
     * @param m_options Options specifying the parameters of the [[DataSource]].
     */
    constructor(m_tileFactory, m_options) {
        super(m_options.name, m_options.styleSetName, m_options.minZoomLevel, m_options.maxZoomLevel, m_options.storageLevelOffset);
        this.m_tileFactory = m_tileFactory;
        this.m_options = m_options;
        this.logger = harp_utils_1.LoggerManager.instance.create("TileDataSource");
        this.m_isReady = false;
        if (m_options.decoder) {
            this.m_decoder = m_options.decoder;
        }
        else if (m_options.concurrentDecoderServiceName) {
            this.m_decoder = harp_mapview_1.ConcurrentDecoderFacade.getTileDecoder(m_options.concurrentDecoderServiceName, m_options.concurrentDecoderScriptUrl, m_options.concurrentDecoderWorkerCount);
        }
        else {
            throw new Error(`TileDataSource[${this.name}]: unable to create, missing decoder or ` +
                `concurrentDecoderServiceName`);
        }
        this.useGeometryLoader = true;
        this.cacheable = true;
    }
    /** @override */
    dispose() {
        this.decoder.dispose();
    }
    /** @override */
    ready() {
        return this.m_isReady && this.m_options.dataProvider.ready();
    }
    /**
     * Get the [[ITileDecoder]] of this `ITileDataSource`, which has either been passed in with
     * the options, or has been supplied by the [[ConcurrentDecoderFacade]].
     */
    get decoder() {
        return this.m_decoder;
    }
    /** @override */
    async connect() {
        await Promise.all([this.m_options.dataProvider.connect(), this.m_decoder.connect()]);
        this.m_isReady = true;
        this.m_decoder.configure(undefined, undefined, undefined, {
            storageLevelOffset: this.m_options.storageLevelOffset
        });
    }
    /** @override */
    setStyleSet(styleSet, definitions, languages) {
        this.m_decoder.configure(styleSet, definitions, languages);
        this.mapView.markTilesDirty(this);
    }
    /**
     * Apply the [[Theme]] to this data source.
     *
     * Applies new [[StyleSet]] and definitions from theme only if matching styleset (see
     * `styleSetName` property) is found in `theme`.
     * @override
     */
    setTheme(theme, languages) {
        const styleSet = this.styleSetName !== undefined && theme.styles
            ? theme.styles[this.styleSetName]
            : undefined;
        if (styleSet !== undefined) {
            this.setStyleSet(styleSet, theme.definitions, languages);
        }
    }
    /**
     * Get the [[DataProvider]] that has been passed in with the options.
     */
    dataProvider() {
        return this.m_options.dataProvider;
    }
    /** @override */
    getTilingScheme() {
        return this.m_options.tilingScheme;
    }
    /**
     * Create a [[Tile]] and start the asynchronous download of the tile content. The [[Tile]] will
     * be empty, but the download and decoding will be scheduled immediately. [[Tile]] instance is
     * initialized with default copyrights, concatenated with copyrights from copyright provider of
     * this data source.
     *
     * @param tileKey Quadtree address of the requested tile.
     * @override
     */
    getTile(tileKey) {
        const tile = this.m_tileFactory.create(this, tileKey);
        tile.tileLoader = new TileLoader_1.TileLoader(this, tileKey, this.m_options.dataProvider, this.decoder, 0);
        tile.copyrightInfo = this.m_options.copyrightInfo;
        if (this.m_options.copyrightProvider !== undefined) {
            this.m_options.copyrightProvider
                .getCopyrights(tile.geoBox, tileKey.level)
                .then(copyrightInfo => {
                tile.copyrightInfo =
                    tile.copyrightInfo === undefined
                        ? copyrightInfo
                        : [...tile.copyrightInfo, ...copyrightInfo];
                this.requestUpdate();
            });
        }
        tile.load();
        return tile;
    }
    /**
     * Get [[TileInfo]] of a tile.
     *
     * @param tileKey Quadtree address of the requested tile.
     * @returns A promise which will contain the [[TileInfo]] when resolved.
     */
    getTileInfo(tileKey) {
        const promise = new Promise((resolve, reject) => {
            const tileLoader = new TileLoader_1.TileInfoLoader(this, tileKey, this.m_options.dataProvider, this.decoder, 0);
            tileLoader.loadAndDecode().then(loaderState => {
                if (loaderState === harp_mapview_1.TileLoaderState.Ready) {
                    resolve(tileLoader.tileInfo);
                }
                else {
                    reject(new Error(`TileDataSource#getInfoTile wrong final state: ${loaderState}`));
                }
            });
        });
        return promise;
    }
}
exports.TileDataSource = TileDataSource;


/***/ }),

/***/ "../harp-mapview-decoder/lib/TileLoader.ts":
/*!*************************************************!*\
  !*** ../harp-mapview-decoder/lib/TileLoader.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
__webpack_require__(/*! @here/harp-fetch */ "../harp-fetch/index.web.ts");
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
/**
 * Logger to write to console etc.
 */
const logger = harp_utils_1.LoggerManager.instance.create("TileLoader");
/**
 * The [[TileLoader]] manages the different states of loading and decoding for a [[Tile]]. Used by
 * the [[TileDataSource]].
 */
class TileLoader {
    /**
     * Set up loading of a single [[Tile]].
     *
     * @param dataSource The [[DataSource]] the tile belongs to.
     * @param tileKey The quadtree address of a [[Tile]].
     * @param dataProvider The [[DataProvider]] that retrieves the binary tile data.
     * @param tileDecoder The [[ITileDecoder]] that decodes the binary tile to a [[DecodeTile]].
     * @param priority The priority given to the loading job. Highest number will be served first.
     */
    constructor(dataSource, tileKey, dataProvider, tileDecoder, priority) {
        this.dataSource = dataSource;
        this.tileKey = tileKey;
        this.dataProvider = dataProvider;
        this.tileDecoder = tileDecoder;
        this.priority = priority;
        /**
         * Current state of `TileLoader`.
         */
        this.state = harp_mapview_1.TileLoaderState.Initialized;
        /**
         * The abort controller notifying the [[DataProvider]] to cancel loading.
         */
        this.loadAbortController = new AbortController();
    }
    /**
     * Start loading and/or proceed through the various states of loading of this tile.
     *
     * @returns A promise which resolves the [[TileLoaderState]].
     */
    loadAndDecode() {
        switch (this.state) {
            case harp_mapview_1.TileLoaderState.Loading:
            case harp_mapview_1.TileLoaderState.Loaded:
            case harp_mapview_1.TileLoaderState.Decoding:
                // tile is already loading
                return this.donePromise;
            case harp_mapview_1.TileLoaderState.Ready:
            case harp_mapview_1.TileLoaderState.Failed:
            case harp_mapview_1.TileLoaderState.Initialized:
            case harp_mapview_1.TileLoaderState.Canceled:
                // restart loading
                this.startLoading();
                return this.donePromise;
        }
    }
    /**
     * Return the current state in form of a promise. Caller can then wait for the promise to be
     * resolved.
     *
     * @returns A promise which resolves the current [[TileLoaderState]].
     */
    waitSettled() {
        if (!this.donePromise) {
            return Promise.resolve(this.state);
        }
        return this.donePromise;
    }
    /**
     * Cancel loading of the [[Tile]].
     * Cancellation token is notified, an internal state is cleaned up.
     */
    cancel() {
        switch (this.state) {
            case harp_mapview_1.TileLoaderState.Loading:
                this.loadAbortController.abort();
                this.loadAbortController = new AbortController();
                break;
            case harp_mapview_1.TileLoaderState.Decoding:
                if (this.requestController) {
                    this.requestController.abort();
                    this.requestController = undefined;
                }
                break;
        }
        this.onDone(harp_mapview_1.TileLoaderState.Canceled);
    }
    /**
     * Return `true` if [[Tile]] is still loading, `false` otherwise.
     */
    get isFinished() {
        return (this.state === harp_mapview_1.TileLoaderState.Ready ||
            this.state === harp_mapview_1.TileLoaderState.Canceled ||
            this.state === harp_mapview_1.TileLoaderState.Failed);
    }
    /**
     * Update the priority of this [[Tile]]'s priority. Is effective to sort the decoding requests
     * in the request queue (used during heavy load).
     */
    updatePriority(priority) {
        this.priority = priority;
        if (this.requestController !== undefined) {
            this.requestController.priority = priority;
        }
    }
    /**
     * Start loading. Only call if loading did not start yet.
     */
    startLoading() {
        const myLoadCancellationToken = this.loadAbortController.signal;
        this.dataProvider
            .getTile(this.tileKey, myLoadCancellationToken)
            .then(payload => {
            if (myLoadCancellationToken.aborted) {
                // safety belt if getTile doesn't really support cancellation tokens
                const err = new Error("Aborted");
                err.name = "AbortError";
                throw err;
            }
            this.onLoaded(payload);
        })
            .catch(error => {
            // Handle abort messages from fetch and also our own.
            if (error.name === "AbortError" || error.message === "AbortError: Aborted") {
                return;
            }
            this.onError(error);
        });
        if (this.donePromise === undefined) {
            this.donePromise = new Promise((resolve, reject) => {
                this.resolveDonePromise = resolve;
                this.rejectedDonePromise = reject;
            });
        }
        this.state = harp_mapview_1.TileLoaderState.Loading;
    }
    /**
     * Called when binary data has been loaded. The loading state is now progressing to decoding.
     *
     * @param payload Binary data in form of [[ArrayBufferLike]], or any object.
     */
    onLoaded(payload) {
        this.state = harp_mapview_1.TileLoaderState.Loaded;
        this.payload = payload;
        if (payload.byteLength !== undefined) {
            if (payload.byteLength === 0) {
                this.onDone(harp_mapview_1.TileLoaderState.Ready);
                return;
            }
        }
        // Object is empty
        if (payload === {}) {
            this.onDone(harp_mapview_1.TileLoaderState.Ready);
            return;
        }
        // TBD: we might suspend decode if tile is not visible ... ?
        this.startDecodeTile();
    }
    /**
     * Start decoding the payload.
     */
    startDecodeTile() {
        const payload = this.payload;
        if (payload === undefined) {
            logger.error("TileLoader#startDecodeTile: Cannot decode without payload");
            return;
        }
        this.state = harp_mapview_1.TileLoaderState.Decoding;
        this.payload = undefined;
        // Save our cancellation point, so we can be reliably cancelled by any subsequent decode
        // attempts
        const requestController = new harp_datasource_protocol_1.RequestController(this.priority);
        this.requestController = requestController;
        const dataSource = this.dataSource;
        this.tileDecoder
            .decodeTile(payload, this.tileKey, dataSource.projection, requestController)
            .then(decodedTile => {
            if (requestController.signal.aborted) {
                // our flow is cancelled, silently return
                return;
            }
            this.onDecoded(decodedTile);
        })
            .catch(error => {
            // Handle abort messages from fetch and also our own.
            if (error.name === "AbortError" || error.message === "AbortError: Aborted") {
                // our flow is cancelled, silently return
                return;
            }
            this.onError(error);
        });
    }
    /**
     * Called when the decoding is finished, and the [[DecodedTile]] has been created.
     *
     * @param decodedTile The [[DecodedTile]].
     */
    onDecoded(decodedTile) {
        this.decodedTile = decodedTile;
        this.onDone(harp_mapview_1.TileLoaderState.Ready);
    }
    /**
     * Cancel the decoding process.
     */
    cancelDecoding() {
        if (this.requestController !== undefined) {
            // we should cancel any decodes already in progress!
            this.requestController.abort();
            this.requestController = undefined;
        }
    }
    /**
     * Called when loading and decoding has finished successfully. Resolves loading promise if the
     * state is Ready, otherwise it rejects the promise with the supplied state.
     *
     * @param doneState The latest state of loading.
     */
    onDone(doneState) {
        if (this.resolveDonePromise && doneState === harp_mapview_1.TileLoaderState.Ready) {
            this.resolveDonePromise(doneState);
        }
        else if (this.rejectedDonePromise) {
            this.rejectedDonePromise(doneState);
        }
        this.resolveDonePromise = undefined;
        this.rejectedDonePromise = undefined;
        this.donePromise = undefined;
        this.state = doneState;
    }
    /**
     * Called when loading or decoding has finished with an error.
     *
     * @param error Error object describing the failing.
     */
    onError(error) {
        if (this.state === harp_mapview_1.TileLoaderState.Canceled) {
            // If we're canceled, we should simply ignore any state transitions and errors from
            // underlying load/decode ops.
            return;
        }
        const dataSource = this.dataSource;
        logger.error(`[${dataSource.name}]: failed to load tile ${this.tileKey.mortonCode()}`, error);
        this.error = error;
        this.onDone(harp_mapview_1.TileLoaderState.Failed);
    }
}
exports.TileLoader = TileLoader;
/**
 * Subclass of [[TileLoader]] which is used by [[TileDataSource]] to load the [[TileInfo]] meta
 * data, not the tile data itself.
 */
class TileInfoLoader extends TileLoader {
    /** @override */
    startDecodeTile() {
        const payload = this.payload;
        if (payload === undefined) {
            logger.error("TileInfoLoader#startDecodeTile: Cannot decode without payload");
            return;
        }
        this.state = harp_mapview_1.TileLoaderState.Decoding;
        this.payload = undefined;
        // Save our cancellation point, so we can be reliably cancelled by any subsequent decode
        // attempts
        const requestController = new harp_datasource_protocol_1.RequestController(this.priority);
        this.requestController = requestController;
        const dataSource = this.dataSource;
        this.tileDecoder
            .getTileInfo(payload, this.tileKey, dataSource.projection, requestController)
            .then(tileInfo => {
            if (requestController.signal.aborted) {
                // our flow is cancelled, silently return
                return;
            }
            this.tileInfo = tileInfo;
            this.onDone(harp_mapview_1.TileLoaderState.Ready);
        })
            .catch(error => {
            // Handle abort messages from fetch and also our own.
            if (error.name === "AbortError" || error.message === "AbortError: Aborted") {
                // our flow is cancelled, silently return
                return;
            }
            this.onError(error);
        });
    }
}
exports.TileInfoLoader = TileInfoLoader;


/***/ }),

/***/ "../harp-mapview/index.js":
/*!********************************!*\
  !*** ../harp-mapview/index.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/AnimatedExtrusionHandler */ "../harp-mapview/lib/AnimatedExtrusionHandler.ts"));
__export(__webpack_require__(/*! ./lib/CameraMovementDetector */ "../harp-mapview/lib/CameraMovementDetector.ts"));
__export(__webpack_require__(/*! ./lib/ClipPlanesEvaluator */ "../harp-mapview/lib/ClipPlanesEvaluator.ts"));
__export(__webpack_require__(/*! ./lib/ColorCache */ "../harp-mapview/lib/ColorCache.ts"));
__export(__webpack_require__(/*! ./lib/composing */ "../harp-mapview/lib/composing/index.ts"));
__export(__webpack_require__(/*! ./lib/ConcurrentDecoderFacade */ "../harp-mapview/lib/ConcurrentDecoderFacade.ts"));
__export(__webpack_require__(/*! ./lib/ConcurrentDecoderFacade */ "../harp-mapview/lib/ConcurrentDecoderFacade.ts"));
__export(__webpack_require__(/*! ./lib/ConcurrentTilerFacade */ "../harp-mapview/lib/ConcurrentTilerFacade.ts"));
__export(__webpack_require__(/*! ./lib/ConcurrentTilerFacade */ "../harp-mapview/lib/ConcurrentTilerFacade.ts"));
__export(__webpack_require__(/*! ./lib/copyrights/CopyrightElementHandler */ "../harp-mapview/lib/copyrights/CopyrightElementHandler.ts"));
__export(__webpack_require__(/*! ./lib/copyrights/CopyrightInfo */ "../harp-mapview/lib/copyrights/CopyrightInfo.ts"));
__export(__webpack_require__(/*! ./lib/copyrights/CopyrightCoverageProvider */ "../harp-mapview/lib/copyrights/CopyrightCoverageProvider.ts"));
__export(__webpack_require__(/*! ./lib/copyrights/UrlCopyrightProvider */ "../harp-mapview/lib/copyrights/UrlCopyrightProvider.ts"));
__export(__webpack_require__(/*! ./lib/DataSource */ "../harp-mapview/lib/DataSource.ts"));
__export(__webpack_require__(/*! ./lib/PolarTileDataSource */ "../harp-mapview/lib/PolarTileDataSource.ts"));
__export(__webpack_require__(/*! ./lib/DecodedTileHelpers */ "../harp-mapview/lib/DecodedTileHelpers.ts"));
__export(__webpack_require__(/*! ./lib/DepthPrePass */ "../harp-mapview/lib/DepthPrePass.ts"));
__export(__webpack_require__(/*! ./lib/ElevationRangeSource */ "../harp-mapview/lib/ElevationRangeSource.ts"));
__export(__webpack_require__(/*! ./lib/image/Image */ "../harp-mapview/lib/image/Image.ts"));
__export(__webpack_require__(/*! ./lib/image/ImageCache */ "../harp-mapview/lib/image/ImageCache.ts"));
__export(__webpack_require__(/*! ./lib/image/MapViewImageCache */ "../harp-mapview/lib/image/MapViewImageCache.ts"));
__export(__webpack_require__(/*! ./lib/MapView */ "../harp-mapview/lib/MapView.ts"));
__export(__webpack_require__(/*! ./lib/MapViewFog */ "../harp-mapview/lib/MapViewFog.ts"));
__export(__webpack_require__(/*! ./lib/MapViewPoints */ "../harp-mapview/lib/MapViewPoints.ts"));
__export(__webpack_require__(/*! ./lib/PickHandler */ "../harp-mapview/lib/PickHandler.ts"));
__export(__webpack_require__(/*! ./lib/poi/Poi */ "../harp-mapview/lib/poi/Poi.ts"));
__export(__webpack_require__(/*! ./lib/poi/PoiManager */ "../harp-mapview/lib/poi/PoiManager.ts"));
__export(__webpack_require__(/*! ./lib/poi/PoiTableManager */ "../harp-mapview/lib/poi/PoiTableManager.ts"));
__export(__webpack_require__(/*! ./lib/RoadPicker */ "../harp-mapview/lib/RoadPicker.ts"));
__export(__webpack_require__(/*! ./lib/Statistics */ "../harp-mapview/lib/Statistics.ts"));
__export(__webpack_require__(/*! ./lib/text/TextElement */ "../harp-mapview/lib/text/TextElement.ts"));
__export(__webpack_require__(/*! ./lib/text/TextElementsRenderer */ "../harp-mapview/lib/text/TextElementsRenderer.ts"));
__export(__webpack_require__(/*! ./lib/text/TextStyleCache */ "../harp-mapview/lib/text/TextStyleCache.ts"));
__export(__webpack_require__(/*! ./lib/ThemeLoader */ "../harp-mapview/lib/ThemeLoader.ts"));
__export(__webpack_require__(/*! ./lib/Tile */ "../harp-mapview/lib/Tile.ts"));
__export(__webpack_require__(/*! ./lib/geometry/TileDataAccessor */ "../harp-mapview/lib/geometry/TileDataAccessor.ts"));
__export(__webpack_require__(/*! ./lib/geometry/TileGeometry */ "../harp-mapview/lib/geometry/TileGeometry.ts"));
__export(__webpack_require__(/*! ./lib/Utils */ "../harp-mapview/lib/Utils.ts"));
__export(__webpack_require__(/*! ./lib/VisibleTileSet */ "../harp-mapview/lib/VisibleTileSet.ts"));
__export(__webpack_require__(/*! ./lib/WorkerBasedDecoder */ "../harp-mapview/lib/WorkerBasedDecoder.ts"));
__export(__webpack_require__(/*! ./lib/WorkerBasedTiler */ "../harp-mapview/lib/WorkerBasedTiler.ts"));
__export(__webpack_require__(/*! ./lib/workers/WorkerLoader */ "../harp-mapview/lib/workers/WorkerLoader.ts"));


/***/ }),

/***/ "../harp-mapview/lib/AnimatedExtrusionHandler.ts":
/*!*******************************************************!*\
  !*** ../harp-mapview/lib/AnimatedExtrusionHandler.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const MapView_1 = __webpack_require__(/*! ./MapView */ "../harp-mapview/lib/MapView.ts");
/**
 * Animation states for extrusion effect
 */
var AnimatedExtrusionState;
(function (AnimatedExtrusionState) {
    AnimatedExtrusionState[AnimatedExtrusionState["None"] = 0] = "None";
    AnimatedExtrusionState[AnimatedExtrusionState["Started"] = 1] = "Started";
    AnimatedExtrusionState[AnimatedExtrusionState["Playing"] = 2] = "Playing";
    AnimatedExtrusionState[AnimatedExtrusionState["Finished"] = 3] = "Finished";
})(AnimatedExtrusionState = exports.AnimatedExtrusionState || (exports.AnimatedExtrusionState = {}));
/**
 * Handles animated extrusion effect of the buildings in [[MapView]].
 */
class AnimatedExtrusionHandler {
    /**
     * Creates an [[AnimatedExtrusionHandler]] in [[MapView]].
     *
     * @param m_mapView Instance of [[MapView]] that passes `zoomLevel`
     * through the `zoom` property update
     */
    constructor(m_mapView) {
        this.m_mapView = m_mapView;
        /**
         * Animate the extrusion of the buildings if set to `true`.
         */
        this.enabled = true;
        /**
         * Duration of the building's extrusion in milliseconds
         */
        this.duration = 750;
        /**
         * If `forceEnabled` is set to `true` then `animateExtrusion` and `animateExtrusionDuration`
         * values from [[extrudedPolygonTechnique]] will be ignored in [[Tile]] and
         * `AnimatedExtrusionHandler.enabled` with `AnimatedExtrusionHandler.duration` will be used
         */
        this.forceEnabled = false;
        this.m_tileHandlerMap = new Map();
        this.m_zoomDirection = 0;
        this.m_zoomLevelPrevious = this.m_mapView.zoomLevel;
    }
    /**
     * Returns direction of the last zoom event.
     * Zoom in - positive value, zoom out - negative value
     */
    get zoomDirection() {
        return this.m_zoomDirection;
    }
    /**
     * [[MapView]] updates zoom level. Then [[AnimatedExtrusionTileHandler]] calculates actual
     * extrusion ratio and trigger animation
     */
    set zoom(zoomLevel) {
        // if zoomLevel has been changed since last render
        if (this.m_zoomLevelPrevious !== zoomLevel) {
            this.m_tileHandlerMap.forEach(tileHandler => {
                if (this.m_mapView.getDataSourceByName(tileHandler.tile.dataSource.name) !==
                    undefined) {
                    this.m_zoomDirection = zoomLevel > this.m_zoomLevelPrevious ? 1 : -1;
                    tileHandler.zoomLevelChanged(this.m_zoomDirection);
                }
            });
            this.m_zoomLevelPrevious = zoomLevel;
        }
    }
    /**
     * Checks whether animated extrusion effect was forcibly turned off/on in [[MapView]]
     */
    get forceAnimatedExtrusion() {
        return this.m_forceAnimatedExtrusion;
    }
    /**
     * If set to `true` it will force the animation extrusion effect to run.
     * In case it was set to `false` animation extrusion effect will be switched off.
     */
    set forceAnimatedExtrusion(animatedExtrusion) {
        this.m_forceAnimatedExtrusion = animatedExtrusion;
    }
    /**
     * Returns `animatedExtrusionDuration` value that was set in [[MapView]].
     */
    get forceAnimatedExtrusionDuration() {
        return this.m_forceAnimatedExtrusionDuration;
    }
    /**
     * If value is set, it will overlap in [[Tile]] with
     * `animatedExtrusionDuration` property from [[ExtrudedPolygonTechnique]]
     * and `DEFAULT_DURATION` from [[AnimatedExtrusionTileHandler]].
     */
    set forceAnimatedExtrusionDuration(extrusionDuration) {
        this.m_forceAnimatedExtrusionDuration = extrusionDuration;
    }
    /**
     * Adds an [[AnimatedExtrusionTileHandler]] to [[AnimatedExtrusionHandler]]
     */
    add(tileHandler) {
        this.m_tileHandlerMap.set(tileHandler.tile, tileHandler);
    }
    /**
     * Removes tile from the list subscribed for extrusion ratio updates
     */
    removeTile(tile) {
        this.m_tileHandlerMap.delete(tile);
    }
    /**
     * Returns first [[AnimatedExtrusionTileHandler]] existed from the list of [[Tile]]s
     */
    find(tileKeys) {
        for (const tileHandler of this.m_tileHandlerMap) {
            for (const tileKey of tileKeys) {
                if (tileKey !== undefined &&
                    tileHandler[0].tileKey.mortonCode() === tileKey.mortonCode()) {
                    return tileHandler[1];
                }
            }
        }
        return undefined;
    }
    /**
     * Is `true` if any extrusion handlers are currently animating.
     */
    get isAnimating() {
        for (const tileHandler of this.m_tileHandlerMap) {
            if (tileHandler[1].isAnimating) {
                return true;
            }
        }
        return false;
    }
}
exports.AnimatedExtrusionHandler = AnimatedExtrusionHandler;
/**
 * Implements animated extrusion effect for the extruded objects in the [[Tile]]
 */
class AnimatedExtrusionTileHandler {
    constructor(m_tile, extrudedObjects, m_animatedExtrusionDuration) {
        this.m_tile = m_tile;
        this.m_animatedExtrusionDuration = m_animatedExtrusionDuration;
        this.m_extrudedObjects = [];
        this.m_animatedExtrusionRatio = harp_materials_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
        this.m_animatedExtrusionState = AnimatedExtrusionState.None;
        this.m_animatedExtrusionStartTime = undefined;
        this.animateExtrusion = (event) => {
            if (this.m_animatedExtrusionState !== AnimatedExtrusionState.Playing) {
                if (this.m_animatedExtrusionState === AnimatedExtrusionState.Started) {
                    this.m_animatedExtrusionState = AnimatedExtrusionState.Playing;
                }
                else {
                    return;
                }
            }
            const currentTime = Date.now();
            if (this.m_animatedExtrusionStartTime === undefined ||
                this.m_animatedExtrusionStartTime <= 0) {
                this.m_animatedExtrusionStartTime = currentTime;
            }
            const timeProgress = Math.min(currentTime - this.m_animatedExtrusionStartTime, this.m_animatedExtrusionDuration);
            this.extrusionRatio = harp_utils_1.MathUtils.easeInOutCubic(harp_materials_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MIN, harp_materials_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX, timeProgress / this.m_animatedExtrusionDuration);
            if (timeProgress >= this.m_animatedExtrusionDuration) {
                this.m_animatedExtrusionState = AnimatedExtrusionState.Finished;
                this.stopExtrusionAnimation();
            }
            this.m_tile.dataSource.requestUpdate();
        };
        this.m_mapView = m_tile.mapView;
        this.m_animatedExtrusionHandler = this.m_mapView.animatedExtrusionHandler;
        extrudedObjects.forEach(extrudedObject => {
            this.m_extrudedObjects.push(extrudedObject.object);
        });
        this.startExtrusionAnimationIfNeeded(this.m_animatedExtrusionHandler.zoomDirection);
    }
    /**
     * Set an extrusion ratio value for the materials [[MapMeshBasicMaterial]]
     * and [[EdgeMaterial]]. Controlled by [[AnimatedExtrusionHandler]]
     * for extrusion animation effect.
     */
    set extrusionRatio(value) {
        this.m_animatedExtrusionRatio = value;
        this.m_extrudedObjects.forEach(object => {
            const material = object
                .material;
            material.extrusionRatio = this.m_animatedExtrusionRatio;
        });
    }
    /**
     * Returns the [[Tile]] related to [[AnimatedExtrusionTileHandler]]
     */
    get tile() {
        return this.m_tile;
    }
    /**
     * Return the current state of animated extrusion effect
     */
    get animationState() {
        return this.m_animatedExtrusionState;
    }
    /**
     * Is `true` if this handler is currently animating.
     */
    get isAnimating() {
        return this.m_animatedExtrusionState !== AnimatedExtrusionState.Finished;
    }
    /**
     * Cancel animation and remove from [[AnimatedExtrusionHandler]]
     */
    dispose() {
        this.stopExtrusionAnimation();
        this.m_animatedExtrusionHandler.removeTile(this.m_tile);
    }
    /**
     * Start / Stop extrusion animation if zoom level was changed
     */
    zoomLevelChanged(zoomDirection) {
        if (this.m_tile.isVisible === false &&
            this.m_animatedExtrusionState !== AnimatedExtrusionState.None) {
            this.m_animatedExtrusionState = AnimatedExtrusionState.None;
            this.stopExtrusionAnimation();
        }
        if (this.m_tile.isVisible === true &&
            this.m_animatedExtrusionState === AnimatedExtrusionState.None) {
            this.startExtrusionAnimationIfNeeded(zoomDirection);
        }
    }
    getChildTiles(tileKeys) {
        const result = [];
        tileKeys.forEach(tileKey => {
            const childTileKeys = this.tile.dataSource.getTilingScheme().getSubTileKeys(tileKey);
            for (const childTileKey of childTileKeys) {
                result.push(childTileKey);
            }
        });
        return result;
    }
    // search for the [[Tile]] with extrusion animation started
    startExtrusionAnimationIfNeeded(zoomDirection) {
        const { quadTreeSearchDistanceUp, quadTreeSearchDistanceDown } = this.tile.mapView.visibleTileSet.options;
        const tile = this.m_tile;
        let extrusionStartTime;
        if (zoomDirection !== undefined) {
            let tileHandler;
            // if zoom out, go down and look for a child tile
            if (zoomDirection < 0) {
                let nextLevelDiff = 0;
                let tileKeys = [tile.tileKey];
                while (quadTreeSearchDistanceDown > nextLevelDiff &&
                    extrusionStartTime === undefined) {
                    const childTileKeys = this.getChildTiles(tileKeys);
                    if (childTileKeys !== undefined) {
                        tileHandler = this.m_animatedExtrusionHandler.find(childTileKeys);
                        if (tileHandler !== undefined) {
                            extrusionStartTime = tileHandler.m_animatedExtrusionStartTime;
                            break;
                        }
                        tileKeys = childTileKeys;
                    }
                    nextLevelDiff++;
                }
            }
            // if zoom in, go up and get the parent tile
            if (zoomDirection > 0) {
                let nextLevelDiff = 0;
                let tileKey = tile.tileKey;
                while (quadTreeSearchDistanceUp > nextLevelDiff &&
                    extrusionStartTime === undefined &&
                    tileKey.level !== 0) {
                    const parentTileKey = tileKey.parent();
                    tileHandler = this.m_animatedExtrusionHandler.find([parentTileKey]);
                    if (tileHandler !== undefined) {
                        extrusionStartTime = tileHandler.m_animatedExtrusionStartTime;
                        break;
                    }
                    tileKey = parentTileKey;
                    nextLevelDiff++;
                }
            }
        }
        this.startExtrusionAnimation(extrusionStartTime);
    }
    startExtrusionAnimation(startTime) {
        this.m_animatedExtrusionState = AnimatedExtrusionState.Started;
        this.m_animatedExtrusionStartTime = startTime;
        this.animateExtrusion();
        this.m_mapView.addEventListener(MapView_1.MapViewEventNames.AfterRender, this.animateExtrusion);
    }
    stopExtrusionAnimation() {
        this.m_mapView.removeEventListener(MapView_1.MapViewEventNames.AfterRender, this.animateExtrusion);
    }
}
exports.AnimatedExtrusionTileHandler = AnimatedExtrusionTileHandler;


/***/ }),

/***/ "../harp-mapview/lib/BackgroundDataSource.ts":
/*!***************************************************!*\
  !*** ../harp-mapview/lib/BackgroundDataSource.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const DataSource_1 = __webpack_require__(/*! ./DataSource */ "../harp-mapview/lib/DataSource.ts");
const TileGeometryCreator_1 = __webpack_require__(/*! ./geometry/TileGeometryCreator */ "../harp-mapview/lib/geometry/TileGeometryCreator.ts");
const Tile_1 = __webpack_require__(/*! ./Tile */ "../harp-mapview/lib/Tile.ts");
/**
 * Provides background geometry for all tiles.
 */
class BackgroundDataSource extends DataSource_1.DataSource {
    constructor() {
        super("background");
        this.m_tilingScheme = BackgroundDataSource.DEFAULT_TILING_SCHEME;
        this.cacheable = true;
    }
    updateStorageLevelOffset() {
        let storageLevelOffset;
        this.mapView.dataSources.forEach(ds => {
            if (ds === this) {
                return;
            }
            const tilingScheme = ds.getTilingScheme();
            if (tilingScheme === this.m_tilingScheme) {
                storageLevelOffset =
                    storageLevelOffset === undefined
                        ? ds.storageLevelOffset
                        : Math.max(storageLevelOffset, ds.storageLevelOffset);
            }
        });
        if (storageLevelOffset === undefined) {
            storageLevelOffset = 0;
        }
        if (storageLevelOffset !== this.storageLevelOffset) {
            this.storageLevelOffset = storageLevelOffset;
            this.mapView.clearTileCache(this.name);
        }
    }
    /** @override */
    setTheme(theme, languages) {
        this.mapView.clearTileCache(this.name);
    }
    setTilingScheme(tilingScheme) {
        const newScheme = tilingScheme || BackgroundDataSource.DEFAULT_TILING_SCHEME;
        if (newScheme === this.m_tilingScheme) {
            return;
        }
        this.m_tilingScheme = newScheme;
        this.updateStorageLevelOffset();
        this.mapView.clearTileCache(this.name);
    }
    /** @override */
    getTilingScheme() {
        return this.m_tilingScheme;
    }
    /** @override */
    getTile(tileKey) {
        const tile = new Tile_1.Tile(this, tileKey);
        tile.forceHasGeometry(true);
        tile.removeDecodedTile(); // Skip geometry loading.
        TileGeometryCreator_1.TileGeometryCreator.instance.addGroundPlane(tile, Number.MIN_SAFE_INTEGER);
        return tile;
    }
}
exports.BackgroundDataSource = BackgroundDataSource;
BackgroundDataSource.DEFAULT_TILING_SCHEME = harp_geoutils_1.webMercatorTilingScheme;


/***/ }),

/***/ "../harp-mapview/lib/CameraMovementDetector.ts":
/*!*****************************************************!*\
  !*** ../harp-mapview/lib/CameraMovementDetector.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const three_1 = __webpack_require__(/*! three */ "three");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-mapview/lib/Utils.ts");
/**
 * The default value for camera movement throttling, in milliseconds.
 */
const DEFAULT_THROTTLING_TIMEOUT = 300;
/**
 * The `CameraMovementDetector` class checks for changes in camera position and orientation, to
 * detect continuous movements without the animation mode activated in [[MapView]]. If the
 * interaction is not continuous enough, you can use a throttling timer to reduce the number of
 * callbacks.
 */
class CameraMovementDetector {
    /**
     * Initializes the detector with timeout value and callbacks. [[MapView]] also provides
     * events for client code to be notified when these cues occur.
     *
     * @param m_throttlingTimeout The delay, in milliseconds, between the last user interaction
     * detected and the call to `m_movementFinishedFunc`; the default is `300`.
     * @param m_movementStartedFunc Callback function, called when the user starts interacting.
     * @param m_movementFinishedFunc Callback function, called when the user stops interacting.
     */
    constructor(m_throttlingTimeout, m_movementStartedFunc, m_movementFinishedFunc) {
        this.m_throttlingTimeout = m_throttlingTimeout;
        this.m_movementStartedFunc = m_movementStartedFunc;
        this.m_movementFinishedFunc = m_movementFinishedFunc;
        this.m_lastCameraPos = new three_1.Vector3();
        this.m_newCameraPos = new three_1.Vector3();
        this.m_throttlingTimerId = undefined;
        this.m_movementDetectorDeadline = 0;
        this.onDeadlineTimer = () => {
            this.m_throttlingTimerId = undefined;
            const now = performance.now();
            if (now >= this.m_movementDetectorDeadline) {
                this.movementFinished();
            }
            else {
                this.startMovementFinishedTimer(now);
            }
        };
        if (this.m_throttlingTimeout === undefined) {
            this.m_throttlingTimeout = DEFAULT_THROTTLING_TIMEOUT;
        }
    }
    /**
     * Checks if the camera has moved since the last time it was checked. The
     * `m_movementStartedFunc` is called when a movement starts. If no movement
     * is detected, a timer for `m_movementFinishedFunc` starts.
     *
     * @param mapView [[Mapview]]'s position and camera are checked for modifications.
     */
    checkCameraMoved(mapView, now) {
        const newAttitude = Utils_1.MapViewUtils.extractAttitude(mapView, mapView.camera);
        const newCameraPos = mapView.camera.getWorldPosition(this.m_newCameraPos);
        if (this.m_lastAttitude === undefined) {
            this.m_lastCameraPos.copy(newCameraPos);
            this.m_lastAttitude = newAttitude;
            return false;
        }
        const cameraMoved = !this.m_lastCameraPos.equals(newCameraPos) ||
            newAttitude.yaw !== this.m_lastAttitude.yaw ||
            newAttitude.pitch !== this.m_lastAttitude.pitch ||
            newAttitude.roll !== this.m_lastAttitude.roll;
        if (cameraMoved) {
            this.m_lastCameraPos.copy(newCameraPos);
            this.m_lastAttitude = newAttitude;
        }
        if (cameraMoved !== this.m_cameraMovedLastFrame) {
            if (cameraMoved) {
                this.movementStarted();
            }
            this.m_cameraMovedLastFrame = cameraMoved;
        }
        if (cameraMoved) {
            // Start timer
            this.m_movementDetectorDeadline = now + this.m_throttlingTimeout;
            this.startMovementFinishedTimer(now);
        }
        return this.m_cameraMovedLastFrame;
    }
    /**
     * Reset the saved camera position. Next time checkCameraMoved is called, it will return
     * `false`.
     */
    clear(mapView) {
        const newCameraPos = mapView.camera.getWorldPosition(this.m_newCameraPos);
        this.m_lastCameraPos.set(newCameraPos.x, newCameraPos.y, newCameraPos.z);
        const newAttitude = Utils_1.MapViewUtils.extractAttitude(mapView, mapView.camera);
        this.m_lastAttitude = newAttitude;
    }
    /**
     * Force change of camera position. Next time checkCameraMoved is called, it will return `true`.
     */
    forceMoved() {
        this.m_lastCameraPos.set(Number.NaN, Number.NaN, Number.NaN);
    }
    /**
     * Returns `true` if the camera of this [[MapView]] is currently moving. In this case the
     * `m_movementFinishedFunc` is waiting to be called after the throttling timer runs out.
     */
    get cameraIsMoving() {
        return this.m_throttlingTimerId !== undefined;
    }
    /**
     * Disposes resources and kills the throttling timer.
     */
    dispose() {
        this.removeMovementFinishedTimer();
        this.m_movementStartedFunc = undefined;
        this.m_movementFinishedFunc = undefined;
    }
    /**
     * Returns `true` if the camera has moved in the last frame.
     */
    get cameraMovedLastFrame() {
        return this.m_cameraMovedLastFrame === true;
    }
    movementStarted() {
        if (this.m_movementStartedFunc !== undefined) {
            this.m_movementStartedFunc();
        }
    }
    movementFinished() {
        this.removeMovementFinishedTimer();
        if (this.m_movementFinishedFunc !== undefined) {
            this.m_movementFinishedFunc();
        }
    }
    startMovementFinishedTimer(now) {
        if (this.m_throttlingTimerId === undefined) {
            const remainingTime = Math.max(0, this.m_movementDetectorDeadline - now);
            this.m_throttlingTimerId = setTimeout(this.onDeadlineTimer, remainingTime);
        }
    }
    removeMovementFinishedTimer() {
        if (this.m_throttlingTimerId !== undefined) {
            clearTimeout(this.m_throttlingTimerId);
            this.m_throttlingTimerId = undefined;
        }
    }
}
exports.CameraMovementDetector = CameraMovementDetector;


/***/ }),

/***/ "../harp-mapview/lib/ClipPlanesEvaluator.ts":
/*!**************************************************!*\
  !*** ../harp-mapview/lib/ClipPlanesEvaluator.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const THREE = __webpack_require__(/*! three */ "three");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-mapview/lib/Utils.ts");
const epsilon = 0.000001;
/**
 * Simplest camera clip planes evaluator, interpolates near/far planes based on ground distance.
 *
 * At general ground distance to camera along the surface normal is used as reference point for
 * planes evaluation, where near plane distance is set as fraction of this distance refereed as
 * [[nearMultiplier]]. Far plane equation has its own multiplier - [[nearFarMultiplier]],
 * which is applied to near plane and offset giving finally far plane distance.
 * This evaluator supports both planar and spherical projections, although it's behavior is
 * slightly different in each case. General algorithm sets near plane between camera and
 * ground level, while far plane is just calculated using scale and bias approach with far offset
 * and multiplier.
 * @deprecated Class contains the legacy (first and original) clip planes evaluation method, which
 * is widelly used in examples thus is still kept for backward compatibility and comparisons.
 */
class InterpolatedClipPlanesEvaluator {
    constructor(nearMin = 0.1, nearMultiplier = 0.1, nearFarMultiplier = 50.0, farOffset = 200.0) {
        this.nearMin = nearMin;
        this.nearMultiplier = nearMultiplier;
        this.nearFarMultiplier = nearFarMultiplier;
        this.farOffset = farOffset;
        this.m_tmpVectors = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3()
        ];
        this.m_tmpQuaternion = new THREE.Quaternion();
        harp_utils_1.assert(nearMin > 0);
        harp_utils_1.assert(nearFarMultiplier >= 0);
        harp_utils_1.assert(farOffset >= 0);
        this.farMin = nearMin * nearFarMultiplier + farOffset;
    }
    // tslint:disable-next-line: no-empty
    set minElevation(elevation) { }
    get minElevation() {
        // This evaluator does not support elevation so its always set to 0.
        return 0;
    }
    // tslint:disable-next-line: no-empty
    set maxElevation(elevation) { }
    get maxElevation() {
        // This evaluator does not support elevation so its always set to 0.
        return 0;
    }
    evaluateClipPlanes(mapView) {
        const camera = mapView.camera;
        const projection = mapView.projection;
        let nearPlane = this.nearMin;
        let farPlane = this.farMin;
        if (projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            // near and far plane for a set up where
            // the camera is looking at the center of the scene.
            const r = harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS;
            const d = camera.position.length();
            const alpha = Math.asin(r / d);
            // Extract X, Y, Z axes into tmp vectors array.
            camera.matrixWorld.extractBasis(this.m_tmpVectors[0], this.m_tmpVectors[1], this.m_tmpVectors[2]);
            // Setup quaternion based on X axis.
            this.m_tmpQuaternion.setFromAxisAngle(this.m_tmpVectors[0], alpha);
            // Acquire forward vector based on Z axis reversed (keep it in tmpVectors[2]).
            const fwd = this.m_tmpVectors[2].negate();
            // Apply quaternion rotation to forward vector, store it in tmpVectors[1].
            const fwdRot = this.m_tmpVectors[1].copy(fwd).applyQuaternion(this.m_tmpQuaternion);
            // Store camera position tmpVectors[0] and reference it with p.
            const p = this.m_tmpVectors[0].copy(camera.position);
            p.addScaledVector(fwdRot, Math.sqrt(d * d - r * r));
            farPlane = p.sub(camera.position).dot(fwd);
            nearPlane = Math.max(this.nearMin, projection.groundDistance(camera.position) * this.nearMultiplier);
        }
        else if (projection.type === harp_geoutils_1.ProjectionType.Planar) {
            const groundDistance = projection.groundDistance(camera.position);
            nearPlane = Math.max(this.nearMin, groundDistance * this.nearMultiplier);
            // Will be already clamped to minFar due to clamping above.
            farPlane = nearPlane * this.nearFarMultiplier + this.farOffset;
        }
        else {
            harp_utils_1.assert(false, "Unsupported projection type");
        }
        const viewRanges = {
            near: nearPlane,
            far: farPlane,
            minimum: this.nearMin,
            maximum: farPlane
        };
        return viewRanges;
    }
}
exports.InterpolatedClipPlanesEvaluator = InterpolatedClipPlanesEvaluator;
/**
 * Abstract evaluator class that adds support for elevation constraints.
 *
 * Classes derived from this should implement algorithms that takes into account rendered
 * features height (elevations), such as ground plane is no more flat (or spherical), but
 * contains geometry that should be overlapped by frustum planes.
 */
class ElevationBasedClipPlanesEvaluator {
    constructor(maxElevation, minElevation) {
        harp_utils_1.assert(maxElevation >= minElevation);
        this.m_minElevation = minElevation;
        this.m_maxElevation = maxElevation;
    }
    /**
     * Set maximum elevation above sea level to be rendered.
     *
     * @param elevation the elevation (altitude) value in world units (meters).
     * @note If you set this exactly to the maximum rendered feature height (altitude above
     * the sea, you may notice some flickering or even polygons disappearing related to rounding
     * errors or depth buffer precision. In such cases increase [[nearFarMargin]] or add a little
     * bit offset to your assumed maximum elevation.
     * @note Reasonable values are in between (-DeadSeeDepression, MtEverestHeight>, both values
     * are defined in [[EarthConstant]] as [[EarthConstant.MIN_ELEVATION]] and
     * [[EarthConstant.MAX_ELEVATION]] respectively.
     * @see minElevation for more information about precision and rounding errors.
     */
    set maxElevation(elevation) {
        this.m_maxElevation = elevation;
        // Min elevation should be at least equal or smaller to max elevation.
        this.m_minElevation = Math.min(elevation, this.m_minElevation);
    }
    /**
     * Get maximum elevation to be covered by camera frustum.
     */
    get maxElevation() {
        return this.m_maxElevation;
    }
    /**
     * Set minimum elevation to be rendered, values beneath the sea level are negative.
     *
     * @param elevation the minimum elevation (depression) in world units (meters).
     * @note If you set this parameter to zero you may not see any features rendered if they are
     * just below the sea level more than half of [[nearFarMargin]] assumed. Similarly if set to
     * -100m and rendered features lays exactly in such depression, you may notice that problem.
     * The errors usually come from projection precision loss and depth buffer nature (significant
     * precision loss closer to far plane). Thus is such cases either increase the margin (if you
     * are sure features are just at this elevation, or setup bigger offset for [[minElevation]].
     * Reasonable values are between <-DeadSeaDepression, MtEverestHeight), where the first denotes
     * lowest depression on the Earth defined as [[EarthConstants.MIN_ELEVATION]] and the second is
     * the highest point our planet.
     * @see https://developer.nvidia.com/content/depth-precision-visualized
     */
    set minElevation(elevation) {
        this.m_minElevation = elevation;
        // Max elevation should be at least equal or bigger than min elevation.
        this.m_maxElevation = Math.max(elevation, this.m_maxElevation);
    }
    /**
     * Get minimum elevation to be covered by camera frustum.
     */
    get minElevation() {
        return this.m_minElevation;
    }
}
exports.ElevationBasedClipPlanesEvaluator = ElevationBasedClipPlanesEvaluator;
/**
 * Top view, clip planes evaluator that computes view ranges based on ground distance and elevation.
 *
 * This evaluator supports both planar and spherical projections, although it behavior is
 * slightly different in each case. General algorithm sets near plane and far plane close
 * to ground level, but taking into account maximum and minimum elevation of features on the ground.
 *
 * @note This evaluator supports only cameras which are always looking down the ground surface
 * (top-down view) along surface normal and does not preserve correct clip planes when
 * modifying camera pitch (tilt) angle. In simple words it is suitable only for top view camera
 * settings.
 */
class TopViewClipPlanesEvaluator extends ElevationBasedClipPlanesEvaluator {
    /**
     * Allows to setup near/far offsets (margins), rendered geometry elevation relative to sea
     * level as also minimum near plane and maximum far plane distance constraints.
     * It is strongly recommended to set some reasonable [[nearFarMargin]] (offset) between near
     * and far planes to avoid flickering.
     * @param maxElevation defines near plane offset from the ground in the surface normal
     * direction, positive values allows to render elevated terrain features (mountains,
     * buildings). Defaults to Burj Khalifa building height.
     * @param minElevation defines far plane offset from the ground surface, negative values moves
     * far plane below the ground level (use it to render depressions). Default zero - sea level.
     * @param nearMin minimum allowable near plane distance from camera, must be bigger than zero.
     * @param nearFarMarginRatio minimum distance between near and far plane, as a ratio of average
     * near/far plane distance, it have to be significantly bigger than zero (especially if
     * [[maxElevation]] and [[minElevation]] are equal), otherwise you may notice flickering when
     * rendering, or even render empty scene if frustum planes are almost equal.
     * @param farMaxRatio maximum ratio between ground and far plane distance, allows to limit
     * viewing distance at overall. Have to be bigger than 1.0.
     * @note Keep in mind that this evaluator does not evaluate terrain (or building) elevation
     * automatically, to keep such features rendered (between frustum planes) use [[minElevation]],
     * [[maxElevation]] constraints. You may change this parameters at any time, but it requires
     * repeating [[evaluatePlanes]] step, if your camera is moving you need to evaluate planes
     * anyway.
     * @note You may treat [[minElevation]] and [[maxElevation]] parameters as the maximum and
     * minimum renderable elevation respectively along the surface normal, when camera is
     * constantly looking downwards (top-down view). If you need [[ClipPlanesEvaluator]] for
     * cameras that support tilt or yaw please use [[TiltViewClipPlanesEvaluator]].
     * @note [[nearFarMaxRatio]] does not limit far plane when spherical projection is in use,
     * the algorithm used there estimates distance to point on tangent where line from camera
     * touches the sphere horizon and there is no reason to clamp it.
     */
    constructor(maxElevation = harp_geoutils_1.EarthConstants.MAX_BUILDING_HEIGHT, minElevation = 0, nearMin = 1.0, nearFarMarginRatio = 0.05, farMaxRatio = 6.0) {
        super(maxElevation, minElevation);
        this.nearMin = nearMin;
        this.nearFarMarginRatio = nearFarMarginRatio;
        this.farMaxRatio = farMaxRatio;
        /**
         * Helper for reducing number of objects created at runtime.
         */
        this.m_tmpVectors = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3()
        ];
        /**
         * Helper object for reducing performance impact.
         */
        this.m_tmpQuaternion = new THREE.Quaternion();
        harp_utils_1.assert(nearMin > 0);
        harp_utils_1.assert(nearFarMarginRatio > epsilon);
        harp_utils_1.assert(farMaxRatio > 1.0);
        const nearFarMargin = nearFarMarginRatio * nearMin;
        this.m_minimumViewRange = {
            near: nearMin,
            far: nearMin + nearFarMargin,
            minimum: this.nearMin,
            maximum: Math.max(nearMin * farMaxRatio, nearMin + nearFarMargin)
        };
    }
    /** @override */
    evaluateClipPlanes(mapView) {
        if (mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            return this.evaluateDistanceSphericalProj(mapView);
        }
        else if (mapView.projection.type === harp_geoutils_1.ProjectionType.Planar) {
            return this.evaluateDistancePlanarProj(mapView);
        }
        harp_utils_1.assert(false, "Unsupported projection type");
        return Object.assign({}, this.minimumViewRange);
    }
    /**
     * Get minimum view range that is possible to achieve with current evaluator settings.
     * @note This value will not change after evaluator is constructed.
     */
    get minimumViewRange() {
        return this.m_minimumViewRange;
    }
    /**
     * Calculate camera altitude (closest distance) to ground level in world units.
     * @param camera
     * @param projection
     */
    getCameraAltitude(camera, projection) {
        return projection.groundDistance(camera.position);
    }
    evaluateDistancePlanarProj(mapView) {
        const { camera, projection } = mapView;
        harp_utils_1.assert(projection.type !== harp_geoutils_1.ProjectionType.Spherical);
        let nearPlane = this.nearMin;
        let farPlane = this.nearMin * this.farMaxRatio;
        // Calculate distance to closest point on the ground.
        const groundDistance = this.getCameraAltitude(camera, projection);
        const farMax = groundDistance * this.farMaxRatio;
        // We could at least try to keep margins along the eye vector (center of the view) in
        // tact with pitch angle changes, but this does not solve all tilt angle problems,
        // rather use more sophisticated evaluator.
        nearPlane = groundDistance - this.maxElevation;
        farPlane = groundDistance - this.minElevation;
        // Apply the constraints.
        nearPlane = Math.max(nearPlane, this.nearMin);
        farPlane = Math.min(farPlane, farMax);
        // Apply margins
        const nearFarMargin = (this.nearFarMarginRatio * (nearPlane + farPlane)) / 2;
        nearPlane = Math.max(nearPlane - nearFarMargin / 2, this.nearMin);
        farPlane = Math.max(farPlane + nearFarMargin / 2, nearPlane + nearFarMargin);
        const viewRanges = {
            near: nearPlane,
            far: farPlane,
            minimum: this.nearMin,
            maximum: Math.max(farMax, farPlane)
        };
        return viewRanges;
    }
    evaluateDistanceSphericalProj(mapView) {
        const { camera, projection } = mapView;
        harp_utils_1.assert(projection.type === harp_geoutils_1.ProjectionType.Spherical);
        let nearPlane = this.nearMin;
        let farPlane = this.nearMin * this.farMaxRatio;
        // The near plane calculus is quite straight forward and works the same as for planar
        // projections. We simply search for the closest point of the ground just above
        // the camera, then we apply margin (elevation) to it along the sphere surface normal:
        const cameraAltitude = this.getCameraAltitude(camera, projection);
        nearPlane = cameraAltitude - this.maxElevation;
        // Far plane calculation requires different approaches depending from camera projection:
        // - perspective
        // - orthographic
        const r = harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS;
        let d = camera.position.length();
        d = d === 0 ? epsilon : d;
        if (camera.type === "PerspectiveCamera") {
            // This solution computes near and far plane for a set up where
            // the camera is looking at the center of the scene.
            // The far plane distance calculus requires finding the sphere tangent line that is
            // co-linear with (goes thru) camera position, such tangent creates right angle
            // with sphere diameter where it touches its surface (point T). Given that sphere is
            // always at world origin and camera orbits around it we have (see
            // #getTangentBasedFarPlane):
            // angle(OTC) = 90
            // sin(OCT) = sin(alpha) = r / d
            // alpha = asin(r / d)
            const alpha = Math.asin(r / d);
            // If alpha it bigger than half fov angle, our visibility limit is set by tangent
            // line, otherwise we need to find top (or right) plane intersection with sphere,
            // which is definitely closer than the tangent point mentioned above.
            const cam = camera;
            // Take fov directly if it is vertical, otherwise we translate it using aspect ratio:
            const aspect = cam.aspect > 1 ? cam.aspect : 1 / cam.aspect;
            const halfFovAngle = THREE.Math.degToRad((cam.fov * aspect) / 2);
            const farTangent = this.getTangentBasedFarPlane(cam, d, r, alpha);
            farPlane =
                halfFovAngle > alpha
                    ? farTangent
                    : this.getFovBasedFarPlane(cam, d, r, 2 * halfFovAngle, projection);
        }
        // Orthographic camera projection
        else {
            farPlane = this.getOrthoBasedFarPlane(d, r);
        }
        // In extreme cases the largest depression assumed may be further than tangent
        // based far plane distance, take it into account
        const farMin = cameraAltitude - this.minElevation;
        const farMax = cameraAltitude * this.farMaxRatio;
        // Apply the constraints.
        nearPlane = Math.max(nearPlane, this.nearMin);
        farPlane = Math.max(farPlane, farMin);
        // Apply margins
        const nearFarMargin = (this.nearFarMarginRatio * (nearPlane + farPlane)) / 2;
        nearPlane = Math.max(nearPlane - nearFarMargin / 2, this.nearMin);
        farPlane = Math.max(farPlane + nearFarMargin / 2, nearPlane + nearFarMargin);
        const viewRanges = {
            near: nearPlane,
            far: farPlane,
            minimum: this.nearMin,
            maximum: farMax
        };
        return viewRanges;
    }
    /**
     * Calculate distance from a point to the tangent point of a sphere.
     *
     * Returns zero if point is below surface or only very slightly above surface of sphere.
     * @param d Distance from point to center of sphere
     * @param r Radius of sphere
     */
    getTangentDistance(d, r) {
        // There may be situations when maximum elevation still remains below sea level
        // (elevation < 0) or it is negligible (elevation ~ epsilon)
        if (d - r < epsilon) {
            return 0;
        }
        // The distance to tangent point may be described as:
        // t = sqrt(d^2 - r^2)
        return Math.sqrt(d * d - r * r);
    }
    /**
     * Calculate far plane depending on furthest visible distance from camera position.
     *
     * Furthest visible distance is assumed to be distance from camera to horizon
     * plus distance from elevated geometry to horizon(so that high objects behind horizon
     * remain visible).
     * @param camera The camera of the mapview
     * @param d Distance from camera to origin
     * @param r Radius of earth
     * @param alpha Angle between camera eye vector and tangent
     */
    getTangentBasedFarPlane(camera, d, r, alpha) {
        // Find tangent point intersection distance
        //         , - ~ ~ ~ - ,
        //     , '               ' ,        E
        //   ,           .           ,    . ' far + elev
        //  ,            .   r + e   , '   /
        // ,             .     ,  '    ,  /
        // ,             . O '         , / te
        // ,             | .           ,/
        //  ,            |   .  r     ,/
        //   ,           |      .    ,
        //     ,         |        , '_____ far
        //       ' -_, _ | _ ,  ' / T
        //     near      |      /
        //               |    / t
        //             d |  /
        //               |/
        //               C
        const t = this.getTangentDistance(d, r);
        // Because we would like to see elevated geometry that may be visible beyond
        // the tangent point on ground surface, we need to extend viewing distance along
        // the tangent line by te (see graph above).
        const te = this.getTangentDistance(r + this.maxElevation, r);
        // Next step is to project CE vector(length t + te) onto camera eye (forward) vector
        // to get maximum camera far plane distance.
        //
        // Knowing that:
        // tangentVec.dot(cameraFwdVec) = cos(alpha) * len(tangentVec) * len(cameraFwdVec).
        // where:
        // ||cameraFwdVec|| == 1 ^ ||tangentVec|| == t + te
        // Formula simplifies to:
        const far = Math.cos(alpha) * (t + te);
        return far;
    }
    getFovBasedFarPlane(camera, d, r, fovAngle, projection) {
        // Find intersection point that is closer to tangent point.
        //
        //         , - ~ ~ ~ - ,
        //     , '               ' ,
        //   ,           .           ,
        //  ,            .     r     ,' T1
        // ,             .     ,  '  / ,
        // ,             . O.'  a   /  ,
        // ,             | .  `  . /   ,
        //  ,            |   .  r / TA,
        //   ,           |    .  /   ,
        //     ,         |     ./  ,'_____ far
        //       ' -_, _ | _ , /' T0
        //     near      |    /
        //               |   / t
        //             d | /
        //               |/
        //               C
        //
        // See:
        // tslint:disable-next-line: max-line-length
        // https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection
        // Vector from camera to world center
        const dVec = camera.position;
        // Extract camera X, Y, Z orientation axes into tmp vectors array.
        camera.matrixWorld.extractBasis(this.m_tmpVectors[0], this.m_tmpVectors[1], this.m_tmpVectors[2]);
        // Setup quaternion (X axis based) for angle between frustum plane and camera eye.
        this.m_tmpQuaternion.setFromAxisAngle(this.m_tmpVectors[0], fovAngle / 2);
        // Acquire camera (eye) forward vector from Z axis (keep it in tmpVectors[2]).
        const cameraFwdVec = this.m_tmpVectors[2];
        // Apply quaternion to forward vector, creating intersection vector, which is
        // parallel to top or right frustum plane (depending on the aspect ratio).
        const tVec = this.m_tmpVectors[1].copy(cameraFwdVec).applyQuaternion(this.m_tmpQuaternion);
        // Calculate camera to origin vector projection onto frustum plane (top or right).
        // This gives us the length of CTA segment:
        const cta = dVec.dot(tVec);
        // If it is negative, it means that the dVec and the tVec points in
        // opposite directions - there is no intersection - or intersection could
        // potentially be behind the intersection ray's origin (camera position).
        if (cta < 0) {
            // Intersection points are behind camera, camera looks in wrong direction.
            const groundDistance = this.getCameraAltitude(camera, projection);
            // Setup far plane to maximum distance.
            return groundDistance * this.farMaxRatio;
        }
        // Knowing the length of |CTA| we just need to subtract the length of |T0TA|
        // segment from it to get far plane distance.
        // In order to calculate |T0TA| we firstly need to use use Pythagorean theorem to
        // find length of |OTA| = a. Here we use the right triangle formed by O-C-TA points:
        // |OC|^2 = |CTA|^2 + |OTA|^2, where |OTA| = a, |OC| = d, |CTA| = cta
        // a^2 = d^2 - cta^2
        const a2 = dVec.dot(dVec) - cta * cta;
        // Note that if a is greater than sphere radius the ray misses the sphere and
        // thus there is no intersection at all.
        const r2 = r * r;
        harp_utils_1.assert(a2 <= r2, "Please use this evaluator only for top view camera poses.");
        // Now to find the length of |T0TA| == |T1TA| we use the second right triangle
        // formed by O-T0-TA points. Of course we know that |T0TA| segment length is
        // equal to |T1TA|, and |OT0| segment is simply sphere radius.
        // In order to find |T0TA| length we again use Pythagorean theorem, which says:
        // |OT0|^2 = |OTA|^2 + |T0TA|^2, where |OTO| = r, |OTA| = a
        // |T0TA|^2 = r^2 - a^2
        const tota = Math.sqrt(r2 - a2);
        // Finally our far plane (intersection point) is defined as:
        return cta - tota;
    }
    getOrthoBasedFarPlane(d, r) {
        //         , - ~ ~ ~ - ,
        //     , '               ' ,     E
        //   ,            .--------- ,-.'- far + elev
        // | ,            .   r + e , `, |
        // |,             .     , '     ,| te
        // |,             . O '.........,|..
        // |,             |        r    ,|  far
        // | ,            |            , |
        // |  ,           |           ,  | t
        // |    ,         |        , '   |
        // |      ' -_, _ | _ ,  '       |
        // |    near      | \/___________| near - elev
        // |              |              |
        // |            d |              |
        // |              |              |
        //                C
        // The distance to tangent point may be described as:
        const t = d;
        // Tangent extension due to terrain elevation behind the horizon may be calculated
        // based on the right triangle:
        // (r+maxElev)^2 = r^2 + te^2
        // te = sqrt((r+maxElev)^2 - r^2)
        // although we may not calculate it if elevation is negligible:
        const te = this.maxElevation < epsilon
            ? 0
            : Math.sqrt(r + this.maxElevation) * (r + this.maxElevation) - r * r;
        // Both near and far planes distances are directly applied to frustum, because tangents'
        // lines are parallel to camera look at vector.
        // Now far plane distance is constituted with:
        return t + te;
    }
}
exports.TopViewClipPlanesEvaluator = TopViewClipPlanesEvaluator;
/**
 * Evaluates camera clipping planes taking into account ground distance and camera angles.
 *
 * This evaluator provides support for camera with varying tilt (pitch) angle, the angle
 * between camera __look at__ vector and the ground surface normal.
 */
class TiltViewClipPlanesEvaluator extends TopViewClipPlanesEvaluator {
    /**
     * Calculate the camera distance to the ground in direction of look at vector.
     * This is not equivalent to camera altitude cause value will change according to look at
     * direction. It simply measures the distance of intersection point between ray from
     * camera and ground level, yet without taking into account terrain elevation nor buildings.
     * @param camera
     * @param projection
     * @note Use with extreme care cause due to optimizations the internal temporary vectors
     * are used (m_tmpVectors[0], m_tmpVectors[1]). Those should not be used in outlining
     * function scope (caller).
     */
    getCameraLookAtDistance(camera, projection) {
        harp_utils_1.assert(projection.type !== harp_geoutils_1.ProjectionType.Spherical);
        // Using simple trigonometry we may approximate the distance of camera eye vector
        // intersection with theoretical ground, knowing camera altitude and tilt angle:
        // cos(tiltAngle) = altitude / groundDistance
        // groundDistance = altitude / cos(tiltAngle)
        // where:
        // cos(tiltAngle) = dot(lookAt, eyeInverse)
        const lookAt = this.m_tmpVectors[0];
        camera.getWorldDirection(lookAt).normalize();
        const normal = this.m_tmpVectors[1];
        projection.surfaceNormal(camera.position, normal);
        normal.negate();
        let cosTiltAngle = lookAt.dot(normal);
        cosTiltAngle = cosTiltAngle === 0 ? epsilon : cosTiltAngle;
        return this.getCameraAltitude(camera, projection) / cosTiltAngle;
    }
    /**
     * Calculate the lengths of frustum planes intersection with the ground plane.
     * This evaluates distances between eye vector (or eye plane in orthographic projection) and
     * ground intersections of top and bottom frustum planes.
     * @note This method assumes the world surface (ground) to be flat and
     * works only with planar projections.
     *
     * @param mapView The [[MapView]] instance in use.
     */
    getFrustumGroundIntersectionDist(mapView) {
        harp_utils_1.assert(mapView.projection.type !== harp_geoutils_1.ProjectionType.Spherical);
        const camera = mapView.camera;
        const projection = mapView.projection;
        // This algorithm computes the length of frustum planes before intersecting with a flat
        // ground surface. Entire computation is split over two projections method and performed
        // for top and bottom plane, with addition of terrain (ground) elevation which is taken
        // into account.
        // The following diagram may help explain the algorithm below.
        //   🎥
        //   C
        //   |\
        //   |.\ .
        //   | . \  . t
        // z |  .  \   .c2
        //   |  c1.  \e ___. max elev
        //   |     .   \      .
        //___|a___D1.____\E1_____.D2______ g
        //   C1      .     \ __. min elev
        //            .      \.E2
        //          b  .    .
        //              . .
        //               .
        // Where:
        // - C gives the camera position.
        // - z is the height of the camera above the ground.
        // - z1 == z2 == z, for perspective camera all planes origin its the same
        // - a is a right angle.
        // - e is the look at vector of the camera.
        // - t and b are the frustum planes of the camera (top and bottom respectively).
        // - angle between c1 to c2 is the fov.
        // - c1, c2 - vectors from camera to the ground along frustum planes.
        // - angles between c1 and e or e and c2 splits fov on equal halves.
        // - d1 and d2 are the intersection points of the frustum with the world/ground plane.
        // - angle between z and e is the pitch of the camera.
        // - angle between g and e is the tilt angle.
        // - g is the ground/world surface
        //
        // The goal is to find distance for top/bottom planes intersections of frustum with ground
        // plane.
        // This are the distances from C->D1 and C->D2, and are described as
        // c1 and c2. Then we may compensate/correct those distances with actual
        // ground elevations, which is done by simply offsetting camera altitude, as it is
        // opposite to elevating ground level.
        const halfPiLimit = Math.PI / 2 - epsilon;
        const cameraAltitude = this.getCameraAltitude(camera, projection);
        const cameraTilt = this.getCameraTilt(mapView);
        // Angle between z and c2
        let topAngleRad;
        // Angle between z and c1
        let bottomAngleRad;
        // Bottom plane origin altitude
        let z1;
        // Top plane origin altitude
        let z2;
        // For perspective projection:
        if (camera.type === "PerspectiveCamera") {
            const cam = camera;
            // Angle between z and c2, note, the fov is vertical, otherwise we would need to
            // translate it using aspect ratio:
            // let aspect = camera.aspect > 1 ? camera.aspect : 1 / camera.aspect;
            const aspect = 1;
            // Half fov angle in radians
            const halfFovAngle = THREE.Math.degToRad((cam.fov * aspect) / 2);
            topAngleRad = harp_utils_1.MathUtils.clamp(cameraTilt + halfFovAngle, -halfPiLimit, halfPiLimit);
            bottomAngleRad = harp_utils_1.MathUtils.clamp(cameraTilt - halfFovAngle, -halfPiLimit, halfPiLimit);
            z1 = z2 = cameraAltitude;
        }
        // For orthographic projection:
        else {
            const cam = camera;
            // For orthogonal camera projections we may simply ignore FOV and use 0 for FOV
            // the top/bottom planes are simply parallel to the eye vector:
            topAngleRad = bottomAngleRad = cameraTilt;
            // Although the ray origin is not always the same (eye position) as for
            // the perspective projections, thus we need to compensate for ortho-cube
            // dimensions:
            // sin(tilt) = zc2 / top
            // sin(tilt) = zc1 / bottom
            // zc2 = sin(tilt) * top
            // zc1 = sin(tilt) * bottom
            const sinBeta = Math.sin(cameraTilt);
            z2 = cameraAltitude + sinBeta * cam.top;
            z1 = cameraAltitude - sinBeta * cam.bottom;
        }
        // Distance along the top plane to the ground - c2
        // cos(topAngle) = (z2 - minElev) / |c2|
        // |c2| = (z2 - minElev) / cos(topAngle)
        const topDist = (z2 - this.minElevation) / Math.cos(topAngleRad);
        // Distance along the bottom plane to the ground - c1
        // cos(bottomAngle) = (z - minElev) / |c1|
        // |c1| = (z - minElev) / cos(bottomAngle)
        const bottomDist = (z1 - this.maxElevation) / Math.cos(bottomAngleRad);
        return {
            top: Math.max(topDist, 0),
            bottom: Math.max(bottomDist, 0)
        };
    }
    /** @override */
    evaluateDistancePlanarProj(mapView) {
        harp_utils_1.assert(mapView.projection.type !== harp_geoutils_1.ProjectionType.Spherical);
        const viewRanges = Object.assign({}, this.minimumViewRange);
        // Generally near/far planes are set to keep top/bottom planes intersection distance.
        // Then elevations margins are applied. Here margins (min/max elevations) are meant to
        // be defined as distance along the ground normal vector thus during camera
        // tilt they may affect near/far planes positions differently.
        const planesDist = this.getFrustumGroundIntersectionDist(mapView);
        const { camera, projection } = mapView;
        // Project clipping plane distances for the top/bottom frustum planes (edges), but
        // only if we deal with perspective camera type, this step is not required
        // for orthographic projections, cause all clip planes are parallel to eye vector.
        if (camera.type === "PerspectiveCamera") {
            const cam = camera;
            // Angle between z and c2, note, the fov is vertical, otherwise we would need to
            // translate it using aspect ratio:
            // let aspect = camera.aspect > 1 ? camera.aspect : 1 / camera.aspect;
            const aspect = 1;
            // Half fov angle in radians
            const halfFovAngle = THREE.Math.degToRad((cam.fov * aspect) / 2);
            const cosHalfFov = Math.cos(halfFovAngle);
            // cos(halfFov) = near / bottomDist
            // near = cos(halfFov) * bottomDist
            viewRanges.near = planesDist.bottom * cosHalfFov;
            // cos(halfFov) = far / topDist
            // far = cos(halfFov) * topDist
            viewRanges.far = planesDist.top * cosHalfFov;
        }
        // Orthographic camera projection.
        else {
            viewRanges.near = planesDist.bottom;
            viewRanges.far = planesDist.top;
        }
        // Clamp values to constraints.
        const lookAtDist = this.getCameraLookAtDistance(camera, projection);
        const farMax = lookAtDist * this.farMaxRatio;
        viewRanges.near = Math.max(viewRanges.near, this.nearMin);
        viewRanges.far = Math.min(viewRanges.far, farMax);
        // Apply margins
        const nearFarMargin = (this.nearFarMarginRatio * (viewRanges.near + viewRanges.far)) / 2;
        viewRanges.near = Math.max(viewRanges.near - nearFarMargin / 2, this.nearMin);
        viewRanges.far = Math.max(viewRanges.far + nearFarMargin / 2, viewRanges.near + nearFarMargin);
        viewRanges.minimum = this.nearMin;
        viewRanges.maximum = farMax;
        return viewRanges;
    }
    /** @override */
    evaluateDistanceSphericalProj(mapView) {
        const { camera, projection } = mapView;
        harp_utils_1.assert(projection.type === harp_geoutils_1.ProjectionType.Spherical);
        const viewRanges = Object.assign({}, this.minimumViewRange);
        // Near plane calculus is pretty straightforward and does not depend on camera tilt:
        const cameraAltitude = this.getCameraAltitude(camera, projection);
        viewRanges.near = cameraAltitude - this.maxElevation;
        // Take fov directly if it is vertical, otherwise we translate it using aspect ratio:
        const aspect = camera.aspect > 1 ? camera.aspect : 1 / camera.aspect;
        const halfFovAngle = THREE.Math.degToRad((camera.fov * aspect) / 2);
        if (camera instanceof THREE.PerspectiveCamera) {
            // Now we need to account for camera tilt and frustum volume, so the longest
            // frustum edge does not intersects with sphere, it takes the worst case
            // scenario regardless of camera tilt, so may be improved little bit with more
            // sophisticated algorithm.
            viewRanges.near *= Math.cos(halfFovAngle);
        }
        // Far plane calculation requires different approaches depending from camera projection:
        // - perspective
        // - orthographic
        const cameraToOrigin = this.m_tmpVectors[0].copy(camera.position).negate();
        const r = harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS;
        const d = cameraToOrigin.length();
        let farPlane;
        if (camera instanceof THREE.PerspectiveCamera) {
            // Step-wise calculate angle between camera eye vector and tangent
            // Calculate angle between surface normal(below camera position) and tangent.
            const alpha = Math.asin(r / d);
            // Calculate angle between look at and surface normal(below camera position)
            const cameraPitch = this.getCameraPitch(cameraToOrigin, camera);
            // Calculate angle between camera eye vector and tangent.
            const modifiedAlpha = Math.abs(alpha - cameraPitch);
            // Use tangent based far plane if horizon is within field of view
            const farTangent = this.getTangentBasedFarPlane(camera, d, r, modifiedAlpha);
            farPlane =
                halfFovAngle >= modifiedAlpha
                    ? farTangent
                    : this.getTiltedFovBasedFarPlane(d, r, halfFovAngle, cameraPitch);
        }
        else {
            farPlane = this.getOrthoBasedFarPlane(d, r);
        }
        viewRanges.far = farPlane;
        // Apply the constraints.
        const farMin = cameraAltitude - this.minElevation;
        const farMax = mapView.targetDistance * this.farMaxRatio;
        viewRanges.near = Math.max(viewRanges.near, this.nearMin);
        viewRanges.far = harp_utils_1.MathUtils.clamp(viewRanges.far, farMin, farMax);
        // Apply margins.
        const nearFarMargin = (this.nearFarMarginRatio * (viewRanges.near + viewRanges.far)) / 2;
        viewRanges.near = Math.max(viewRanges.near - nearFarMargin / 2, this.nearMin);
        viewRanges.far = Math.max(viewRanges.far + nearFarMargin / 2, viewRanges.near + nearFarMargin);
        // Set minimum and maximum view range.
        viewRanges.minimum = this.nearMin;
        viewRanges.maximum = farMax;
        return viewRanges;
    }
    getTiltedFovBasedFarPlane(d, r, halfFovAngle, cameraPitch) {
        // Find intersection point that is closer to tangent point.
        //
        //         , - ~ ~ ~ - ,
        //     , '               ' ,
        //   ,           .           ,
        //  ,            .     r     ,' T1
        // ,             .     ,  '  / ,
        // ,             . O.'  a   /  ,
        // ,             | .  `  . /   ,
        //  ,            |   .  r / TA,
        //   ,           |    .  /   ,
        //     ,         |     ./  ,'_____ far
        //       ' -_, _ | _ , /' T0
        //     near      |    /
        //               |   / t
        //             d | /
        //               |/
        //               C
        //
        // See:
        // tslint:disable-next-line: max-line-length
        // https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection
        // compute length of t (distance to fov intersection with sphere)
        // with law of cosines:
        // r² = d² + t² - 2dt * cos(alpha)
        // solved for t:
        // t0 = d * cos(alpha) - sqrt(d²*cos²(alpha) - d² + r²)  <-- first intersection
        // t1 = d * cos(alpha) + sqrt(d²*cos²(alpha) - d² + r²)  <-- second intersection
        // Use first intersection:
        const cosAlpha = Math.cos(cameraPitch + halfFovAngle);
        const dSqr = d * d;
        const t = d * cosAlpha - Math.sqrt(dSqr * cosAlpha * cosAlpha - dSqr + r * r);
        harp_utils_1.assert(!isNaN(t), "Field of view does not intersect sphere. Use tangent based far plane instead.");
        // project t onto camera fwd vector
        const far = Math.cos(halfFovAngle) * t;
        return far;
    }
    getCameraPitch(cameraToOrigin, camera) {
        cameraToOrigin.normalize();
        const lookAt = camera.getWorldDirection(this.m_tmpVectors[1]).normalize();
        const cosAlpha1 = cameraToOrigin.dot(lookAt);
        const cameraPitch = Math.acos(harp_utils_1.MathUtils.clamp(cosAlpha1, -1.0, 1.0));
        return cameraPitch;
    }
    getCameraTilt(mapView) {
        return Utils_1.MapViewUtils.extractCameraTilt(mapView.camera, mapView.projection);
    }
}
exports.TiltViewClipPlanesEvaluator = TiltViewClipPlanesEvaluator;
/**
 * Provides the most basic evaluation concept giving fixed values with some constraints.
 */
class FixedClipPlanesEvaluator {
    constructor(minNear = 1, minFarOffset = 10) {
        this.minNear = minNear;
        this.minFarOffset = minFarOffset;
        this.minFar = minNear + minFarOffset;
        this.m_nearPlane = minNear;
        this.m_farPlane = this.minFar;
    }
    get nearPlane() {
        return this.m_nearPlane;
    }
    set nearPlane(fixedNear) {
        this.invalidatePlanes(fixedNear, this.m_farPlane);
    }
    get farPlane() {
        return this.m_farPlane;
    }
    set farPlane(fixedFar) {
        this.invalidatePlanes(this.m_nearPlane, fixedFar);
    }
    // tslint:disable-next-line: no-empty
    set minElevation(elevation) { }
    get minElevation() {
        // This evaluator does not support elevation so its always set to 0.
        return 0;
    }
    // tslint:disable-next-line: no-empty
    set maxElevation(elevation) { }
    get maxElevation() {
        // This evaluator does not support elevation so its always set to 0.
        return 0;
    }
    evaluateClipPlanes(mapView) {
        // We do not need to perform actual evaluation cause results are precomputed and
        // kept stable until somebody changes the properties.
        const viewRanges = {
            near: this.m_nearPlane,
            far: this.m_farPlane,
            minimum: this.minNear,
            maximum: this.m_farPlane
        };
        return viewRanges;
    }
    invalidatePlanes(near, far) {
        // When clamping prefer to extend far plane at about minimum distance, giving
        // near distance setup priority over far.
        const nearDist = Math.max(this.minNear, near);
        const farDist = Math.max(this.minFar, far, nearDist + this.minFarOffset);
        this.m_nearPlane = nearDist;
        this.m_farPlane = farDist;
    }
}
exports.FixedClipPlanesEvaluator = FixedClipPlanesEvaluator;
/**
 * Factory function that creates default [[ClipPlanesEvaluator]] that calculates near plane based
 * on ground distance and camera orientation.
 *
 * Creates [[TiltViewClipPlanesEvaluator]].
 */
exports.createDefaultClipPlanesEvaluator = () => new TiltViewClipPlanesEvaluator();


/***/ }),

/***/ "../harp-mapview/lib/ColorCache.ts":
/*!*****************************************!*\
  !*** ../harp-mapview/lib/ColorCache.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Use `ColorCache` to reuse a color specified by name and save allocation as well as
 * setup time.
 *
 * Implemented as a singleton. Do not modify colors after getting them from the `ColorCache`.
 */
class ColorCache {
    constructor() {
        this.m_map = new Map();
    }
    /**
     * Return instance of `ColorCache`.
     */
    static get instance() {
        return this.m_instance;
    }
    /**
     * Returns the color for the given `colorCode`. This function may reuse a previously generated
     * color, so you cannot modify the contents of the color.
     *
     * @param colorCode ThreeJS color code or name. You must provide a valid color code or name,
     * as this function does not do any validation.
     */
    getColor(colorCode) {
        if (typeof colorCode === "number") {
            colorCode = "#" + colorCode.toString(16).padStart(6, "0");
        }
        let color = this.m_map.get(colorCode);
        if (color !== undefined) {
            return color;
        }
        color = new THREE.Color(colorCode);
        this.m_map.set(colorCode, color);
        return color;
    }
    /**
     * Returns the number of elements in the cache.
     */
    get size() {
        return this.m_map.size;
    }
    /**
     * Clears the cache. Only references to the THREE.Color are removed from the cache.
     * Consequently, clearing the cache does not cause any negative visual impact.
     */
    clear() {
        this.m_map.clear();
    }
}
exports.ColorCache = ColorCache;
ColorCache.m_instance = new ColorCache();


/***/ }),

/***/ "../harp-mapview/lib/ConcurrentDecoderFacade.ts":
/*!******************************************************!*\
  !*** ../harp-mapview/lib/ConcurrentDecoderFacade.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ConcurrentWorkerSet_1 = __webpack_require__(/*! ./ConcurrentWorkerSet */ "../harp-mapview/lib/ConcurrentWorkerSet.ts");
const WorkerBasedDecoder_1 = __webpack_require__(/*! ./WorkerBasedDecoder */ "../harp-mapview/lib/WorkerBasedDecoder.ts");
/**
 * Default concurrent decoder helper.
 *
 * A convenient singleton that maintains a separate [[ConcurrentWorkerSet]] for each bundle
 * requested. Provides easy access to [[WorkerBasedDecoder]]s for data sources.
 */
class ConcurrentDecoderFacade {
    /**
     * Returns a [[WorkerBasedDecoder]] instance.
     *
     * @param decoderServiceType The name of the decoder service type.
     * @param scriptUrl The optional URL with the workers' script.
     * @param workerCount The number of web workers to use.
     */
    static getTileDecoder(decoderServiceType, scriptUrl, workerCount) {
        const workerSet = this.getWorkerSet(scriptUrl, workerCount);
        return new WorkerBasedDecoder_1.WorkerBasedDecoder(workerSet, decoderServiceType);
    }
    /**
     * Returns a [[ConcurrentWorkerSet]] instance based on the script URL specified.
     *
     * @param scriptUrl The optional URL with the workers' script. If not specified,
     * the function uses [[defaultScriptUrl]] instead.
     * @param workerCount The number of web workers to use.
     */
    static getWorkerSet(scriptUrl, workerCount) {
        if (scriptUrl === undefined) {
            scriptUrl = this.defaultScriptUrl;
        }
        let workerSet = this.workerSets[scriptUrl];
        if (workerSet === undefined) {
            workerSet = new ConcurrentWorkerSet_1.ConcurrentWorkerSet({
                scriptUrl,
                workerCount: workerCount === undefined ? this.defaultWorkerCount : workerCount
            });
            this.workerSets[scriptUrl] = workerSet;
        }
        return workerSet;
    }
    /**
     * Destroys a [[ConcurrentWorkerSet]] instance.
     *
     * @param scriptUrl The worker script URL that was used to create the [[ConcurrentWorkerSet]].
     */
    static destroyWorkerSet(scriptUrl) {
        const workerSet = this.workerSets[scriptUrl];
        if (workerSet !== undefined) {
            workerSet.destroy();
            delete this.workerSets[scriptUrl];
        }
    }
    /**
     * Destroys all managed [[ConcurrentWorkerSet]]s.
     */
    static destroy() {
        Object.keys(this.workerSets).forEach(name => {
            this.workerSets[name].destroy();
        });
        this.workerSets = {};
    }
}
exports.ConcurrentDecoderFacade = ConcurrentDecoderFacade;
/**
 * The URL containing a script to fall back (default) to when looking for worker sets
 * and decoders.
 */
ConcurrentDecoderFacade.defaultScriptUrl = "./decoder.bundle.js";
/**
 * The default number of workers.
 */
ConcurrentDecoderFacade.defaultWorkerCount = undefined;
/**
 * The [[ConcurrentWorkerSet]] instances which are stored by the script URL.
 */
ConcurrentDecoderFacade.workerSets = {};


/***/ }),

/***/ "../harp-mapview/lib/ConcurrentTilerFacade.ts":
/*!****************************************************!*\
  !*** ../harp-mapview/lib/ConcurrentTilerFacade.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ConcurrentWorkerSet_1 = __webpack_require__(/*! ./ConcurrentWorkerSet */ "../harp-mapview/lib/ConcurrentWorkerSet.ts");
const WorkerBasedTiler_1 = __webpack_require__(/*! ./WorkerBasedTiler */ "../harp-mapview/lib/WorkerBasedTiler.ts");
/**
 * Default concurrent tiler helper.
 *
 * A convenient singleton that maintains a separate [[ConcurrentWorkerSet]] for each bundle
 * requested. Provides easy access to [[WorkerBasedTiler]]s for data sources.
 */
class ConcurrentTilerFacade {
    /**
     * Returns a [[WorkerBasedTiler]] instance.
     *
     * @param tilerServiceType The name of the tiler service type.
     * @param scriptUrl The optional URL with the workers' script.
     * @param workerCount The number of web workers to use.
     */
    static getTiler(tilerServiceType, scriptUrl, workerCount) {
        const workerSet = this.getWorkerSet(scriptUrl, workerCount);
        return new WorkerBasedTiler_1.WorkerBasedTiler(workerSet, tilerServiceType);
    }
    /**
     * Returns a [[ConcurrentWorkerSet]] instance based on the script URL specified.
     *
     * @param scriptUrl The optional URL with the workers' script. If not specified,
     * the function uses [[defaultScriptUrl]] instead.
     * @param workerCount The number of web workers to use.
     */
    static getWorkerSet(scriptUrl, workerCount) {
        if (scriptUrl === undefined) {
            scriptUrl = this.defaultScriptUrl;
        }
        let workerSet = this.workerSets[scriptUrl];
        if (workerSet === undefined) {
            workerSet = new ConcurrentWorkerSet_1.ConcurrentWorkerSet({
                scriptUrl,
                workerCount: workerCount === undefined ? this.defaultWorkerCount : workerCount
            });
            this.workerSets[scriptUrl] = workerSet;
        }
        return workerSet;
    }
    /**
     * Destroys a [[ConcurrentWorkerSet]] instance.
     *
     * @param scriptUrl The worker script URL that was used to create the [[ConcurrentWorkerSet]].
     */
    static destroyWorkerSet(scriptUrl) {
        const workerSet = this.workerSets[scriptUrl];
        if (workerSet !== undefined) {
            workerSet.destroy();
            delete this.workerSets[scriptUrl];
        }
    }
    /**
     * Destroys all managed [[ConcurrentWorkerSet]]s.
     */
    static destroy() {
        Object.keys(this.workerSets).forEach(name => {
            this.workerSets[name].destroy();
        });
        this.workerSets = {};
    }
}
exports.ConcurrentTilerFacade = ConcurrentTilerFacade;
/**
 * The URL containing a script to fall back (default) to when looking for worker sets
 * and tilers.
 */
ConcurrentTilerFacade.defaultScriptUrl = "./decoder.bundle.js";
/**
 * The default number of workers.
 */
ConcurrentTilerFacade.defaultWorkerCount = 1;
/**
 * The [[ConcurrentWorkerSet]] instances which are stored by the script URL.
 */
ConcurrentTilerFacade.workerSets = {};


/***/ }),

/***/ "../harp-mapview/lib/ConcurrentWorkerSet.ts":
/*!**************************************************!*\
  !*** ../harp-mapview/lib/ConcurrentWorkerSet.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const WorkerLoader_1 = __webpack_require__(/*! ./workers/WorkerLoader */ "../harp-mapview/lib/workers/WorkerLoader.ts");
const THREE = __webpack_require__(/*! three */ "three");
const logger = harp_utils_1.LoggerManager.instance.create("ConcurrentWorkerSet");
function isLoggingMessage(message) {
    return message && typeof message.level === "number" && message.type === harp_utils_1.WORKERCHANNEL_MSG_TYPE;
}
exports.isLoggingMessage = isLoggingMessage;
/**
 * The default number of Web Workers to use if `navigator.hardwareConcurrency` is unavailable.
 */
const DEFAULT_WORKER_COUNT = 2;
/**
 * The default timeout for first message from worker.
 *
 * @see [[WorkerLoader.startWorker]]
 */
exports.DEFAULT_WORKER_INITIALIZATION_TIMEOUT = 10000;
/**
 * A set of concurrent Web Workers. Acts as a Communication Peer for [[WorkerService]] instances
 * running in Web Workers.
 *
 * Starts and manages a certain number of web workers and provides a means to communicate
 * with them using various communication schemes, such as:
 *  - [[addEventListener]] : receive a unidirectional messages
 *  - [[broadcastMessage]] : send unidirectional broadcast message
 *  - [[invokeRequest]] : send a request that waits for a response, with load balancing
 *  - [[postMessage]] : send a unidirectional message, with load balancing
 *
 * The request queue holds all requests before they are stuffed into the event queue, allows for
 * easy (and early) cancelling of requests. The workers now only get a single new RequestMessage
 * when they return their previous result, or if they are idle. When they are idle, they are stored
 * in m_availableWorkers.
 */
class ConcurrentWorkerSet {
    /**
     * Creates a new `ConcurrentWorkerSet`.
     *
     * Creates as many Web Workers as specified in `options.workerCount`, from the script provided
     * in `options.scriptUrl`. If `options.workerCount` is not specified, the value specified in
     * `navigator.hardwareConcurrency` is used instead.
     *
     * The worker set is implicitly started when constructed.
     */
    constructor(m_options) {
        this.m_options = m_options;
        this.m_workerChannelLogger = harp_utils_1.LoggerManager.instance.create("WorkerChannel");
        this.m_eventListeners = new Map();
        this.m_workers = new Array();
        // List of idle workers that can be given the next job. It is using a LIFO scheme to reduce
        // memory consumption in idle workers.
        this.m_availableWorkers = new Array();
        this.m_workerPromises = new Array();
        this.m_readyPromises = new Map();
        this.m_requests = new Map();
        this.m_workerRequestQueue = [];
        this.m_nextMessageId = 0;
        this.m_stopped = true;
        this.m_referenceCount = 0;
        /**
         * Handles messages received from workers. This method is protected so that the message
         * reception can be simulated through an extended class, to avoid relying on real workers.
         *
         * @param workerId The workerId of the web worker.
         * @param event The event to dispatch.
         */
        this.onWorkerMessage = (workerId, event) => {
            if (harp_datasource_protocol_1.WorkerServiceProtocol.isResponseMessage(event.data)) {
                const response = event.data;
                if (response.messageId === null) {
                    logger.error(`[${this.m_options.scriptUrl}]: Bad ResponseMessage: no messageId`);
                    return;
                }
                const entry = this.m_requests.get(response.messageId);
                if (entry === undefined) {
                    logger.error(`[${this.m_options.scriptUrl}]: Bad ResponseMessage: invalid messageId`);
                    return;
                }
                if (workerId >= 0 && workerId < this.m_workers.length) {
                    const worker = this.m_workers[workerId];
                    this.m_availableWorkers.push(worker);
                    // Check if any new work has been put into the queue.
                    this.checkWorkerRequestQueue();
                }
                else {
                    logger.error(`[${this.m_options.scriptUrl}]: onWorkerMessage: invalid workerId`);
                }
                if (response.errorMessage !== undefined) {
                    const error = new Error(response.errorMessage);
                    if (response.errorStack !== undefined) {
                        error.stack = response.errorStack;
                    }
                    entry.resolver(error);
                }
                else {
                    entry.resolver(undefined, response.response);
                }
            }
            else if (harp_datasource_protocol_1.WorkerServiceProtocol.isInitializedMessage(event.data)) {
                const readyPromise = this.getReadyPromise(event.data.service);
                if (++readyPromise.count === this.m_workerPromises.length) {
                    readyPromise.resolve();
                }
            }
            else if (isLoggingMessage(event.data)) {
                switch (event.data.level) {
                    case harp_utils_1.LogLevel.Trace:
                        this.m_workerChannelLogger.trace(...event.data.message);
                        break;
                    case harp_utils_1.LogLevel.Debug:
                        this.m_workerChannelLogger.debug(...event.data.message);
                        break;
                    case harp_utils_1.LogLevel.Log:
                        this.m_workerChannelLogger.log(...event.data.message);
                        break;
                    case harp_utils_1.LogLevel.Info:
                        this.m_workerChannelLogger.info(...event.data.message);
                        break;
                    case harp_utils_1.LogLevel.Warn:
                        this.m_workerChannelLogger.warn(...event.data.message);
                        break;
                    case harp_utils_1.LogLevel.Error:
                        this.m_workerChannelLogger.error(...event.data.message);
                        break;
                }
            }
            else {
                this.eventHandler(event);
            }
        };
        this.start();
    }
    /**
     * Adds an external reference and increments the internal reference counter by one.
     *
     * To implement a reference-count based automatic resource cleanup, use this function with
     * [[removeReference]].
     */
    addReference() {
        this.m_referenceCount += 1;
        if (this.m_referenceCount === 1 && this.m_stopped) {
            this.start();
        }
    }
    /**
     * Decrements the internal reference counter by 1.
     *
     * When the internal reference counter reaches 0, this function calls [[dispose]] to clear the
     * resources.
     *
     * Use with [[addReference]] to implement reference-count based automatic resource cleanup.
     */
    removeReference() {
        this.m_referenceCount -= 1;
        if (this.m_referenceCount === 0) {
            this.destroy();
        }
    }
    /**
     * Starts workers.
     *
     * Use to start workers already stopped by [[stop]] or [[destroy]] calls.
     *
     * Note: The worker set is implicitly started on construction - no need to call [[start]] on
     * fresh instance.
     *
     * @param options optional, new worker set options
     */
    start(options) {
        if (options !== undefined) {
            this.m_options = options;
        }
        if (!this.m_stopped) {
            throw new Error("ConcurrentWorker set already started");
        }
        this.m_workerCount = harp_utils_1.getOptionValue(this.m_options.workerCount, typeof navigator !== "undefined" && navigator.hardwareConcurrency !== undefined
            ? // We need to have at least one worker
                THREE.Math.clamp(navigator.hardwareConcurrency - 1, 1, 2)
            : undefined, DEFAULT_WORKER_COUNT);
        // Initialize the workers. The workers now have an ID to identify specific workers and
        // handle their busy state.
        const timeout = harp_utils_1.getOptionValue(this.m_options.workerConnectionTimeout, exports.DEFAULT_WORKER_INITIALIZATION_TIMEOUT);
        for (let workerId = 0; workerId < this.m_workerCount; ++workerId) {
            const workerPromise = WorkerLoader_1.WorkerLoader.startWorker(this.m_options.scriptUrl, timeout).then(worker => {
                const listener = (evt) => {
                    this.onWorkerMessage(workerId, evt);
                };
                worker.addEventListener("message", listener);
                this.m_workers.push(worker);
                this.m_availableWorkers.push(worker);
                return {
                    worker,
                    listener
                };
            });
            this.m_workerPromises.push(workerPromise);
        }
        this.m_stopped = false;
    }
    /**
     * The number of workers started for this worker set. The value is `undefined` until the workers
     * have been created.
     */
    get workerCount() {
        return this.m_workerCount;
    }
    /**
     * Stops workers.
     *
     * Waits for all pending requests to be finished and stops all workers.
     *
     * Use [[start]] to start this worker again.
     *
     * @returns `Promise` that resolves when all workers are destroyed.
     */
    async stop() {
        this.m_stopped = true;
        await this.waitForAllResponses().then(() => {
            this.terminateWorkers();
        });
    }
    /**
     * Destroys all workers immediately.
     *
     * Resolves all pending request promises with a `worker destroyed` error.
     *
     * Use [[start]] to start this worker again.
     */
    destroy() {
        this.m_stopped = true;
        // respond with all pending request
        this.m_requests.forEach(entry => {
            entry.resolver(new Error("worker destroyed"));
        });
        this.m_requests.clear();
        this.m_workerRequestQueue = [];
        this.terminateWorkers();
        // clean other stuff
        this.m_eventListeners.clear();
    }
    /**
     * Waits for `service` to be initialized in all workers.
     *
     * Each service that starts in a worker sends an [[isInitializedMessage]] to confirm that
     * it has started successfully. This method resolves when all workers in a set have
     * `service` initialized.
     *
     * Promise is rejected if any of worker fails to start.
     *
     * @param serviceId The service identifier.
     */
    async connect(serviceId) {
        this.ensureStarted();
        await Promise.all(this.m_workerPromises);
        return this.getReadyPromise(serviceId).promise;
    }
    /**
     * Registers an event listener for events that originated in a web worker, for a given
     * `serviceId`. You can only set one event listener per `serviceId`.
     *
     * @param serviceId The service to listen to.
     * @param callback The callback to invoke for matching events.
     */
    addEventListener(serviceId, callback) {
        this.m_eventListeners.set(serviceId, callback);
    }
    /**
     * Removes a previously set event listener for the given `serviceId`.
     *
     * @param serviceId The service from which to remove the event listeners.
     */
    removeEventListener(serviceId) {
        this.m_eventListeners.delete(serviceId);
    }
    /**
     * Invokes a request that expects a response from a random worker.
     *
     * Sends [[RequestMessage]] and resolves when a matching [[ResponseMessage]] is received from
     * workers. Use this function when interfacing with "RPC-like" calls to services.
     *
     * @param serviceId The name of service, as registered with the [[WorkerClient]] instance.
     * @param request The request to process.
     * @param transferList An optional array of `ArrayBuffer`s to transfer to the worker context.
     * @param requestController An optional [[RequestController]] to store state of cancelling.
     *
     * @returns A `Promise` that resolves with a response from the service.
     */
    invokeRequest(serviceId, request, transferList, requestController) {
        this.ensureStarted();
        const messageId = this.m_nextMessageId++;
        let resolver;
        const promise = new Promise((resolve, reject) => {
            resolver = (error, response) => {
                this.m_requests.delete(messageId);
                if (error !== undefined) {
                    reject(error);
                }
                else {
                    resolve(response);
                }
            };
        });
        this.m_requests.set(messageId, {
            promise,
            resolver: resolver
        });
        const message = {
            service: serviceId,
            type: harp_datasource_protocol_1.WorkerServiceProtocol.ServiceMessageName.Request,
            messageId,
            request
        };
        this.postRequestMessage(message, transferList, requestController);
        return promise;
    }
    /**
     * Invokes a request that expects responses from all workers.
     *
     * Send [[RequestMessage]]  to all workers and resolves when all workers have sent a matching
     * [[ResponseMessage]]. Use this function to wait on request that need to happen on all workers
     * before proceeding (like synchronous worker service creation).
     *
     * @param serviceId The name of service, as registered with the [[WorkerClient]] instance.
     * @param request The request to process.
     * @param transferList An optional array of `ArrayBuffer`s to transfer to the worker context.
     *
     * @returns Array of `Promise`s that resolves with a response from each worker (unspecified
     * order).
     */
    broadcastRequest(serviceId, request, transferList) {
        this.ensureStarted();
        const promises = [];
        for (const worker of this.m_workers) {
            const messageId = this.m_nextMessageId++;
            let resolver;
            const promise = new Promise((resolve, reject) => {
                resolver = (error, response) => {
                    this.m_requests.delete(messageId);
                    if (error !== undefined) {
                        reject(error);
                    }
                    else {
                        resolve(response);
                    }
                };
            });
            promises.push(promise);
            this.m_requests.set(messageId, {
                promise,
                resolver: resolver
            });
            const message = {
                service: serviceId,
                type: harp_datasource_protocol_1.WorkerServiceProtocol.ServiceMessageName.Request,
                messageId,
                request
            };
            if (transferList !== undefined) {
                worker.postMessage(message, transferList);
            }
            else {
                worker.postMessage(message);
            }
        }
        return Promise.all(promises);
    }
    /**
     * Posts a message to all workers.
     *
     * @param message The message to send.
     * @param buffers Optional buffers to transfer to the workers.
     */
    broadcastMessage(message, buffers) {
        this.ensureStarted();
        if (buffers !== undefined) {
            this.m_workers.forEach(worker => worker.postMessage(message, buffers));
        }
        else {
            this.m_workers.forEach(worker => worker.postMessage(message));
        }
    }
    /**
     * The size of the request queue for debugging and profiling.
     */
    get requestQueueSize() {
        return this.m_workerRequestQueue.length;
    }
    /**
     * The number of workers for debugging and profiling.
     */
    get numWorkers() {
        return this.m_workers.length;
    }
    /**
     * The number of workers for debugging and profiling.
     */
    get numIdleWorkers() {
        return this.m_availableWorkers.length;
    }
    /**
     * Subclasses must call this function when a worker emits an event.
     *
     * @param event The event to dispatch.
     */
    eventHandler(event) {
        if (typeof event.data.type !== "string") {
            return; // not an event generated by us, ignore.
        }
        this.dispatchEvent(event.data.type, event);
    }
    /**
     * Posts a [[WorkerServiceProtocol.RequestMessage]] to an available worker. If no worker is
     * available, the request is put into a queue.
     *
     * @param message The message to send.
     * @param buffers Optional buffers to transfer to the worker.
     * @param requestController An optional [[RequestController]] to store state of cancelling.
     */
    postRequestMessage(message, buffers, requestController) {
        this.ensureStarted();
        if (this.m_workers.length === 0) {
            throw new Error("ConcurrentWorkerSet#postMessage: no workers started");
        }
        // Check if the requestController has received the abort signal, in which case the request
        // is ignored.
        if (requestController !== undefined && requestController.signal.aborted) {
            const entry = this.m_requests.get(message.messageId);
            if (entry === undefined) {
                logger.error(`[${this.m_options.scriptUrl}]: Bad RequestMessage: invalid messageId`);
                return;
            }
            const err = new Error("Aborted");
            err.name = "AbortError";
            entry.resolver(err, undefined);
            return;
        }
        if (this.m_availableWorkers.length > 0) {
            const worker = this.m_availableWorkers.pop();
            if (buffers !== undefined) {
                worker.postMessage(message, buffers);
            }
            else {
                worker.postMessage(message);
            }
        }
        else {
            // We need a priority to keep sorting stable, so we have to add a RequestController.
            if (requestController === undefined) {
                requestController = new harp_datasource_protocol_1.RequestController(0);
            }
            if (requestController.priority === 0) {
                // If the requests do not get a priority, they should keep their sorting order.
                requestController.priority = -this.m_nextMessageId;
            }
            this.m_workerRequestQueue.unshift({
                message,
                buffers,
                requestController
            });
        }
    }
    ensureStarted() {
        if (this.m_stopped) {
            throw new Error("ConcurrentWorkerSet stopped");
        }
    }
    async waitForAllResponses() {
        const promises = new Array();
        this.m_requests.forEach(entry => {
            promises.push(entry.promise);
        });
        await Promise.all(promises);
    }
    dispatchEvent(id, message) {
        const callback = this.m_eventListeners.get(id);
        if (callback === undefined) {
            return;
        } // unknown event, ignore.
        callback(message);
    }
    terminateWorkers() {
        // terminate all workers
        this.m_workerPromises.forEach(workerPromise => {
            workerPromise.then(workerEntry => {
                if (workerEntry === undefined) {
                    return;
                }
                workerEntry.worker.removeEventListener("message", workerEntry.listener);
                workerEntry.worker.terminate();
            });
        });
        this.m_workers = [];
        this.m_workerPromises = [];
        this.m_availableWorkers = [];
        this.m_readyPromises.clear();
    }
    getReadyPromise(id) {
        const readyPromise = this.m_readyPromises.get(id);
        if (readyPromise !== undefined) {
            return readyPromise;
        }
        const newPromise = {
            count: 0,
            promise: undefined,
            resolve: () => {
                /* placeholder */
            },
            reject: (error) => {
                newPromise.error = error;
            },
            error: undefined
        };
        newPromise.promise = new Promise((resolve, reject) => {
            const that = newPromise;
            if (that.error !== undefined) {
                reject(that.error);
            }
            else if (that.count === this.m_workerPromises.length) {
                resolve();
            }
            that.resolve = resolve;
            that.reject = reject;
        });
        this.m_readyPromises.set(id, newPromise);
        return newPromise;
    }
    /**
     * Check the worker request queue, if there are any queued up decoding jobs and idle workers,
     * they will be executed with postRequestMessage. The requests in the queue are sorted before
     * the request with the highest priority is selected for processing.
     */
    checkWorkerRequestQueue() {
        if (this.m_workerRequestQueue.length === 0 || this.m_availableWorkers.length === 0) {
            return;
        }
        this.m_workerRequestQueue.sort((a, b) => {
            return a.requestController.priority - b.requestController.priority;
        });
        // Get the request with the highest priority and send it (again).
        while (this.m_availableWorkers.length > 0 && this.m_workerRequestQueue.length > 0) {
            const request = this.m_workerRequestQueue.pop();
            this.postRequestMessage(request.message, request.buffers, request.requestController);
        }
    }
}
exports.ConcurrentWorkerSet = ConcurrentWorkerSet;


/***/ }),

/***/ "../harp-mapview/lib/DataSource.ts":
/*!*****************************************!*\
  !*** ../harp-mapview/lib/DataSource.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const THREE = __webpack_require__(/*! three */ "three");
const UPDATE_EVENT = { type: "update" };
/**
 * Derive a class from `DataSource` to contribute data and geometries to the [[MapView]].
 */
class DataSource extends THREE.EventDispatcher {
    /**
     * Constructs a new `DataSource`.
     *
     * @param uniqueName A unique name that represents this `DataSource`.
     * @param styleSetName The name of the [[StyleSet]] to refer to in a [[Theme]], to decode vector
     * tiles.
     * @param minZoomLevel Minimum zoom level this `DataSource` can be displayed in.
     * @param maxZoomLevel Maximum zoom level this `DataSource` can be displayed in.
     * @param storageLevelOffset Storage level offset applied to this `DataSource`.
     */
    constructor(uniqueName, styleSetName, minZoomLevel, maxZoomLevel, storageLevelOffset) {
        super();
        /**
         * Set to `true` if this `DataSource` is enabled; `false` otherwise.
         */
        this.enabled = true;
        /**
         * Set to `true` if the [[MapView]] can cache tiles produced by this `DataSource`.
         */
        this.cacheable = false;
        /**
         * Set to `true` if the loader should be used to get the tile contents.
         */
        this.useGeometryLoader = false;
        /**
         * Whether the datasource should have a ground plane (this plane covers the tile entirely and
         * has the minimum possible renderOrder), this can be required in some cases when fallback
         * parent tiles need to be covered by the children, otherwise the content will overlap.
         * Default is false
         */
        this.addGroundPlane = false;
        /**
         * Minimum zoom level this `DataSource` can be displayed in.
         */
        this.m_minZoomLevel = 1;
        /**
         * Maximum zoom level this `DataSource` can be displayed in.
         */
        this.m_maxZoomLevel = 20;
        /**
         * Current value of [[maxGeometryHeight]] property.
         */
        this.m_maxGeometryHeight = 0;
        /**
         * Storage level offset applied to this `DataSource`.
         */
        this.m_storageLevelOffset = 0;
        if (uniqueName === undefined || uniqueName.length === 0) {
            uniqueName = `anonymous-datasource#${++DataSource.uniqueNameCounter}`;
        }
        this.name = uniqueName;
        this.styleSetName = styleSetName;
        if (minZoomLevel !== undefined) {
            this.m_minZoomLevel = minZoomLevel;
        }
        if (maxZoomLevel !== undefined) {
            this.m_maxZoomLevel = maxZoomLevel;
        }
        if (storageLevelOffset !== undefined) {
            this.m_storageLevelOffset = storageLevelOffset;
        }
    }
    /**
     * Returns the name of the [[StyleSet]] to use for the decoding.
     */
    get styleSetName() {
        return this.m_styleSetName;
    }
    /**
     * Sets the name of the [[StyleSet]] to use for the decoding. If this [[DataSource]] is already
     * attached to a [[MapView]], this setter then reapplies [[StyleSet]] with this name found in
     * [[MapView]]s theme.
     */
    set styleSetName(styleSetName) {
        this.m_styleSetName = styleSetName;
        if (this.m_mapView !== undefined && styleSetName !== undefined) {
            this.setTheme(this.m_mapView.theme);
        }
    }
    /**
     * Destroys this `DataSource`.
     */
    dispose() {
        // to be overloaded by subclasses
    }
    /**
     * Purges all the caching done by this `DataSource`
     */
    clearCache() {
        // to be overloaded by subclasses
    }
    /**
     * Returns `true` if this `DataSource` is ready and the [[MapView]] can invoke `getTile()` to
     * start requesting data.
     */
    ready() {
        return true;
    }
    /**
     * The [[MapView]] that is holding this `DataSource`.
     */
    get mapView() {
        if (this.m_mapView === undefined) {
            throw new Error("This DataSource was not added to MapView");
        }
        return this.m_mapView;
    }
    /**
     * The [[Projection]] used by the [[MapView]] that is holding this `DataSource`.
     *
     * An `Error` is thrown if you call this method before this `DataSource` has been added
     * to a [[MapView]].
     */
    get projection() {
        return this.mapView.projection;
    }
    /**
     * This method is called when the `DataSource` is added to a [[MapView]]. Reimplement this
     * method to provide any custom initialization, such as, to establish a network connection,
     * or to initialize complex data structures.
     */
    async connect() {
        // to be overloaded by subclasses
    }
    /**
     * This method is called when this `DataSource` is added to a [[MapView]].
     *
     * Reimplementations of this method must invoke the definition of the super class.
     *
     * @param mapView The instance of the [[MapView]].
     */
    attach(mapView) {
        this.m_mapView = mapView;
    }
    /**
     * This method is called when this `DataSource` is removed from a [[MapView]].
     *
     * Reimplementations of this method must invoke the definition of the super class.
     *
     * @param mapView The instance of the [[MapView]].
     */
    detach(mapView) {
        harp_utils_1.assert(this.m_mapView === mapView);
        this.m_mapView = undefined;
    }
    /**
     * Invoked by [[MapView]] to notify when the [[Theme]] has been changed.
     *
     * If `DataSource` depends on a `styleSet` or `languages`, it must update its tiles' geometry.
     *
     * @deprecated, Use [[setTheme]].
     *
     * @param styleSet The new theme that [[MapView]] uses.
     * @param languages An optional list of languages for the `DataSource`.
     */
    // tslint:disable-next-line:no-unused-variable
    setStyleSet(styleSet, definitions, languages) {
        // to be overwritten by subclasses
    }
    /**
     * Apply the [[Theme]] to this data source.
     *
     * If `DataSource` depends on a `styleSet` defined by this theme or `languages`, it must update
     * its tiles' geometry.
     *
     * @param languages
     */
    setTheme(theme, languages) {
        // to be overwritten by subclasses
    }
    /**
     * Used to configure the languages used by the `DataSource` according to priority;
     * the first language in the array has the highest priority.
     *
     * @param languages An array of ISO 639-1 language codes.
     */
    setLanguages(languages) {
        // to be overloaded by subclasses
    }
    /**
     * This method is called by [[MapView]] before the tile needs to be updated, for example after
     * a theme change.
     *
     * @param tile The [[Tile]] to update.
     */
    // tslint:disable-next-line:no-unused-variable
    updateTile(tile) {
        // to be overloaded by subclasses
    }
    /**
     * This method is called by the [[MapView]] to determine if the content of the surrounding
     * tiles must be preloaded.
     *
     * @returns `true` if the [[MapView]] should try to preload tiles surrounding the visible
     * tiles; `false` otherwise. The default is `false`.
     */
    shouldPreloadTiles() {
        return false;
    }
    /**
     * The minimum zoom level to use for display.
     *
     * @returns The minimum zoom level to use for display.
     */
    get minZoomLevel() {
        return this.m_minZoomLevel;
    }
    set minZoomLevel(level) {
        this.m_minZoomLevel = level;
    }
    /**
     * The maximum zoom level to use for display.
     */
    get maxZoomLevel() {
        return this.m_maxZoomLevel;
    }
    set maxZoomLevel(level) {
        this.m_maxZoomLevel = level;
    }
    /**
     * Maximum geometry height above ground level this `DataSource` can produce.
     *
     * Used in first stage of frustum culling before [[Tile.maxGeometryHeight]] data is available.
     *
     * @default 0.
     */
    get maxGeometryHeight() {
        return this.m_maxGeometryHeight;
    }
    set maxGeometryHeight(value) {
        this.m_maxGeometryHeight = value;
    }
    /**
     * The difference between storage level and display level of tile.
     *
     * Storage level offset is a value applied (added) to current zoom level giving
     * a final tile level being displayed. This way we may differentate current
     * zoom level from the storage level that is displayed, giving fine grained
     * control over the tiles being decoded an displayed.
     */
    get storageLevelOffset() {
        return this.m_storageLevelOffset;
    }
    /**
     * Setup the relative offset between storage level and display level of tile.
     *
     * @param levelOffset Difference between zoom level and display level.
     */
    set storageLevelOffset(levelOffset) {
        this.m_storageLevelOffset = levelOffset;
    }
    /**
     * Enables or disables overlay of geometry on elevation. It must be overloaded by data sources
     * supporting this feature.
     *
     * @param value True to enable, false to disable.
     */
    setEnableElevationOverlay(enable) {
        // to be overloaded by subclasses
    }
    /**
     * Computes the zoom level to use for display.
     *
     * @param zoomLevel The zoom level of the [[MapView]].
     * @returns The zoom level to use for display.
     */
    getDisplayZoomLevel(zoomLevel) {
        return THREE.Math.clamp(zoomLevel + this.m_storageLevelOffset, this.m_minZoomLevel, this.m_maxZoomLevel);
    }
    /**
     * Returns `true` if [[DataSource]] can load tile with given [[TileKey]] and zoom level.
     *
     * @param zoomLevel The zoom level of the [[MapView]].
     * @param tileKey The unique identifier for a map tile.
     * @returns `true` if the tile for the given [[TileKey]] can be loaded.
     */
    canGetTile(zoomLevel, tileKey) {
        return tileKey.level <= zoomLevel;
    }
    /**
     * Returns `true` if [[MapView]] should traverse tiles further with given [[TileKey]] and
     * zoom level.
     *
     * @param zoomLevel The zoom level of the [[MapView]].
     * @param tileKey The unique identifier for a map tile.
     * @returns `true` if the subtiles of the given [[TileKey]] should be
     * checked for collisions.
     */
    shouldSubdivide(zoomLevel, tileKey) {
        return tileKey.level <= zoomLevel;
    }
    /**
     * Returns `true` if [[MapView]] should render the text elements with the given [[TileKey]] and
     * zoom level.
     *
     * This is an additional check for the tiles that are already selected for rendering so the
     * default implementation returns `true`.
     *
     * @param zoomLevel The zoom level.
     * @param tileKey The unique identifier for a map tile.
     * @returns `true` if the text elements created for the given [[TileKey]] should be rendered.
     */
    // tslint:disable-next-line:no-unused-variable
    shouldRenderText(zoomLevel, tileKey) {
        return true;
    }
    /**
     * Sends a request to the [[MapView]] to redraw the scene.
     */
    requestUpdate() {
        this.dispatchEvent(UPDATE_EVENT);
    }
}
exports.DataSource = DataSource;
/**
 * A counter to generate unique names for each `DataSource`, if no name is provided in the
 * constructor.
 */
DataSource.uniqueNameCounter = 0;


/***/ }),

/***/ "../harp-mapview/lib/DebugContext.ts":
/*!*******************************************!*\
  !*** ../harp-mapview/lib/DebugContext.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const isNode = typeof window === "undefined";
/**
 * A `DebugOption` is a pair that consists of an option value and an array of change listeners.
 * Listeners are called up when setting the option's value.
 */
class DebugOption extends THREE.EventDispatcher {
    /**
     * Constructs the `DebugOption`.
     *
     * @param value The value of the option.
     */
    constructor(value) {
        super();
        this.value = value;
    }
    /**
     * Updates the value of a given option.
     *
     * @param value The new value for the option.
     * @param name The name of the option to set.
     */
    set(value, name) {
        this.value = value;
        this.dispatchEvent({ type: DebugOption.SET_EVENT_TYPE, name, value });
    }
}
DebugOption.SET_EVENT_TYPE = "set";
/**
 * Maintains a map of [[DebugOption]]s. You can add listeners to debug options by passing their
 * names.
 */
class DebugContext {
    /**
     * Builds a `DebugContext`.
     */
    constructor() {
        this.m_optionsMap = new Map();
        // If we have a `window` object, we store the context in it to make it available in the
        // console.
        if (!isNode && typeof window !== "undefined" && window) {
            const debugInfo = window;
            debugInfo.__debugContext = this;
        }
    }
    /**
     * Sets the value of an option. Calls change listeners of that option, even if the value has
     * not been changed. The change listeners provided here are not called during this set
     * operation.
     *
     * @param name Name of the option.
     * @param value Value of the option.
     */
    setValue(name, value) {
        let opt = this.m_optionsMap.get(name);
        if (!opt) {
            opt = new DebugOption(value);
            this.m_optionsMap.set(name, opt);
        }
        else {
            opt.set(value, name);
        }
    }
    /**
     * Gets the option value.
     *
     * @param name Name of option.
     */
    getValue(name) {
        const opt = this.m_optionsMap.get(name);
        return opt ? opt.value : undefined;
    }
    /**
     * Determines if the option is registered.
     *
     * @param name Name of option.
     */
    hasOption(name) {
        return this.m_optionsMap.get(name) !== undefined;
    }
    /**
     * Adds a listener to a debug option.
     *
     * @param name Name of the option that requires a listener.
     * @param listener The listener function to add.
     */
    addEventListener(name, listener) {
        const opt = this.m_optionsMap.get(name);
        if (opt) {
            opt.addEventListener(DebugOption.SET_EVENT_TYPE, listener);
        }
        else {
            throw Error("Unknown option: " + name);
        }
    }
    /**
     * Checks for a listener in a debug option.
     *
     * @param name Name of the option to check for.
     * @param listener The listener function to check for.
     */
    hasEventListener(name, listener) {
        const opt = this.m_optionsMap.get(name);
        if (opt) {
            return opt.hasEventListener(DebugOption.SET_EVENT_TYPE, listener);
        }
        else {
            throw Error("Unknown option: " + name);
        }
    }
    /**
     * Removes a listener from a debug option.
     *
     * @param name Name of the option from which to remove a listener.
     * @param listener The listener function to remove.
     */
    removeEventListener(name, listener) {
        const opt = this.m_optionsMap.get(name);
        if (opt) {
            opt.removeEventListener(DebugOption.SET_EVENT_TYPE, listener);
        }
        else {
            throw Error("Unknown option: " + name);
        }
    }
    /**
     * Provides access to the options map. This method is useful for creating an automatic
     * browser GUI.
     */
    get options() {
        return this.m_optionsMap;
    }
    /**
     * Clears away all debug options. Currently, `THREE.EventDispatcher` does not provide an API
     * to remove all event listeners.
     */
    clear() {
        this.m_optionsMap.forEach(option => {
            option.set(undefined, "");
        });
    }
}
exports.DebugContext = DebugContext;
exports.debugContext = new DebugContext();


/***/ }),

/***/ "../harp-mapview/lib/DecodedTileHelpers.ts":
/*!*************************************************!*\
  !*** ../harp-mapview/lib/DecodedTileHelpers.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const THREE = __webpack_require__(/*! three */ "three");
const MapViewPoints_1 = __webpack_require__(/*! ./MapViewPoints */ "../harp-mapview/lib/MapViewPoints.ts");
const ThemeHelpers_1 = __webpack_require__(/*! ./ThemeHelpers */ "../harp-mapview/lib/ThemeHelpers.ts");
const logger = harp_utils_1.LoggerManager.instance.create("DecodedTileHelpers");
const DEFAULT_SKIP_PROPERTIES = [
    ...harp_datasource_protocol_1.TEXTURE_PROPERTY_KEYS,
    "mapProperties",
    "normalMapProperties",
    "displacementMapProperties",
    "roughnessMapProperties",
    "emissiveMapProperties",
    "alphaMapProperties",
    "metalnessMapProperties",
    "bumpMapProperties"
];
/**
 * Create a material, depending on the rendering technique provided in the options.
 *
 * @param options The material options the subsequent functions need.
 * @param materialUpdateCallback Optional callback when the material gets updated,
 *                               e.g. after texture loading.
 *
 * @returns new material instance that matches `technique.name`
 */
function createMaterial(options, textureReadyCallback) {
    const technique = options.technique;
    const Constructor = getMaterialConstructor(technique);
    const settings = {};
    if (Constructor === undefined) {
        return undefined;
    }
    if (Constructor.prototype instanceof THREE.RawShaderMaterial &&
        Constructor !== harp_materials_1.HighPrecisionLineMaterial) {
        settings.fog = options.fog;
    }
    const material = new Constructor(settings);
    if (technique.id !== undefined) {
        material.name = technique.id;
    }
    if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {
        material.flatShading = true;
        // We do not support mixing vertex colors (static) and material colors (may be dynamic)
        // mixture. Vertex colors are stored in VBO and are not modifiable - some solution for
        // this problem is proposed in the HARP-8289 and PR #1164.
        // TODO: Remove when problem with substitute (vertex & material) colors will be solved.
        if (technique.vertexColors === true) {
            delete technique.color;
        }
    }
    material.depthTest = harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) && technique.depthTest !== false;
    if (harp_datasource_protocol_1.isStandardTechnique(technique) ||
        harp_datasource_protocol_1.isTerrainTechnique(technique) ||
        harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {
        harp_datasource_protocol_1.TEXTURE_PROPERTY_KEYS.forEach((texturePropertyName) => {
            const textureProperty = technique[texturePropertyName];
            if (textureProperty === undefined) {
                return;
            }
            const onLoad = (texture) => {
                const properties = technique[texturePropertyName + "Properties"];
                if (properties !== undefined) {
                    if (properties.wrapS !== undefined) {
                        texture.wrapS = ThemeHelpers_1.toWrappingMode(properties.wrapS);
                    }
                    if (properties.wrapT !== undefined) {
                        texture.wrapT = ThemeHelpers_1.toWrappingMode(properties.wrapT);
                    }
                    if (properties.magFilter !== undefined) {
                        texture.magFilter = ThemeHelpers_1.toTextureFilter(properties.magFilter);
                    }
                    if (properties.minFilter !== undefined) {
                        texture.minFilter = ThemeHelpers_1.toTextureFilter(properties.minFilter);
                    }
                    if (properties.flipY !== undefined) {
                        texture.flipY = properties.flipY;
                    }
                    if (properties.repeatU !== undefined) {
                        texture.repeat.x = properties.repeatU;
                    }
                    if (properties.repeatV !== undefined) {
                        texture.repeat.y = properties.repeatV;
                    }
                }
                material[texturePropertyName] = texture;
                texture.needsUpdate = true;
                material.needsUpdate = true;
                if (textureReadyCallback) {
                    textureReadyCallback(texture);
                }
            };
            const onError = (error) => {
                logger.error("#createMaterial: Failed to load texture: ", error);
            };
            let textureUrl;
            if (typeof textureProperty === "string") {
                textureUrl = textureProperty;
            }
            else if (harp_datasource_protocol_1.isTextureBuffer(textureProperty)) {
                if (textureProperty.type === "image/raw") {
                    const properties = textureProperty.dataTextureProperties;
                    if (properties !== undefined) {
                        const textureDataType = properties.type
                            ? ThemeHelpers_1.toTextureDataType(properties.type)
                            : undefined;
                        const textureBuffer = getTextureBuffer(textureProperty.buffer, textureDataType);
                        const texture = new THREE.DataTexture(textureBuffer, properties.width, properties.height, properties.format ? ThemeHelpers_1.toPixelFormat(properties.format) : undefined, textureDataType);
                        onLoad(texture);
                    }
                    else {
                        onError("no data texture properties provided.");
                    }
                }
                else {
                    const textureBlob = new Blob([textureProperty.buffer], {
                        type: textureProperty.type
                    });
                    textureUrl = URL.createObjectURL(textureBlob);
                }
            }
            if (textureUrl) {
                new THREE.TextureLoader().load(textureUrl, onLoad, undefined, // onProgress
                onError);
            }
        });
    }
    if (harp_datasource_protocol_1.isShaderTechnique(technique)) {
        // Special case for ShaderTechnique.
        applyShaderTechniqueToMaterial(technique, material);
    }
    else {
        // Generic technique.
        applyTechniqueToMaterial(technique, material, options.env, options.skipExtraProps);
    }
    return material;
}
exports.createMaterial = createMaterial;
/**
 * Returns a [[THREE.BufferAttribute]] created from a provided [[BufferAttribute]] object.
 *
 * @param attribute BufferAttribute a WebGL compliant buffer
 */
function getBufferAttribute(attribute) {
    switch (attribute.type) {
        case "float":
            return new THREE.BufferAttribute(new Float32Array(attribute.buffer), attribute.itemCount);
        case "uint8":
            return new THREE.BufferAttribute(new Uint8Array(attribute.buffer), attribute.itemCount, attribute.normalized);
        case "uint16":
            return new THREE.BufferAttribute(new Uint16Array(attribute.buffer), attribute.itemCount, attribute.normalized);
        case "uint32":
            return new THREE.BufferAttribute(new Uint32Array(attribute.buffer), attribute.itemCount, attribute.normalized);
        case "int8":
            return new THREE.BufferAttribute(new Int8Array(attribute.buffer), attribute.itemCount, attribute.normalized);
        case "int16":
            return new THREE.BufferAttribute(new Int16Array(attribute.buffer), attribute.itemCount, attribute.normalized);
        case "int32":
            return new THREE.BufferAttribute(new Int32Array(attribute.buffer), attribute.itemCount, attribute.normalized);
        default:
            throw new Error(`unsupported buffer of type ${attribute.type}`);
    } // switch
}
exports.getBufferAttribute = getBufferAttribute;
/**
 * Gets the default `three.js` object constructor associated with the given technique.
 *
 * @param technique The technique.
 */
function getObjectConstructor(technique) {
    if (technique.name === undefined) {
        return undefined;
    }
    switch (technique.name) {
        case "extruded-line":
        case "standard":
        case "terrain":
        case "extruded-polygon":
        case "fill":
        case "dashed-line":
        case "solid-line":
            return THREE.Mesh;
        case "circles":
            return MapViewPoints_1.Circles;
        case "squares":
            return MapViewPoints_1.Squares;
        case "line":
            return THREE.LineSegments;
        case "segments":
            return THREE.LineSegments;
        case "shader": {
            if (!harp_datasource_protocol_1.isShaderTechnique(technique)) {
                throw new Error("Invalid technique");
            }
            switch (technique.primitive) {
                case "line":
                    return THREE.Line;
                case "segments":
                    return THREE.LineSegments;
                case "point":
                    return THREE.Points;
                case "mesh":
                    return THREE.Mesh;
                default:
                    return undefined;
            }
        }
        case "text":
        case "labeled-icon":
        case "line-marker":
        case "label-rejection-line":
            return undefined;
    }
}
exports.getObjectConstructor = getObjectConstructor;
/**
 * Non material properties of [[BaseTechnique]]
 */
exports.BASE_TECHNIQUE_NON_MATERIAL_PROPS = ["name", "id", "renderOrder", "transient"];
/**
 * Returns a [[MaterialConstructor]] basing on provided technique object.
 *
 * @param technique [[Technique]] object which the material will be based on.
 */
function getMaterialConstructor(technique) {
    if (technique.name === undefined) {
        return undefined;
    }
    switch (technique.name) {
        case "extruded-line":
            if (!harp_datasource_protocol_1.isExtrudedLineTechnique(technique)) {
                throw new Error("Invalid extruded-line technique");
            }
            return technique.shading === "standard"
                ? harp_materials_1.MapMeshStandardMaterial
                : harp_materials_1.MapMeshBasicMaterial;
        case "standard":
        case "terrain":
        case "extruded-polygon":
            return harp_materials_1.MapMeshStandardMaterial;
        case "dashed-line":
        case "solid-line":
            return harp_materials_1.SolidLineMaterial;
        case "fill":
            return harp_materials_1.MapMeshBasicMaterial;
        case "squares":
            return THREE.PointsMaterial;
        case "circles":
            return harp_materials_1.CirclePointsMaterial;
        case "line":
        case "segments":
            return THREE.LineBasicMaterial;
        case "shader":
            return THREE.ShaderMaterial;
        case "text":
        case "labeled-icon":
        case "line-marker":
        case "label-rejection-line":
            return undefined;
    }
}
exports.getMaterialConstructor = getMaterialConstructor;
/**
 * Allows to easy parse/encode technique's base color property value as number coded color.
 *
 * Function takes care about property parsing, interpolation and encoding if neccessary. If
 * you wish to get default value without interpolation simply ignore @param zoom when calling.
 *
 * @see ColorUtils
 * @param technique the technique where we search for base (transparency) color value
 * @param zoomLevel zoom level used for value interpolation.
 * @returns [[number]] encoded color value (in custom #TTRRGGBB) format or [[undefined]] if
 * base color property is not defined in the technique passed.
 */
function evaluateBaseColorProperty(technique, env) {
    const baseColorProp = getBaseColorProp(technique);
    if (baseColorProp !== undefined) {
        return evaluateColorProperty(baseColorProp, env);
    }
    return undefined;
}
exports.evaluateBaseColorProperty = evaluateBaseColorProperty;
/**
 * Apply [[ShaderTechnique]] parameters to material.
 *
 * @param technique the [[ShaderTechnique]] which requires special handling
 * @param material material to which technique will be applied
 */
function applyShaderTechniqueToMaterial(technique, material) {
    // The shader technique takes the argument from its `params' member.
    const params = technique.params;
    // Remove base color and transparency properties from the processed set.
    const baseColorPropName = getBaseColorPropName(technique);
    const hasBaseColor = baseColorPropName && baseColorPropName in technique.params;
    const props = Object.getOwnPropertyNames(params).filter(propertyName => {
        // Omit base color and related transparency attributes if its defined in technique
        if (baseColorPropName === propertyName ||
            (hasBaseColor && harp_datasource_protocol_1.TRANSPARENCY_PROPERTY_KEYS.indexOf(propertyName) !== -1)) {
            return false;
        }
        const prop = propertyName;
        if (prop === "name") {
            // skip reserved property names
            return false;
        }
        return true;
    });
    // Apply all technique properties omitting base color and transparency attributes.
    props.forEach(propertyName => {
        // TODO: Check if properties values should not be interpolated, possible bug in old code!
        // This behavior is kept in the new version too, level is set to undefined.
        applyTechniquePropertyToMaterial(material, propertyName, params[propertyName]);
    });
    if (hasBaseColor) {
        const propColor = baseColorPropName;
        // Finally apply base color and related properties to material (opacity, transparent)
        applyBaseColorToMaterial(material, material[propColor], technique, params[propColor]);
    }
}
/**
 * Apply generic technique parameters to material.
 *
 * Skips non-material [[Technique]] props:
 *  * [[BaseTechnique]] props,
 *  * `name` which is used as discriminator for technique types,
 *  * props starting with `_`
 *  * props found `skipExtraProps`
 *
 * `THREE.Color` properties are supported.
 *
 * @param technique technique from where params are copied
 * @param material target material
 * @param zoomLevel tile zoom level for zoom-level dependent props
 * @param skipExtraProps optional, skipped props.
 */
function applyTechniqueToMaterial(technique, material, env, skipExtraProps) {
    // Remove transparent color from the firstly processed properties set.
    const baseColorPropName = getBaseColorPropName(technique);
    const hasBaseColor = baseColorPropName && baseColorPropName in technique;
    const genericProps = Object.getOwnPropertyNames(technique).filter(propertyName => {
        if (propertyName.startsWith("_") ||
            exports.BASE_TECHNIQUE_NON_MATERIAL_PROPS.indexOf(propertyName) !== -1 ||
            DEFAULT_SKIP_PROPERTIES.indexOf(propertyName) !== -1 ||
            (skipExtraProps !== undefined && skipExtraProps.indexOf(propertyName) !== -1)) {
            return false;
        }
        // Omit base color and related transparency attributes if its defined in technique.
        if (baseColorPropName === propertyName ||
            (hasBaseColor && harp_datasource_protocol_1.TRANSPARENCY_PROPERTY_KEYS.indexOf(propertyName) !== -1)) {
            return false;
        }
        const prop = propertyName;
        const m = material;
        if (typeof m[prop] === "undefined") {
            return false;
        }
        return true;
    });
    // Apply all other properties (even colors), but not transparent (base) ones.
    genericProps.forEach(propertyName => {
        const value = technique[propertyName];
        if (value !== undefined) {
            applyTechniquePropertyToMaterial(material, propertyName, value, env);
        }
    });
    // Finally apply base (possibly transparent) color itself, using blend modes to
    // provide transparency if needed.
    if (hasBaseColor) {
        applyBaseColorToMaterial(material, material[baseColorPropName], technique, technique[baseColorPropName], env);
    }
}
/**
 * Apply single and generic technique property to corresponding material parameter.
 *
 * @note Special handling for material attributes of [[THREE.Color]] type is provided thus it
 * does not provide constructor that would take [[string]] or [[number]] values.
 *
 * @param material target material
 * @param propertyName material and technique parameter name (or index) that is to be transferred
 * @param techniqueAttrValue technique property value which will be applied to material attribute
 * @param zoomLevel optional tile zoom level.
 */
function applyTechniquePropertyToMaterial(material, propertyName, techniqueAttrValue, env) {
    const m = material;
    if (m[propertyName] instanceof THREE.Color) {
        applySecondaryColorToMaterial(material[propertyName], techniqueAttrValue, env);
    }
    else {
        m[propertyName] = evaluateProperty(techniqueAttrValue, env);
    }
}
/**
 * Apply technique color to material taking special care with transparent (RGBA) colors.
 *
 * @note This function is intended to be used with secondary, triary etc. technique colors,
 * not the base ones that may contain transparency information. Such colors should be processed
 * with [[applyTechniqueBaseColorToMaterial]] function.
 *
 * @param technique an technique the applied color comes from
 * @param material the material to which color is applied
 * @param prop technique property (color) name
 * @param value color value
 * @param zoomLevel optional tile zoom level for zoom-level dependent properties are evaluated.
 */
function applySecondaryColorToMaterial(materialColor, techniqueColor, env) {
    let value = evaluateColorProperty(techniqueColor, env);
    if (harp_datasource_protocol_1.ColorUtils.hasAlphaInHex(value)) {
        logger.warn("Used RGBA value for technique color without transparency support!");
        // Just for clarity remove transparency component, even if that would be ignored
        // by THREE.Color.setHex() function.
        value = harp_datasource_protocol_1.ColorUtils.removeAlphaFromHex(value);
    }
    materialColor.setHex(value);
}
exports.applySecondaryColorToMaterial = applySecondaryColorToMaterial;
/**
 * Apply technique base color (transparency support) to material with modifying material opacity.
 *
 * This method applies main (or base) technique color with transparency support to the corresponding
 * material color, with an effect on entire [[THREE.Material]] __opacity__ and __transparent__
 * attributes.
 *
 * @note Transparent colors should be processed as the very last technique attributes,
 * since their effect on material properties like [[THREE.Material.opacity]] and
 * [[THREE.Material.transparent]] could be overridden by corresponding technique params.
 *
 * @param technique an technique the applied color comes from
 * @param material the material to which color is applied
 * @param prop technique property (color) name
 * @param value color value in custom number format
 * @param zoomLevel optional, tile zoom level for zoom-level dependent properties are evaluated.
 */
function applyBaseColorToMaterial(material, materialColor, technique, techniqueColor, env) {
    const colorValue = evaluateColorProperty(techniqueColor, env);
    const { r, g, b, a } = harp_datasource_protocol_1.ColorUtils.getRgbaFromHex(colorValue);
    // Override material opacity and blending by mixing technique defined opacity
    // with main color transparency
    const tech = technique;
    let opacity = a;
    if (tech.opacity !== undefined) {
        opacity *= evaluateProperty(tech.opacity, env);
    }
    opacity = THREE.Math.clamp(opacity, 0, 1);
    material.opacity = opacity;
    materialColor.setRGB(r, g, b);
    const opaque = opacity >= 1.0;
    if (!opaque) {
        harp_materials_1.enableBlending(material);
    }
    else {
        harp_materials_1.disableBlending(material);
    }
}
exports.applyBaseColorToMaterial = applyBaseColorToMaterial;
/**
 * Calculates the value of the technique defined property.
 *
 * Function takes care about property interpolation (when @param zoom is set) as also parsing
 * string encoded numbers.
 *
 * @note Use with care, because function does not recognize property type.
 * @param value the value of color property defined in technique
 * @param zoomLevel zoom level used for interpolation.
 */
function evaluateProperty(value, env) {
    if (env !== undefined && (harp_datasource_protocol_1.isInterpolatedProperty(value) || harp_datasource_protocol_1.Expr.isExpr(value))) {
        value = harp_datasource_protocol_1.getPropertyValue(value, env);
    }
    return value;
}
/**
 * Calculates the numerical value of the technique defined color property.
 *
 * Function takes care about color interpolation (when @param zoom is set) as also parsing
 * string encoded colors.
 *
 * @note Use with care, because function does not recognize property type.
 * @param value the value of color property defined in technique
 * @param zoomLevel zoom level used for interpolation.
 */
function evaluateColorProperty(value, env) {
    value = evaluateProperty(value, env);
    if (typeof value === "number") {
        return value;
    }
    if (typeof value === "string") {
        const parsed = harp_datasource_protocol_1.parseStringEncodedColor(value);
        if (parsed !== undefined) {
            return parsed;
        }
    }
    throw new Error(`Unsupported color format: '${value}'`);
}
exports.evaluateColorProperty = evaluateColorProperty;
/**
 * Compile expressions in techniques as they were received from decoder.
 */
function compileTechniques(techniques) {
    techniques.forEach((technique) => {
        for (const propertyName in technique) {
            if (!technique.hasOwnProperty(propertyName)) {
                continue;
            }
            const value = technique[propertyName];
            if (harp_datasource_protocol_1.isJsonExpr(value) && propertyName !== "kind") {
                // "kind" is reserved.
                try {
                    technique[propertyName] = harp_datasource_protocol_1.Expr.fromJSON(value);
                }
                catch (error) {
                    logger.error("#compileTechniques: Failed to compile expression:", error);
                }
            }
        }
    });
}
exports.compileTechniques = compileTechniques;
/**
 * Allows to access base color property value for given technique.
 *
 * The color value may be encoded in [[number]], [[string]] or even as
 * [[InterpolateProperty]].
 *
 * @param technique The techniqe where we seach for base color property.
 * @returns The value of technique color used to apply transparency.
 */
function getBaseColorProp(technique) {
    const baseColorPropName = getBaseColorPropName(technique);
    if (baseColorPropName !== undefined) {
        if (!harp_datasource_protocol_1.isShaderTechnique(technique)) {
            const propColor = baseColorPropName;
            return technique[propColor];
        }
        else {
            const params = technique.params;
            const propColor = baseColorPropName;
            return params[propColor];
        }
    }
    return undefined;
}
function getBaseColorPropName(technique) {
    const techDescriptor = harp_datasource_protocol_1.techniqueDescriptors[technique.name];
    return techDescriptor !== undefined ? techDescriptor.attrTransparencyColor : undefined;
}
function getTextureBuffer(buffer, textureDataType) {
    if (textureDataType === undefined) {
        return new Uint8Array(buffer);
    }
    switch (textureDataType) {
        case THREE.UnsignedByteType:
            return new Uint8Array(buffer);
        case THREE.ByteType:
            return new Int8Array(buffer);
        case THREE.ShortType:
            return new Int16Array(buffer);
        case THREE.UnsignedShortType:
            return new Uint16Array(buffer);
        case THREE.IntType:
            return new Int32Array(buffer);
        case THREE.UnsignedIntType:
            return new Uint32Array(buffer);
        case THREE.FloatType:
            return new Float32Array(buffer);
        case THREE.HalfFloatType:
            return new Uint16Array(buffer);
    }
    throw new Error("Unsupported texture data type");
}


/***/ }),

/***/ "../harp-mapview/lib/DepthPrePass.ts":
/*!*******************************************!*\
  !*** ../harp-mapview/lib/DepthPrePass.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const ColorUtils_1 = __webpack_require__(/*! @here/harp-datasource-protocol/lib/ColorUtils */ "../harp-datasource-protocol/lib/ColorUtils.ts");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const DecodedTileHelpers_1 = __webpack_require__(/*! ./DecodedTileHelpers */ "../harp-mapview/lib/DecodedTileHelpers.ts");
/**
 * Bitmask used for the depth pre-pass to prevent multiple fragments in the same screen position
 * from rendering color.
 */
exports.DEPTH_PRE_PASS_STENCIL_MASK = 0x01;
/**
 * Render order offset for the depth pre-pass to ensure that it's rendered first.
 */
const DEPTH_PRE_PASS_RENDER_ORDER_OFFSET = 1e-6;
/**
 * Check if technique requires (and not disables) use of depth prepass.
 *
 * Depth prepass is enabled if correct opacity is specified (in range `(0,1)`) _and_ not explicitly
 * disabled by `enableDepthPrePass` option.
 *
 * @param technique [[BaseStandardTechnique]] instance to be checked
 */
function isRenderDepthPrePassEnabled(technique) {
    // Depth pass explicitly disabled
    if (technique.enableDepthPrePass === false) {
        return false;
    }
    let transparent = technique.opacity !== undefined && technique.opacity > 0.0 && technique.opacity < 1.0;
    // If not opaque then check if transparency may be modified via alpha in base color.
    // Otherwise we don't need to even test base color because opacity mixed with any base alpha,
    // will always produce some transparency effect.
    if (!transparent) {
        // We do not support switching depth pass during alpha interpolation, ignore zoom level
        // when calculating base color value.
        const color = DecodedTileHelpers_1.evaluateBaseColorProperty(technique);
        if (color !== undefined) {
            const alpha = ColorUtils_1.ColorUtils.getAlphaFromHex(color);
            transparent = alpha > 0.0 && alpha < 1.0;
        }
    }
    return transparent;
}
exports.isRenderDepthPrePassEnabled = isRenderDepthPrePassEnabled;
/**
 * Creates material for depth prepass.
 *
 * Creates material that writes only to the z-buffer. Updates the original material instance, to
 * support depth prepass.
 *
 * @param baseMaterial The base material of mesh that is updated to work with depth prepass
 *     and then used. This parameter is a template for depth prepass material that is returned.
 * @returns depth prepass material, which is a clone of `baseMaterial` with the adapted settings.
 */
function createDepthPrePassMaterial(baseMaterial) {
    baseMaterial.depthWrite = false;
    baseMaterial.depthFunc = THREE.EqualDepth;
    baseMaterial.colorWrite = true;
    harp_materials_1.enforceBlending(baseMaterial);
    const depthPassMaterial = baseMaterial.clone();
    depthPassMaterial.depthWrite = true;
    depthPassMaterial.depthTest = true;
    depthPassMaterial.depthFunc = THREE.LessDepth;
    depthPassMaterial.colorWrite = false;
    depthPassMaterial.opacity = 1.0;
    depthPassMaterial.blending = THREE.NoBlending;
    return depthPassMaterial;
}
exports.createDepthPrePassMaterial = createDepthPrePassMaterial;
// tslint:disable:max-line-length
/**
 * Clones a given mesh to render it in the depth prepass with another material. Both the original
 * and depth prepass meshes, when rendered in the correct order, create the proper depth prepass
 * effect. The original mesh material is slightly modified by [[createDepthPrePassMaterial]] to
 * support the depth prepass. This method is usable only if the material of this mesh has an
 * opacity value in the range `(0,1)`.
 *
 * The DepthPrePass object is created wis a slightly smaller `renderOrder` as the original mesh
 * to ensure that it's rendered first.
 *
 * @param mesh original mesh
 * @returns `Mesh` depth pre pass
 */
// tslint:enable:max-line-length
function createDepthPrePassMesh(mesh) {
    const originalGeometry = mesh.geometry;
    if (!(originalGeometry instanceof THREE.BufferGeometry)) {
        throw new Error("#createDepthPassMesh only BufferGeometry is supported");
    }
    const positionAttribute = originalGeometry.getAttribute("position");
    if (!positionAttribute) {
        throw new Error("#createDepthPassMesh position attribute not found");
    }
    const depthPassGeometry = new THREE.BufferGeometry();
    depthPassGeometry.setAttribute("position", positionAttribute);
    const uvAttribute = originalGeometry.getAttribute("uv");
    if (uvAttribute) {
        depthPassGeometry.setAttribute("uv", uvAttribute);
    }
    const normalAttribute = originalGeometry.getAttribute("normal");
    if (normalAttribute) {
        depthPassGeometry.setAttribute("normal", normalAttribute);
    }
    const extrusionAxisAttribute = originalGeometry.getAttribute("extrusionAxis");
    if (extrusionAxisAttribute) {
        depthPassGeometry.setAttribute("extrusionAxis", extrusionAxisAttribute);
    }
    if (originalGeometry.index) {
        depthPassGeometry.setIndex(originalGeometry.index);
    }
    for (const group of originalGeometry.groups) {
        const { start, count, materialIndex } = group;
        depthPassGeometry.addGroup(start, count, materialIndex);
    }
    const depthPassMaterial = mesh.material instanceof Array
        ? mesh.material.map(createDepthPrePassMaterial)
        : createDepthPrePassMaterial(mesh.material);
    const depthPassMesh = new THREE.Mesh(depthPassGeometry, depthPassMaterial);
    depthPassMesh.renderOrder = mesh.renderOrder - DEPTH_PRE_PASS_RENDER_ORDER_OFFSET;
    return depthPassMesh;
}
exports.createDepthPrePassMesh = createDepthPrePassMesh;
/**
 * Sets up all the needed stencil logic needed for the depth pre-pass.
 *
 * This logic is in place to avoid z-fighting artifacts that can appear in geometries that have
 * coplanar triangles inside the same mesh.
 *
 * @param depthMesh Mesh created by `createDepthPrePassMesh`.
 * @param colorMesh Original mesh.
 */
function setDepthPrePassStencil(depthMesh, colorMesh) {
    // Set up depth mesh stencil logic.
    // Set the depth pre-pass stencil bit for all processed fragments. We use
    // `THREE.AlwaysStencilFunc` and not `THREE.NotEqualStencilFunc` to force all fragments to pass
    // the stencil test and write the correct depth value.
    const depthMaterial = depthMesh.material;
    depthMaterial.stencilWrite = true;
    depthMaterial.stencilFail = THREE.KeepStencilOp;
    depthMaterial.stencilZFail = THREE.KeepStencilOp;
    depthMaterial.stencilZPass = THREE.ReplaceStencilOp;
    depthMaterial.stencilFunc = THREE.AlwaysStencilFunc;
    depthMaterial.stencilRef = 0xff;
    depthMaterial.stencilFuncMask = exports.DEPTH_PRE_PASS_STENCIL_MASK;
    // Set up color mesh stencil logic.
    // Only write color for pixels with the depth pre-pass stencil bit set. Also, once a pixel is
    // rendered, set the stencil bit to 0 to prevent subsequent pixels in the same clip position
    // from rendering color again.
    const colorMaterial = colorMesh.material;
    colorMaterial.stencilWrite = true;
    colorMaterial.stencilFail = THREE.KeepStencilOp;
    colorMaterial.stencilZFail = THREE.KeepStencilOp;
    colorMaterial.stencilZPass = THREE.ZeroStencilOp;
    colorMaterial.stencilFunc = THREE.EqualStencilFunc;
    colorMaterial.stencilRef = 0xff;
    colorMaterial.stencilFuncMask = exports.DEPTH_PRE_PASS_STENCIL_MASK;
}
exports.setDepthPrePassStencil = setDepthPrePassStencil;


/***/ }),

/***/ "../harp-mapview/lib/ElevationRangeSource.ts":
/*!***************************************************!*\
  !*** ../harp-mapview/lib/ElevationRangeSource.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Status of the elevation range calculation.
 */
var CalculationStatus;
(function (CalculationStatus) {
    // Calculated approximately. A more precise result may be available later.
    CalculationStatus[CalculationStatus["PendingApproximate"] = 0] = "PendingApproximate";
    // Calculation completed. The result is final, won't improve upon retrying.
    CalculationStatus[CalculationStatus["FinalPrecise"] = 1] = "FinalPrecise";
})(CalculationStatus = exports.CalculationStatus || (exports.CalculationStatus = {}));


/***/ }),

/***/ "../harp-mapview/lib/FrustumIntersection.ts":
/*!**************************************************!*\
  !*** ../harp-mapview/lib/FrustumIntersection.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const THREE = __webpack_require__(/*! three */ "three");
const ElevationRangeSource_1 = __webpack_require__(/*! ./ElevationRangeSource */ "../harp-mapview/lib/ElevationRangeSource.ts");
const MapTileCuller_1 = __webpack_require__(/*! ./MapTileCuller */ "../harp-mapview/lib/MapTileCuller.ts");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-mapview/lib/Utils.ts");
const tmpVectors3 = [new THREE.Vector3(), new THREE.Vector3()];
const tmpVector4 = new THREE.Vector4();
/**
 * Represents a unique TileKey and the area it takes up on screen.
 *
 * Note, in certain tiling projections, it is possible to have an offset, which represents a tile
 * which has fully wrapped around, hence this defaults to 0 to simplify usage for projections which
 * don't require it.
 */
class TileKeyEntry {
    constructor(tileKey, area, offset = 0, minElevation = 0, maxElevation = 0, distance = 0) {
        this.tileKey = tileKey;
        this.area = area;
        this.offset = offset;
        this.minElevation = minElevation;
        this.maxElevation = maxElevation;
        this.distance = distance;
    }
}
exports.TileKeyEntry = TileKeyEntry;
function getGeoBox(tilingScheme, childTileKey, offset) {
    const geoBox = tilingScheme.getGeoBox(childTileKey);
    const longitudeOffset = 360.0 * offset;
    geoBox.northEast.longitude += longitudeOffset;
    geoBox.southWest.longitude += longitudeOffset;
    return geoBox;
}
/**
 * Computes the tiles intersected by the frustum defined by the current camera setup.
 */
class FrustumIntersection {
    constructor(m_camera, mapView, m_extendedFrustumCulling, m_tileWrappingEnabled, m_enableMixedLod) {
        this.m_camera = m_camera;
        this.mapView = mapView;
        this.m_extendedFrustumCulling = m_extendedFrustumCulling;
        this.m_tileWrappingEnabled = m_tileWrappingEnabled;
        this.m_enableMixedLod = m_enableMixedLod;
        this.m_frustum = new THREE.Frustum();
        // used to project global coordinates into camera local coordinates
        this.m_viewProjectionMatrix = new THREE.Matrix4();
        this.m_rootTileKeys = [];
        this.m_tileKeyEntries = new Map();
        this.m_mapTileCuller = new MapTileCuller_1.MapTileCuller(m_camera);
    }
    /**
     * Return camera used for generating frustum.
     */
    get camera() {
        return this.m_camera;
    }
    /**
     * Return projection used to convert geo coordinates to world coordinates.
     */
    get projection() {
        return this.mapView.projection;
    }
    /**
     * Updates the frustum to match the current camera setup.
     */
    updateFrustum(projectionMatrixOverride) {
        this.m_viewProjectionMatrix.multiplyMatrices(projectionMatrixOverride !== undefined
            ? projectionMatrixOverride
            : this.m_camera.projectionMatrix, this.m_camera.matrixWorldInverse);
        this.m_frustum.setFromMatrix(this.m_viewProjectionMatrix);
        if (this.m_extendedFrustumCulling) {
            this.m_mapTileCuller.setup();
        }
        this.computeRequiredInitialRootTileKeys(this.m_camera.position);
    }
    /**
     * Computes the tiles intersected by the updated frustum, see [[updateFrustum]].
     *
     * @param tilingScheme The tiling scheme used to generate the tiles.
     * @param elevationRangeSource Source of elevation range data if any.
     * @param zoomLevels A list of zoom levels to render.
     * @param dataSources A list of data sources to render.
     * @returns The computation result, see [[FrustumIntersection.Result]].
     */
    compute(tilingScheme, elevationRangeSource, zoomLevels, dataSources) {
        this.m_tileKeyEntries.clear();
        let calculationFinal = true;
        // Compute target tile area in clip space size.
        // A tile should take up roughly 256x256 pixels on screen in accordance to
        // the zoom level chosen by [MapViewUtils.calculateZoomLevelFromDistance].
        harp_utils_1.assert(this.mapView.viewportHeight !== 0);
        const targetTileArea = Math.pow(256 / this.mapView.viewportHeight, 2);
        const obbIntersections = this.mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical;
        const tileBounds = obbIntersections ? new harp_geoutils_1.OrientedBox3() : new THREE.Box3();
        const uniqueZoomLevels = new Set(zoomLevels);
        // create tile key map per zoom level
        for (const zoomLevel of uniqueZoomLevels) {
            this.m_tileKeyEntries.set(zoomLevel, new Map());
        }
        for (const item of this.m_rootTileKeys) {
            const tileKeyEntry = new TileKeyEntry(item.tileKey, Infinity, item.offset, item.minElevation, item.maxElevation);
            for (const zoomLevel of uniqueZoomLevels) {
                const tileKeyEntries = this.m_tileKeyEntries.get(zoomLevel);
                tileKeyEntries.set(Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(item.tileKey, item.offset), tileKeyEntry);
            }
        }
        const useElevationRangeSource = elevationRangeSource !== undefined &&
            elevationRangeSource.getTilingScheme() === tilingScheme;
        const workList = [...this.m_rootTileKeys.values()];
        while (workList.length > 0) {
            const tileEntry = workList.pop();
            if (tileEntry === undefined) {
                break;
            }
            // Stop subdivision if hightest visible level is reached
            const tileKey = tileEntry.tileKey;
            const subdivide = dataSources.some((ds, i) => ds.shouldSubdivide(zoomLevels[i], tileKey));
            if (!subdivide) {
                continue;
            }
            // Stop subdivision if area of tile is too small(mixed LOD only)
            if (this.m_enableMixedLod && tileEntry.area < targetTileArea) {
                continue;
            }
            const parentTileKey = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(tileKey, tileEntry.offset);
            // delete parent tile key from applicable zoom levels
            for (const zoomLevel of uniqueZoomLevels) {
                if (tileKey.level >= zoomLevel) {
                    continue;
                }
                const tileKeyEntries = this.m_tileKeyEntries.get(zoomLevel);
                tileKeyEntries.delete(parentTileKey);
            }
            for (const childTileKey of tilingScheme.getSubTileKeys(tileKey)) {
                const offset = tileEntry.offset;
                const tileKeyAndOffset = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(childTileKey, offset);
                const geoBox = getGeoBox(tilingScheme, childTileKey, offset);
                // For tiles without elevation range source, default 0 (getGeoBox always
                // returns box with altitude min/max equal to zero) will be propagated as
                // min and max elevation, these tiles most probably contains features that
                // lays directly on the ground surface.
                if (useElevationRangeSource) {
                    const range = elevationRangeSource.getElevationRange(childTileKey);
                    geoBox.southWest.altitude = range.minElevation;
                    geoBox.northEast.altitude = range.maxElevation;
                    calculationFinal =
                        calculationFinal &&
                            range.calculationStatus === ElevationRangeSource_1.CalculationStatus.FinalPrecise;
                }
                this.mapView.projection.projectBox(geoBox, tileBounds);
                const { area, distance } = this.computeTileAreaAndDistance(tileBounds);
                if (area > 0) {
                    const subTileEntry = new TileKeyEntry(childTileKey, area, offset, geoBox.southWest.altitude, // minElevation
                    geoBox.northEast.altitude, // maxElevation
                    distance);
                    // insert sub tile entry into tile entries map per zoom level
                    for (const zoomLevel of uniqueZoomLevels) {
                        if (subTileEntry.tileKey.level > zoomLevel) {
                            continue;
                        }
                        const tileKeyEntries = this.m_tileKeyEntries.get(zoomLevel);
                        tileKeyEntries.set(tileKeyAndOffset, subTileEntry);
                    }
                    workList.push(subTileEntry);
                }
            }
        }
        return { tileKeyEntries: this.m_tileKeyEntries, calculationFinal };
    }
    /**
     * Estimate screen space area of tile and distance to center of tile
     * @param tileBounds The bounding volume of a tile
     * @return Area estimate and distance to tile center in clip space
     */
    computeTileAreaAndDistance(tileBounds) {
        if (tileBounds instanceof THREE.Box3) {
            if ((this.m_extendedFrustumCulling &&
                !this.m_mapTileCuller.frustumIntersectsTileBox(tileBounds)) ||
                !this.m_frustum.intersectsBox(tileBounds)) {
                return {
                    area: 0,
                    distance: Infinity
                };
            }
        }
        else if (!tileBounds.intersects(this.m_frustum)) {
            return {
                area: 0,
                distance: Infinity
            };
        }
        // Project tile bounds center
        const center = tileBounds.getCenter(tmpVectors3[0]);
        const projectedPoint = tmpVector4
            .set(center.x, center.y, center.z, 1.0)
            .applyMatrix4(this.m_viewProjectionMatrix);
        // Estimate objects screen space size with diagonal of bounds
        // Dividing by w projects object size to screen space
        const size = tileBounds.getSize(tmpVectors3[1]);
        const objectSize = (0.5 * size.length()) / projectedPoint.w;
        return {
            area: objectSize * objectSize,
            distance: projectedPoint.z / projectedPoint.w
        };
    }
    /**
     * Create a list of root nodes to test against the frustum. The root nodes each start at level 0
     * and have an offset (see [[Tile]]) based on:
     * - the current position [[worldCenter]].
     * - the height of the camera above the world.
     * - the field of view of the camera (the maximum value between the horizontal / vertical
     *   values)
     * - the tilt of the camera (because we see more tiles when tilted).
     *
     * @param worldCenter The center of the camera in world space.
     */
    computeRequiredInitialRootTileKeys(worldCenter) {
        this.m_rootTileKeys = [];
        const rootTileKey = harp_geoutils_1.TileKey.fromRowColumnLevel(0, 0, 0);
        const tileWrappingEnabled = this.mapView.projection.type === harp_geoutils_1.ProjectionType.Planar;
        if (!tileWrappingEnabled || !this.m_tileWrappingEnabled) {
            this.m_rootTileKeys.push(new TileKeyEntry(rootTileKey, Infinity, 0, 0));
            return;
        }
        const worldGeoPoint = this.mapView.projection.unprojectPoint(worldCenter);
        const startOffset = Math.round(worldGeoPoint.longitude / 360.0);
        // This algorithm computes the number of offsets we need to test. The following diagram may
        // help explain the algorithm below.
        //
        //   |🎥
        //   |.\ .
        //   | . \  .
        // z |  .  \   .c2
        //   |  c1.  \b    .
        //   |     .   \      .
        //___|a___d1.____\e______.d2______f
        //
        // Where:
        // - 🎥 is the camera
        // - z is the height of the camera above the ground.
        // - a is a right angle.
        // - b is the look at vector of the camera.
        // - c1 and c2 are the frustum planes of the camera.
        // - c1 to c2 is the fov.
        // - d1 and d2 are the intersection points of the frustum with the world plane.
        // - e is the tilt/pitch of the camera.
        // - f is the world
        //
        // The goal is to find the distance from e->d2. This is a longitude value, and we convert it
        // to some offset range. Note e->d2 >= e->d1 (because we can't have a negative tilt).
        // To find e->d2, we use the right triangle 🎥, a, d2 and subtract the distance a->d2 with
        // a->e.
        // a->d2 is found using the angle between a and d2 from the 🎥, this is simply e (because of
        // similar triangles, angle between a, 🎥 and e equals the tilt) + half of the fov (because
        // we need the angle between e, 🎥 and d2) and using trigonometry, result is therefore:
        // (tan(a->d2) * z).
        // a->e needs just the tilt and trigonometry to compute, result is: (tan(a->e) * z).
        const camera = this.m_camera;
        const cameraPitch = Utils_1.MapViewUtils.extractAttitude(this.mapView, camera).pitch;
        // Ensure that the aspect is >= 1.
        const aspect = camera.aspect > 1 ? camera.aspect : 1 / camera.aspect;
        // Angle between a->d2, note, the fov is vertical, hence we translate to horizontal.
        const totalAngleRad = THREE.Math.degToRad((camera.fov * aspect) / 2) + cameraPitch;
        // Length a->d2
        const worldLengthHorizontalFull = Math.tan(totalAngleRad) * camera.position.z;
        // Length a->e
        const worldLengthHorizontalSmallerHalf = Math.tan(cameraPitch) * camera.position.z;
        // Length e -> d2
        const worldLengthHorizontal = worldLengthHorizontalFull - worldLengthHorizontalSmallerHalf;
        const worldLeftPoint = new THREE.Vector3(worldCenter.x - worldLengthHorizontal, worldCenter.y, worldCenter.z);
        const worldLeftGeoPoint = this.mapView.projection.unprojectPoint(worldLeftPoint);
        // We multiply by SQRT2 because we need to account for a rotated view (in which case there
        // are more tiles that can be seen).
        const offsetRange = THREE.Math.clamp(Math.ceil(Math.abs((worldGeoPoint.longitude - worldLeftGeoPoint.longitude) / 360) * Math.SQRT2), 0, 
        // We can store currently up to 16 unique keys(2^4, where 4 is the default bit-shift
        // value which is used currently in the [[VisibleTileSet]] methods) hence we can have a
        // maximum range of 7 (because 2*7+1 = 15).
        7);
        for (let offset = -offsetRange + startOffset; offset <= offsetRange + startOffset; offset++) {
            this.m_rootTileKeys.push(new TileKeyEntry(rootTileKey, Infinity, offset, 0, 0));
        }
    }
}
exports.FrustumIntersection = FrustumIntersection;


/***/ }),

/***/ "../harp-mapview/lib/MapTileCuller.ts":
/*!********************************************!*\
  !*** ../harp-mapview/lib/MapTileCuller.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Second step tile culling: Do additional check for intersection of box and frustum by checking if
 * the frustum is outside any plane of the tiles `bbox` (oriented, not AABB). It's in the inverse of
 * the standard frustum test, which excludes many cases where the large terrain tiles straddle the
 * planes of the frustum.
 *
 * @see http://www.iquilezles.org/www/articles/frustumcorrect/frustumcorrect.htm
 */
class MapTileCuller {
    /**
     * Constructs a `MapTileCuller`.
     *
     * @param m_camera A `THREE.Camera`.
     */
    constructor(m_camera) {
        this.m_camera = m_camera;
        this.m_globalFrustumMin = new THREE.Vector3();
        this.m_globalFrustumMax = new THREE.Vector3();
        this.m_frustumCorners = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3()
        ];
    }
    /**
     * Sets up culling and computes frustum corners. You mus call this function before the culling
     * starts.
     */
    setup() {
        const frustumCorners = this.getFrustumCorners();
        const matrix = this.m_camera.matrixWorld;
        this.m_globalFrustumMin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this.m_globalFrustumMax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        for (const frustumCorner of frustumCorners) {
            frustumCorner.applyMatrix4(matrix);
            this.m_globalFrustumMin.x = Math.min(this.m_globalFrustumMin.x, frustumCorner.x);
            this.m_globalFrustumMin.y = Math.min(this.m_globalFrustumMin.y, frustumCorner.y);
            this.m_globalFrustumMin.z = Math.min(this.m_globalFrustumMin.z, frustumCorner.z);
            this.m_globalFrustumMax.x = Math.max(this.m_globalFrustumMax.x, frustumCorner.x);
            this.m_globalFrustumMax.y = Math.max(this.m_globalFrustumMax.y, frustumCorner.y);
            this.m_globalFrustumMax.z = Math.max(this.m_globalFrustumMax.z, frustumCorner.z);
        }
    }
    /**
     * Checks if the tile's bounding box intersects with the current view's frustum.
     *
     * @param tileBounds The bounding box for the tile.
     */
    frustumIntersectsTileBox(tileBounds) {
        const globalFrustumMin = this.m_globalFrustumMin;
        const globalFrustumMax = this.m_globalFrustumMax;
        if (globalFrustumMax.x < tileBounds.min.x ||
            globalFrustumMax.y < tileBounds.min.y ||
            globalFrustumMax.z < tileBounds.min.z ||
            globalFrustumMin.x > tileBounds.max.x ||
            globalFrustumMin.y > tileBounds.max.y ||
            globalFrustumMin.z > tileBounds.max.z) {
            return false;
        }
        return true;
    }
    /**
     * Returns the eight corners of the frustum.
     */
    getFrustumCorners() {
        const frustumCorners = this.m_frustumCorners;
        const invProjMatrix = this.m_camera.projectionMatrixInverse;
        let cornerIndex = 0;
        function addPoint(x, y, z) {
            frustumCorners[cornerIndex++].set(x, y, z).applyMatrix4(invProjMatrix);
        }
        const w = 1;
        const h = 1;
        const n = -1;
        const f = 1;
        // near
        addPoint(-w, -h, n);
        addPoint(w, -h, n);
        addPoint(-w, h, n);
        addPoint(w, h, n);
        // far
        addPoint(-w, -h, f);
        addPoint(w, -h, f);
        addPoint(-w, h, f);
        addPoint(w, h, f);
        return frustumCorners;
    }
}
exports.MapTileCuller = MapTileCuller;


/***/ }),

/***/ "../harp-mapview/lib/MapView.ts":
/*!**************************************!*\
  !*** ../harp-mapview/lib/MapView.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const THREE = __webpack_require__(/*! three */ "three");
const AnimatedExtrusionHandler_1 = __webpack_require__(/*! ./AnimatedExtrusionHandler */ "../harp-mapview/lib/AnimatedExtrusionHandler.ts");
const BackgroundDataSource_1 = __webpack_require__(/*! ./BackgroundDataSource */ "../harp-mapview/lib/BackgroundDataSource.ts");
const CameraMovementDetector_1 = __webpack_require__(/*! ./CameraMovementDetector */ "../harp-mapview/lib/CameraMovementDetector.ts");
const ClipPlanesEvaluator_1 = __webpack_require__(/*! ./ClipPlanesEvaluator */ "../harp-mapview/lib/ClipPlanesEvaluator.ts");
const composing_1 = __webpack_require__(/*! ./composing */ "../harp-mapview/lib/composing/index.ts");
const ConcurrentDecoderFacade_1 = __webpack_require__(/*! ./ConcurrentDecoderFacade */ "../harp-mapview/lib/ConcurrentDecoderFacade.ts");
const CopyrightInfo_1 = __webpack_require__(/*! ./copyrights/CopyrightInfo */ "../harp-mapview/lib/copyrights/CopyrightInfo.ts");
const FrustumIntersection_1 = __webpack_require__(/*! ./FrustumIntersection */ "../harp-mapview/lib/FrustumIntersection.ts");
const overlayOnElevation_1 = __webpack_require__(/*! ./geometry/overlayOnElevation */ "../harp-mapview/lib/geometry/overlayOnElevation.ts");
const PhasedTileGeometryManager_1 = __webpack_require__(/*! ./geometry/PhasedTileGeometryManager */ "../harp-mapview/lib/geometry/PhasedTileGeometryManager.ts");
const TileGeometryManager_1 = __webpack_require__(/*! ./geometry/TileGeometryManager */ "../harp-mapview/lib/geometry/TileGeometryManager.ts");
const MapViewImageCache_1 = __webpack_require__(/*! ./image/MapViewImageCache */ "../harp-mapview/lib/image/MapViewImageCache.ts");
const MapViewFog_1 = __webpack_require__(/*! ./MapViewFog */ "../harp-mapview/lib/MapViewFog.ts");
const PickHandler_1 = __webpack_require__(/*! ./PickHandler */ "../harp-mapview/lib/PickHandler.ts");
const PickingRaycaster_1 = __webpack_require__(/*! ./PickingRaycaster */ "../harp-mapview/lib/PickingRaycaster.ts");
const PoiManager_1 = __webpack_require__(/*! ./poi/PoiManager */ "../harp-mapview/lib/poi/PoiManager.ts");
const PoiRendererFactory_1 = __webpack_require__(/*! ./poi/PoiRendererFactory */ "../harp-mapview/lib/poi/PoiRendererFactory.ts");
const PoiTableManager_1 = __webpack_require__(/*! ./poi/PoiTableManager */ "../harp-mapview/lib/poi/PoiTableManager.ts");
const PolarTileDataSource_1 = __webpack_require__(/*! ./PolarTileDataSource */ "../harp-mapview/lib/PolarTileDataSource.ts");
const ScreenCollisions_1 = __webpack_require__(/*! ./ScreenCollisions */ "../harp-mapview/lib/ScreenCollisions.ts");
const ScreenProjector_1 = __webpack_require__(/*! ./ScreenProjector */ "../harp-mapview/lib/ScreenProjector.ts");
const SkyBackground_1 = __webpack_require__(/*! ./SkyBackground */ "../harp-mapview/lib/SkyBackground.ts");
const Statistics_1 = __webpack_require__(/*! ./Statistics */ "../harp-mapview/lib/Statistics.ts");
const FontCatalogLoader_1 = __webpack_require__(/*! ./text/FontCatalogLoader */ "../harp-mapview/lib/text/FontCatalogLoader.ts");
const MapViewState_1 = __webpack_require__(/*! ./text/MapViewState */ "../harp-mapview/lib/text/MapViewState.ts");
const TextCanvasFactory_1 = __webpack_require__(/*! ./text/TextCanvasFactory */ "../harp-mapview/lib/text/TextCanvasFactory.ts");
const TextElementsRenderer_1 = __webpack_require__(/*! ./text/TextElementsRenderer */ "../harp-mapview/lib/text/TextElementsRenderer.ts");
const ThemeHelpers_1 = __webpack_require__(/*! ./ThemeHelpers */ "../harp-mapview/lib/ThemeHelpers.ts");
const ThemeLoader_1 = __webpack_require__(/*! ./ThemeLoader */ "../harp-mapview/lib/ThemeLoader.ts");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-mapview/lib/Utils.ts");
const VisibleTileSet_1 = __webpack_require__(/*! ./VisibleTileSet */ "../harp-mapview/lib/VisibleTileSet.ts");
// Cache value, because access to process.env.NODE_ENV is SLOW!
const isProduction = "development" === "production";
if (isProduction) {
    // In production: silence logging below error.
    harp_utils_1.LoggerManager.instance.setLogLevelForAll(harp_utils_1.LogLevel.Error);
}
else {
    // In dev: silence logging below log (silences "debug" and "trace" levels).
    harp_utils_1.LoggerManager.instance.setLogLevelForAll(harp_utils_1.LogLevel.Log);
}
var MapViewEventNames;
(function (MapViewEventNames) {
    /** Called before this `MapView` starts to render a new frame. */
    MapViewEventNames["Update"] = "update";
    /** Called when the WebGL canvas is resized. */
    MapViewEventNames["Resize"] = "resize";
    /** Called when the frame is about to be rendered. */
    MapViewEventNames["Render"] = "render";
    /** Called after a frame has been rendered. */
    MapViewEventNames["AfterRender"] = "didrender";
    /** Called after the first frame has been rendered. */
    MapViewEventNames["FirstFrame"] = "first-render";
    /** Called when the first view has all the necessary tiles loaded and rendered. */
    MapViewEventNames["FrameComplete"] = "frame-complete";
    /** Called when the theme has been loaded with the internal [[ThemeLoader]]. */
    MapViewEventNames["ThemeLoaded"] = "theme-loaded";
    /** Called when the animation mode has started. */
    MapViewEventNames["AnimationStarted"] = "animation-started";
    /** Called when the animation mode has stopped. */
    MapViewEventNames["AnimationFinished"] = "animation-finished";
    /** Called when a camera interaction has been detected. */
    MapViewEventNames["MovementStarted"] = "movement-started";
    /** Called when a camera interaction has been stopped. */
    MapViewEventNames["MovementFinished"] = "movement-finished";
    /** Called when a data source has been connected or failed to connect. */
    MapViewEventNames["DataSourceConnect"] = "datasource-connect";
    /** Emitted when copyright info of rendered map has been changed. */
    MapViewEventNames["CopyrightChanged"] = "copyright-changed";
    /** Called when the WebGL context is lost. */
    MapViewEventNames["ContextLost"] = "webglcontext-lost";
    /** Called when the WebGL context is restored. */
    MapViewEventNames["ContextRestored"] = "webglcontext-restored";
    /** Called when camera position has been changed. */
    MapViewEventNames["CameraPositionChanged"] = "camera-changed";
})(MapViewEventNames = exports.MapViewEventNames || (exports.MapViewEventNames = {}));
const logger = harp_utils_1.LoggerManager.instance.create("MapView");
const DEFAULT_CLEAR_COLOR = 0xefe9e1;
const DEFAULT_FOV_CALCULATION = { type: "dynamic", fov: 40 };
const DEFAULT_CAM_NEAR_PLANE = 0.1;
const DEFAULT_CAM_FAR_PLANE = 4000000;
const MAX_FIELD_OF_VIEW = 140;
const MIN_FIELD_OF_VIEW = 10;
exports.MAX_TILT_ANGLE = 89;
// All objects in fallback tiles are reduced by this amount.
exports.FALLBACK_RENDER_ORDER_OFFSET = 20000;
const DEFAULT_MIN_ZOOM_LEVEL = 1;
/**
 * Default maximum zoom level.
 */
const DEFAULT_MAX_ZOOM_LEVEL = 20;
/**
 * Default minimum camera height.
 */
const DEFAULT_MIN_CAMERA_HEIGHT = 20;
/**
 * Amount of framerate values to pick average from
 */
const FRAME_RATE_RING_SIZE = 12;
/**
 * Default starting value for FPS computation.
 */
const FALLBACK_FRAME_RATE = 30;
/**
 * Zoom level to request terrain tiles for getting the height of the camera above terrain.
 */
const TERRAIN_ZOOM_LEVEL = 4;
/**
 * Style set used by [[PolarTileDataSource]] by default.
 */
const DEFAULT_POLAR_STYLE_SET_NAME = "polar";
// Event type: cast needed to workaround wrong THREE.js typings.
const UPDATE = { type: MapViewEventNames.Update };
const RENDER_EVENT = { type: MapViewEventNames.Render };
const DID_RENDER_EVENT = { type: MapViewEventNames.AfterRender };
const FIRST_FRAME_EVENT = { type: MapViewEventNames.FirstFrame };
const FRAME_COMPLETE_EVENT = { type: MapViewEventNames.FrameComplete };
const THEME_LOADED_EVENT = { type: MapViewEventNames.ThemeLoaded };
const ANIMATION_STARTED_EVENT = { type: MapViewEventNames.AnimationStarted };
const ANIMATION_FINISHED_EVENT = { type: MapViewEventNames.AnimationFinished };
const MOVEMENT_STARTED_EVENT = { type: MapViewEventNames.MovementStarted };
const MOVEMENT_FINISHED_EVENT = { type: MapViewEventNames.MovementFinished };
const CONTEXT_LOST_EVENT = { type: MapViewEventNames.ContextLost };
const CONTEXT_RESTORED_EVENT = { type: MapViewEventNames.ContextRestored };
const COPYRIGHT_CHANGED_EVENT = { type: MapViewEventNames.CopyrightChanged };
const cache = {
    vector2: [new THREE.Vector2()],
    vector3: [new THREE.Vector3()]
};
/**
 * Hint for the WebGL implementation on which power mode to prefer.
 *
 * @see https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14.12
 */
var MapViewPowerPreference;
(function (MapViewPowerPreference) {
    /** Default value. */
    MapViewPowerPreference["Default"] = "default";
    /** Lower power mode, used to conserve energy. */
    MapViewPowerPreference["LowPower"] = "low-power";
    /** Maximum performance. */
    MapViewPowerPreference["HighPerformance"] = "high-performance";
})(MapViewPowerPreference = exports.MapViewPowerPreference || (exports.MapViewPowerPreference = {}));
/**
 * Default settings used by [[MapView]] collected in one place.
 */
exports.MapViewDefaults = {
    projection: harp_geoutils_1.mercatorProjection,
    maxVisibleDataSourceTiles: 100,
    extendedFrustumCulling: true,
    tileCacheSize: 200,
    resourceComputationType: VisibleTileSet_1.ResourceComputationType.EstimationInMb,
    quadTreeSearchDistanceUp: 3,
    quadTreeSearchDistanceDown: 2,
    pixelRatio: typeof window !== "undefined" && window.devicePixelRatio !== undefined
        ? window.devicePixelRatio
        : 1.0,
    geoCenter: new harp_geoutils_1.GeoCoordinates(25, 0, 30000000),
    target: new harp_geoutils_1.GeoCoordinates(25, 0),
    zoomLevel: 5,
    tilt: 0,
    heading: 0,
    theme: {}
};
/**
 * The core class of the library to call in order to create a map visualization. It needs to be
 * linked to datasources.
 */
class MapView extends THREE.EventDispatcher {
    /**
     * Constructs a new `MapView` with the given options or canvas element.
     *
     * @param options The `MapView` options or the HTML canvas element used to display the map.
     */
    constructor(options) {
        super();
        this.dumpNext = false;
        this.m_renderLabels = true;
        this.m_screenCollisions = new ScreenCollisions_1.ScreenCollisions();
        this.m_visibleTileSetLock = false;
        this.m_tileWrappingEnabled = true;
        this.m_zoomLevel = DEFAULT_MIN_ZOOM_LEVEL;
        this.m_minZoomLevel = DEFAULT_MIN_ZOOM_LEVEL;
        this.m_maxZoomLevel = DEFAULT_MAX_ZOOM_LEVEL;
        this.m_minCameraHeight = DEFAULT_MIN_CAMERA_HEIGHT;
        this.m_screenCamera = new THREE.OrthographicCamera(-1, 1, 1, -1);
        /**
         * Relative to eye camera.
         *
         * This camera is internal camera used to improve precision
         * when rendering geometries.
         */
        this.m_rteCamera = new THREE.PerspectiveCamera();
        this.m_targetGeoPos = exports.MapViewDefaults.target.clone();
        // Focus point world coords may be calculated after setting projection, use dummy value here.
        this.m_targetWorldPos = new THREE.Vector3();
        this.m_viewRanges = {
            near: DEFAULT_CAM_NEAR_PLANE,
            far: DEFAULT_CAM_FAR_PLANE,
            minimum: DEFAULT_CAM_NEAR_PLANE,
            maximum: DEFAULT_CAM_FAR_PLANE
        };
        this.m_scene = new THREE.Scene();
        this.m_fog = new MapViewFog_1.MapViewFog(this.m_scene);
        this.m_mapTilesRoot = new THREE.Object3D();
        this.m_mapAnchors = new THREE.Object3D();
        this.m_animationCount = 0;
        this.m_drawing = false;
        this.m_updatePending = false;
        this.m_frameNumber = 0;
        this.m_maxFps = 0;
        this.m_detectedFps = FALLBACK_FRAME_RATE;
        this.m_forceCameraAspect = undefined;
        //
        // sources
        //
        this.m_tileDataSources = [];
        this.m_connectedDataSources = new Set();
        this.m_failedDataSources = new Set();
        this.m_enablePolarDataSource = true;
        this.m_plane = new THREE.Plane(new THREE.Vector3(0, 0, 1));
        this.m_sphere = new THREE.Sphere(undefined, harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS);
        this.m_theme = {};
        this.m_themeIsLoading = false;
        this.m_firstFrameRendered = false;
        this.m_firstFrameComplete = false;
        this.m_initialTextPlacementDone = false;
        this.m_frameTimeIndex = 0;
        this.m_frameTimeRing = [];
        this.m_imageCache = new MapViewImageCache_1.MapViewImageCache(this);
        this.m_poiManager = new PoiManager_1.PoiManager(this);
        this.m_poiTableManager = new PoiTableManager_1.PoiTableManager(this);
        this.m_lastTileIds = "";
        this.m_copyrightInfo = [];
        this.m_env = new harp_datasource_protocol_1.MapEnv({});
        /**
         * Default handler for webglcontextlost event.
         *
         * Note: The renderer `this.m_renderer` may not be initialized when this function is called.
         */
        this.onWebGLContextLost = (event) => {
            this.dispatchEvent(CONTEXT_LOST_EVENT);
            logger.warn("WebGL context lost", event);
        };
        /**
         * Default handler for webglcontextrestored event.
         *
         * Note: The renderer `this.m_renderer` may not be initialized when this function is called.
         */
        this.onWebGLContextRestored = (event) => {
            this.dispatchEvent(CONTEXT_RESTORED_EVENT);
            if (this.m_renderer !== undefined) {
                if (this.m_theme !== undefined && this.m_theme.clearColor !== undefined) {
                    this.m_renderer.setClearColor(new THREE.Color(this.m_theme.clearColor));
                }
                else {
                    this.m_renderer.setClearColor(DEFAULT_CLEAR_COLOR);
                }
                this.update();
            }
            logger.warn("WebGL context restored", event);
        };
        // make a copy to avoid unwanted changes to the original options.
        this.m_options = Object.assign({}, options);
        this.m_uriResolver = this.m_options.uriResolver;
        if (this.m_options.minZoomLevel !== undefined) {
            this.m_minZoomLevel = this.m_options.minZoomLevel;
        }
        if (this.m_options.maxZoomLevel !== undefined) {
            this.m_maxZoomLevel = this.m_options.maxZoomLevel;
        }
        if (this.m_options.minCameraHeight !== undefined) {
            this.m_minCameraHeight = this.m_options.minCameraHeight;
        }
        if (this.m_options.decoderUrl !== undefined) {
            ConcurrentDecoderFacade_1.ConcurrentDecoderFacade.defaultScriptUrl = this.m_uriResolver
                ? this.m_uriResolver.resolveUri(this.m_options.decoderUrl)
                : this.m_options.decoderUrl;
        }
        if (this.m_options.decoderCount !== undefined) {
            ConcurrentDecoderFacade_1.ConcurrentDecoderFacade.defaultWorkerCount = this.m_options.decoderCount;
        }
        this.m_visibleTileSetOptions = Object.assign(Object.assign({}, exports.MapViewDefaults), { clipPlanesEvaluator: options.clipPlanesEvaluator !== undefined
                ? options.clipPlanesEvaluator
                : ClipPlanesEvaluator_1.createDefaultClipPlanesEvaluator() });
        if (options.projection !== undefined) {
            this.m_visibleTileSetOptions.projection = options.projection;
        }
        if (options.extendedFrustumCulling !== undefined) {
            this.m_visibleTileSetOptions.extendedFrustumCulling = options.extendedFrustumCulling;
        }
        if (options.maxVisibleDataSourceTiles !== undefined) {
            this.m_visibleTileSetOptions.maxVisibleDataSourceTiles =
                options.maxVisibleDataSourceTiles;
        }
        if (options.tileCacheSize !== undefined) {
            this.m_visibleTileSetOptions.tileCacheSize = options.tileCacheSize;
        }
        if (options.resourceComputationType !== undefined) {
            this.m_visibleTileSetOptions.resourceComputationType = options.resourceComputationType;
        }
        if (options.quadTreeSearchDistanceUp !== undefined) {
            this.m_visibleTileSetOptions.quadTreeSearchDistanceUp =
                options.quadTreeSearchDistanceUp;
        }
        if (options.quadTreeSearchDistanceDown !== undefined) {
            this.m_visibleTileSetOptions.quadTreeSearchDistanceDown =
                options.quadTreeSearchDistanceDown;
        }
        if (options.enablePolarDataSource !== undefined) {
            this.m_enablePolarDataSource = options.enablePolarDataSource;
        }
        this.m_pixelRatio = options.pixelRatio;
        if (options.maxFps !== undefined) {
            this.m_maxFps = Math.max(0, options.maxFps);
        }
        this.m_options.enableStatistics = this.m_options.enableStatistics === true;
        this.m_languages = this.m_options.languages;
        if (!isProduction &&
            this.m_options.collisionDebugCanvas !== undefined &&
            this.m_options.collisionDebugCanvas !== null) {
            this.m_collisionDebugCanvas = this.m_options.collisionDebugCanvas;
            this.m_screenCollisions = new ScreenCollisions_1.ScreenCollisionsDebug(this.m_collisionDebugCanvas);
        }
        this.handleRequestAnimationFrame = this.renderFunc.bind(this);
        this.handlePostponedAnimationFrame = this.postponedAnimationFrame.bind(this);
        this.m_pickHandler = new PickHandler_1.PickHandler(this, this.m_rteCamera, this.m_options.enableRoadPicking === true, this.m_options.enablePickTechnique === true);
        if (this.m_options.tileWrappingEnabled !== undefined) {
            this.m_tileWrappingEnabled = this.m_options.tileWrappingEnabled;
        }
        // Initialization of the stats
        this.setupStats(this.m_options.enableStatistics);
        this.canvas.addEventListener("webglcontextlost", this.onWebGLContextLost);
        this.canvas.addEventListener("webglcontextrestored", this.onWebGLContextRestored);
        // Initialization of the renderer
        this.m_renderer = new THREE.WebGLRenderer({
            canvas: this.canvas,
            antialias: this.nativeWebglAntialiasEnabled,
            alpha: this.m_options.alpha,
            preserveDrawingBuffer: this.m_options.preserveDrawingBuffer === true,
            powerPreference: this.m_options.powerPreference === undefined
                ? MapViewPowerPreference.Default
                : this.m_options.powerPreference
        });
        this.m_renderer.autoClear = false;
        // This is detailed at https://threejs.org/docs/#api/renderers/WebGLRenderer.info
        // When using several WebGLRenderer#render calls per frame, it is the only way to get
        // correct rendering data from ThreeJS.
        this.m_renderer.info.autoReset = false;
        this.setupRenderer();
        this.m_options.fovCalculation =
            this.m_options.fovCalculation === undefined
                ? DEFAULT_FOV_CALCULATION
                : this.m_options.fovCalculation;
        this.m_options.fovCalculation.fov = THREE.Math.clamp(this.m_options.fovCalculation.fov, MIN_FIELD_OF_VIEW, MAX_FIELD_OF_VIEW);
        // Initialization of mCamera and mVisibleTiles
        const { width, height } = this.getCanvasClientSize();
        const aspect = width / height;
        this.m_camera = new THREE.PerspectiveCamera(this.m_options.fovCalculation.fov, aspect, DEFAULT_CAM_NEAR_PLANE, DEFAULT_CAM_FAR_PLANE);
        this.m_camera.up.set(0, 0, 1);
        this.projection.projectPoint(this.m_targetGeoPos, this.m_targetWorldPos);
        this.m_focalLength = 0;
        this.m_scene.add(this.m_camera); // ensure the camera is added to the scene.
        this.m_screenProjector = new ScreenProjector_1.ScreenProjector(this.m_camera);
        // setup camera with initial position
        this.setupCamera(options);
        this.m_targetDistance = this.m_camera.position.distanceTo(this.m_targetWorldPos);
        this.m_raycaster = new PickingRaycaster_1.PickingRaycaster(width, height);
        this.m_movementDetector = new CameraMovementDetector_1.CameraMovementDetector(this.m_options.movementThrottleTimeout, () => this.movementStarted(), () => this.movementFinished());
        const mapPassAntialiasSettings = this.m_options.customAntialiasSettings;
        this.mapRenderingManager = new composing_1.MapRenderingManager(width, height, this.m_options.dynamicPixelRatio, mapPassAntialiasSettings);
        this.m_tileGeometryManager =
            this.m_options.enablePhasedLoading === true
                ? new PhasedTileGeometryManager_1.PhasedTileGeometryManager(this)
                : new TileGeometryManager_1.SimpleTileGeometryManager(this);
        if (options.enableMixedLod !== undefined) {
            this.m_enableMixedLod = options.enableMixedLod;
        }
        this.m_visibleTiles = this.createVisibleTileSet();
        this.m_animatedExtrusionHandler = new AnimatedExtrusionHandler_1.AnimatedExtrusionHandler(this);
        this.m_backgroundDataSource = new BackgroundDataSource_1.BackgroundDataSource();
        this.addDataSource(this.m_backgroundDataSource);
        if (this.m_enablePolarDataSource) {
            const styleSetName = options.polarStyleSetName !== undefined
                ? options.polarStyleSetName
                : DEFAULT_POLAR_STYLE_SET_NAME;
            this.m_polarDataSource = new PolarTileDataSource_1.PolarTileDataSource({
                styleSetName,
                geometryLevelOffset: options.polarGeometryLevelOffset
            });
            this.updatePolarDataSource();
        }
        if (options.backgroundTilingScheme !== undefined) {
            this.m_backgroundDataSource.setTilingScheme(options.backgroundTilingScheme);
        }
        this.initTheme();
        this.m_textElementsRenderer = this.createTextRenderer();
        this.drawFrame();
    }
    /**
     * @returns Whether label rendering is enabled.
     */
    get renderLabels() {
        return this.m_renderLabels;
    }
    /**
     * Enables or disables rendering of labels.
     * @param value `true` to enable labels `false` to disable them.
     */
    set renderLabels(value) {
        this.m_renderLabels = value;
    }
    /**
     * @hidden
     * The [[TextElementsRenderer]] select the visible [[TextElement]]s and renders them.
     */
    get textElementsRenderer() {
        return this.m_textElementsRenderer;
    }
    /**
     * @hidden
     * The [[CameraMovementDetector]] detects camera movements. Made available for performance
     * measurements.
     */
    get cameraMovementDetector() {
        return this.m_movementDetector;
    }
    /**
     * The [[AnimatedExtrusionHandler]] controls animated extrusion effect
     * of the extruded objects in the [[Tile]]
     */
    get animatedExtrusionHandler() {
        return this.m_animatedExtrusionHandler;
    }
    /**
     * The [[TileGeometryManager]] manages geometry during loading and handles hiding geometry of
     * specified [[GeometryKind]]s.
     */
    get tileGeometryManager() {
        return this.m_tileGeometryManager;
    }
    get enableMixedLod() {
        return this.m_enableMixedLod;
    }
    set enableMixedLod(enableMixedLod) {
        // Skip unnecessary update
        if (this.m_enableMixedLod === enableMixedLod) {
            return;
        }
        this.m_enableMixedLod = enableMixedLod;
        this.m_visibleTiles = this.createVisibleTileSet();
        this.resetTextRenderer();
        this.update();
    }
    /**
     * Disposes this `MapView`.
     *
     * This function cleans the resources that are managed manually including those that exist in
     * shared caches.
     *
     * Note: This function does not try to clean objects that can be disposed off easily by
     * TypeScript's garbage collecting mechanism. Consequently, if you need to perform a full
     * cleanup, you must ensure that all references to this `MapView` are removed.
     */
    dispose() {
        if (this.m_movementFinishedUpdateTimerId) {
            clearTimeout(this.m_movementFinishedUpdateTimerId);
            this.m_movementFinishedUpdateTimerId = undefined;
        }
        if (this.m_animationFrameHandle !== undefined) {
            cancelAnimationFrame(this.m_animationFrameHandle);
            this.m_animationFrameHandle = undefined;
        }
        this.canvas.removeEventListener("webglcontextlost", this.onWebGLContextLost);
        this.canvas.removeEventListener("webglcontextrestored", this.onWebGLContextRestored);
        for (const dataSource of this.m_tileDataSources) {
            dataSource.dispose();
        }
        this.m_visibleTiles.clearTileCache();
        this.m_textElementsRenderer.clearRenderStates();
        this.m_renderer.dispose();
        this.m_imageCache.clear();
        this.m_movementDetector.dispose();
    }
    /**
     * The way the cache usage is computed, either based on size in MB (mega bytes) or in number of
     * tiles.
     */
    get resourceComputationType() {
        return this.m_visibleTiles.resourceComputationType;
    }
    set resourceComputationType(value) {
        this.m_visibleTiles.resourceComputationType = value;
    }
    /**
     * Returns the cache size.
     */
    getCacheSize() {
        return this.m_visibleTiles.getDataSourceCacheSize();
    }
    /**
     * Sets the cache size in number of tiles.
     *
     * @param size The cache size in tiles.
     * @param numVisibleTiles The number of tiles visible, which is size/2 by default.
     */
    setCacheSize(size, numVisibleTiles) {
        this.m_visibleTiles.setDataSourceCacheSize(size);
        numVisibleTiles = numVisibleTiles !== undefined ? numVisibleTiles : size / 2;
        this.m_visibleTiles.setNumberOfVisibleTiles(Math.floor(numVisibleTiles));
        this.updateImages();
        this.updateLighting();
        this.m_textElementsRenderer.invalidateCache();
        this.updateSkyBackground();
        this.update();
    }
    /**
     * Specfies whether extended frustum culling is enabled or disabled.
     */
    get extendedFrustumCulling() {
        return this.m_options.extendedFrustumCulling !== undefined
            ? this.m_visibleTileSetOptions.extendedFrustumCulling
            : true;
    }
    /**
     * Enable of disable extended frustum culling.
     */
    set extendedFrustumCulling(value) {
        this.m_visibleTileSetOptions.extendedFrustumCulling = value;
    }
    /**
     * Returns the status of frustum culling after each update.
     */
    get lockVisibleTileSet() {
        return this.m_visibleTileSetLock;
    }
    /**
     * Enable of disable frustum culling after each update.
     */
    set lockVisibleTileSet(value) {
        this.m_visibleTileSetLock = value;
    }
    /**
     * Gets the optional camera used to render the scene.
     */
    get pointOfView() {
        return this.m_pointOfView;
    }
    /**
     * Sets the optional camera used to render the scene.
     */
    set pointOfView(pointOfView) {
        this.m_pointOfView = pointOfView;
        this.update();
    }
    /**
     * Loads a post effects definition file.
     *
     * @param postEffectsFile File URL describing the post effects.
     */
    loadPostEffects(postEffectsFile) {
        fetch(postEffectsFile)
            .then(response => response.json())
            .then((postEffects) => {
            this.m_postEffects = postEffects;
            this.setPostEffects();
        });
    }
    /**
     * The abstraction of the [[MapRenderingManager]] API for post effects.
     */
    get postEffects() {
        return this.m_postEffects;
    }
    set postEffects(postEffects) {
        this.m_postEffects = postEffects;
        this.setPostEffects();
    }
    /**
     * Gets the current `Theme` used by this `MapView` to style map elements.
     */
    get theme() {
        return this.m_theme;
    }
    /**
     * Changes the `Theme` used by this `MapView` to style map elements.
     */
    set theme(theme) {
        if (!ThemeLoader_1.ThemeLoader.isThemeLoaded(theme)) {
            this.m_themeIsLoading = true;
            // If theme is not yet loaded, let's set theme asynchronously
            ThemeLoader_1.ThemeLoader.load(theme, { uriResolver: this.m_uriResolver })
                .then(loadedTheme => {
                this.m_themeIsLoading = false;
                this.theme = loadedTheme;
            })
                .catch(error => {
                this.m_themeIsLoading = false;
                logger.error(`failed to set theme: ${error}`, error);
            });
            return;
        }
        // Fog and sky.
        this.m_theme.fog = theme.fog;
        this.m_theme.sky = theme.sky;
        this.updateSkyBackground();
        this.m_fog.reset(this.m_theme);
        this.m_theme.lights = theme.lights;
        this.updateLighting();
        // Clear color.
        this.m_theme.clearColor = theme.clearColor;
        this.renderer.setClearColor(new THREE.Color(theme.clearColor));
        // Images.
        this.m_theme.images = theme.images;
        this.m_theme.imageTextures = theme.imageTextures;
        this.updateImages();
        // POI tables.
        this.m_theme.poiTables = theme.poiTables;
        this.loadPoiTables();
        // Text.
        this.m_theme.textStyles = theme.textStyles;
        this.m_theme.defaultTextStyle = theme.defaultTextStyle;
        this.m_theme.fontCatalogs = theme.fontCatalogs;
        this.resetTextRenderer();
        if (Array.isArray(theme.priorities)) {
            this.m_theme.priorities = theme.priorities;
        }
        if (Array.isArray(theme.labelPriorities)) {
            this.m_theme.labelPriorities = theme.labelPriorities;
        }
        if (this.m_theme.styles === undefined) {
            this.m_theme.styles = {};
        }
        if (this.m_backgroundDataSource) {
            this.m_backgroundDataSource.setTheme(this.m_theme);
        }
        this.m_theme.styles = theme.styles || {};
        this.m_theme.definitions = theme.definitions;
        for (const dataSource of this.m_tileDataSources) {
            dataSource.setTheme(this.m_theme);
        }
        THEME_LOADED_EVENT.time = Date.now();
        this.dispatchEvent(THEME_LOADED_EVENT);
        this.update();
    }
    /**
     * [[UriResolver]] used to resolve application/deployment specific `URI`s into actual `URLs`
     * that can be loaded with `fetch`.
     */
    get uriResolver() {
        return this.m_uriResolver;
    }
    /**
     * Gets the value of the forced custom camera aspect.
     * Every time a frame is rendered, `MapView` resets the camera aspect.
     *
     * You can disable this behavior by setting the value to `undefined`.
     */
    get forceCameraAspect() {
        return this.m_forceCameraAspect;
    }
    /**
     * Sets the custom forced camera aspect ratio to use while rendering.
     */
    set forceCameraAspect(aspect) {
        this.m_forceCameraAspect = aspect;
    }
    /**
     * Maximum FPS. If defined (and > 0) it is the maximum FPS that is used.
     */
    set maxFps(fps) {
        this.m_maxFps = Math.max(0, fps);
    }
    get maxFps() {
        return Math.max(0, this.m_maxFps);
    }
    /**
     * Lists the ISO 639-1 language codes for DataSources to use.
     */
    get languages() {
        return this.m_languages;
    }
    /**
     * Sets the list of ISO 639-1 language codes for DataSources to use.
     */
    set languages(languages) {
        this.m_languages = languages;
        this.m_tileDataSources.forEach((dataSource) => {
            dataSource.setLanguages(this.m_languages);
        });
        this.update();
    }
    get copyrightInfo() {
        return this.m_copyrightInfo;
    }
    /**
     * @hidden
     * Disable all fading animations (for debugging and performance measurement). Defaults to
     * `false`.
     */
    set disableFading(disable) {
        this.m_textElementsRenderer.disableFading = disable;
    }
    get disableFading() {
        return this.m_textElementsRenderer.disableFading;
    }
    /**
     * @hidden
     * Return current frame number.
     */
    get frameNumber() {
        return this.m_frameNumber;
    }
    /**
     * @hidden
     * Reset the frame number to 0.
     */
    resetFrameNumber() {
        this.m_frameNumber = 0;
        this.m_previousFrameTimeStamp = undefined;
    }
    addEventListener(type, listener) {
        super.addEventListener(type, listener);
    }
    removeEventListener(type, listener) {
        super.removeEventListener(type, listener);
    }
    /**
     * The HTML canvas element used by this `MapView`.
     */
    get canvas() {
        return this.m_options.canvas;
    }
    /**
     * The HTML canvas element used by this `MapView`.
     */
    get collisionDebugCanvas() {
        return this.m_collisionDebugCanvas;
    }
    /**
     * The THREE.js scene used by this `MapView`.
     */
    get scene() {
        return this.m_scene;
    }
    /**
     * The THREE.js camera used by this `MapView` to render the main scene.
     */
    get camera() {
        return this.m_camera;
    }
    /**
     * The THREE.js `WebGLRenderer` used by this scene.
     */
    get renderer() {
        return this.m_renderer;
    }
    /**
     * The color used to clear the view.
     */
    get clearColor() {
        const rendererClearColor = this.m_renderer.getClearColor();
        return rendererClearColor !== undefined ? rendererClearColor.getHex() : 0;
    }
    /**
     * The color used to clear the view.
     */
    set clearColor(color) {
        this.m_renderer.setClearColor(color);
    }
    /**
     * The projection used to project geo coordinates to world coordinates.
     */
    get projection() {
        return this.m_visibleTileSetOptions.projection;
    }
    /**
     * Changes the projection at run time.
     *
     * @param projection The [[Projection]] instance to use.
     */
    set projection(projection) {
        // The geo center must be reset when changing the projection, because the
        // camera's position is based on the projected geo center.
        let target = Utils_1.MapViewUtils.getWorldTargetFromCamera(this.camera, this.projection);
        if (target === null) {
            logger.warn("MapView does not support a view pointing in the void, using last focus point.");
            target = this.worldTarget;
        }
        const targetCoordinates = this.projection.unprojectPoint(target);
        const targetDistance = this.camera.position.distanceTo(target);
        const attitude = Utils_1.MapViewUtils.extractAttitude(this, this.camera);
        const pitchDeg = THREE.Math.radToDeg(attitude.pitch);
        const headingDeg = -THREE.Math.radToDeg(attitude.yaw);
        this.m_visibleTileSetOptions.projection = projection;
        this.updatePolarDataSource();
        this.clearTileCache();
        this.textElementsRenderer.clearRenderStates();
        this.m_visibleTiles = this.createVisibleTileSet();
        this.lookAt(targetCoordinates, targetDistance, pitchDeg, headingDeg);
    }
    /**
     * Get camera clipping planes evaluator used.
     */
    get clipPlanesEvaluator() {
        return this.m_visibleTileSetOptions.clipPlanesEvaluator;
    }
    /**
     * Changes the clip planes evaluator at run time.
     */
    set clipPlanesEvaluator(clipPlanesEvaluator) {
        this.m_visibleTileSetOptions.clipPlanesEvaluator = clipPlanesEvaluator;
    }
    /**
     * The distance (in pixels) between the screen and the camera.
     */
    get focalLength() {
        return this.m_focalLength;
    }
    /** @internal
     * Get geo coordinates of camera focus (target) point.
     *
     * @see worldTarget
     *
     * @returns geo coordinates of the camera focus point.
     */
    get target() {
        return this.m_targetGeoPos;
    }
    /** @internal
     * Get world coordinates of camera focus point.
     *
     * @note The focus point coordinates are updated with each camera update so you don't need
     * to re-calculate it, although if the camera started looking to the void, the last focus
     * point is stored.
     *
     * @returns world coordinates of the camera focus point.
     */
    get worldTarget() {
        return this.m_targetWorldPos;
    }
    /** @internal
     * Get distance from camera to the point of focus in world units.
     *
     * @note If camera does not point to any ground anymore the last focus point distance is
     * then returned.
     *
     * @returns Last known focus point distance.
     */
    get targetDistance() {
        return this.m_targetDistance;
    }
    /**
     * Get object describing frustum planes distances and min/max visibility range for actual
     * camera setup.
     * Near and far plane distance are self explanatory while minimum and maximum visibility range
     * describes the extreme near/far planes distances that may be achieved with current camera
     * settings, meaning at current zoom level (ground distance) and any possible orientation.
     * @note Visibility is directly related to camera [[ClipPlaneEvaluator]] used and determines
     * the maximum possible distance of camera far clipping plane regardless of tilt, but may change
     * whenever zoom level changes. Distance is measured in world units which may be approximately
     * equal to meters, but this depends on the distortion related to projection type used.
     */
    get viewRanges() {
        return this.m_viewRanges;
    }
    /**
     * The position in geo coordinates of the center of the scene.
     */
    get geoCenter() {
        return this.projection.unprojectPoint(this.m_camera.position).normalized();
    }
    /**
     * The position in geo coordinates of the center of the scene.
     * Longitude values outside of -180 and +180 are acceptable.
     */
    set geoCenter(geoCenter) {
        if (geoCenter.altitude !== undefined) {
            this.projection.projectPoint(geoCenter, this.m_camera.position);
        }
        else {
            // Preserve the current altitude
            const altitude = this.geoCenter.altitude;
            this.projection.projectPoint(new harp_geoutils_1.GeoCoordinates(geoCenter.latitude, geoCenter.longitude, altitude), this.m_camera.position);
        }
        this.update();
    }
    /**
     * The node in this MapView's scene containing the user [[MapAnchor]]s.
     * All (first level) children of this node will be positioned in world space according to the
     * [[MapAnchor.geoPosition]].
     * Deeper level children can be used to position custom objects relative to the anchor node.
     */
    get mapAnchors() {
        return this.m_mapAnchors;
    }
    /**
     * The position in world coordinates of the center of the scene.
     */
    get worldCenter() {
        return this.m_camera.position;
    }
    /**
     * The root object of the scene. Contains all `rootObjects` of the [[Tile]]s.
     */
    get worldRootObject() {
        return this.m_mapTilesRoot;
    }
    /**
     * Get the [[PickHandler]] for this `mapView`.
     */
    get pickHandler() {
        return this.m_pickHandler;
    }
    /**
     * Get the [[ImageCache]] that belongs to this `MapView`.
     */
    get imageCache() {
        return this.m_imageCache;
    }
    /**
     * @hidden
     * Get the [[PoiManager]] that belongs to this `MapView`.
     */
    get poiManager() {
        return this.m_poiManager;
    }
    /**
     * @hidden
     * Get the array of [[PoiTableManager]] that belongs to this `MapView`.
     */
    get poiTableManager() {
        return this.m_poiTableManager;
    }
    /**
     * The minimum camera height in meters.
     */
    get minCameraHeight() {
        return this.m_minCameraHeight;
    }
    /**
     * The minimum zoom level.
     */
    get minZoomLevel() {
        return this.m_minZoomLevel;
    }
    /**
     * The minimum zoom level.
     */
    set minZoomLevel(zoomLevel) {
        this.m_minZoomLevel = zoomLevel;
        this.update();
    }
    /**
     * The maximum zoom level. Default is 14.
     */
    get maxZoomLevel() {
        return this.m_maxZoomLevel;
    }
    /**
     * The maximum zoom level.
     */
    set maxZoomLevel(zoomLevel) {
        this.m_maxZoomLevel = zoomLevel;
        this.update();
    }
    /**
     * Returns the zoom level for the given camera setup.
     */
    get zoomLevel() {
        return this.m_zoomLevel;
    }
    set zoomLevel(zoomLevel) {
        this.m_zoomLevel = THREE.Math.clamp(zoomLevel, this.m_minZoomLevel, this.m_maxZoomLevel);
        Utils_1.MapViewUtils.zoomOnTargetPosition(this, 0, 0, this.m_zoomLevel);
        this.update();
    }
    /**
     * Environment used to evaluate dynamic scene expressions.
     */
    get env() {
        return this.m_env;
    }
    /**
     * Returns the storage level for the given camera setup.
     * Actual storage level of the rendered data also depends on [[DataSource.storageLevelOffset]].
     */
    get storageLevel() {
        return THREE.Math.clamp(Math.floor(this.m_zoomLevel), this.m_minZoomLevel, this.m_maxZoomLevel);
    }
    /**
     * Returns height of the viewport in pixels.
     */
    get viewportHeight() {
        return this.canvas.height;
    }
    /**
     * Returns `true` if the native WebGL antialiasing is enabled.
     *
     * @default `true` for `pixelRatio` < `2.0`, `false` otherwise.
     */
    get nativeWebglAntialiasEnabled() {
        return this.m_options.enableNativeWebglAntialias === undefined
            ? this.pixelRatio < 2.0
            : this.m_options.enableNativeWebglAntialias;
    }
    /**
     * Returns 'true' if the phased loading is currently enabled.
     *
     * @default `false`.
     */
    get phasedLoadingEnabled() {
        return this.m_options.enablePhasedLoading === true;
    }
    /**
     * Returns [[DataSource]]s displayed by this `MapView`.
     */
    get dataSources() {
        return this.m_tileDataSources;
    }
    /**
     * Set's the way in which the fov is calculated on the map view. Note, for
     * this to take visual effect, the map should be rendered after calling this
     * function.
     * @param fovCalculation How the FOV is calculated.
     */
    setFovCalculation(fovCalculation) {
        this.m_options.fovCalculation = fovCalculation;
        this.calculateFocalLength(this.m_renderer.getSize(cache.vector2[0]).height);
        this.updateCameras();
    }
    /**
     * Returns the unique [[DataSource]] matching the given name.
     */
    getDataSourceByName(dataSourceName) {
        return this.m_tileDataSources.find(ds => ds.name === dataSourceName);
    }
    /**
     * Returns the array of [[DataSource]]s referring to the same [[StyleSet]].
     */
    getDataSourcesByStyleSetName(styleSetName) {
        return this.m_tileDataSources.filter(ds => ds.styleSetName === styleSetName);
    }
    /**
     * Returns true if the specified [[DataSource]] is enabled.
     */
    isDataSourceEnabled(dataSource) {
        return (dataSource.enabled &&
            dataSource.ready() &&
            this.m_connectedDataSources.has(dataSource.name));
    }
    /**
     * Adds a new [[DataSource]] to this `MapView`. `MapView` needs at least one [[DataSource]] to
     * display something.
     *
     * @param dataSource The data source.
     */
    addDataSource(dataSource) {
        const twinDataSource = this.getDataSourceByName(dataSource.name);
        if (twinDataSource !== undefined) {
            throw new Error(`A DataSource with the name "${dataSource.name}" already exists in this MapView.`);
        }
        dataSource.attach(this);
        dataSource.setEnableElevationOverlay(this.m_elevationProvider !== undefined);
        this.m_tileDataSources.push(dataSource);
        if (this.m_backgroundDataSource) {
            this.m_backgroundDataSource.updateStorageLevelOffset();
        }
        return dataSource
            .connect()
            .then(() => {
            return new Promise(resolve => {
                if (this.theme !== undefined && this.theme.styles !== undefined) {
                    resolve();
                    return;
                }
                const resolveOnce = () => {
                    this.removeEventListener(MapViewEventNames.ThemeLoaded, resolveOnce);
                    resolve();
                };
                this.addEventListener(MapViewEventNames.ThemeLoaded, resolveOnce);
            });
        })
            .then(() => {
            const alreadyRemoved = this.m_tileDataSources.indexOf(dataSource) === -1;
            if (alreadyRemoved) {
                return;
            }
            dataSource.addEventListener(MapViewEventNames.Update, () => {
                this.update();
            });
            dataSource.setTheme(this.m_theme);
            this.m_connectedDataSources.add(dataSource.name);
            this.dispatchEvent({
                type: MapViewEventNames.DataSourceConnect,
                dataSourceName: dataSource.name
            });
            this.update();
        })
            .catch(error => {
            logger.error(`Failed to connect to datasource ${dataSource.name}: ${error.message}`);
            this.m_failedDataSources.add(dataSource.name);
            this.dispatchEvent({
                type: MapViewEventNames.DataSourceConnect,
                dataSourceName: dataSource.name,
                error
            });
        });
    }
    /**
     * Removes [[DataSource]] from this `MapView`.
     *
     * @param dataSource The data source to be removed
     */
    removeDataSource(dataSource) {
        const dsIndex = this.m_tileDataSources.indexOf(dataSource);
        if (dsIndex === -1) {
            return;
        }
        dataSource.detach(this);
        this.m_visibleTiles.removeDataSource(dataSource);
        this.m_tileDataSources.splice(dsIndex, 1);
        this.m_connectedDataSources.delete(dataSource.name);
        this.m_failedDataSources.delete(dataSource.name);
        if (this.m_backgroundDataSource) {
            this.m_backgroundDataSource.updateStorageLevelOffset();
        }
        this.update();
    }
    /**
     * Access the `VisibleTileSet` to get access to all current datasources and their visible tiles.
     */
    get visibleTileSet() {
        return this.m_visibleTiles;
    }
    /**
     * Adds new overlay text elements to this `MapView`.
     *
     * @param textElements Array of [[TextElement]] to be added.
     */
    addOverlayText(textElements) {
        this.m_textElementsRenderer.addOverlayText(textElements);
        this.update();
    }
    /**
     * Adds new overlay text elements to this `MapView`.
     *
     * @param textElements Array of [[TextElement]] to be added.
     */
    clearOverlayText() {
        this.m_textElementsRenderer.clearOverlayText();
    }
    /**
     * The method that sets the camera to the desired angle (`tiltDeg`) and `distance` (in meters)
     * to the `target` location, from a certain heading (`headingAngle`).
     *
     * @param target The location to look at.
     * @param distance The distance of the camera to the target in meters.
     * @param tiltDeg The camera tilt angle in degrees (0 is vertical), curbed below 89deg.
     * @param headingDeg The camera heading angle in degrees and clockwise (as opposed to yaw),
     * starting north.
     */
    lookAt(target, distance, tiltDeg = 0, headingDeg = 0) {
        const limitedTilt = Math.min(Utils_1.MapViewUtils.MAX_TILT_DEG, tiltDeg);
        // MapViewUtils#setRotation uses pitch, not tilt, which is different in sphere projection.
        // But in sphere, in the tangent space of the target of the camera, pitch = tilt. So, put
        // the camera on the target, so the tilt can be passed to getRotation as a pitch.
        Utils_1.MapViewUtils.getCameraRotationAtTarget(this.projection, target, -headingDeg, limitedTilt, this.camera.quaternion);
        Utils_1.MapViewUtils.getCameraPositionFromTargetCoordinates(target, distance, -headingDeg, limitedTilt, this.projection, this.camera.position);
        this.camera.updateMatrixWorld(true);
        // TODO: Consider forcing entire cameras update, see: [[updateCameras]]
        this.m_targetGeoPos.copy(target);
        this.m_targetWorldPos.copy(this.projection.projectPoint(target));
        this.m_targetDistance = distance;
    }
    /**
     * Moves the camera to the specified [[GeoCoordinates]], sets the desired `zoomLevel` and
     * adjusts the yaw and pitch. The pitch of the camera is always curbed so that the camera cannot
     * look above the horizon. This paradigm is necessary in [[MapControls]], where the center of \
     * the screen is used for the orbiting interaction (3 fingers / right mouse button).
     *
     * @param geoPos Geolocation to move the camera to.
     * @param zoomLevel Desired zoom level.
     * @param yawDeg Camera yaw in degrees, counter-clockwise (as opposed to heading), starting
     * north.
     * @param pitchDeg Camera pitch in degrees.
     */
    setCameraGeolocationAndZoom(geoPos, zoomLevel, yawDeg = 0, pitchDeg = 0) {
        this.geoCenter = geoPos;
        let limitedPitch = Math.min(89, pitchDeg); // 90 leads to imprecision issues.
        if (this.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            const maxPitchRadWithCurvature = Math.asin(harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS /
                (Utils_1.MapViewUtils.calculateDistanceToGroundFromZoomLevel(this, zoomLevel) +
                    harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS));
            const maxPitchDegWithCurvature = THREE.Math.radToDeg(maxPitchRadWithCurvature);
            limitedPitch = Math.min(limitedPitch, maxPitchDegWithCurvature);
        }
        Utils_1.MapViewUtils.zoomOnTargetPosition(this, 0, 0, zoomLevel);
        Utils_1.MapViewUtils.setRotation(this, yawDeg, limitedPitch);
        this.update();
    }
    /**
     * Returns `true` if this `MapView` is constantly redrawing the scene.
     */
    get animating() {
        return this.m_animationCount > 0;
    }
    /**
     * Begin animating the scene.
     */
    beginAnimation() {
        if (this.m_animationCount++ === 0) {
            if (!this.m_updatePending) {
                this.m_updatePending = true;
                this.drawFrame();
            }
            ANIMATION_STARTED_EVENT.time = Date.now();
            this.dispatchEvent(ANIMATION_STARTED_EVENT);
        }
    }
    /**
     * Stop animating the scene.
     */
    endAnimation() {
        if (this.m_animationCount > 0) {
            --this.m_animationCount;
        }
        if (this.m_animationCount === 0) {
            ANIMATION_FINISHED_EVENT.time = Date.now();
            this.dispatchEvent(ANIMATION_FINISHED_EVENT);
        }
    }
    /**
     * Returns `true` if the camera moved in the last frame.
     */
    get cameraIsMoving() {
        return this.m_movementDetector.cameraIsMoving;
    }
    /**
     * Returns `true` if the current frame will immediately be followed by another frame.
     */
    get isDynamicFrame() {
        return (this.cameraIsMoving ||
            this.animating ||
            this.m_updatePending ||
            this.m_animatedExtrusionHandler.isAnimating);
    }
    /**
     * Returns the ratio between a pixel and a world unit for the current camera (in the center of
     * the camera projection).
     */
    get pixelToWorld() {
        if (this.m_pixelToWorld === undefined) {
            // At this point fov calculation should be always defined.
            harp_utils_1.assert(this.m_options.fovCalculation !== undefined);
            // NOTE: Look at distance is the distance to camera focus (and pivot) point.
            // In screen space this point is located in the center of canvas.
            // Given that zoom level is not modified (clamped by camera pitch), the following
            // formulas are all equivalent:
            // lookAtDistance = (EQUATORIAL_CIRCUMFERENCE * focalLength) / (256 * zoomLevel^2);
            // lookAtDistance = abs(cameraPos.z) / cos(cameraPitch);
            // Here we may use precalculated target distance (once pre frame):
            const lookAtDistance = this.m_targetDistance;
            // Find world space object size that corresponds to one pixel on screen.
            this.m_pixelToWorld = Utils_1.MapViewUtils.calculateWorldSizeByFocalLength(this.m_focalLength, lookAtDistance, 1);
        }
        return this.m_pixelToWorld;
    }
    /**
     * Returns the ratio between a world and a pixel unit for the current camera (in the center of
     * the camera projection).
     */
    get worldToPixel() {
        return 1.0 / this.pixelToWorld;
    }
    get pixelRatio() {
        if (this.m_pixelRatio !== undefined) {
            return this.m_pixelRatio;
        }
        return typeof window !== "undefined" && window.devicePixelRatio !== undefined
            ? window.devicePixelRatio
            : 1.0;
    }
    /**
     * PixelRatio in the WebGlRenderer. May contain values > 1.0 for high resolution screens
     * (HiDPI).
     *
     * A value of `undefined` will make the getter return `window.devicePixelRatio`, setting a value
     * of `1.0` will disable the use of HiDPI on all devices.
     *
     * @note Since the current pixelRatio may have been used in some calculations (e.g. the icons)
     * they may appear in the wrong size now. To ensure proper display of data, a call to
     * `clearTileCache()` is required if the pixelRatio is changed after tiles have been loaded.
     *
     * @memberof MapView
     */
    set pixelRatio(pixelRatio) {
        this.m_pixelRatio = pixelRatio;
        if (this.renderer.getPixelRatio() !== this.pixelRatio) {
            this.renderer.setPixelRatio(this.pixelRatio);
        }
    }
    /**
     * PixelRatio ratio for rendering when the camera is moving or an animation is running. Useful
     * when rendering on high resolution displays with low performance GPUs that may be
     * fill-rate-limited.
     *
     * If a value is specified, a low resolution render pass is used to render the scene into a
     * low resolution render target, before it is copied to the screen.
     *
     * A value of `undefined` disables the low res render pass. Values between 0.5 and
     * `window.devicePixelRatio` can be tried to give  good results. The value should not be larger
     * than `window.devicePixelRatio`.
     *
     * @note Since no anti-aliasing is applied during dynamic rendering with `dynamicPixelRatio`
     * defined, visual artifacts may occur, especially with thin lines..
     *
     * @note The resolution of icons and text labels is not affected.
     *
     * @default `undefined`
     */
    set dynamicPixelRatio(ratio) {
        this.mapRenderingManager.lowResPixelRatio = ratio;
    }
    get dynamicPixelRatio() {
        return this.mapRenderingManager.lowResPixelRatio;
    }
    /**
     * Returns the screen position of the given geo coordinates.
     *
     * @param geoPos The geo coordinates.
     * @returns The screen position in CSS/client coordinates (no pixel ratio applied) or
     * `undefined`.
     */
    getScreenPosition(geoPos) {
        this.projection.projectPoint(geoPos, cache.vector3[0]);
        const p = this.m_screenProjector.project(cache.vector3[0]);
        if (p !== undefined) {
            const { width, height } = this.getCanvasClientSize();
            p.x = p.x + width / 2;
            p.y = height - (p.y + height / 2);
        }
        return p;
    }
    /**
     * Returns a ray caster using the supplied screen positions.
     *
     * @param x The X position in css/client coordinates (without applied display ratio).
     * @param y The Y position in css/client coordinates (without applied display ratio).
     *
     * @alpha
     *
     * @return Raycaster with origin at the camera and direction based on the supplied x / y screen
     * points.
     */
    raycasterFromScreenPoint(x, y) {
        this.m_raycaster.setFromCamera(this.getNormalizedScreenCoordinates(x, y), this.m_rteCamera);
        return this.m_raycaster;
    }
    /**
     * Returns the world space position from the given screen position. The return value can be
     * `null`, in case the camera is facing the horizon and the given `(x, y)` value is not
     * intersecting the ground plane.
     *
     * @param x The X position in css/client coordinates (without applied display ratio).
     * @param y The Y position in css/client coordinates (without applied display ratio).
     */
    getWorldPositionAt(x, y) {
        this.m_raycaster.setFromCamera(this.getNormalizedScreenCoordinates(x, y), this.m_camera);
        return this.projection.type === harp_geoutils_1.ProjectionType.Spherical
            ? this.m_raycaster.ray.intersectSphere(this.m_sphere, cache.vector3[0])
            : this.m_raycaster.ray.intersectPlane(this.m_plane, cache.vector3[0]);
    }
    /**
     * Returns the [[GeoCoordinates]] from the given screen position. The return value can be
     * `null`, in case the camera is facing the horizon and the given `(x, y)` value is not
     * intersecting the ground plane.
     *
     * @param x The X position in css/client coordinates (without applied display ratio).
     * @param y The Y position in css/client coordinates (without applied display ratio).
     */
    getGeoCoordinatesAt(x, y) {
        const worldPosition = this.getWorldPositionAt(x, y);
        if (!worldPosition) {
            return null;
        }
        return this.projection.unprojectPoint(worldPosition);
    }
    /**
     * Returns the normalized screen coordinates from the given pixel position.
     *
     * @param x The X position in css/client coordinates (without applied display ratio).
     * @param y The Y position in css/client coordinates (without applied display ratio).
     */
    getNormalizedScreenCoordinates(x, y) {
        // use clientWidth and clientHeight as it does not apply the pixelRatio and
        // therefore supports also HiDPI devices
        const { width, height } = this.getCanvasClientSize();
        return new THREE.Vector3((x / width) * 2 - 1, -((y / height) * 2) + 1, 0);
    }
    /**
     * Do a raycast on all objects in the scene. Useful for picking. Limited to objects that
     * THREE.js can raycast, the solid lines that get their geometry in the shader cannot be tested
     * for intersection.
     *
     * Note, if a [[DataSource]] adds an [[Object3D]] to a [[Tile]], it will be only pickable once
     * [[MapView.render]] has been called, this is because [[MapView.render]] method creates the
     * internal three.js root [[Object3D]] which is used in the [[PickHandler]] internally.
     * This method will not test for intersection custom objects added to the scene by for
     * example calling directly the [[scene.add]] method from THREE.
     *
     * @param x The X position in css/client coordinates (without applied display ratio).
     * @param y The Y position in css/client coordinates (without applied display ratio).
     * @returns The list of intersection results.
     */
    intersectMapObjects(x, y) {
        return this.m_pickHandler.intersectMapObjects(x, y);
    }
    /**
     * Resize the HTML canvas element and the THREE.js `WebGLRenderer`.
     *
     * @param width The new width.
     * @param height The new height.
     */
    resize(width, height) {
        this.m_renderer.setSize(width, height, false);
        if (this.m_renderer.getPixelRatio() !== this.pixelRatio) {
            this.m_renderer.setPixelRatio(this.pixelRatio);
        }
        if (this.mapRenderingManager !== undefined) {
            this.mapRenderingManager.setSize(width, height);
        }
        if (this.collisionDebugCanvas !== undefined) {
            this.collisionDebugCanvas.width = width;
            this.collisionDebugCanvas.height = height;
        }
        this.updateCameras();
        this.update();
        this.dispatchEvent({
            type: MapViewEventNames.Resize,
            size: {
                width,
                height
            }
        });
    }
    /**
     * Redraws scene immediately
     *
     * @note Before using this method, set `synchronousRendering` to `true`
     * in the [[MapViewOptions]]
     */
    renderSync() {
        this.renderFunc(harp_utils_1.PerformanceTimer.now());
    }
    /**
     * Requests a redraw of the scene.
     */
    update() {
        this.dispatchEvent(UPDATE);
        if (this.m_updatePending) {
            return;
        } // compress the update request
        this.m_updatePending = true;
        if (this.animating) {
            return;
        } // nothing to do
        this.drawFrame();
    }
    /**
     * Returns `true` if an update has already been requested, such that after a currently rendering
     * frame, the next frame will be rendered immediately.
     */
    get updatePending() {
        return this.m_updatePending;
    }
    /**
     * Requests a redraw of the scene.
     * @deprecated Use the [[update]] method instead.
     */
    requestUpdateIfNeeded() {
        this.update();
    }
    /**
     * Clear the tile cache.
     *
     * Remove the [[Tile]] objects created by cacheable [[DataSource]]s. If a [[DataSource]] name is
     * provided, this method restricts the eviction the [[DataSource]] with the given name.
     *
     * @param dataSourceName The name of the [[DataSource]].
     */
    clearTileCache(dataSourceName) {
        if (dataSourceName !== undefined) {
            const dataSource = this.getDataSourceByName(dataSourceName);
            if (dataSource) {
                this.m_visibleTiles.clearTileCache(dataSource);
                dataSource.clearCache();
            }
        }
        else {
            this.m_visibleTiles.clearTileCache();
            this.m_tileDataSources.forEach(dataSource => dataSource.clearCache());
        }
        if (this.m_elevationProvider !== undefined) {
            this.m_elevationProvider.clearCache();
        }
    }
    /**
     * Apply visitor to all visible tiles.
     *
     * @param fun Visitor function
     */
    forEachVisibleTile(fun) {
        this.m_visibleTiles.forEachVisibleTile(fun);
    }
    /**
     * Apply a visitor function to all tiles in the cache.
     *
     * @param visitor Visitor function
     */
    forEachCachedTile(visitor) {
        this.m_visibleTiles.forEachCachedTile(visitor);
    }
    /**
     * Visit each tile in visible, rendered, and cached sets.
     *
     *  * Visible and temporarily rendered tiles will be marked for update and retained.
     *  * Cached but not rendered/visible will be evicted.
     *
     * @param dataSource If passed, only the tiles from this [[DataSource]] instance are processed.
     * If `undefined`, tiles from all [[DataSource]]s are processed.
     */
    markTilesDirty(dataSource) {
        this.m_visibleTiles.markTilesDirty(dataSource);
    }
    /**
     * Sets the DataSource which contains the elevations, the elevation range source, and the
     * elevation provider. Only a single elevation source is possible per [[MapView]]
     *
     * If the terrain-datasource is merged with this repository, we could internally construct
     * the [[ElevationRangeSource]] and the [[ElevationProvider]] and access would be granted to
     * the application when it asks for it, to simplify the API.
     *
     * @param elevationSource The datasource containing the terrain tiles.
     * @param elevationRangeSource Allows access to the elevation min / max per tile.
     * @param elevationProvider Allows access to the elevation at a given location or a ray
     *      from the camera.
     */
    setElevationSource(elevationSource, elevationRangeSource, elevationProvider) {
        // Try to remove incase this method was already called, will do nothing if it doesn't exist.
        this.removeDataSource(elevationSource);
        this.addDataSource(elevationSource);
        this.m_elevationRangeSource = elevationRangeSource;
        this.m_elevationRangeSource.connect();
        this.m_elevationProvider = elevationProvider;
        this.dataSources.forEach(dataSource => {
            dataSource.setEnableElevationOverlay(true);
        });
        this.m_tileGeometryManager.setTileUpdateCallback((tile) => {
            overlayOnElevation_1.overlayOnElevation(tile);
        });
        this.clearTileCache();
    }
    /**
     * Clears any elevation sources and provider previously set.
     * @param elevationSource The datasource to be cleared.
     */
    clearElevationSource(elevationSource) {
        this.removeDataSource(elevationSource);
        this.m_elevationRangeSource = undefined;
        this.m_elevationProvider = undefined;
        this.dataSources.forEach(dataSource => {
            dataSource.setEnableElevationOverlay(false);
        });
        this.m_tileGeometryManager.setTileUpdateCallback(undefined);
        this.clearTileCache();
    }
    /**
     * Public access to [[MapViewFog]] allowing to toggle it by setting its `enabled` property.
     */
    get fog() {
        return this.m_fog;
    }
    setPostEffects() {
        // First clear all the effects, then enable them from what is specified.
        this.mapRenderingManager.bloom.enabled = false;
        this.mapRenderingManager.outline.enabled = false;
        this.mapRenderingManager.vignette.enabled = false;
        this.mapRenderingManager.sepia.enabled = false;
        if (this.m_postEffects !== undefined) {
            if (this.m_postEffects.bloom !== undefined) {
                this.mapRenderingManager.bloom = this.m_postEffects.bloom;
            }
            if (this.m_postEffects.outline !== undefined) {
                this.mapRenderingManager.outline.enabled = this.m_postEffects.outline.enabled;
                this.mapRenderingManager.updateOutline(this.m_postEffects.outline);
            }
            if (this.m_postEffects.vignette !== undefined) {
                this.mapRenderingManager.vignette = this.m_postEffects.vignette;
            }
            if (this.m_postEffects.sepia !== undefined) {
                this.mapRenderingManager.sepia = this.m_postEffects.sepia;
            }
        }
    }
    /**
     * Returns the elevation provider.
     */
    get elevationProvider() {
        return this.m_elevationProvider;
    }
    /**
     * Plug-in PolarTileDataSource for spherical projection and plug-out otherwise
     */
    updatePolarDataSource() {
        const dataSource = this.m_polarDataSource;
        if (this.m_enablePolarDataSource === true && dataSource !== undefined) {
            const twinDataSource = this.getDataSourceByName(dataSource.name);
            if (this.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
                if (twinDataSource === undefined) {
                    this.addDataSource(dataSource);
                }
            }
            else {
                if (twinDataSource !== undefined) {
                    this.removeDataSource(dataSource);
                }
            }
        }
    }
    /**
     * Updates the camera and the projections and resets the screen collisions,
     * note, setupCamera must be called before this is called.
     * @param viewRanges optional parameter that supplies new view ranges, most importantly
     * near/far clipping planes distance. If parameter is not provided view ranges will be
     * calculated from [[ClipPlaneEvaluator]] used in [[VisibleTileSet]].
     */
    updateCameras(viewRanges) {
        const { width, height } = this.m_renderer.getSize(cache.vector2[0]);
        this.m_camera.aspect =
            this.m_forceCameraAspect !== undefined ? this.m_forceCameraAspect : width / height;
        this.setFovOnCamera(this.m_options.fovCalculation, height);
        // When calculating clip planes account for the highest building on the earth,
        // multiplying its height by projection scaling factor. This approach assumes
        // constantHeight property of extruded polygon technique is set as default false,
        // otherwise the near plane margins will be bigger then required, but still correct.
        const projectionScale = this.projection.getScaleFactor(this.camera.position);
        const maxGeometryHeightScaled = projectionScale *
            this.m_tileDataSources.reduce((r, ds) => Math.max(r, ds.maxGeometryHeight), 0);
        // Copy all properties from new view ranges to our readonly object.
        // This allows to keep all view ranges references valid and keeps up-to-date
        // information within them. Works the same as copping all properties one-by-one.
        Object.assign(this.m_viewRanges, viewRanges === undefined
            ? this.m_visibleTiles.updateClipPlanes(maxGeometryHeightScaled)
            : viewRanges);
        this.m_camera.near = this.m_viewRanges.near;
        this.m_camera.far = this.m_viewRanges.far;
        this.m_camera.updateProjectionMatrix();
        this.m_camera.updateMatrixWorld(false);
        // Update the "relative to eye" camera. Copy the public camera parameters
        // and place the "relative to eye" at the world's origin.
        this.m_rteCamera.copy(this.m_camera);
        this.m_rteCamera.position.setScalar(0);
        this.m_rteCamera.updateMatrixWorld(true);
        this.m_screenCamera.left = width / -2;
        this.m_screenCamera.right = width / 2;
        this.m_screenCamera.bottom = height / -2;
        this.m_screenCamera.top = height / 2;
        this.m_screenCamera.updateProjectionMatrix();
        this.m_screenCamera.updateMatrixWorld(false);
        this.m_screenProjector.update(this.camera, width, height);
        this.m_screenCollisions.update(width, height);
        this.m_pixelToWorld = undefined;
        const cameraPitch = Utils_1.MapViewUtils.extractAttitude(this, this.m_camera).pitch;
        const cameraPosZ = this.getCameraHeightAboveTerrain(TERRAIN_ZOOM_LEVEL);
        const zoomLevelDistance = cameraPosZ / Math.cos(Math.min(cameraPitch, Math.PI / 3));
        this.m_zoomLevel = Utils_1.MapViewUtils.calculateZoomLevelFromDistance(this, zoomLevelDistance);
        this.m_fog.update(this, this.m_viewRanges.maximum);
        const target = Utils_1.MapViewUtils.getWorldTargetFromCamera(this.m_camera, this.projection);
        if (target !== null) {
            this.m_targetWorldPos.copy(target);
            this.m_targetGeoPos = this.projection.unprojectPoint(target);
            this.m_targetDistance = this.camera.position.distanceTo(target);
        }
    }
    /**
     * Update `Env` instance used for style `Expr` evaluations.
     */
    updateEnv() {
        this.m_env.entries.$zoom = this.m_zoomLevel;
        // This one introduces unnecessary calculation of pixelToWorld, even if it's barely
        // used in our styles.
        this.m_env.entries.$pixelToMeters = this.pixelToWorld;
        this.m_env.entries.$frameNumber = this.m_frameNumber;
    }
    /**
     * Returns the height of the camera above the earths surface.
     *
     * If there is an ElevationProvider, this is used. Otherwise the projection is used to determine
     * how high the camera is above the surface.
     *
     * @param level Which level to request the surface height from.
     * @return Height in world units.
     */
    getCameraHeightAboveTerrain(level) {
        if (this.elevationProvider !== undefined) {
            const heightAboveTerrain = this.elevationProvider.getHeight(this.geoCenter, level);
            if (heightAboveTerrain !== undefined) {
                const height = this.projection.unprojectAltitude(this.m_camera.position) - heightAboveTerrain;
                return Math.max(height, 1);
            }
        }
        return Math.abs(this.projection.groundDistance(this.m_camera.position));
    }
    detectCurrentFps(now) {
        // Skip the first frames, they are from not originated from requestAnimationFrame()
        if (this.m_previousRequestAnimationTime !== undefined && this.m_frameNumber > 5) {
            const currentFps = 1000 / (now - this.m_previousRequestAnimationTime);
            this.m_frameTimeRing[this.m_frameTimeIndex % FRAME_RATE_RING_SIZE] = currentFps;
            this.m_frameTimeIndex++;
            const capturedFrames = Math.min(this.m_frameTimeIndex, FRAME_RATE_RING_SIZE);
            let sum = 0;
            for (let i = 0; i < capturedFrames; i++) {
                sum += this.m_frameTimeRing[i];
            }
            this.m_detectedFps = sum / capturedFrames;
        }
        this.m_previousRequestAnimationTime = now;
    }
    /**
     * Draw a new frame.
     */
    drawFrame() {
        if (this.m_drawing || this.m_options.synchronousRendering) {
            return;
        }
        // Cancel an active requestAnimationFrame() cycle. Failure to do this may end up in
        // rendering multiple times during a single frame.
        if (this.m_animationFrameHandle !== undefined) {
            cancelAnimationFrame(this.m_animationFrameHandle);
            this.m_animationFrameHandle = undefined;
        }
        if (this.m_maxFps <= 0) {
            // Render at maximum FPS.
            this.m_animationFrameHandle = requestAnimationFrame(this.handleRequestAnimationFrame);
            return;
        }
        // Magic ingredient to compensate time flux.
        const fudgeTimeInMs = 3;
        const vSyncFrameTime = 1000 / this.m_detectedFps;
        const frameInterval = 1000 / this.m_maxFps;
        const previousFrameTime = this.m_previousFrameTimeStamp === undefined ? 0 : this.m_previousFrameTimeStamp;
        // Compute a practical value to compare against.
        const targetTime = previousFrameTime + frameInterval - vSyncFrameTime - fudgeTimeInMs;
        this.m_targetRequestAnimationTime = targetTime;
        this.postponedAnimationFrame(previousFrameTime);
    }
    postponedAnimationFrame(now) {
        if (this.m_targetRequestAnimationTime === undefined) {
            return;
        }
        if (this.m_animationFrameHandle !== undefined) {
            cancelAnimationFrame(this.m_animationFrameHandle);
            this.m_animationFrameHandle = undefined;
        }
        this.detectCurrentFps(now);
        this.m_animationFrameHandle = requestAnimationFrame(now > this.m_targetRequestAnimationTime
            ? this.handleRequestAnimationFrame
            : this.handlePostponedAnimationFrame);
    }
    /**
     * Draw a new frame.
     */
    renderFunc(time) {
        this.render(time);
    }
    /**
     * Returns the list of the enabled data sources.
     */
    getEnabledTileDataSources() {
        // ### build this list once decoders && datasources are ready
        const enabledDataSources = [];
        for (const dataSource of this.m_tileDataSources) {
            if (this.isDataSourceEnabled(dataSource)) {
                enabledDataSources.push(dataSource);
            }
        }
        return enabledDataSources;
    }
    /**
     * Renders the current frame.
     */
    render(time) {
        if (this.m_drawing) {
            return;
        }
        ++this.m_frameNumber;
        const stats = Statistics_1.PerformanceStatistics.instance;
        const gatherStatistics = stats.enabled;
        const frameStartTime = time;
        RENDER_EVENT.time = time;
        this.dispatchEvent(RENDER_EVENT);
        let currentFrameEvent;
        if (gatherStatistics) {
            currentFrameEvent = stats.currentFrame;
            currentFrameEvent.setValue("renderCount.frameNumber", this.m_frameNumber);
            if (this.m_previousFrameTimeStamp !== undefined) {
                const timeSincePreviousFrame = frameStartTime - this.m_previousFrameTimeStamp;
                if (gatherStatistics) {
                    currentFrameEvent.setValue("render.fullFrameTime", timeSincePreviousFrame);
                    // For convenience and easy readability
                    currentFrameEvent.setValue("render.fps", 1000 / timeSincePreviousFrame);
                }
            }
        }
        this.m_previousFrameTimeStamp = frameStartTime;
        let setupTime;
        let cullTime;
        let textPlacementTime;
        let drawTime;
        let textDrawTime;
        let endTime;
        this.m_renderer.info.reset();
        this.m_updatePending = false;
        this.m_thisFrameTilesChanged = undefined;
        this.m_drawing = true;
        if (this.m_renderer.getPixelRatio() !== this.pixelRatio) {
            this.m_renderer.setPixelRatio(this.pixelRatio);
        }
        this.updateCameras();
        this.updateEnv();
        this.m_renderer.clear();
        // clear the scene
        while (this.m_mapTilesRoot.children.length > 0) {
            this.m_mapTilesRoot.remove(this.m_mapTilesRoot.children[0]);
        }
        if (gatherStatistics) {
            setupTime = harp_utils_1.PerformanceTimer.now();
        }
        // TBD: Update renderList only any of its params (camera, etc...) has changed.
        if (!this.lockVisibleTileSet) {
            const viewRangesStatus = this.m_visibleTiles.updateRenderList(this.storageLevel, Math.floor(this.zoomLevel), this.getEnabledTileDataSources(), this.m_elevationRangeSource);
            // View ranges has changed due to features (with elevation) that affects clip planes
            // positioning, update cameras with new clip planes positions.
            if (viewRangesStatus.viewRangesChanged) {
                this.updateCameras(viewRangesStatus.viewRanges);
            }
        }
        if (gatherStatistics) {
            cullTime = harp_utils_1.PerformanceTimer.now();
        }
        const renderList = this.m_visibleTiles.dataSourceTileList;
        // no need to check everything if we're not going to create text renderer.
        renderList.forEach(({ zoomLevel, renderedTiles }) => {
            renderedTiles.forEach(tile => {
                this.renderTileObjects(tile, zoomLevel);
                //We know that rendered tiles are visible (in the view frustum), so we update the
                //frame number, note we don't do this for the visibleTiles because some may still be
                //loading (and therefore aren't visible in the sense of being seen on the screen).
                //Note also, this number isn't currently used anywhere so should be considered to be
                //removed in the future (though could be good for debugging purposes).
                tile.frameNumLastVisible = this.m_frameNumber;
            });
        });
        // Check if this is the time to place the labels for the first time. Pretty much everything
        // should have been loaded, and no animation should be running.
        if (!this.m_initialTextPlacementDone &&
            !this.m_firstFrameComplete &&
            !this.isDynamicFrame &&
            !this.m_themeIsLoading &&
            this.m_poiTableManager.finishedLoading &&
            this.m_visibleTiles.allVisibleTilesLoaded &&
            this.m_connectedDataSources.size + this.m_failedDataSources.size ===
                this.m_tileDataSources.length &&
            !this.m_textElementsRenderer.initializing &&
            !this.m_textElementsRenderer.loading) {
            this.m_initialTextPlacementDone = true;
        }
        this.m_mapAnchors.children.forEach((childObject) => {
            if (childObject.geoPosition === undefined) {
                return;
            }
            this.projection.projectPoint(childObject.geoPosition, childObject.position);
            childObject.position.sub(this.camera.position);
        });
        this.m_animatedExtrusionHandler.zoom = this.m_zoomLevel;
        if (currentFrameEvent !== undefined) {
            // Make sure the counters all have a value.
            currentFrameEvent.addValue("renderCount.numTilesRendered", 0);
            currentFrameEvent.addValue("renderCount.numTilesVisible", 0);
            currentFrameEvent.addValue("renderCount.numTilesLoading", 0);
            // Increment the counters for all data sources.
            renderList.forEach(({ zoomLevel, renderedTiles, visibleTiles, numTilesLoading }) => {
                currentFrameEvent.addValue("renderCount.numTilesRendered", renderedTiles.size);
                currentFrameEvent.addValue("renderCount.numTilesVisible", visibleTiles.length);
                currentFrameEvent.addValue("renderCount.numTilesLoading", numTilesLoading);
            });
        }
        if (this.m_movementDetector.checkCameraMoved(this, time)) {
            const { yaw, pitch, roll } = Utils_1.MapViewUtils.extractAttitude(this, this.camera);
            const { latitude, longitude, altitude } = this.geoCenter;
            this.dispatchEvent({
                type: MapViewEventNames.CameraPositionChanged,
                latitude,
                longitude,
                altitude,
                yaw,
                pitch,
                roll,
                zoom: this.zoomLevel
            });
        }
        // The camera used to render the scene.
        const camera = this.m_pointOfView !== undefined ? this.m_pointOfView : this.m_rteCamera;
        if (this.renderLabels) {
            this.prepareRenderTextElements(time);
        }
        if (gatherStatistics) {
            textPlacementTime = harp_utils_1.PerformanceTimer.now();
        }
        if (this.m_skyBackground !== undefined && this.projection.type === harp_geoutils_1.ProjectionType.Planar) {
            this.m_skyBackground.updateCamera(this.m_camera);
        }
        this.mapRenderingManager.render(this.m_renderer, this.m_scene, camera, !this.isDynamicFrame);
        if (gatherStatistics) {
            drawTime = harp_utils_1.PerformanceTimer.now();
        }
        if (this.renderLabels) {
            this.finishRenderTextElements();
        }
        if (gatherStatistics) {
            textDrawTime = harp_utils_1.PerformanceTimer.now();
        }
        if (!this.m_firstFrameRendered) {
            this.m_firstFrameRendered = true;
            if (gatherStatistics) {
                stats.appResults.set("firstFrame", time);
            }
            FIRST_FRAME_EVENT.time = time;
            this.dispatchEvent(FIRST_FRAME_EVENT);
        }
        this.m_visibleTiles.disposePendingTiles();
        this.m_drawing = false;
        if (this.animating || this.m_updatePending) {
            this.drawFrame();
        }
        this.checkCopyrightUpdates();
        if (currentFrameEvent !== undefined) {
            endTime = harp_utils_1.PerformanceTimer.now();
            currentFrameEvent.setValue("render.setupTime", setupTime - frameStartTime);
            currentFrameEvent.setValue("render.cullTime", cullTime - setupTime);
            currentFrameEvent.setValue("render.textPlacementTime", textPlacementTime - cullTime);
            currentFrameEvent.setValue("render.drawTime", drawTime - textPlacementTime);
            currentFrameEvent.setValue("render.textDrawTime", textDrawTime - drawTime);
            currentFrameEvent.setValue("render.cleanupTime", endTime - textDrawTime);
            currentFrameEvent.setValue("render.frameRenderTime", endTime - frameStartTime);
            Statistics_1.PerformanceStatistics.instance.storeFrameInfo(this.m_renderer.info);
        }
        DID_RENDER_EVENT.time = time;
        this.dispatchEvent(DID_RENDER_EVENT);
        // After completely rendering this frame, it is checked if this frame was the first complete
        // frame, with no more tiles, geometry and labels waiting to be added, and no animation
        // running. The initial placement of text in this render call may have changed the loading
        // state of the TextElementsRenderer, so this has to be checked again.
        if (!this.m_firstFrameComplete &&
            this.m_initialTextPlacementDone &&
            !this.isDynamicFrame &&
            !this.textElementsRenderer.loading) {
            this.m_firstFrameComplete = true;
            if (gatherStatistics) {
                stats.appResults.set("firstFrameComplete", time);
            }
            FRAME_COMPLETE_EVENT.time = time;
            this.dispatchEvent(FRAME_COMPLETE_EVENT);
        }
    }
    renderTileObjects(tile, zoomLevel) {
        const worldOffsetX = tile.computeWorldOffsetX();
        if (tile.willRender(zoomLevel)) {
            for (const object of tile.objects) {
                object.position.copy(tile.center);
                if (object.displacement !== undefined) {
                    object.position.add(object.displacement);
                }
                object.position.x += worldOffsetX;
                object.position.sub(this.m_camera.position);
                if (tile.localTangentSpace) {
                    object.setRotationFromMatrix(tile.boundingBox.getRotationMatrix());
                }
                object.frustumCulled = false;
                if (object._backupRenderOrder === undefined) {
                    object._backupRenderOrder = object.renderOrder;
                }
                const isBuilding = object.userData !== undefined &&
                    object.userData.kind !== undefined &&
                    object.userData.kind.includes(harp_datasource_protocol_1.GeometryKind.Building);
                // When falling back to a parent tile (i.e. tile.levelOffset < 0) there will
                // be overlaps with the already loaded tiles. Therefore all (flat) objects
                // in a fallback tile must be shifted, such that their renderOrder is less
                // than the groundPlane that each neighbouring Tile has (it has a renderOrder
                // of -10000, see addGroundPlane in TileGeometryCreator), only then can we be
                // sure that nothing of the parent will be rendered on top of the children,
                // as such, we shift using the FALLBACK_RENDER_ORDER_OFFSET.
                // This does not apply to buildings b/c they are 3d and the overlaps
                // are resolved with a depth prepass. Note we set this always to ensure that if
                // the Tile is used as a fallback, and then used normally, that we have the correct
                // renderOrder.
                object.renderOrder =
                    object._backupRenderOrder +
                        (!isBuilding && tile.levelOffset < 0
                            ? exports.FALLBACK_RENDER_ORDER_OFFSET * tile.levelOffset
                            : 0);
                this.m_mapTilesRoot.add(object);
            }
        }
        tile.didRender();
    }
    prepareRenderTextElements(time) {
        // Disable rendering of text elements for debug camera. TextElements are rendered using an
        // orthographic camera that covers the entire available screen space. Unfortunately, this
        // particular camera set up is not compatible with the debug camera.
        const debugCameraActive = this.m_pointOfView !== undefined;
        if (debugCameraActive) {
            return;
        }
        this.m_textElementsRenderer.placeText(this.m_visibleTiles.dataSourceTileList, time);
    }
    finishRenderTextElements() {
        const canRenderTextElements = this.m_pointOfView === undefined;
        if (canRenderTextElements) {
            // copy far value from scene camera, as the distance to the POIs matter now.
            this.m_screenCamera.far = this.m_viewRanges.maximum;
            this.m_textElementsRenderer.renderText(this.m_screenCamera);
        }
    }
    initTheme() {
        const theme = harp_utils_1.getOptionValue(this.m_options.theme, exports.MapViewDefaults.theme);
        this.m_themeIsLoading = true;
        Promise.resolve(theme)
            // tslint:disable-next-line: no-shadowed-variable
            .then(theme => ThemeLoader_1.ThemeLoader.load(theme, { uriResolver: this.m_uriResolver }))
            // tslint:disable-next-line: no-shadowed-variable
            .then(theme => {
            this.m_themeIsLoading = false;
            this.theme = theme;
        })
            .catch(error => {
            this.m_themeIsLoading = false;
            const themeName = typeof this.m_options.theme === "string" ? ` from ${this.m_options.theme}` : "";
            logger.error(`Failed to load theme${themeName}: ${error}`, error);
        });
    }
    setupCamera(options) {
        const { width, height } = this.getCanvasClientSize();
        const defaultGeoCenter = exports.MapViewDefaults.geoCenter;
        this.projection.projectPoint(defaultGeoCenter, this.m_camera.position);
        if (this.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            this.m_camera.lookAt(this.scene.position);
        }
        this.m_targetDistance = defaultGeoCenter.altitude;
        this.calculateFocalLength(height);
        this.m_visibleTiles = this.createVisibleTileSet();
        this.setInitialCameraPosition(options);
        // ### move & customize
        this.resize(width, height);
        this.m_screenCamera.position.z = 1;
        this.m_screenCamera.near = 0;
    }
    setInitialCameraPosition(options) {
        const target = harp_geoutils_1.GeoCoordinates.fromObject(harp_utils_1.getOptionValue(options.target, exports.MapViewDefaults.target));
        target.altitude = 0; // ensure that look at target has height of 0
        const zoomLevel = harp_utils_1.getOptionValue(options.zoomLevel, exports.MapViewDefaults.zoomLevel);
        const tilt = harp_utils_1.getOptionValue(options.tilt, exports.MapViewDefaults.tilt);
        const heading = harp_utils_1.getOptionValue(options.heading, exports.MapViewDefaults.heading);
        this.lookAt(target, 300000, tilt, heading);
        this.zoomLevel = zoomLevel;
    }
    createVisibleTileSet() {
        const enableMixedLod = this.m_enableMixedLod === undefined
            ? this.projection.type === harp_geoutils_1.ProjectionType.Spherical
            : this.m_enableMixedLod;
        return new VisibleTileSet_1.VisibleTileSet(new FrustumIntersection_1.FrustumIntersection(this.m_camera, this, this.m_visibleTileSetOptions.extendedFrustumCulling, this.m_tileWrappingEnabled, enableMixedLod), this.m_tileGeometryManager, this.m_visibleTileSetOptions);
    }
    updateSkyBackground() {
        if (this.m_theme === undefined) {
            return;
        }
        const theme = this.m_theme;
        if (this.m_skyBackground instanceof SkyBackground_1.SkyBackground && theme.sky !== undefined) {
            // there is a sky in the view and there is a sky option in the theme. Update the colors
            this.updateSkyBackgroundColors(theme.sky, theme.clearColor);
        }
        else if (this.m_skyBackground === undefined && theme.sky !== undefined) {
            // there is no sky in the view but there is a sky option in the theme
            this.addNewSkyBackground(theme.sky, theme.clearColor);
            return;
        }
        else if (this.m_skyBackground instanceof SkyBackground_1.SkyBackground && theme.sky === undefined) {
            // there is a sky in the view, but not in the theme
            this.removeSkyBackGround();
        }
    }
    addNewSkyBackground(sky, clearColor) {
        if (sky.type === "gradient" && sky.groundColor === undefined) {
            sky.groundColor = harp_utils_1.getOptionValue(clearColor, "#000000");
        }
        this.m_skyBackground = new SkyBackground_1.SkyBackground(sky, this.projection.type, this.m_camera);
        this.m_scene.background = this.m_skyBackground.texture;
    }
    removeSkyBackGround() {
        this.m_scene.background = null;
        if (this.m_skyBackground !== undefined) {
            this.m_skyBackground.dispose();
            this.m_skyBackground = undefined;
        }
    }
    updateSkyBackgroundColors(sky, clearColor) {
        if (sky.type === "gradient" && sky.groundColor === undefined) {
            sky.groundColor = harp_utils_1.getOptionValue(clearColor, "#000000");
        }
        if (this.m_skyBackground !== undefined) {
            this.m_skyBackground.updateTexture(sky, this.projection.type);
        }
    }
    updateLighting() {
        if (!this.m_theme) {
            return;
        }
        const theme = this.m_theme;
        if (theme.clearColor !== undefined) {
            this.m_renderer.setClearColor(new THREE.Color(theme.clearColor));
        }
        if (this.m_createdLights) {
            this.m_createdLights.forEach((light) => {
                this.m_scene.remove(light);
            });
        }
        if (theme.lights !== undefined) {
            this.m_createdLights = [];
            theme.lights.forEach((lightDescription) => {
                const light = ThemeHelpers_1.createLight(lightDescription);
                if (!light) {
                    logger.warn(
                    // tslint:disable-next-line: max-line-length
                    `MapView: failed to create light ${lightDescription.name} of type ${lightDescription.type}`);
                    return;
                }
                this.m_scene.add(light);
                this.m_createdLights.push(light);
            });
        }
    }
    movementStarted() {
        this.m_textElementsRenderer.movementStarted();
        MOVEMENT_STARTED_EVENT.time = Date.now();
        this.dispatchEvent(MOVEMENT_STARTED_EVENT);
    }
    movementFinished() {
        this.m_textElementsRenderer.movementFinished();
        MOVEMENT_FINISHED_EVENT.time = Date.now();
        this.dispatchEvent(MOVEMENT_FINISHED_EVENT);
        // render at the next possible time.
        if (!this.animating) {
            if (this.m_movementFinishedUpdateTimerId !== undefined) {
                clearTimeout(this.m_movementFinishedUpdateTimerId);
            }
            this.m_movementFinishedUpdateTimerId = setTimeout(() => {
                this.m_movementFinishedUpdateTimerId = undefined;
                this.update();
            }, 0);
        }
    }
    /**
     * Check if the set of visible tiles changed since the last frame.
     *
     * May be called multiple times per frame.
     *
     * Equality is computed by creating a string containing the IDs of the tiles.
     */
    checkIfTilesChanged() {
        if (this.m_thisFrameTilesChanged !== undefined) {
            return this.m_thisFrameTilesChanged;
        }
        const renderList = this.m_visibleTiles.dataSourceTileList;
        const tileIdList = [];
        tileIdList.length = 0;
        renderList.forEach(({ dataSource, renderedTiles }) => {
            renderedTiles.forEach(tile => {
                tileIdList.push(dataSource.name + "-" + tile.tileKey.mortonCode());
            });
        });
        tileIdList.sort();
        const newTileIds = tileIdList.join("#");
        if (newTileIds !== this.m_lastTileIds) {
            this.m_lastTileIds = newTileIds;
            this.m_thisFrameTilesChanged = true;
        }
        else {
            this.m_thisFrameTilesChanged = false;
        }
        return this.m_thisFrameTilesChanged;
    }
    checkCopyrightUpdates() {
        if (!this.checkIfTilesChanged()) {
            return;
        }
        const newCopyrightInfo = this.getRenderedTilesCopyrightInfo();
        if (newCopyrightInfo === this.m_copyrightInfo) {
            return;
        }
        if (newCopyrightInfo.length === this.m_copyrightInfo.length) {
            let allEqual = true;
            for (let i = 0; i < newCopyrightInfo.length; i++) {
                const a = newCopyrightInfo[i];
                const b = this.m_copyrightInfo[i];
                if (a.label !== b.label) {
                    allEqual = false;
                    break;
                }
            }
            if (allEqual) {
                return;
            }
        }
        this.m_copyrightInfo = newCopyrightInfo;
        this.dispatchEvent(COPYRIGHT_CHANGED_EVENT);
    }
    getRenderedTilesCopyrightInfo() {
        let result = [];
        for (const tileList of this.m_visibleTiles.dataSourceTileList) {
            for (const tile of tileList.renderedTiles.values()) {
                const tileCopyrightInfo = tile.copyrightInfo;
                if (tileCopyrightInfo === undefined || tileCopyrightInfo.length === 0) {
                    continue;
                }
                result = CopyrightInfo_1.CopyrightInfo.mergeArrays(result, tileCopyrightInfo);
            }
        }
        return result;
    }
    updateImages() {
        if (!this.m_theme) {
            return;
        }
        const theme = this.m_theme;
        this.m_imageCache.clear();
        this.poiManager.clear();
        if (theme.images !== undefined) {
            for (const name of Object.keys(theme.images)) {
                const image = theme.images[name];
                this.m_imageCache.addImage(name, image.url, image.preload === true);
                if (typeof image.atlas === "string") {
                    this.poiManager.addTextureAtlas(name, image.atlas);
                }
            }
        }
        if (theme.imageTextures !== undefined) {
            theme.imageTextures.forEach((imageTexture) => {
                this.poiManager.addImageTexture(imageTexture);
            });
        }
    }
    loadPoiTables() {
        if (this.m_theme === undefined) {
            return;
        }
        this.poiTableManager.clear();
        // Add the POI tables defined in the theme.
        this.poiTableManager
            .loadPoiTables(this.m_theme)
            .then(() => this.update())
            .catch(() => this.update());
    }
    setupStats(enable) {
        // tslint:disable-next-line:no-unused-expression
        new Statistics_1.PerformanceStatistics(enable, 1000);
    }
    setupRenderer() {
        this.m_renderer.setClearColor(DEFAULT_CLEAR_COLOR);
        this.m_scene.add(this.m_mapTilesRoot);
        this.m_scene.add(this.m_mapAnchors);
    }
    createTextRenderer() {
        const updateCallback = () => {
            this.update();
        };
        return new TextElementsRenderer_1.TextElementsRenderer(new MapViewState_1.MapViewState(this, this.checkIfTilesChanged.bind(this)), this.m_camera, updateCallback, this.m_screenCollisions, this.m_screenProjector, new TextCanvasFactory_1.TextCanvasFactory(this.m_renderer), this.m_poiManager, new PoiRendererFactory_1.PoiRendererFactory(this), new FontCatalogLoader_1.FontCatalogLoader(this.m_theme), this.m_theme, this.m_options);
    }
    resetTextRenderer() {
        const overlayText = this.m_textElementsRenderer.overlayText;
        this.m_textElementsRenderer = this.createTextRenderer();
        if (overlayText !== undefined) {
            this.m_textElementsRenderer.addOverlayText(overlayText);
        }
    }
    limitFov(fov, aspect) {
        fov = THREE.Math.clamp(fov, MIN_FIELD_OF_VIEW, MAX_FIELD_OF_VIEW);
        let hFov = THREE.Math.radToDeg(Utils_1.MapViewUtils.calculateHorizontalFovByVerticalFov(THREE.Math.degToRad(fov), aspect));
        if (hFov > MAX_FIELD_OF_VIEW || hFov < MIN_FIELD_OF_VIEW) {
            hFov = THREE.Math.clamp(hFov, MIN_FIELD_OF_VIEW, MAX_FIELD_OF_VIEW);
            fov = THREE.Math.radToDeg(Utils_1.MapViewUtils.calculateVerticalFovByHorizontalFov(THREE.Math.degToRad(hFov), aspect));
        }
        return fov;
    }
    /**
     * Sets the field of view calculation, and applies it immediately to the camera.
     *
     * @param type How to calculate the FOV
     */
    setFovOnCamera(fovCalculation, height) {
        let fov = 0;
        if (fovCalculation.type === "fixed") {
            this.calculateFocalLength(height);
            fov = fovCalculation.fov;
        }
        else {
            harp_utils_1.assert(this.m_focalLength !== 0);
            fov = Utils_1.MapViewUtils.calculateFovByFocalLength(this.m_focalLength, height);
        }
        this.m_camera.fov = this.limitFov(fov, this.m_camera.aspect);
    }
    /**
     * Sets the focal length based on the supplied fov and the height of the canvas. This must be
     * called at least once. This is necessary to be recalled when the [[FovCalculation]]'s type is
     * fixed. In such cases, when the height changes, the focal length must be readjusted whereas
     * the FOV stays the same. The opposite is true for the dynamic case, where the focal length is
     * fixed but the FOV changes.
     * @param height Height of the canvas in css / client pixels.
     */
    calculateFocalLength(height) {
        harp_utils_1.assert(this.m_options.fovCalculation !== undefined);
        this.m_focalLength = Utils_1.MapViewUtils.calculateFocalLengthByVerticalFov(THREE.Math.degToRad(this.m_options.fovCalculation.fov), height);
    }
    /**
     * Get canvas client size in css/client pixels.
     *
     * Supports canvases not attached to DOM, which have 0 as `clientWidth` and `clientHeight` by
     * calculating it from actual canvas size and current pixel ratio.
     */
    getCanvasClientSize() {
        const { clientWidth, clientHeight } = this.canvas;
        if (clientWidth === 0 ||
            clientHeight === 0 ||
            typeof clientWidth !== "number" ||
            typeof clientHeight !== "number") {
            const pixelRatio = this.m_renderer.getPixelRatio();
            return {
                width: Math.round(this.canvas.width / pixelRatio),
                height: Math.round(this.canvas.height / pixelRatio)
            };
        }
        else {
            return { width: clientWidth, height: clientHeight };
        }
    }
}
exports.MapView = MapView;


/***/ }),

/***/ "../harp-mapview/lib/MapViewFog.ts":
/*!*****************************************!*\
  !*** ../harp-mapview/lib/MapViewFog.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const THREE = __webpack_require__(/*! three */ "three");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-mapview/lib/Utils.ts");
/**
 * Manages the fog display in [[MapView]].
 */
class MapViewFog {
    /**
     * Constructs a `MapViewFog` instance.
     *
     * @param m_scene The scene used in [[MapView]] that contains the map objects.
     */
    constructor(m_scene) {
        this.m_scene = m_scene;
        this.m_enabled = true;
        this.m_fog = new THREE.Fog(0x000000); // Default color asked by DefinitelyTyped.
        this.m_fogIsDefined = false;
        this.m_cachedTheme = { styles: {} };
    }
    /**
     * Allows for disabling the fog, even if it is defined in the theme. Use this property for
     * custom views like the demo app's debug camera. However, if the theme does not define a
     * fog, enabling this property here has no effect.
     *
     * @param value A boolean that specifies whether the fog should be enabled or disabled.
     */
    set enabled(enableFog) {
        this.m_enabled = enableFog;
        if (enableFog && this.m_fogIsDefined && this.m_scene.fog === null) {
            this.add();
        }
        else if (!enableFog && this.m_scene.fog !== null) {
            this.remove();
        }
    }
    /**
     * Returns the current fog status, enabled or disabled.
     */
    get enabled() {
        return this.m_enabled;
    }
    /**
     * Sets the fog depending on the [[Theme]] instance provided. This function is called when a
     * theme is loaded. Fog is added only if the theme contains a fog definition with a:
     * - `color` property, used to set the fog color.
     * - `startRatio` property, used to set the start distance of the fog as a ratio of the far
     * clipping plane distance.
     *
     * @param theme A [[Theme]] instance.
     */
    reset(theme) {
        this.m_cachedTheme = theme;
        if (theme !== undefined &&
            theme.fog !== undefined &&
            theme.fog.color !== undefined &&
            theme.fog.startRatio !== undefined) {
            this.m_fogIsDefined = true;
            this.m_fog.color.set(theme.fog.color);
            if (this.m_enabled && this.m_scene.fog === null) {
                this.add();
            }
        }
        else {
            this.m_fogIsDefined = false;
            if (this.m_scene.fog !== null) {
                this.remove();
            }
        }
    }
    /**
     * Updates the fog at runtime, depending on the camera.
     *
     * @param camera An instance of a `THREE.Camera` with a `far` property.
     */
    update(mapView, viewDistance) {
        if (this.m_scene.fog !== null &&
            this.m_cachedTheme !== undefined &&
            this.m_cachedTheme.fog &&
            this.m_cachedTheme.fog.startRatio !== undefined &&
            (mapView.camera.far !== undefined || viewDistance !== undefined)) {
            // If maximum visibility range is available use it instead of camera.far distance,
            // this makes fog independent from dynamic camera planes and keeps consistent
            // distance based "melting" (fog) effect during a tilt.
            const viewRange = viewDistance !== undefined ? viewDistance : mapView.camera.far;
            // TODO: We may move below constants to theme Fog definition
            // Density of the fog when viewing straight along the horizon line.
            const horizontalDensity = 1.0;
            // Theoretical density of the fog when viewing straight from top to down.
            const verticalDensity = 0.0;
            // The fraction of the maximum viewing distance along the eye vector
            // to start applying the fog.
            const startRatio = this.m_cachedTheme.fog.startRatio;
            // The fraction of maximum viewing range at which fog fully covers geometry.
            const endRatio = 1.0;
            harp_utils_1.assert(startRatio <= endRatio);
            const t = Math.abs(Math.cos(Utils_1.MapViewUtils.extractCameraTilt(mapView.camera, mapView.projection)));
            const density = harp_utils_1.MathUtils.smoothStep(horizontalDensity, verticalDensity, t);
            this.m_fog.near = harp_utils_1.MathUtils.lerp(viewRange * startRatio, viewRange, 1.0 - density);
            this.m_fog.far = harp_utils_1.MathUtils.lerp(viewRange * endRatio, viewRange, density);
            this.m_fog.near = Math.min(this.m_fog.near, mapView.camera.far);
            this.m_fog.far = Math.min(this.m_fog.far, mapView.camera.far);
        }
    }
    /**
     * Handles fog addition.
     */
    add() {
        // When the fog is changed, ThreeJS takes care of recompiling its built-in materials...
        this.m_scene.fog = this.m_fog;
        // ...except the `RawShaderMaterial`, on purpose, so it needs to be updated from the app.
        this.setFogInRawShaderMaterials(true);
    }
    /**
     * Handles fog removal.
     */
    remove() {
        // When the fog is changed, ThreeJS takes care of recompiling its built-in materials...
        this.m_scene.fog = null;
        // ...except the `RawShaderMaterial`, on purpose, so it needs to be updated from the app.
        this.setFogInRawShaderMaterials(false);
    }
    /**
     * ThreeJS lets users manage the `RawShaderMaterial` themselves, so they need to be modified
     * explicitly.
     *
     * @see https://github.com/mrdoob/three.js/blob/dev/src/renderers/webgl/WebGLProgram.js#L298
     */
    setFogInRawShaderMaterials(enableFog) {
        this.m_scene.traverse(object => {
            if (!(object instanceof THREE.Mesh)) {
                return;
            }
            if (!(object.material instanceof THREE.Material)) {
                return;
            }
            // HighPrecisionLineMaterial does not support fog
            if (object.material instanceof harp_materials_1.HighPrecisionLineMaterial) {
                return;
            }
            // We may skip redundant updates.
            if (object.material.fog === enableFog) {
                return;
            }
            object.material.fog = enableFog;
            // Fog properties can't be easily changed at runtime (once the material
            // is rendered at least once) and thus requires building of new shader
            // program - force material update.
            object.material.needsUpdate = true;
        });
    }
}
exports.MapViewFog = MapViewFog;


/***/ }),

/***/ "../harp-mapview/lib/MapViewPoints.ts":
/*!********************************************!*\
  !*** ../harp-mapview/lib/MapViewPoints.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * `MapViewPoints` is a class to extend for the `"circles"` and `"squares"` [[Technique]]s to
 * implement raycasting of [[THREE.Points]] as expected in [[MapView]], that are in screen space. It
 * copies the behaviour of the `raycast` method in [[THREE.Points]] and dispatches it to its
 * children classes, [[Circles]] and [[Squares]], who hold the intersection testing in the
 * `testPoint` method. This class also has the ability to dismiss the testing via the
 * `enableRayTesting` flag.
 *
 * Its main motivation is to handle the point styles of XYZ projects.
 *
 * @see https://github.com/mrdoob/three.js/blob/master/src/objects/Points.js
 */
class MapViewPoints extends THREE.Points {
    constructor() {
        super(...arguments);
        /**
         * This allows to discard the ray testing.
         */
        this.enableRayTesting = true;
    }
    /**
     * This method is similar to the original method `raycast` in [[THREE.Points]] except that it
     * then calls the tailored `testPoint` method in the children classes to test intersections
     * depending on whether the points are circles or squares, which [[THREE.Points]] cannot do.
     *
     * @param raycaster The raycaster.
     * @param intersects The array to fill with the results.
     */
    raycast(raycaster, intersects) {
        if (!this.enableRayTesting) {
            return;
        }
        const geometry = this.geometry;
        const matrixWorld = this.matrixWorld;
        const screenCoords = raycaster.ray.origin
            .clone()
            .add(raycaster.ray.direction)
            .project(raycaster.camera);
        const mouseCoords = new THREE.Vector2(Math.ceil(((screenCoords.x + 1) / 2) * raycaster.width), Math.ceil(((1 - screenCoords.y) / 2) * raycaster.height));
        if (geometry instanceof THREE.BufferGeometry) {
            const point = new THREE.Vector3();
            const index = geometry.index;
            const attributes = geometry.attributes;
            const positions = attributes.position.array;
            if (index !== null) {
                const indices = index.array;
                for (let i = 0, il = indices.length; i < il; i++) {
                    const a = indices[i];
                    point.fromArray(positions, a * 3);
                    const pointInfo = getPointInfo(point, matrixWorld, raycaster);
                    if (pointInfo.pointIsOnScreen) {
                        this.testPoint(point, pointInfo.absoluteScreenPosition, mouseCoords, i, pointInfo.distance, intersects);
                    }
                }
            }
            else {
                for (let i = 0, l = positions.length / 3; i < l; i++) {
                    point.fromArray(positions, i * 3);
                    const pointInfo = getPointInfo(point, matrixWorld, raycaster);
                    if (pointInfo.pointIsOnScreen) {
                        this.testPoint(point, pointInfo.absoluteScreenPosition, mouseCoords, i, pointInfo.distance, intersects);
                    }
                }
            }
        }
        else {
            const vertices = geometry.vertices;
            for (let index = 0; index < vertices.length; index++) {
                const point = vertices[index];
                const pointInfo = getPointInfo(point, matrixWorld, raycaster);
                if (pointInfo.pointIsOnScreen) {
                    this.testPoint(point, pointInfo.absoluteScreenPosition, mouseCoords, index, pointInfo.distance, intersects);
                }
            }
        }
    }
}
exports.MapViewPoints = MapViewPoints;
function getPointInfo(point, matrixWorld, raycaster) {
    const worldPosition = point.clone();
    worldPosition.applyMatrix4(matrixWorld);
    const distance = worldPosition.distanceTo(raycaster.ray.origin);
    worldPosition.project(raycaster.camera);
    const relativeScreenPosition = new THREE.Vector2(worldPosition.x, worldPosition.y);
    const pointIsOnScreen = relativeScreenPosition.x < 1 &&
        relativeScreenPosition.x > -1 &&
        relativeScreenPosition.y < 1 &&
        relativeScreenPosition.y > -1;
    if (pointIsOnScreen) {
        worldPosition.x = ((worldPosition.x + 1) / 2) * raycaster.width;
        worldPosition.y = ((1 - worldPosition.y) / 2) * raycaster.height;
        const absoluteScreenPosition = new THREE.Vector2(worldPosition.x, worldPosition.y);
        return {
            absoluteScreenPosition,
            pointIsOnScreen,
            distance
        };
    }
    return {
        pointIsOnScreen
    };
}
/**
 * Point object that implements the raycasting of circles in screen space.
 */
class Circles extends MapViewPoints {
    /** @override */
    testPoint(point, screenPosition, pickCoordinates, index, distance, intersects) {
        const dx = screenPosition.x - pickCoordinates.x;
        const dy = screenPosition.y - pickCoordinates.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const radius = this.material.size / 2;
        if (dist <= radius) {
            intersects.push({
                point,
                distance,
                index,
                object: this
            });
        }
    }
}
exports.Circles = Circles;
/**
 * Point object that implements the raycasting of squares in screen space.
 */
class Squares extends MapViewPoints {
    /** @override */
    testPoint(point, screenPosition, pickCoordinates, index, distance, intersects) {
        const dx = screenPosition.x - pickCoordinates.x;
        const dy = screenPosition.y - pickCoordinates.y;
        const halfSize = this.material.size / 2;
        if (Math.abs(dx) <= halfSize && Math.abs(dy) <= halfSize) {
            intersects.push({
                point,
                distance,
                index,
                object: this
            });
        }
    }
}
exports.Squares = Squares;


/***/ }),

/***/ "../harp-mapview/lib/PathBlockingElement.ts":
/*!**************************************************!*\
  !*** ../harp-mapview/lib/PathBlockingElement.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * This path in world coordinates is projected to screen space and blocks all other labels.
 *
 * It could be used for example:
 * - Border rejects labels.
 * - Route blocks street labels from being rendered underneath.
 *
 * Could potentially be expanded in future to have a priority, however for now, this isn't required.
 */
class PathBlockingElement {
    /**
     * Constructs a path from a list of points.
     * Pre allocates the [[screenSpaceLines]] used to render.
     * @param points Points in world coordinates.
     */
    constructor(points) {
        this.points = points;
        this.screenSpaceLines = new Array(points.length >= 2 ? points.length - 1 : 0);
        for (let i = 0; i < this.screenSpaceLines.length; i++) {
            this.screenSpaceLines[i] = new THREE.Line3(new THREE.Vector3(), new THREE.Vector3());
        }
    }
}
exports.PathBlockingElement = PathBlockingElement;


/***/ }),

/***/ "../harp-mapview/lib/PickHandler.ts":
/*!******************************************!*\
  !*** ../harp-mapview/lib/PickHandler.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const MapViewPoints_1 = __webpack_require__(/*! ./MapViewPoints */ "../harp-mapview/lib/MapViewPoints.ts");
const RoadPicker_1 = __webpack_require__(/*! ./RoadPicker */ "../harp-mapview/lib/RoadPicker.ts");
/**
 * Describes the general type of a picked object.
 */
var PickObjectType;
(function (PickObjectType) {
    /**
     * Unspecified.
     */
    PickObjectType[PickObjectType["Unspecified"] = 0] = "Unspecified";
    /**
     * A point object.
     */
    PickObjectType[PickObjectType["Point"] = 1] = "Point";
    /**
     * A line object.
     */
    PickObjectType[PickObjectType["Line"] = 2] = "Line";
    /**
     * An area object.
     */
    PickObjectType[PickObjectType["Area"] = 3] = "Area";
    /**
     * The text part of a [[TextElement]]
     */
    PickObjectType[PickObjectType["Text"] = 4] = "Text";
    /**
     * The Icon of a [[TextElement]].
     */
    PickObjectType[PickObjectType["Icon"] = 5] = "Icon";
    /**
     * Any general 3D object, for example, a landmark.
     */
    PickObjectType[PickObjectType["Object3D"] = 6] = "Object3D";
})(PickObjectType = exports.PickObjectType || (exports.PickObjectType = {}));
/**
 * Handles the picking of scene geometry and roads.
 */
class PickHandler {
    constructor(mapView, camera, enableRoadPicking = true, enablePickTechnique = false) {
        this.mapView = mapView;
        this.camera = camera;
        this.enableRoadPicking = enableRoadPicking;
        this.enablePickTechnique = enablePickTechnique;
        this.m_plane = new THREE.Plane(new THREE.Vector3(0, 0, 1));
        if (enableRoadPicking) {
            this.m_roadPicker = new RoadPicker_1.RoadPicker(mapView);
        }
    }
    /**
     * The `RoadPicker` class manages picking of roads, which may not be pickable in THREE.js,
     * since their geometry is generated in the vertex shader. The `RoadPicker` requires that
     * all [[Tile]]s are registered before they can be picked successfully.
     */
    registerTile(tile) {
        return this.m_roadPicker !== undefined ? this.m_roadPicker.registerTile(tile) : undefined;
    }
    /**
     * Does a raycast on all objects in the scene; useful for picking. This function is Limited to
     * objects that THREE.js can raycast. However, any solid lines that have their geometry in the
     * shader cannot be tested for intersection.
     *
     * @param x The X position in CSS/client coordinates, without the applied display ratio.
     * @param y The Y position in CSS/client coordinates, without the applied display ratio.
     * @returns the list of intersection results.
     */
    intersectMapObjects(x, y) {
        const worldPos = this.mapView.getNormalizedScreenCoordinates(x, y);
        const rayCaster = this.mapView.raycasterFromScreenPoint(x, y);
        const pickResults = [];
        if (this.mapView.textElementsRenderer !== undefined) {
            const { clientWidth, clientHeight } = this.mapView.canvas;
            const screenX = worldPos.x * clientWidth * 0.5 * this.mapView.pixelRatio;
            const screenY = worldPos.y * clientHeight * 0.5 * this.mapView.pixelRatio;
            const scenePosition = new THREE.Vector2(screenX, screenY);
            this.mapView.textElementsRenderer.pickTextElements(scenePosition, pickResults);
        }
        // calculate objects intersecting the picking ray
        const intersects = rayCaster.intersectObjects(this.mapView.worldRootObject.children, true);
        for (const intersect of intersects) {
            const pickResult = {
                type: PickObjectType.Unspecified,
                point: intersect.point,
                distance: intersect.distance,
                intersection: intersect
            };
            if (intersect.object.userData === undefined ||
                intersect.object.userData.feature === undefined) {
                pickResults.push(pickResult);
                continue;
            }
            const featureData = intersect.object.userData.feature;
            if (this.enablePickTechnique) {
                pickResult.technique = intersect.object.userData.technique;
            }
            this.addObjInfo(featureData, intersect, pickResult);
            if (featureData.objInfos !== undefined) {
                const featureId = featureData.objInfos.length === 1
                    ? harp_datasource_protocol_1.getFeatureId(featureData.objInfos[0])
                    : undefined;
                pickResult.featureId = featureId;
            }
            let pickObjectType;
            switch (featureData.geometryType) {
                case harp_datasource_protocol_1.GeometryType.Point:
                case harp_datasource_protocol_1.GeometryType.Text:
                    pickObjectType = PickObjectType.Point;
                    break;
                case harp_datasource_protocol_1.GeometryType.Line:
                case harp_datasource_protocol_1.GeometryType.ExtrudedLine:
                case harp_datasource_protocol_1.GeometryType.SolidLine:
                case harp_datasource_protocol_1.GeometryType.TextPath:
                    pickObjectType = PickObjectType.Line;
                    break;
                case harp_datasource_protocol_1.GeometryType.Polygon:
                case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:
                    pickObjectType = PickObjectType.Area;
                    break;
                case harp_datasource_protocol_1.GeometryType.Object3D:
                    pickObjectType = PickObjectType.Object3D;
                    break;
                default:
                    pickObjectType = PickObjectType.Unspecified;
            }
            pickResult.type = pickObjectType;
            pickResults.push(pickResult);
        }
        if (this.enableRoadPicking) {
            const planeIntersectPosition = new THREE.Vector3();
            const cameraPos = this.mapView.camera.position.clone();
            rayCaster.setFromCamera(worldPos, this.mapView.camera);
            rayCaster.ray.intersectPlane(this.m_plane, planeIntersectPosition);
            this.mapView.forEachVisibleTile(tile => {
                this.m_roadPicker.intersectRoads(tile, cameraPos, planeIntersectPosition, pickResults);
            });
        }
        pickResults.sort((a, b) => {
            return a.distance - b.distance;
        });
        return pickResults;
    }
    addObjInfo(featureData, intersect, pickResult) {
        if (pickResult.intersection.object instanceof MapViewPoints_1.MapViewPoints) {
            pickResult.userData = featureData.objInfos[intersect.index];
            return;
        }
        else if (featureData.objInfos === undefined ||
            featureData.starts === undefined ||
            intersect.faceIndex === undefined) {
            return;
        }
        if (featureData.starts.length > 1) {
            let objInfosIndex = 0;
            for (const polygonStartFace of featureData.starts) {
                if (polygonStartFace > intersect.faceIndex * 3) {
                    break;
                }
                objInfosIndex++;
            }
            pickResult.userData = featureData.objInfos[objInfosIndex - 1];
        }
        else {
            pickResult.userData = featureData.objInfos[0];
        }
    }
}
exports.PickHandler = PickHandler;


/***/ }),

/***/ "../harp-mapview/lib/PickingRaycaster.ts":
/*!***********************************************!*\
  !*** ../harp-mapview/lib/PickingRaycaster.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Raycasting points is not supported as necessary in Three.js. This class extends a
 * [[THREE.Raycaster]] and adds the width / height of the canvas to allow picking of screen space
 * geometry.
 *
 * @internal
 */
class PickingRaycaster extends THREE.Raycaster {
    /**
     * Constructor.
     *
     * @param width the canvas width.
     * @param height the canvas height.
     */
    constructor(width, height) {
        super();
        this.width = width;
        this.height = height;
    }
}
exports.PickingRaycaster = PickingRaycaster;


/***/ }),

/***/ "../harp-mapview/lib/PolarTileDataSource.ts":
/*!**************************************************!*\
  !*** ../harp-mapview/lib/PolarTileDataSource.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const index_decoder_1 = __webpack_require__(/*! @here/harp-datasource-protocol/index-decoder */ "../harp-datasource-protocol/index-decoder.ts");
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const DataSource_1 = __webpack_require__(/*! ./DataSource */ "../harp-mapview/lib/DataSource.ts");
const DecodedTileHelpers_1 = __webpack_require__(/*! ./DecodedTileHelpers */ "../harp-mapview/lib/DecodedTileHelpers.ts");
const Tile_1 = __webpack_require__(/*! ./Tile */ "../harp-mapview/lib/Tile.ts");
/**
 * [[DataSource]] providing geometry for poles
 */
class PolarTileDataSource extends DataSource_1.DataSource {
    constructor({ name = "polar", styleSetName, minZoomLevel, maxZoomLevel, storageLevelOffset = -2, geometryLevelOffset = -1, debugTiles = false }) {
        super(name, styleSetName, minZoomLevel, maxZoomLevel, storageLevelOffset);
        this.m_tilingScheme = harp_geoutils_1.polarTilingScheme;
        this.m_maxLatitude = harp_geoutils_1.MathUtils.radToDeg(harp_geoutils_1.MercatorConstants.MAXIMUM_LATITUDE);
        this.m_geometryLevelOffset = geometryLevelOffset;
        this.m_debugTiles = debugTiles;
        this.cacheable = false;
    }
    /** @override */
    dispose() {
        if (this.m_northPoleMaterial) {
            this.m_northPoleMaterial.dispose();
            delete this.m_northPoleMaterial;
        }
        if (this.m_southPoleMaterial) {
            this.m_southPoleMaterial.dispose();
            delete this.m_southPoleMaterial;
        }
        if (this.m_styleSetEvaluator) {
            delete this.m_styleSetEvaluator;
        }
    }
    createMaterial(kind, styleSetEvaluator) {
        const env = new index_decoder_1.MapEnv({
            $geometryType: "polygon",
            $layer: "earth",
            kind
        });
        const techniques = styleSetEvaluator.getMatchingTechniques(env);
        return techniques.length !== 0
            ? DecodedTileHelpers_1.createMaterial({ technique: techniques[0], env })
            : undefined;
    }
    /** @override */
    setStyleSet(styleSet, definitions, languages) {
        this.dispose();
        if (styleSet !== undefined) {
            this.m_styleSetEvaluator = new index_decoder_1.StyleSetEvaluator(styleSet, definitions);
            this.m_northPoleMaterial = this.createMaterial("north_pole", this.m_styleSetEvaluator);
            this.m_southPoleMaterial = this.createMaterial("south_pole", this.m_styleSetEvaluator);
        }
        this.mapView.markTilesDirty(this);
    }
    /** @override */
    setTheme(theme, languages) {
        const styleSet = (this.styleSetName !== undefined && theme.styles && theme.styles[this.styleSetName]) ||
            [];
        this.setStyleSet(styleSet, theme.definitions, languages);
    }
    /** @override */
    canGetTile(zoomLevel, tileKey) {
        if (zoomLevel !== tileKey.level || tileKey.level < 1) {
            return false;
        }
        const { north, south } = this.m_tilingScheme.getGeoBox(tileKey);
        return north > this.m_maxLatitude || south < -this.m_maxLatitude;
    }
    /** @override */
    shouldSubdivide(zoomLevel, tileKey) {
        if (zoomLevel <= tileKey.level) {
            return false;
        }
        const { north, south } = this.m_tilingScheme.getGeoBox(tileKey);
        return north > this.m_maxLatitude || south < -this.m_maxLatitude;
    }
    /** @override */
    getTilingScheme() {
        return this.m_tilingScheme;
    }
    /** @override */
    getTile(tileKey) {
        const tile = new Tile_1.Tile(this, tileKey);
        this.createTileGeometry(tile);
        return tile;
    }
    get geometryLevelOffset() {
        return this.m_geometryLevelOffset;
    }
    set geometryLevelOffset(geometryLevelOffset) {
        this.m_geometryLevelOffset = geometryLevelOffset;
    }
    intersectEdge(latitude, a, b) {
        const latA = a.latitude;
        const latB = b.latitude;
        let lonA = a.longitude;
        let lonB = b.longitude;
        if (Math.abs(latA) === 90) {
            lonA = lonB;
        }
        if (Math.abs(latB) === 90) {
            lonB = lonA;
        }
        const deltaLat = latB - latA;
        const deltaLon = lonB - lonA;
        const scale = (latitude - latA) / deltaLat;
        return new harp_geoutils_1.GeoCoordinates(latitude, lonA + deltaLon * scale, 0);
    }
    createTileGeometry(tile) {
        const { north, south } = tile.geoBox;
        const isNorthPole = north > 0 && south >= 0;
        const material = isNorthPole ? this.m_northPoleMaterial : this.m_southPoleMaterial;
        if (material === undefined) {
            tile.forceHasGeometry(true);
            return;
        }
        const srcProjection = this.m_tilingScheme.projection;
        const dstProjection = this.projection;
        const maxLat = this.m_maxLatitude;
        const poleLat = isNorthPole ? maxLat : -maxLat;
        const box = this.m_tilingScheme.boundingBoxGenerator.getWorldBox(tile.tileKey);
        const pBL = srcProjection.unprojectPoint(new THREE.Vector3(box.min.x, box.min.y, 0));
        const pBR = srcProjection.unprojectPoint(new THREE.Vector3(box.max.x, box.min.y, 0));
        const pTR = srcProjection.unprojectPoint(new THREE.Vector3(box.max.x, box.max.y, 0));
        const pTL = srcProjection.unprojectPoint(new THREE.Vector3(box.min.x, box.max.y, 0));
        let points;
        let needsGeometryCut = false;
        // special case where tile contains half of the hemisphere
        if (tile.tileKey.level === 1) {
            const isLeftHalf = box.min.x === 0;
            const poleX = isLeftHalf ? box.max.x : box.min.x;
            const poleY = (box.max.y + box.min.y) / 2;
            const pPole = srcProjection.unprojectPoint(new THREE.Vector3(poleX, poleY, 0));
            // coordinates are not used, needed for right position
            const pXX = isLeftHalf ? pBL : pBR;
            points = isNorthPole
                ? isLeftHalf
                    ? [pPole, pTR, pXX, pBR]
                    : [pPole, pBL, pXX, pTL]
                : isLeftHalf
                    ? [pPole, pBR, pXX, pTR]
                    : [pPole, pTL, pXX, pBL];
            needsGeometryCut = true;
        }
        else {
            // ccw for north, cw for south
            points = isNorthPole ? [pBL, pBR, pTR, pTL] : [pBL, pTL, pTR, pBR];
            const lats = points.map(p => p.latitude);
            const lmax = Math.max(...lats);
            const lmin = Math.min(...lats);
            const isAllPointsOut = isNorthPole ? lmax < poleLat : lmin > poleLat;
            if (isAllPointsOut) {
                return;
            }
            const isSomePointsOut = isNorthPole ? lmin < poleLat : lmax > poleLat;
            needsGeometryCut = isSomePointsOut;
            if (needsGeometryCut) {
                const nearest = lats.indexOf(isNorthPole ? lmax : lmin);
                if (nearest !== 0) {
                    for (let i = 0; i < nearest; i++) {
                        points.push(points.shift());
                    }
                }
            }
        }
        if (needsGeometryCut) {
            const centerX = (box.min.x + box.max.x) / 2;
            const centerY = (box.min.y + box.max.y) / 2;
            const center = srcProjection.unprojectPoint(new THREE.Vector3(centerX, centerY, 0));
            harp_geoutils_1.TransverseMercatorUtils.alignLongitude(points, center);
            // points aligned as follows:
            // a - nearest to the pole, always in
            // b - next to nearest
            // c - farthes from the pole, always out
            // d - prev from nearest
            const a = points[0];
            const b = points[1];
            const c = points[2];
            const d = points[3];
            const inPointB = Math.abs(b.latitude) >= maxLat;
            const inPointD = Math.abs(d.latitude) >= maxLat;
            const cutStart = inPointB
                ? this.intersectEdge(poleLat, b, c)
                : this.intersectEdge(poleLat, a, b);
            const cutEnd = inPointD
                ? this.intersectEdge(poleLat, d, c)
                : this.intersectEdge(poleLat, a, d);
            points.splice(inPointB ? 2 : 1, 4, cutStart);
            const level = tile.tileKey.level - this.storageLevelOffset + this.m_geometryLevelOffset;
            // tslint:disable-next-line:no-bitwise
            const subdivisions = 1 << Math.max(0, level);
            const step = 360 / subdivisions;
            const cutIndexStart = Math.floor((cutStart.longitude + 180) / step);
            const cutIndexEnd = Math.ceil((cutEnd.longitude + 180) / step);
            for (let i = cutIndexStart + 1; i < cutIndexEnd; i++) {
                points.push(new harp_geoutils_1.GeoCoordinates(poleLat, i * step - 180, 0));
            }
            points.push(cutEnd);
            if (inPointD) {
                points.push(d);
            }
        }
        const g = new THREE.Geometry();
        for (const point of points) {
            const projected = dstProjection.projectPoint(point, new THREE.Vector3());
            g.vertices.push(projected.sub(tile.center));
        }
        for (let i = 1; i < points.length - 1; i++) {
            g.faces.push(isNorthPole ? new THREE.Face3(0, i, i + 1) : new THREE.Face3(0, i + 1, i));
        }
        const geometry = new THREE.BufferGeometry();
        geometry.fromGeometry(g);
        g.dispose();
        const mesh = new THREE.Mesh(geometry, material);
        mesh.userData = {
            dataSource: this.name,
            tileKey: tile.tileKey
        };
        if (this.m_debugTiles) {
            const color = Math.round(Math.abs(Math.sin(11 * tile.tileKey.mortonCode())) * 0xffffff);
            mesh.material = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.5 });
            tile.objects.push(new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color, wireframe: true })));
        }
        tile.objects.push(mesh);
    }
}
exports.PolarTileDataSource = PolarTileDataSource;


/***/ }),

/***/ "../harp-mapview/lib/RoadPicker.ts":
/*!*****************************************!*\
  !*** ../harp-mapview/lib/RoadPicker.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const Expr_1 = __webpack_require__(/*! @here/harp-datasource-protocol/lib/Expr */ "../harp-datasource-protocol/lib/Expr.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const DecodedTileHelpers_1 = __webpack_require__(/*! ./DecodedTileHelpers */ "../harp-mapview/lib/DecodedTileHelpers.ts");
const PickHandler_1 = __webpack_require__(/*! ./PickHandler */ "../harp-mapview/lib/PickHandler.ts");
const logger = harp_utils_1.LoggerManager.instance.create("RoadPicker");
const MAX_DISTANCE_ERROR = 0.01;
/**
 * The `RoadPicker` class manages picking of roads, which may not be pickable in THREE.js, since
 * their geometry is generated in the vertex shader.
 */
class RoadPicker {
    constructor(m_mapView) {
        this.m_mapView = m_mapView;
    }
    /**
     * Registers a tile with the `RoadPicker`. This function extracts line data from the [[Tile]],
     * but only if the tile has the necessary [[ExtendedTileInfo]] that allows for road features to
     * be reconstructed.
     *
     * @param tile The tile to register.
     */
    registerTile(tile) {
        harp_utils_1.assert(tile.decodedTile !== undefined);
        if (tile.decodedTile === undefined || tile.decodedTile.tileInfo === undefined) {
            return undefined;
        }
        const extendedTileInfo = tile.decodedTile.tileInfo;
        const lineFeatures = extendedTileInfo.lineGroup;
        if (lineFeatures === undefined || lineFeatures.numFeatures === 0) {
            // tileInfo not of expected type [[ExtendedTileInfo]]
            return undefined;
        }
        const widths = [];
        widths.length = lineFeatures.numFeatures;
        DecodedTileHelpers_1.compileTechniques(extendedTileInfo.techniqueCatalog);
        const mapView = this.m_mapView;
        for (let i = 0; i < lineFeatures.numFeatures; i++) {
            const technique = extendedTileInfo.techniqueCatalog[lineFeatures.techniqueIndex[i]];
            const isDynamic = technique.metricUnit === "Pixel" ||
                Expr_1.Expr.isExpr(technique.lineWidth) ||
                typeof technique.lineWidth === "string";
            widths[i] =
                technique.lineWidth !== undefined
                    ? isDynamic
                        ? () => {
                            const unitFactor = technique.metricUnit === "Pixel" ? mapView.pixelToWorld : 1.0;
                            return (harp_datasource_protocol_1.getPropertyValue(technique.lineWidth, mapView.env) *
                                unitFactor *
                                0.5);
                        }
                        : technique.lineWidth
                    : 1.0;
        }
        const objInfos = extendedTileInfo.lineGroup.userData;
        const roadIntersectionData = {
            ids: lineFeatures.featureIds,
            techniqueIndex: lineFeatures.techniqueIndex,
            starts: lineFeatures.positionIndex,
            widths,
            positions: lineFeatures.positions,
            techniques: extendedTileInfo.techniqueCatalog,
            objInfos
        };
        return roadIntersectionData;
    }
    /**
     * Tests the `pickPos` point for intersection with all roads on a tile.
     *
     * @param tile The tile to pick.
     * @param eyePos The WorldPosition of eye or camera to compute distances.
     * @param pickPos The WorldPosition of the picked point, on the plane.
     * @param results The existing array of [[PickResult]]; new results should be appended.
     */
    intersectRoads(tile, eyePos, pickPos, results) {
        if (tile.boundingBox.distanceToPoint(pickPos) > MAX_DISTANCE_ERROR) {
            // outside of bounding box of tile
            return false;
        }
        const roadIntersectionData = tile.roadIntersectionData;
        if (roadIntersectionData === undefined) {
            return false;
        }
        const ids = roadIntersectionData.ids;
        const techniques = roadIntersectionData.techniques;
        const techniqueIndices = roadIntersectionData.techniqueIndex;
        const numFeatures = ids.length;
        const positions = roadIntersectionData.positions;
        const widths = roadIntersectionData.widths;
        const px = pickPos.x - tile.center.x;
        const py = pickPos.y - tile.center.y;
        const pickDistance = pickPos.distanceTo(eyePos);
        if (widths.length !== ids.length ||
            ids.length !== techniqueIndices.length ||
            techniqueIndices.length !== roadIntersectionData.starts.length) {
            logger.error("The amount of widths, ids, techniqueIndices and starts has to be the same");
            return false;
        }
        for (let i = 0; i < numFeatures; i++) {
            const technique = techniques[techniqueIndices[i]];
            // if the technique is marked as background or as transient, we ignore it for picking
            if ( /*technique.isBackground === true ||*/technique.transient === true) {
                continue;
            }
            const featureStart = roadIntersectionData.starts[i];
            const featureEnd = i < numFeatures - 1
                ? roadIntersectionData.starts[i + 1]
                : roadIntersectionData.positions.length;
            let startX = positions[featureStart];
            let startY = positions[featureStart + 1];
            const widthEntry = widths[i];
            const actualWidth = Math.max(1, typeof widthEntry === "function" ? widthEntry() : widthEntry);
            const lineWidthSqr = actualWidth * actualWidth;
            let closestDistSqr = Number.MAX_VALUE;
            for (let j = featureStart + 2; j < featureEnd; j += 2) {
                const endX = positions[j];
                const endY = positions[j + 1];
                const distSqr = harp_utils_1.Math2D.distToSegmentSquared(px, py, startX, startY, endX, endY);
                if (distSqr < lineWidthSqr) {
                    if (distSqr < closestDistSqr) {
                        closestDistSqr = distSqr;
                    }
                }
                startX = endX;
                startY = endY;
            }
            if (closestDistSqr < Number.MAX_VALUE) {
                const roadPickResult = {
                    type: PickHandler_1.PickObjectType.Line,
                    point: pickPos,
                    distance: pickDistance,
                    distFromCenter: Math.sqrt(closestDistSqr),
                    featureId: ids[i],
                    positions: positions.slice(featureStart, featureEnd),
                    technique
                };
                this.addUserData(roadPickResult, i, roadIntersectionData.objInfos);
                results.push(roadPickResult);
            }
        }
        return false;
    }
    addUserData(roadPickResult, index, objInfos) {
        if (objInfos !== undefined && objInfos.length > 0) {
            roadPickResult.userData = Object.assign({}, objInfos[index]);
        }
    }
}
exports.RoadPicker = RoadPicker;


/***/ }),

/***/ "../harp-mapview/lib/ScreenCollisions.ts":
/*!***********************************************!*\
  !*** ../harp-mapview/lib/ScreenCollisions.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const THREE = __webpack_require__(/*! three */ "three");
const DebugContext_1 = __webpack_require__(/*! ./DebugContext */ "../harp-mapview/lib/DebugContext.ts");
// tslint:disable-next-line:no-var-requires
const RBush = __webpack_require__(/*! rbush */ "../../node_modules/rbush/rbush.min.js");
const logger = harp_utils_1.LoggerManager.instance.create("ScreenCollissions");
class CollisionBox extends harp_utils_1.Math2D.Box {
    constructor(box) {
        super();
        if (box !== undefined) {
            this.copy(box);
        }
    }
    copy(box) {
        if (box instanceof harp_utils_1.Math2D.Box) {
            this.set(box.x, box.y, box.w, box.h);
        }
        else if (box instanceof THREE.Box2) {
            this.set(box.min.x, box.min.y, box.max.x - box.min.x, box.max.y - box.min.y);
        }
        else {
            this.set(box.minX, box.minY, box.maxX - box.minX, box.maxY - box.minY);
        }
        return this;
    }
    get minX() {
        return this.x;
    }
    set minX(minX) {
        this.x = minX;
    }
    get maxX() {
        return this.x + this.w;
    }
    set maxX(maxX) {
        this.w = maxX - this.x;
    }
    get minY() {
        return this.y;
    }
    set minY(minY) {
        this.y = minY;
    }
    get maxY() {
        return this.y + this.h;
    }
    set maxY(maxY) {
        this.h = maxY - this.y;
    }
}
exports.CollisionBox = CollisionBox;
/**
 * Collision box with additional boxes defining tighter bounds for the enclosed feature
 * (e.g.glyph bounds for text).
 */
class DetailedCollisionBox extends CollisionBox {
    constructor(box, detailBoxes) {
        super(box);
        this.detailBoxes = detailBoxes;
    }
}
exports.DetailedCollisionBox = DetailedCollisionBox;
function isLineWithBound(box) {
    return box.line !== undefined;
}
exports.isLineWithBound = isLineWithBound;
const tmpCollisionBox = new CollisionBox();
class ScreenCollisions {
    /**
     * Constructs a new ScreenCollisions object.
     */
    constructor() {
        /** The screen bounding box. */
        this.screenBounds = new harp_utils_1.Math2D.Box();
        /** Tree of allocated bounds. */
        this.rtree = new RBush();
        //
    }
    /**
     * Resets the list of allocated screen bounds.
     */
    reset() {
        this.rtree.clear();
    }
    /**
     * Updates the screen bounds that are used to check if bounding boxes are visible.
     *
     * @param width The width of the container.
     * @param height The height of the container.
     */
    update(width, height) {
        this.screenBounds.set(width / -2, height / -2, width, height);
        this.reset();
    }
    /**
     * Marks the region of the screen intersecting with the given bounding box as allocated.
     *
     * @param bounds The bounding box in NDC scaled coordinates (i.e. top left is -width/2,
     * -height/2)
     */
    allocate(bounds) {
        const bbox = !(bounds instanceof CollisionBox) ? new CollisionBox(bounds) : bounds;
        this.rtree.insert(bbox);
    }
    /**
     * Inserts the given bounds into the rtree.
     *
     * @param bounds The bounding boxes (the bounding boxes must be in the space returned from the
     * ScreenProjector.project method).
     */
    allocateIBoxes(bounds) {
        this.rtree.load(bounds);
    }
    /**
     * Search for all bounds in the tree intersecting with the given box.
     * @param box The box used for the search.
     * @returns An array of all IBoxes intersecting with the given box.
     */
    search(box) {
        return this.rtree.search(box);
    }
    /**
     * Checks if the given bounding box is already allocated.
     *
     * @param bounds The bounding box in world coordinates.
     */
    isAllocated(bounds) {
        const collisionBox = bounds instanceof CollisionBox ? bounds : tmpCollisionBox.copy(bounds);
        const results = this.search(collisionBox);
        return this.intersectsDetails(collisionBox, results);
    }
    /**
     * Checks if the given screen bounds intersects with the frustum of the active camera.
     *
     * @param bounds The bounding box in world coordinates.
     */
    isVisible(bounds) {
        return this.screenBounds.intersects(bounds);
    }
    /**
     * Checks if the given screen bounds is contained within the frustum of the active camera.
     *
     * @param bounds The bounding box in world coordinates.
     */
    isFullyVisible(bounds) {
        return this.screenBounds.containsBox(bounds);
    }
    /**
     * Test whether a given [[CollisionBox]] intersects with any of the details in the specified
     * [[IBox]]es.
     *
     * @param testBox The box to test for intersection.
     * @param boxes The candidate boxes the test box may intersect with. It's assumed that the
     * global bounds of these boxes intersect with the given test box.
     * @returns `true` if any intersection found.
     */
    intersectsDetails(testBox, boxes) {
        for (const box of boxes) {
            if (box instanceof DetailedCollisionBox) {
                for (const detailBox of box.detailBoxes) {
                    if (detailBox.intersects(testBox)) {
                        return true;
                    }
                }
            }
            else if (isLineWithBound(box)) {
                const boundedLine = box;
                if (this.intersectsLine(testBox, boundedLine)) {
                    return true;
                }
            }
            else {
                return true;
            }
        }
        return false;
    }
    /**
     * Computes the intersection between the supplied CollisionBox and the LineWithBound.
     * @note The [[CollisionBox]] is in Screen Bounds space, whereas the line must be
     * in Screen Coordinate space
     * @deprecated Because this is meant just for testing.
     */
    intersectsLine(bbox, boundedLine) {
        const line = boundedLine.line;
        // Note, these aren't normalized, but it doesn't matter, we are just interested
        // in the sign.
        const lineXDiffTransformed = line.end.x - line.start.x;
        // Sign of bottom left, bottom right, top left and top right corners.
        let signBL;
        let signBR;
        let signTL;
        let signTR;
        if (lineXDiffTransformed !== 0) {
            const lineYDiffTransformed = line.end.y - line.start.y;
            const normalX = lineYDiffTransformed;
            const normalY = -lineXDiffTransformed;
            const D = line.start.y - (lineYDiffTransformed / lineXDiffTransformed) * line.start.x;
            signBL = Math.sign(bbox.minX * normalX + (bbox.minY - D) * normalY);
            signBR = Math.sign(bbox.maxX * normalX + (bbox.minY - D) * normalY);
            signTL = Math.sign(bbox.minX * normalX + (bbox.maxY - D) * normalY);
            signTR = Math.sign(bbox.maxX * normalX + (bbox.maxY - D) * normalY);
        }
        else {
            signBL = Math.sign(bbox.minX - line.start.x);
            signBR = Math.sign(bbox.maxX - line.start.x);
            signTL = Math.sign(bbox.minX - line.start.x);
            signTR = Math.sign(bbox.maxX - line.start.x);
        }
        return signBL !== signBR || signBL !== signTL || signBL !== signTR;
    }
}
exports.ScreenCollisions = ScreenCollisions;
/**
 * @hidden
 *
 * Shows requests for screen space during labelling in an HTML canvas, which should be sized like
 * the actual map canvas. It can be placed on top of the map canvas to show exactly which requests
 * for screen space were done.
 *
 * Also logs statistics.
 */
class ScreenCollisionsDebug extends ScreenCollisions {
    /**
     * Constructs a new ScreenCollisions object which renders its state to a 2D canvas.
     */
    constructor(debugCanvas) {
        super();
        /** 2D rendering context. */
        this.m_renderContext = null;
        this.m_renderingEnabled = false;
        this.m_numAllocations = 0;
        this.m_numSuccessfulTests = 0;
        this.m_numFailedTests = 0;
        this.m_numSuccessfulVisibilityTests = 0;
        this.m_numFailedVisibilityTests = 0;
        if (debugCanvas !== undefined && debugCanvas !== null) {
            this.m_renderContext = debugCanvas.getContext("2d");
        }
    }
    /**
     * Resets the list of allocated bounds and clears the debug canvas.
     * @override
     */
    reset() {
        super.reset();
        this.m_numAllocations = 0;
        this.m_numSuccessfulTests = 0;
        this.m_numFailedTests = 0;
        this.m_numSuccessfulVisibilityTests = 0;
        this.m_numFailedVisibilityTests = 0;
    }
    /**
     * Updates the screen bounds used to check if bounding boxes are visible.
     *
     * @param width The width of the container.
     * @param height The height of the container.
     * @override
     */
    update(width, height) {
        if (this.m_renderingEnabled) {
            logger.log(
            // tslint:disable-next-line: max-line-length
            `Allocations: ${this.m_numAllocations} Successful Tests: ${this.m_numSuccessfulTests} Failed Tests: ${this.m_numFailedTests}  Successful Visibility Tests: ${this.m_numSuccessfulVisibilityTests}  Failed Visibility Tests: ${this.m_numFailedVisibilityTests} `);
        }
        super.update(width, height);
        if (this.m_renderContext !== null) {
            this.m_renderContext.canvas.width = width;
            this.m_renderContext.canvas.height = height;
        }
        // activate in the browser with:
        // window.__debugContext.setValue("DEBUG_SCREEN_COLLISIONS", true)
        this.m_renderingEnabled = DebugContext_1.debugContext.getValue("DEBUG_SCREEN_COLLISIONS");
    }
    /**
     * Marks the region of the screen intersecting with the given bounding box as allocated.
     *
     * @param bounds the bounding box in world coordinates.
     * @override
     */
    allocate(bounds) {
        super.allocate(bounds);
        this.m_numAllocations++;
        if (this.m_renderingEnabled && this.m_renderContext !== null) {
            this.m_renderContext.strokeStyle = "#6666ff";
            this.m_renderContext.strokeRect(bounds.x - this.screenBounds.x, this.screenBounds.y + this.screenBounds.h - bounds.y - 1, bounds.w, -bounds.h);
        }
    }
    /** @override */
    allocateIBoxes(boundsArray) {
        for (const bounds of boundsArray) {
            this.m_numAllocations++;
            if (this.m_renderingEnabled && this.m_renderContext !== null) {
                this.m_renderContext.strokeStyle = "#aa2222";
                this.m_renderContext.strokeRect(bounds.minX - this.screenBounds.x, this.screenBounds.y + this.screenBounds.h - bounds.minY - 1, bounds.maxX - bounds.minX, -(bounds.maxY - bounds.minY));
            }
        }
        super.allocateIBoxes(boundsArray);
    }
    /** @override */
    intersectsDetails(testBox, boxes) {
        const collisionFound = super.intersectsDetails(testBox, boxes);
        if (this.m_renderingEnabled && this.m_renderContext !== null) {
            const offset = collisionFound ? 2 : 0;
            this.m_renderContext.strokeStyle = collisionFound ? "#FF0000" : "#00ff00";
            this.m_renderContext.strokeRect(testBox.x - this.screenBounds.x - offset, this.screenBounds.y + this.screenBounds.h - testBox.y - 1 + offset, testBox.w + 2 * offset, -testBox.h - 2 * offset);
        }
        if (collisionFound) {
            this.m_numFailedTests++;
        }
        else {
            this.m_numSuccessfulTests++;
        }
        return collisionFound;
    }
    /**
     * Checks if the given screen bounds intersects with the frustum of the active camera.
     *
     * @param bounds The bounding box in world coordinates.
     * @override
     */
    isVisible(bounds) {
        const visible = super.isVisible(bounds);
        if (visible) {
            this.m_numSuccessfulVisibilityTests++;
        }
        else {
            this.m_numFailedVisibilityTests++;
        }
        return visible;
    }
}
exports.ScreenCollisionsDebug = ScreenCollisionsDebug;


/***/ }),

/***/ "../harp-mapview/lib/ScreenProjector.ts":
/*!**********************************************!*\
  !*** ../harp-mapview/lib/ScreenProjector.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Determines whether a position in NDC (Normalized Device Coordinates) is inside the screen.
 * @param ndc The position to check.
 */
function isOnScreen(ndc) {
    return ndc.z > -1 && ndc.z < 1 && ndc.x >= -1 && ndc.x <= 1 && ndc.y >= -1 && ndc.y <= 1;
}
/**
 * @hidden
 * Handles the projection of world coordinates to screen coordinates.
 */
class ScreenProjector {
    /**
     * Constructs a new `ScreenProjector`.
     *
     * @param m_camera Camera to project against.
     */
    constructor(m_camera) {
        this.m_camera = m_camera;
        this.m_width = 0;
        this.m_height = 0;
    }
    /**
     * Height of the screen.
     */
    get width() {
        return this.m_width;
    }
    /**
     * Width of the screen.
     */
    get height() {
        return this.m_height;
    }
    /**
     * Apply current projectionViewMatrix of the camera to project the source vector into
     * screen coordinates.
     *
     * @param {(Vector3Like)} source The source vector to project.
     * @param {THREE.Vector2} target The target vector.
     * @returns {THREE.Vector2} The projected vector (the parameter 'target') or undefined if
     * outside the near / far plane.
     */
    project(source, target = new THREE.Vector2()) {
        const p = this.projectVector(source, ScreenProjector.tempV3);
        if (p.z > -1 && p.z < 1) {
            return this.ndcToScreen(p, target);
        }
        return undefined;
    }
    /**
     * Apply current projectionViewMatrix of the camera to project the source vector into
     * screen coordinates.
     *
     * @param {(Vector3Like)} source The source vector to project.
     * @param {THREE.Vector2} target The target vector.
     * @returns {THREE.Vector2} The projected vector (the parameter 'target') or undefined if
     * outside the screen.
     */
    projectOnScreen(source, target = new THREE.Vector2()) {
        const p = this.projectVector(source, ScreenProjector.tempV3);
        if (isOnScreen(p)) {
            return this.ndcToScreen(p, target);
        }
        return undefined;
    }
    /**
     * Apply current projectionViewMatrix of the camera to project the source vector into
     * screen coordinates. The z component between -1 and 1 is also returned.
     *
     * @param {(Vector3Like)} source The source vector to project.
     * @param {THREE.Vector3} target The target vector.
     * @returns {THREE.Vector3} The projected vector (the parameter 'target') or undefined if
     * outside the near / far plane.
     */
    project3(source, target = new THREE.Vector3()) {
        const p = this.projectVector(source, ScreenProjector.tempV3);
        if (p.z > -1 && p.z < 1) {
            target.set((p.x * this.m_width) / 2, (p.y * this.m_height) / 2, p.z);
            return target;
        }
        return undefined;
    }
    /**
     * Apply current projectionViewMatrix of the camera to project the source vector. Stores
     * result in NDC in the target vector.
     *
     * @param {(Vector3Like)} source The source vector to project.
     * @param {THREE.Vector3} target The target vector.
     * @returns {THREE.Vector3} The projected vector (the parameter 'target').
     */
    projectVector(source, target) {
        target.set(source.x, source.y, source.z).project(this.m_camera);
        return target;
    }
    /**
     * Fast test to check if projected point is on screen.
     *
     * @returns {boolean} `true` if point is on screen, `false` otherwise.
     */
    onScreen(source) {
        const p = this.projectVector(source, ScreenProjector.tempV3);
        return isOnScreen(p);
    }
    /**
     * Update the `ScreenProjector` with the latest values of the screen and the camera.
     *
     * @param {THREE.Camera} camera Camera to project against.
     * @param {number} width Width of screen/canvas.
     * @param {number} height Height of screen/canvas.
     */
    update(camera, width, height) {
        this.m_camera = camera;
        this.m_width = width;
        this.m_height = height;
    }
    ndcToScreen(ndc, screenCoords) {
        return screenCoords.set((ndc.x * this.m_width) / 2, (ndc.y * this.m_height) / 2);
    }
}
exports.ScreenProjector = ScreenProjector;
ScreenProjector.tempV2 = new THREE.Vector2();
ScreenProjector.tempV3 = new THREE.Vector3();


/***/ }),

/***/ "../harp-mapview/lib/SkyBackground.ts":
/*!********************************************!*\
  !*** ../harp-mapview/lib/SkyBackground.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const SkyCubemapTexture_1 = __webpack_require__(/*! ./SkyCubemapTexture */ "../harp-mapview/lib/SkyCubemapTexture.ts");
const SkyGradientTexture_1 = __webpack_require__(/*! ./SkyGradientTexture */ "../harp-mapview/lib/SkyGradientTexture.ts");
/**
 * Class that handles [[MapView]]'s sky background.
 */
class SkyBackground {
    /**
     * Constructs a new `SkyBackground`.
     *
     * @param m_sky Sky configuration parameters.
     * @param m_projectionType [[MapView]]'s projection type.
     * @param camera [[MapView]]'s camera.
     */
    constructor(m_sky, m_projectionType, camera) {
        this.m_sky = m_sky;
        this.m_projectionType = m_projectionType;
        switch (this.m_sky.type) {
            case "gradient":
                this.m_skyTexture = new SkyGradientTexture_1.SkyGradientTexture(this.m_sky, this.m_projectionType);
                this.updateCamera(camera);
                break;
            case "cubemap": {
                this.m_skyTexture = new SkyCubemapTexture_1.SkyCubemapTexture(this.m_sky);
                break;
            }
        }
    }
    /**
     * Disposes allocated resources.
     */
    dispose() {
        this.m_skyTexture.dispose();
    }
    /**
     * Sky texture.
     */
    get texture() {
        return this.m_skyTexture.texture;
    }
    /**
     * This method updates the skybox based on the camera position (needed for some types of sky).
     *
     * @param camera The camera used in the map view.
     */
    updateCamera(camera) {
        if (this.m_sky.type === "gradient") {
            this.m_skyTexture.update(camera);
        }
    }
    /**
     * Updates the sky texture with new parameters.
     *
     * @param params New sky configuration parameters.
     * @param projectionType Which projection is used, this may also change (in which case the
     * textures should be recreated).
     */
    updateTexture(params, projectionType) {
        const isSameSkyType = this.m_sky.type === params.type && this.m_projectionType === projectionType;
        switch (params.type) {
            case "gradient":
                if (isSameSkyType) {
                    this.m_skyTexture.updateTexture(params);
                }
                else {
                    this.m_skyTexture = new SkyGradientTexture_1.SkyGradientTexture(params, projectionType);
                }
                break;
            case "cubemap": {
                if (isSameSkyType) {
                    this.m_skyTexture.updateTexture(params);
                }
                else {
                    this.m_skyTexture = new SkyCubemapTexture_1.SkyCubemapTexture(params);
                }
                break;
            }
        }
        this.m_projectionType = projectionType;
        this.m_sky = params;
    }
}
exports.SkyBackground = SkyBackground;


/***/ }),

/***/ "../harp-mapview/lib/SkyCubemapTexture.ts":
/*!************************************************!*\
  !*** ../harp-mapview/lib/SkyCubemapTexture.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const three_1 = __webpack_require__(/*! three */ "three");
const logger = harp_utils_1.LoggerManager.instance.create("SkyCubemapTexture");
/**
 * Number of faces that form a [[SkyCubemapTexture]].
 */
exports.SKY_CUBEMAP_FACE_COUNT = 6;
/**
 * Maps the faceId to the expected position in the threejs faces array.
 */
var SkyCubemapFaceId;
(function (SkyCubemapFaceId) {
    SkyCubemapFaceId[SkyCubemapFaceId["positiveX"] = 0] = "positiveX";
    SkyCubemapFaceId[SkyCubemapFaceId["negativeX"] = 1] = "negativeX";
    SkyCubemapFaceId[SkyCubemapFaceId["positiveY"] = 2] = "positiveY";
    SkyCubemapFaceId[SkyCubemapFaceId["negativeY"] = 3] = "negativeY";
    SkyCubemapFaceId[SkyCubemapFaceId["positiveZ"] = 4] = "positiveZ";
    SkyCubemapFaceId[SkyCubemapFaceId["negativeZ"] = 5] = "negativeZ";
})(SkyCubemapFaceId = exports.SkyCubemapFaceId || (exports.SkyCubemapFaceId = {}));
/**
 * Class that handles loading all 6 faces of a [[CubeTexture]], to be used with [[SkyBackground]].
 */
class SkyCubemapTexture {
    /**
     * Constructs a new `SkyCubemapTexture`.
     *
     * @param sky Initial [[CubemapSky]] configuration.
     */
    constructor(sky) {
        const faces = this.createCubemapFaceArray(sky);
        this.m_skybox =
            faces !== undefined ? new three_1.CubeTextureLoader().load(faces) : new three_1.CubeTexture();
    }
    /**
     * Disposes allocated resources.
     */
    dispose() {
        this.m_skybox.dispose();
    }
    /**
     * `SkyCubemapTexture`'s texture resource.
     */
    get texture() {
        return this.m_skybox;
    }
    /**
     * Updates the `SkyCubemapTexture` with new parameters.
     *
     * @param params New [[CubemapSky]] configuration.
     */
    updateTexture(sky) {
        const faces = this.createCubemapFaceArray(sky);
        if (faces === undefined) {
            return;
        }
        this.m_skybox = new three_1.CubeTextureLoader().load(faces);
    }
    createCubemapFaceArray(sky) {
        const faces = [
            undefined,
            undefined,
            undefined,
            undefined,
            undefined,
            undefined
        ];
        for (let i = 0; i < exports.SKY_CUBEMAP_FACE_COUNT; ++i) {
            const face = sky[SkyCubemapFaceId[i]];
            if (face === undefined) {
                logger.error(`Face "${SkyCubemapFaceId[i]}" was not defined.`);
                return;
            }
            faces[i] = face;
        }
        return faces;
    }
}
exports.SkyCubemapTexture = SkyCubemapTexture;


/***/ }),

/***/ "../harp-mapview/lib/SkyGradientTexture.ts":
/*!*************************************************!*\
  !*** ../harp-mapview/lib/SkyGradientTexture.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const three_1 = __webpack_require__(/*! three */ "three");
exports.DEFAULT_TEXTURE_SIZE = 512;
exports.DEFAULT_MONOMIAL_POWER = 1;
// Vectors used for skybox bitmap computation.
const cameraDir = [
    new three_1.Vector3(1, 0, 0),
    new three_1.Vector3(-1, 0, 0),
    new three_1.Vector3(0, -1, 0),
    new three_1.Vector3(0, 1, 0),
    new three_1.Vector3(0, 0, 1),
    new three_1.Vector3(0, 0, -1)
];
const cameraRight = [
    new three_1.Vector3(0, 0, -1),
    new three_1.Vector3(0, 0, 1),
    new three_1.Vector3(1, 0, 0),
    new three_1.Vector3(1, 0, 0),
    new three_1.Vector3(1, 0, 0),
    new three_1.Vector3(-1, 0, 0)
];
const cameraUp = [
    new three_1.Vector3(0, 1, 0),
    new three_1.Vector3(0, 1, 0),
    new three_1.Vector3(0, 0, 1),
    new three_1.Vector3(0, 0, -1),
    new three_1.Vector3(0, 1, 0),
    new three_1.Vector3(0, 1, 0)
];
/**
 * Class tha generates a texture containing a linear gradient, to be used with [[SkyBackground]].
 *
 * The gradient is mapped onto a sphere, where `topColor` maps to the top of the upper hemisphere,
 * `bottomColor` to the bottom of the upper hemisphere, and `groundColor` fills the bottom
 *  hemisphere..
 */
class SkyGradientTexture {
    /**
     * Constructs a new `SkyGradientTexture`.
     *
     * @param sky Initial [[GradientSky]] configuration.
     * @param m_projectionType [[MapView]]'s projection type.
     * @param m_height Optional height parameter.
     */
    constructor(sky, m_projectionType, m_height = exports.DEFAULT_TEXTURE_SIZE) {
        this.m_projectionType = m_projectionType;
        this.m_height = m_height;
        const topColor = new three_1.Color(sky.topColor);
        const bottomColor = new three_1.Color(sky.bottomColor);
        const groundColor = new three_1.Color(sky.groundColor);
        this.m_width = this.m_projectionType === harp_geoutils_1.ProjectionType.Planar ? 1.0 : this.m_height;
        this.m_faceCount = this.m_projectionType === harp_geoutils_1.ProjectionType.Planar ? 1.0 : 6.0;
        this.m_faces = [];
        for (let i = 0; i < this.m_faceCount; ++i) {
            const data = new Uint8Array(3 * this.m_width * this.m_height);
            this.fillTextureData(data, i, topColor, bottomColor, groundColor, sky.monomialPower);
            const texture = new three_1.DataTexture(data, this.m_width, this.m_height, three_1.RGBFormat);
            texture.needsUpdate = true;
            texture.unpackAlignment = 1;
            this.m_faces.push(texture);
        }
        if (this.m_projectionType === harp_geoutils_1.ProjectionType.Spherical) {
            this.m_skybox = new three_1.CubeTexture(this.m_faces);
            this.m_skybox.needsUpdate = true;
        }
        else {
            this.m_farClipPlaneDividedVertically = new three_1.Line3();
            this.m_groundPlane = new three_1.Plane(new three_1.Vector3(0, 0, 1));
            this.m_bottomMidFarPoint = new three_1.Vector3();
            this.m_topMidFarPoint = new three_1.Vector3();
            this.m_horizonPosition = new three_1.Vector3();
            this.m_farClipPlaneCorners = [
                new three_1.Vector3(),
                new three_1.Vector3(),
                new three_1.Vector3(),
                new three_1.Vector3()
            ];
        }
    }
    /**
     * Disposes allocated resources.
     */
    dispose() {
        for (let i = 0; i < this.m_faceCount; ++i) {
            this.m_faces[i].dispose();
        }
        if (this.m_projectionType === harp_geoutils_1.ProjectionType.Spherical) {
            this.m_skybox.dispose();
        }
    }
    /**
     * `SkyGradientTexture`'s texture resource (simple texture or cubemap depending on
     * [[MapView]]'s projection).
     */
    get texture() {
        return this.m_projectionType === harp_geoutils_1.ProjectionType.Planar ? this.m_faces[0] : this.m_skybox;
    }
    /**
     * This method updates the position of the texture depending on the camera frustum.
     *
     * @param camera The camera used in the map view.
     */
    update(camera) {
        if (this.m_projectionType === harp_geoutils_1.ProjectionType.Planar) {
            this.setHorizonPosition(camera);
            this.updateTexturePosition();
        }
    }
    /**
     * Updates the `SkyGradientTexture` with new parameters.
     *
     * @param params New [[GradientSky]] configuration.
     */
    updateTexture(sky) {
        for (let i = 0; i < this.m_faceCount; ++i) {
            this.fillTextureData(this.m_faces[i].image.data, i, new three_1.Color(sky.topColor), new three_1.Color(sky.bottomColor), new three_1.Color(sky.groundColor), sky.monomialPower);
            this.m_faces[i].needsUpdate = true;
        }
        if (this.m_projectionType === harp_geoutils_1.ProjectionType.Spherical) {
            this.m_skybox.needsUpdate = true;
        }
    }
    // When creating the texture, a Uint8Array is required, because the resulting texture passed
    // to the scene as a background, is a texImage2D object, that does not accept UintClampedArray
    // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D
    // But, when updating the texture, a Uint8ClampedArray is passed as argument, because
    // this.m_texture.image.data returns a Uint8ClampedArray. That's why this method accepts both.
    fillTextureData(data, faceIdx, topColor, bottomColor, groundColor, monomialPower) {
        const color = new three_1.Color();
        const dir = new three_1.Vector3();
        const right = new three_1.Vector3();
        const up = new three_1.Vector3();
        const upDir = new three_1.Vector3(0, 0, 1);
        for (let i = 0; i < this.m_height; ++i) {
            for (let j = 0; j < this.m_width; ++j) {
                if (this.m_projectionType === harp_geoutils_1.ProjectionType.Spherical) {
                    const offsetX = right
                        .copy(cameraRight[faceIdx])
                        .multiplyScalar(((j + 0.5) / this.m_width) * 2.0 - 1.0);
                    const offsetY = up
                        .copy(cameraUp[faceIdx])
                        .multiplyScalar(((i + 0.5) / this.m_height) * 2.0 - 1.0);
                    dir.copy(cameraDir[faceIdx])
                        .add(offsetX)
                        .add(offsetY)
                        .normalize();
                    const t = Math.max(upDir.dot(dir), 0);
                    color
                        .copy(groundColor)
                        .lerp(bottomColor, Math.min(t * 100, 1))
                        .lerp(topColor, t ** harp_utils_1.getOptionValue(monomialPower, exports.DEFAULT_MONOMIAL_POWER))
                        .multiplyScalar(255);
                }
                else {
                    const t = i / this.m_height;
                    if (i === 0) {
                        color.copy(groundColor).multiplyScalar(255);
                    }
                    else {
                        color
                            .copy(bottomColor)
                            .lerp(topColor, t ** harp_utils_1.getOptionValue(monomialPower, exports.DEFAULT_MONOMIAL_POWER))
                            .multiplyScalar(255);
                    }
                }
                data[i * this.m_width * 3 + j * 3] = color.r;
                data[i * this.m_width * 3 + j * 3 + 1] = color.g;
                data[i * this.m_width * 3 + j * 3 + 2] = color.b;
            }
        }
    }
    setHorizonPosition(camera) {
        this.m_farClipPlaneCorners[0].set(-1, -1, 1).unproject(camera);
        this.m_farClipPlaneCorners[1].set(1, -1, 1).unproject(camera);
        this.m_farClipPlaneCorners[2].set(-1, 1, 1).unproject(camera);
        this.m_farClipPlaneCorners[3].set(1, 1, 1).unproject(camera);
        this.m_bottomMidFarPoint.copy(this.m_farClipPlaneCorners[0])
            .add(this.m_farClipPlaneCorners[1])
            .multiplyScalar(0.5);
        this.m_topMidFarPoint.copy(this.m_farClipPlaneCorners[2])
            .add(this.m_farClipPlaneCorners[3])
            .multiplyScalar(0.5);
        this.m_farClipPlaneDividedVertically.set(this.m_bottomMidFarPoint, this.m_topMidFarPoint);
        const hasIntersection = this.m_groundPlane.intersectLine(this.m_farClipPlaneDividedVertically, this.m_horizonPosition);
        // When there is no intersection between the ground plane and the
        // farClipPlaneDividedVertically, be sure that the horizon is reset. Otherwise a previous
        // intersection point stored in the m_horizonPosition will be considered the valid one.
        if (!hasIntersection) {
            this.m_horizonPosition.set(0.0, 0.0, 0.0);
        }
    }
    updateTexturePosition() {
        const coveredBySky = this.m_bottomMidFarPoint.distanceTo(this.m_horizonPosition);
        const frustumHeight = this.m_farClipPlaneDividedVertically.distance();
        const skyRatio = coveredBySky / frustumHeight;
        // If there is no intersection between the ground plane and the line that defines the far
        // clip plane divided vertically, it means that there is no sky visible and therefore the
        // ground color should be displayed. When there is no intersection, the length of the
        // this.m_horizonPosition is still equal to zero, as threejs initialize an empty vector with
        // all the three components to zero.
        // If there is an intersection, calculate the offset.
        const ratio = this.m_horizonPosition.length() === 0 ? 1 : skyRatio - 2 / this.m_height;
        // If the bottom part of the far clipping plane is under the ground plane, scroll the
        // texture down. Otherwise, the camera is looking at the sky, therefore, scroll the texture
        // up.
        this.m_faces[0].offset.set(0, this.m_bottomMidFarPoint.z <= 0 ? -ratio : skyRatio);
    }
}
exports.SkyGradientTexture = SkyGradientTexture;


/***/ }),

/***/ "../harp-mapview/lib/Statistics.ts":
/*!*****************************************!*\
  !*** ../harp-mapview/lib/Statistics.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const logger = harp_utils_1.LoggerManager.instance.create("Statistics");
/**
 * A simple ring buffer to store the last `n` values of the timer. The buffer works on
 * a First-In-First-Out (FIFO) basis.
 */
class RingBuffer {
    /**
     * Sets up the ring buffer.
     *
     * @param capacity The buffer's capacity.
     */
    constructor(capacity) {
        this.capacity = capacity;
        this.buffer = new Array(capacity);
        this.capacity = capacity;
        this.head = this.tail = this.size = 0;
    }
    /**
     * Clears the contents, removes all elements.
     */
    clear() {
        this.head = this.tail = this.size = 0;
    }
    /**
     * Adds a single element to the ring buffer.
     *
     * @param data Data element.
     */
    enqOne(data) {
        let next = this.head + 1;
        if (next >= this.capacity) {
            next = 0;
        }
        if (this.size < this.capacity) {
            this.size++;
        }
        this.buffer[this.head] = data;
        this.head = next;
        if (this.size === this.capacity) {
            this.tail = this.head;
        }
    }
    /**
     * Adds one or more elements.
     *
     * @param data The elements to add.
     */
    enq(...data) {
        for (const v of data) {
            this.enqOne(v);
        }
    }
    /**
     * Obtains the oldest element (FIFO). May throw an exception if a buffer underrun occurs.
     * Before calling this method, make sure that `size > 0`.
     */
    deq() {
        if (this.size === 0) {
            throw new Error("Ringbuffer underrun");
        }
        const data = this.buffer[this.tail];
        let next = this.tail + 1;
        if (next >= this.capacity) {
            next = 0;
        }
        if (this.size > 0) {
            this.size--;
        }
        this.tail = next;
        return data;
    }
    /**
     * Obtains the oldest element (FIFO) without removing it. Throws an exception if a buffer is
     * empty. Before calling this method, make sure that `size > 0`.
     */
    get top() {
        if (this.size === 0) {
            throw new Error("Ringbuffer underrun");
        }
        return this.buffer[this.tail];
    }
    /**
     * Obtains the latest element (LIFO) without removing it. Throws an exception if a buffer is
     * empty. Before calling this method, make sure that `size > 0`.
     */
    get bottom() {
        if (this.size === 0) {
            throw new Error("Ringbuffer underrun");
        }
        let previous = this.head - 1;
        if (previous < 0) {
            previous = this.capacity - 1;
        }
        return this.buffer[previous];
    }
    /**
     * Creates an iterator for the buffer.
     */
    iterator() {
        return new RingBuffer.Iterator(this);
    }
    /**
     * Returns a copy of the buffer, where the elements are properly sorted from oldest to newest.
     */
    asArray() {
        const array = new Array();
        for (let i = 0; i < this.size; i++) {
            array.push(this.buffer[(this.tail + i) % this.capacity]);
        }
        return array;
    }
}
exports.RingBuffer = RingBuffer;
(function (RingBuffer) {
    /**
     * A local class for RingBuffer<T>
     */
    class Iterator {
        /**
         * Creates an iterator for the ring buffer.
         *
         * @param m_buffer `Ringbuffer` to iterate over.
         * @param m_index Start index.
         */
        constructor(m_buffer, m_index = 0) {
            this.m_buffer = m_buffer;
            this.m_index = m_index;
        }
        /**
         * Gets the iterator's current value. This function does not fail even if an overrun occurs.
         * To detect an overrun, watch the result for [[next]].
         */
        get value() {
            return this.m_buffer.buffer[(this.m_buffer.tail + this.m_index) % this.m_buffer.capacity];
        }
        /**
         * Advances the iterator to the next element.
         *
         * @returns `true` if the iterator is still valid; `false` if an overrun occurs.
         */
        next() {
            this.m_index++;
            return this.m_index < this.m_buffer.size;
        }
    }
    RingBuffer.Iterator = Iterator;
})(RingBuffer = exports.RingBuffer || (exports.RingBuffer = {}));
/**
 * A simple timer that stores only the latest measurement.
 */
class SimpleTimer {
    constructor(statistics, name) {
        this.statistics = statistics;
        this.name = name;
        /** `true` if timer has been started. */
        this.running = false;
    }
    /**
     * Gets the latest measurement. This function may return `undefined` if no measurement
     * was done.
     */
    get value() {
        return this.m_currentValue;
    }
    /**
     * Sets the measurement value for the amount of time that has elapsed from start() to stop().
     * Use this function to override the timer's duration.
     *
     * @param val The timer's duration.
     */
    setValue(val) {
        this.m_currentValue = val;
    }
    /**
     * Resets the value to be able to start again.
     */
    reset() {
        this.m_currentValue = undefined;
    }
    /**
     * Starts the timer. Returns the current time, based on `Performance.now()`.
     */
    start() {
        if (!this.statistics.enabled) {
            return -1;
        }
        if (this.running) {
            throw new Error("Timer '" + this.name + "' is already running");
        }
        this.running = true;
        return (this.m_currentValue = harp_utils_1.PerformanceTimer.now());
    }
    /**
     * Stops the timer. Requires that the timer has started.
     */
    stop() {
        if (!this.statistics.enabled) {
            return -1;
        }
        if (!this.running) {
            throw new Error("Timer '" + this.name + "' has not been started");
        }
        else {
            // this.currentValue is a number now!
            const t = harp_utils_1.PerformanceTimer.now() - (this.m_currentValue || 0);
            this.m_currentValue = t;
            this.setValue(t);
            this.running = false;
            return t;
        }
    }
    /**
     * Samples the timer. Requires that the timer has started.
     *
     * @returns the current timer value; `-1` if statistics are disabled.
     */
    now() {
        if (!this.statistics.enabled) {
            return -1;
        }
        if (!this.running) {
            throw new Error("Timer '" + this.name + "' has not been started");
        }
        else {
            const t = harp_utils_1.PerformanceTimer.now() - (this.m_currentValue || 0);
            return t;
        }
    }
}
exports.SimpleTimer = SimpleTimer;
/**
 * A timer that stores the last `n` samples in a ring buffer.
 */
class SampledTimer extends SimpleTimer {
    /**
     * Creates a `SampledTimer` instance. Must still be added to statistics if it should be logged!
     *
     * @param statistics Statistics to use for management.
     * @param name Name of the timer. Use colons to build a hierarchy.
     */
    constructor(statistics, name) {
        super(statistics, name);
        this.statistics = statistics;
        this.name = name;
        /**
         * The number of times the timer has reset.
         */
        this.numResets = 0;
        /**
         * Maximum samples until the statistics are reset and updated, which may destroy a median
         * computation.
         */
        this.maxNumSamples = 1000;
        /**
         * The array of sampled values, its length cannot exceed `maxNumSamples`.
         */
        this.samples = new RingBuffer(this.maxNumSamples);
    }
    /**
     * Resets the timer and clears all of its historical values.
     * @override
     */
    reset() {
        super.reset();
        this.getStats();
        this.samples.clear();
        this.numResets++;
    }
    /**
     * Add a single measurement to the sample.
     *
     * @param val A measurement to add.
     * @override
     */
    setValue(val) {
        super.setValue(val);
        if (val !== undefined) {
            this.samples.enqOne(val);
        }
    }
    /**
     * Updates the `min`, `max`, `avg`, and `median` values. Currently, this function is expensive,
     * as it requires a copy of the sampled values.
     */
    getStats() {
        return computeArrayStats(this.samples.asArray());
    }
}
exports.SampledTimer = SampledTimer;
/**
 * Only exported for testing
 * @ignore
 *
 * Compute the [[ArrayStats]] for the passed in array of numbers.
 *
 * @param {number[]} samples Array containing sampled values. Will be modified (!) by sorting the
 *      entries.
 * @returns {(Stats | undefined)}
 */
function computeArrayStats(samples) {
    if (samples.length === 0) {
        return undefined;
    }
    samples.sort((a, b) => {
        return a - b;
    });
    const min = samples[0];
    const max = samples[samples.length - 1];
    let median;
    let median75;
    let median90;
    let median95;
    let median97;
    let median99;
    let median999;
    if (samples.length === 1) {
        median75 = median90 = median95 = median97 = median99 = median999 = median = samples[0];
    }
    else if (samples.length === 2) {
        median = samples[0] * 0.5 + samples[1] * 0.5;
        median75 = median90 = median95 = median97 = median99 = median999 = samples[1];
    }
    else {
        const mid = Math.floor(samples.length / 2);
        median =
            samples.length % 2 === 0 ? samples[mid - 1] * 0.5 + samples[mid] * 0.5 : samples[mid];
        const mid75 = Math.round(samples.length * 0.75) - 1;
        median75 = samples[mid75];
        const mid90 = Math.round(samples.length * 0.9) - 1;
        median90 = samples[mid90];
        const mid95 = Math.round(samples.length * 0.95) - 1;
        median95 = samples[mid95];
        const mid97 = Math.round(samples.length * 0.97) - 1;
        median97 = samples[mid97];
        const mid99 = Math.round(samples.length * 0.99) - 1;
        median99 = samples[mid99];
        const mid999 = Math.round(samples.length * 0.999) - 1;
        median999 = samples[mid999];
    }
    let sum = 0;
    for (let i = 0, l = samples.length; i < l; i++) {
        sum += samples[i];
    }
    const avg = sum / samples.length;
    return {
        min,
        max,
        avg,
        median,
        median75,
        median90,
        median95,
        median97,
        median99,
        median999,
        numSamples: samples.length
    };
}
exports.computeArrayStats = computeArrayStats;
/**
 * Only exported for testing
 * @ignore
 *
 * Compute the averages for the passed in array of numbers.
 *
 * @param {number[]} samples Array containing sampled values.
 * @returns {(Stats | undefined)}
 */
function computeArrayAverage(samples) {
    if (samples.length === 0) {
        return undefined;
    }
    let sum = 0;
    for (let i = 0, l = samples.length; i < l; i++) {
        sum += samples[i];
    }
    const avg = sum / samples.length;
    return avg;
}
exports.computeArrayAverage = computeArrayAverage;
/**
 * Measures a sequence of connected events, such as multiple processing stages in a function.
 * Each stage is identified with a timer name, that must be a valid timer in the statistics
 * object. Additionally, all timers within a `MultiStageTimer` must be unique.
 *
 * Internally, the `MultiStageTimer` manages a list of timers where at the end of each stage,
 * one timer stops and the next timer starts.
 */
class MultiStageTimer {
    /**
     * Defines the `MultiStageTimer` with a list of timer names that represent its stages.
     *
     * @param statistics The statistics object that manages the timers.
     * @param name Name of this `MultiStageTimer`.
     * @param stages List of timer names.
     */
    constructor(statistics, name, stages) {
        this.statistics = statistics;
        this.name = name;
        this.stages = stages;
        if (stages.length < 1) {
            throw new Error("MultiStageTimer needs stages");
        }
        stages.forEach(stage => {
            if (!statistics.hasTimer(stage)) {
                throw new Error("Unknown timer: " + stage);
            }
        });
    }
    /**
     * Gets the timer value for the last stage. If the `MultiStageTimer` did not finish its
     * last stage, the value is `undefined`.
     */
    get value() {
        return this.statistics.getTimer(this.stages[this.stages.length - 1]).value;
    }
    /**
     * Resets the timers across all stages.
     */
    reset() {
        if (!this.statistics.enabled) {
            return;
        }
        this.stages.forEach(stage => {
            this.statistics.getTimer(stage).reset();
        });
    }
    /**
     * Starts the `MultiStageTimer` at its first stage.
     */
    start() {
        this.stage = this.stages[0];
        return this.statistics.getTimer(this.stages[0]).value || -1;
    }
    /**
     * Stops the `MultiStageTimer`. Returns the measurement of the last stage, which may be
     * `undefined` if not all stages started.
     */
    stop() {
        this.stage = undefined;
        return this.value !== undefined ? this.value : -1;
    }
    /**
     * Gets the current stage.
     */
    get stage() {
        return this.currentStage;
    }
    /**
     * Sets the current stage. If a new stage is provided, the current timer (if available) is
     * stopped, and the next timer is started. If the timer in the next stage is `undefined`,
     * this is equivalent to calling `stop` on the `MultiStageTimer`.
     *
     * @param stage The next stage to start.
     */
    set stage(stage) {
        if (this.currentStage === stage) {
            return;
        }
        if (this.statistics.enabled && this.currentStage !== undefined) {
            this.statistics.getTimer(this.currentStage).stop();
        }
        this.currentStage = stage;
        if (this.statistics.enabled && this.currentStage !== undefined) {
            this.statistics.getTimer(this.currentStage).start();
        }
    }
}
exports.MultiStageTimer = MultiStageTimer;
/**
 * Manages a set of timers. The main objective of `Statistics` is to log these timers. You can
 * disable statistics to minimize their impact on performance.
 */
class Statistics {
    /**
     * Sets up a group of timers.
     *
     * @param name The statistics name, for logging purposes.
     * @param enabled If `false`, the timers do not measure the performance.
     */
    constructor(name, enabled = false) {
        this.name = name;
        this.enabled = enabled;
        this.timers = new Map();
        this.nullTimer = new SimpleTimer(this, "<null>");
    }
    /**
     * Adds a timer, based on the name specified.
     *
     * @param name The timer's name; must be unique.
     */
    createTimer(name, keepSamples = true) {
        const timer = keepSamples ? new SampledTimer(this, name) : new SimpleTimer(this, name);
        return this.addTimer(timer);
    }
    /**
     * Adds the timer specified.
     *
     * @param timer The timer's name, which must be unique within this statistics object.
     */
    addTimer(timer) {
        if (this.timers.get(timer.name) !== undefined) {
            throw new Error("Duplicate timer name: '" + timer.name + "'");
        }
        this.timers.set(timer.name, timer);
        return timer;
    }
    /**
     * Gets a timer by name.
     *
     * @param name The timer's name.
     */
    getTimer(name) {
        if (!this.enabled) {
            return this.nullTimer;
        }
        const t = this.timers.get(name);
        return t === undefined ? this.nullTimer : t;
    }
    /**
     * Checks if a timer with the specified name already exists.
     *
     * @param name The timer's name.
     * @returns `true` if a timer with `name` already exists; `false` otherwise.
     */
    hasTimer(name) {
        const t = this.timers.get(name);
        return t !== undefined;
    }
    /**
     * Resets all timers.
     */
    reset() {
        this.timers.forEach((timer) => {
            timer.reset();
        });
    }
    /**
     * Prints all values to the console.
     *
     * @param header Optional header line.
     * @param footer Optional footer line.
     */
    log(header, footer) {
        if (header !== undefined || this.name !== undefined) {
            logger.log(header !== undefined ? header : this.name);
        }
        let maxNameLength = 0;
        this.timers.forEach((timer) => {
            maxNameLength = Math.max(maxNameLength, timer.name.length);
        });
        // simple printing function for number limits the number of decimal points.
        const print = (v) => {
            return v !== undefined ? v.toFixed(5) : "?";
        };
        this.timers.forEach((timer) => {
            let s = timer.name + ": " + " ".repeat(maxNameLength - timer.name.length);
            s += print(timer.value);
            // sampled timers also update their stats and log them
            if (timer instanceof SampledTimer) {
                const simpleStats = timer.getStats();
                if (simpleStats !== undefined) {
                    s +=
                        `  [ min=${print(simpleStats.min)}, max=${print(simpleStats.max)}, ` +
                            `avg=${print(simpleStats.avg)}, med=${print(simpleStats.median)}, ` +
                            `med95=${print(simpleStats.median95)}, med99=${print(simpleStats.median99)}, ` +
                            `N=${print(simpleStats.numSamples)} ]`;
                }
            }
            logger.log(s);
        });
        if (footer !== undefined) {
            logger.log(footer);
        }
    }
}
exports.Statistics = Statistics;
/**
 * Class containing all counters, timers and events of the current frame.
 */
class FrameStats {
    constructor() {
        this.entries = new Map();
        this.messages = undefined;
    }
    /**
     * Retrieve the value of the performance number.
     *
     * @param name Name of the performance number.
     * @returns The value of the performance number or `undefined` if it has not been declared by
     *      `setValue` before.
     */
    getValue(name) {
        return this.entries.get(name);
    }
    /**
     * Set the value of the performance number.
     *
     * @param name Name of the performance number.
     * @param name New value of the performance number.
     */
    setValue(name, value) {
        this.entries.set(name, value);
    }
    /**
     * Add a value to the current value of the performance number. If the performance is not known,
     * it will be initialized with `value`.
     *
     * @param name Name of the performance number.
     * @param name Value to be added to the performance number.
     */
    addValue(name, value) {
        const oldValue = this.entries.get(name);
        this.entries.set(name, value + (oldValue === undefined ? 0 : oldValue));
    }
    /**
     * Add a text message to the frame, like "Font XYZ has been loaded"
     *
     * @param message The message to add.
     */
    addMessage(message) {
        if (this.messages === undefined) {
            this.messages = [];
        }
        this.messages.push(message);
    }
    /**
     * Reset all known performance values to `0` and the messages to `undefined`.
     */
    reset() {
        this.entries.forEach((value, name) => {
            this.entries.set(name, 0);
        });
        this.messages = undefined;
    }
}
exports.FrameStats = FrameStats;
/**
 * @ignore
 * Only exported for testing.
 *
 * Instead of passing around an array of objects, we store the frame statistics as an object of
 * arrays. This allows convenient computations from [[RingBuffer]],
 */
class FrameStatsArray {
    constructor(capacity = 0) {
        this.capacity = capacity;
        this.frameEntries = new Map();
        this.messages = new RingBuffer(capacity);
    }
    get length() {
        return this.messages.size;
    }
    reset() {
        this.frameEntries.forEach((buffer, name) => {
            buffer.clear();
        });
        this.messages.clear();
    }
    addFrame(frameStats) {
        const currentSize = this.length;
        const frameEntries = this.frameEntries;
        frameStats.entries.forEach((value, name) => {
            let buffer = frameEntries.get(name);
            if (buffer === undefined) {
                // If there is a buffer that has not been known before, add it to the known buffers,
                // fill it up with with 0 to the size of all the other buffers to make them of equal
                // size to make PerfViz happy.
                buffer = new RingBuffer(this.capacity);
                for (let i = 0; i < currentSize; i++) {
                    buffer.enqOne(0);
                }
                this.frameEntries.set(name, buffer);
            }
            buffer.enqOne(value);
        });
        this.messages.enq(frameStats.messages);
    }
    /**
     * Prints all values to the console.
     */
    log() {
        let maxNameLength = 0;
        this.frameEntries.forEach((buffer, name) => {
            maxNameLength = Math.max(maxNameLength, name.length);
        });
        // simple printing function for number limits the number of decimal points.
        const print = (v) => {
            return v !== undefined ? v.toFixed(5) : "?";
        };
        this.frameEntries.forEach((buffer, name) => {
            let s = name + ": " + " ".repeat(maxNameLength - name.length);
            const simpleStats = computeArrayStats(buffer.asArray());
            if (simpleStats !== undefined) {
                s +=
                    `  [ min=${print(simpleStats.min)}, max=${print(simpleStats.max)}, ` +
                        `avg=${print(simpleStats.avg)}, med=${print(simpleStats.median)}, ` +
                        `med95=${print(simpleStats.median95)}, med99=${print(simpleStats.median99)}, ` +
                        `N=${print(simpleStats.numSamples)} ]`;
            }
            logger.log(s);
        });
    }
}
exports.FrameStatsArray = FrameStatsArray;
/**
 * Performance measurement central. Maintains the current [[FrameStats]], which holds all individual
 * performance numbers.
 *
 * Implemented as an instance for easy access.
 */
class PerformanceStatistics {
    /**
     * Creates an instance of PerformanceStatistics. Overrides the current `instance`.
     *
     * @param {boolean} [enabled=true] If `false` the performance values will not be stored.
     * @param {number} [maxNumFrames=1000] The maximum number of frames that are to be stored.
     * @memberof PerformanceStatistics
     */
    constructor(enabled = true, maxNumFrames = 1000) {
        this.enabled = enabled;
        this.maxNumFrames = maxNumFrames;
        /**
         * Current frame statistics. Contains all values for the current frame. Will be cleared when
         * [[PerformanceStatistics#storeFrameInfo]] is called.
         *
         * @type {FrameStats}
         * @memberof PerformanceStatistics
         */
        this.currentFrame = new FrameStats();
        /**
         * Additional results stored for the current application run, not per frame. Only the last value
         * is stored.
         *
         * @type {(Map<string, number>)}
         */
        this.appResults = new Map();
        /**
         * Additional configuration values stored for the current application run, not per frame. Only
         * the last value is stored.
         *
         * @type {(Map<string, string>)}
         * @memberof PerformanceStatistics
         */
        this.configs = new Map();
        PerformanceStatistics.m_instance = this;
        this.m_frameEvents = new FrameStatsArray(maxNumFrames);
    }
    /**
     * Returns `true` when the maximum number of storable frames is reached.
     *
     * @readonly
     * @type {boolean}
     * @memberof PerformanceStatistics
     */
    get isFull() {
        return this.m_frameEvents.length >= this.maxNumFrames;
    }
    /**
     * Global instance to the instance. The current instance can be overridden by creating a new
     * `PerformanceStatistics`.
     */
    static get instance() {
        if (PerformanceStatistics.m_instance === undefined) {
            PerformanceStatistics.m_instance = new PerformanceStatistics(false, 0);
        }
        return PerformanceStatistics.m_instance;
    }
    /**
     * @ignore
     * Only exported for testing.
     *
     * Return the array of frame events.
     */
    get frameEvents() {
        return this.m_frameEvents;
    }
    /**
     * Clears all settings, all stored frame events as well as the current frame values.
     *
     * @memberof PerformanceStatistics
     */
    clear() {
        this.clearFrames();
        this.configs.clear();
        this.appResults.clear();
    }
    /**
     * Clears only all stored frame events as well as the current frame values.
     *
     * @memberof PerformanceStatistics
     */
    clearFrames() {
        this.m_frameEvents.reset();
        this.currentFrame.reset();
    }
    /**
     * Stores the current frame events into the array of events. Uses [[THREE.WebGLInfo]] to add the
     * render state information to the current frame.
     *
     * @param {THREE.WebGLInfo} webGlInfo
     * @returns {boolean} Returns `false` if the maximum number of storable frames has been reached.
     * @memberof PerformanceStatistics
     */
    storeFrameInfo(webGlInfo) {
        if (this.m_frameEvents.length >= this.maxNumFrames) {
            return false;
        }
        if (webGlInfo !== undefined) {
            if (webGlInfo.render !== undefined) {
                this.currentFrame.setValue("gl.numCalls", webGlInfo.render.calls === null ? 0 : webGlInfo.render.calls);
                this.currentFrame.setValue("gl.numPoints", webGlInfo.render.points === null ? 0 : webGlInfo.render.points);
                this.currentFrame.setValue("gl.numLines", webGlInfo.render.lines === null ? 0 : webGlInfo.render.lines);
                this.currentFrame.setValue("gl.numTriangles", webGlInfo.render.triangles === null ? 0 : webGlInfo.render.triangles);
            }
            if (webGlInfo.memory !== undefined) {
                this.currentFrame.setValue("gl.numGeometries", webGlInfo.memory.geometries === null ? 0 : webGlInfo.memory.geometries);
                this.currentFrame.setValue("gl.numTextures", webGlInfo.memory.textures === null ? 0 : webGlInfo.memory.textures);
            }
            if (webGlInfo.programs !== undefined) {
                this.currentFrame.setValue("gl.numPrograms", webGlInfo.programs === null ? 0 : webGlInfo.programs.length);
            }
        }
        if (window !== undefined && window.performance !== undefined) {
            const memory = window.performance.memory;
            if (memory !== undefined) {
                this.currentFrame.setValue("memory.totalJSHeapSize", memory.totalJSHeapSize);
                this.currentFrame.setValue("memory.usedJSHeapSize", memory.usedJSHeapSize);
                this.currentFrame.setValue("memory.jsHeapSizeLimit", memory.jsHeapSizeLimit);
            }
        }
        this.m_frameEvents.addFrame(this.currentFrame);
        this.currentFrame.reset();
        return true;
    }
    /**
     * Logs all values to the logger.
     *
     * @param header Optional header line.
     * @param footer Optional footer line.
     */
    log(header, footer) {
        logger.log(header !== undefined ? header : "PerformanceStatistics");
        const appResults = this.appResults;
        appResults.forEach((value, name) => {
            logger.log(name, value);
        });
        const configs = this.configs;
        configs.forEach((value, name) => {
            logger.log(name, value);
        });
        this.m_frameEvents.log();
        if (footer !== undefined) {
            logger.log(footer);
        }
    }
    /**
     * Convert to a plain object that can be serialized. Required to copy the test results over to
     * nightwatch.
     */
    getAsPlainObject(onlyLastFrame = false) {
        const appResults = {};
        const configs = {};
        const frames = {};
        const plainObject = {
            configs,
            appResults,
            frames
        };
        const appResultValues = this.appResults;
        appResultValues.forEach((value, name) => {
            appResults[name] = value;
        });
        const configValues = this.configs;
        configValues.forEach((value, name) => {
            configs[name] = value;
        });
        if (onlyLastFrame) {
            for (const [name, buffer] of this.m_frameEvents.frameEntries) {
                frames[name] = buffer.bottom;
            }
        }
        else {
            for (const [name, buffer] of this.m_frameEvents.frameEntries) {
                frames[name] = buffer.asArray();
            }
        }
        plainObject.messages = this.m_frameEvents.messages.asArray();
        return plainObject;
    }
    /**
     * Convert the last frame values to a plain object that can be serialized. Required to copy the
     * test results over to nightwatch.
     */
    getLastFrameStatistics() {
        return this.getAsPlainObject(true);
    }
    /**
     * Convert to a plain object that can be serialized. Required to copy the test results over to
     * nightwatch.
     */
    getAsSimpleFrameStatistics(onlyLastFrame = false) {
        const configs = new Map();
        const appResults = new Map();
        const frames = new Map();
        const simpleStatistics = {
            configs,
            appResults,
            frames,
            messages: this.m_frameEvents.messages.asArray()
        };
        const appResultValues = this.appResults;
        appResultValues.forEach((value, name) => {
            appResults.set(name, value);
        });
        const configValues = this.configs;
        configValues.forEach((value, name) => {
            configs.set(name, value);
        });
        if (onlyLastFrame) {
            for (const [name, buffer] of this.m_frameEvents.frameEntries) {
                frames.set(name, buffer.bottom);
            }
        }
        else {
            for (const [name, buffer] of this.m_frameEvents.frameEntries) {
                frames.set(name, buffer.asArray());
            }
        }
        return simpleStatistics;
    }
}
exports.PerformanceStatistics = PerformanceStatistics;
PerformanceStatistics.m_instance = undefined;


/***/ }),

/***/ "../harp-mapview/lib/ThemeHelpers.ts":
/*!*******************************************!*\
  !*** ../harp-mapview/lib/ThemeHelpers.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Returns `three.js` pixel format object basing on a [[PixelFormat]] specified.
 */
function toPixelFormat(format) {
    switch (format) {
        case "Alpha":
            return THREE.AlphaFormat;
        case "RGB":
            return THREE.RGBFormat;
        case "RGBA":
            return THREE.RGBAFormat;
        case "Luminance":
            return THREE.LuminanceFormat;
        case "LuminanceAlpha":
            return THREE.LuminanceAlphaFormat;
        case "RGBE":
            return THREE.RGBEFormat;
        case "Depth":
            return THREE.DepthFormat;
        case "DepthStencil":
            return THREE.DepthStencilFormat;
        case "Red":
            return THREE.RedFormat;
        default:
            throw new Error(`invalid pixel format: ${format}`);
    }
}
exports.toPixelFormat = toPixelFormat;
/**
 * Returns `three.js` texture data types based on a [[TextureDataType]] specified.
 */
function toTextureDataType(dataType) {
    switch (dataType) {
        case "UnsignedByte":
            return THREE.UnsignedByteType;
        case "Byte":
            return THREE.ByteType;
        case "Short":
            return THREE.ShortType;
        case "UnsignedShort":
            return THREE.UnsignedShortType;
        case "Int":
            return THREE.IntType;
        case "UnsignedInt":
            return THREE.UnsignedIntType;
        case "Float":
            return THREE.FloatType;
        case "HalfFloat":
            return THREE.HalfFloatType;
        default:
            throw new Error(`invalid texture data type: ${dataType}`);
    }
}
exports.toTextureDataType = toTextureDataType;
/**
 * Returns `three.js` wrapping mode object based on a [[WrappingMode]] specified.
 */
function toWrappingMode(mode) {
    switch (mode) {
        case "clamp":
            return THREE.ClampToEdgeWrapping;
        case "repeat":
            return THREE.RepeatWrapping;
        case "mirror":
            return THREE.MirroredRepeatWrapping;
        default:
            throw new Error(`invalid wrapping mode: ${mode}`);
    }
}
exports.toWrappingMode = toWrappingMode;
/**
 * Returns `three.js` texture filter object based on a [[MagFilter]] or [[MinFilter]] specified.
 */
function toTextureFilter(filter) {
    switch (filter) {
        case "nearest":
            return THREE.NearestFilter;
        case "nearestMipMapNearest":
            return THREE.NearestMipMapNearestFilter;
        case "nearestMipMapLinear":
            return THREE.NearestMipMapLinearFilter;
        case "linear":
            return THREE.LinearFilter;
        case "linearMipMapNearest":
            return THREE.LinearMipMapNearestFilter;
        case "linearMipMapLinear":
            return THREE.LinearMipMapLinearFilter;
        default:
            throw new Error(`invalid texture filter: ${filter}`);
    }
}
exports.toTextureFilter = toTextureFilter;
/**
 * Create a specific light for lightening the map.
 */
function createLight(lightDescription) {
    switch (lightDescription.type) {
        case "ambient": {
            const light = new THREE.AmbientLight(lightDescription.color, lightDescription.intensity);
            light.name = lightDescription.name;
            return light;
        }
        case "directional": {
            const light = new THREE.DirectionalLight(lightDescription.color, lightDescription.intensity);
            light.name = lightDescription.name;
            if (lightDescription.castShadow !== undefined) {
                light.castShadow = lightDescription.castShadow;
            }
            light.position.set(lightDescription.direction.x, lightDescription.direction.y, lightDescription.direction.z);
            light.position.normalize();
            return light;
        }
    }
}
exports.createLight = createLight;


/***/ }),

/***/ "../harp-mapview/lib/ThemeLoader.ts":
/*!******************************************!*\
  !*** ../harp-mapview/lib/ThemeLoader.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const Theme_1 = __webpack_require__(/*! @here/harp-datasource-protocol/lib/Theme */ "../harp-datasource-protocol/lib/Theme.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const SkyCubemapTexture_1 = __webpack_require__(/*! ./SkyCubemapTexture */ "../harp-mapview/lib/SkyCubemapTexture.ts");
__webpack_require__(/*! @here/harp-fetch */ "../harp-fetch/index.web.ts");
exports.DEFAULT_MAX_THEME_INTHERITANCE_DEPTH = 4;
/**
 * Loads and validates a theme from URL objects.
 */
class ThemeLoader {
    /**
     * Loads a [[Theme]] from a remote resource, provided as a URL that points to a
     * JSON-encoded theme.
     *
     * By default, resolves following features of theme:
     *
     *  -  `extends` - loads and merges all inherited themes (see [[resolveBaseTheme]])
     *  -  `ref` - resolves all `ref` instances to their values defined in `definitions` section
     *     of theme (see [[resolveThemeReferences]])
     *
     * Relative URIs of reference resources are resolved to full URL using the document's base URL
     * (see [[resolveUrls]]).
     *
     * Custom URIs (of theme itself and of resources referenced by theme) may be resolved with by
     * providing [[UriResolver]] using [[ThemeLoadOptions.uriResolver]] option.
     *
     * @param theme [[Theme]] instance or theme URL to the theme.
     * @param options Optional, a [[ThemeLoadOptions]] objects containing any custom settings for
     *    this load request.
     */
    static async load(theme, options) {
        options = options || {};
        if (typeof theme === "string") {
            const uriResolver = options.uriResolver;
            const themeUrl = uriResolver !== undefined ? uriResolver.resolveUri(theme) : theme;
            const response = await fetch(themeUrl, { signal: options.signal });
            if (!response.ok) {
                throw new Error(`ThemeLoader#load: cannot load theme: ${response.statusText}`);
            }
            theme = (await response.json());
            theme.url = harp_utils_1.resolveReferenceUri(harp_utils_1.getAppBaseUrl(), themeUrl);
            theme = this.resolveUrls(theme, options);
        }
        else if (theme.url === undefined) {
            // assume that theme url is same as baseUrl
            theme.url = harp_utils_1.getAppBaseUrl();
            theme = this.resolveUrls(theme, options);
        }
        if (theme === null || theme === undefined) {
            throw new Error("ThemeLoader#load: loaded resource is not valid JSON");
        }
        theme = theme;
        ThemeLoader.checkTechniqueSupport(theme);
        const resolveDefinitions = harp_utils_1.getOptionValue(options.resolveDefinitions, false);
        theme = await ThemeLoader.resolveBaseThemes(theme, options);
        if (resolveDefinitions) {
            const contextLoader = new harp_utils_1.ContextLogger(options.logger || console, `when processing Theme ${theme.url}:`);
            ThemeLoader.resolveThemeReferences(theme, contextLoader);
        }
        return theme;
    }
    /**
     * Checks if `theme` instance is completely loaded, meaning that `extends` property is resolved.
     *
     * @param theme
     */
    static isThemeLoaded(theme) {
        return theme.extends === undefined;
    }
    /**
     * @deprecated Please use `ThemeLoader.load`
     *
     * Loads a [[Theme]] from a remote resource, provided as a URL that points to a JSON-encoded
     * theme.
     *
     * @param themeUrl The URL to the theme.
     *
     */
    static async loadAsync(themeUrl) {
        return ThemeLoader.load(themeUrl);
    }
    /**
     * Resolves all [[Theme]]'s relatives URLs to full URL using the [[Theme]]'s URL
     * (see: https://www.w3.org/TR/WD-html40-970917/htmlweb.html#h-5.1.2).
     *
     * This method mutates original `theme` instance.
     *
     * @param theme The [[Theme]] to resolve.
     */
    static resolveUrls(theme, options) {
        var _a;
        // Ensure that all resources referenced in theme by relative URIs are in fact relative to
        // theme.
        if (theme.url === undefined) {
            return theme;
        }
        const childUrlResolver = harp_utils_1.composeUriResolvers((_a = options) === null || _a === void 0 ? void 0 : _a.uriResolver, new harp_utils_1.RelativeUriResolver(theme.url));
        const resolveIncludes = options === undefined || !(options.resolveIncludeUris === false);
        if (theme.extends && resolveIncludes) {
            theme.extends = (Array.isArray(theme.extends) ? theme.extends : [theme.extends]).map(baseTheme => {
                if (typeof baseTheme === "string") {
                    return childUrlResolver.resolveUri(baseTheme);
                }
                else {
                    if (baseTheme.url !== undefined) {
                        return baseTheme;
                    }
                    else {
                        baseTheme.url = theme.url;
                        return this.resolveUrls(baseTheme, options);
                    }
                }
            });
        }
        if (!ThemeLoader.convertFlatTheme(theme)) {
            return theme;
        }
        const resolveResources = options === undefined || !(options.resolveResourceUris === false);
        if (resolveResources) {
            ThemeLoader.resolveResources(theme, childUrlResolver);
        }
        return theme;
    }
    static checkTechniqueSupport(theme) {
        if (theme.styles !== undefined) {
            for (const styleSetName in theme.styles) {
                if (!theme.styles.hasOwnProperty(styleSetName)) {
                    continue;
                }
                for (const style of theme.styles[styleSetName]) {
                    switch (style.technique) {
                        // TODO: Re-enable this once "dashed-line" is deprecated.
                        /* case "dashed-line":
                            console.warn(
                                `Using deprecated "dashed-line" technique.
                                Use "solid-line" technique instead`
                            ); */
                        default:
                            break;
                    }
                }
            }
        }
    }
    /**
     * Expand all `ref` expressions in [[Theme]] basing on `definitions`.
     *
     * This method mutates original `theme` instance.
     */
    static resolveThemeReferences(theme, contextLogger) {
        if (theme.definitions !== undefined) {
            contextLogger.pushAttr("definitions");
            /**
             * First, try to resolve all internal references in definitions, so if we may save few
             * CPU cycles if some definition is used many times in actual style sets.
             */
            for (const definitionName in theme.definitions) {
                if (!theme.definitions.hasOwnProperty(definitionName)) {
                    continue;
                }
                const def = theme.definitions[definitionName];
                if (Theme_1.isActualSelectorDefinition(def)) {
                    contextLogger.pushAttr(definitionName);
                    const resolvedDef = ThemeLoader.resolveStyle(def, theme.definitions, contextLogger);
                    contextLogger.pop();
                    if (resolvedDef === undefined) {
                        contextLogger.pushAttr(definitionName);
                        contextLogger.warn("skipping invalid style in definition");
                        contextLogger.pop();
                        delete theme.definitions[definitionName];
                    }
                    else {
                        theme.definitions[definitionName] = resolvedDef;
                    }
                }
            }
            contextLogger.pop();
        }
        if (theme.styles !== undefined) {
            for (const styleSetName in theme.styles) {
                if (!theme.styles.hasOwnProperty(styleSetName)) {
                    continue;
                }
                contextLogger.pushAttr("styles");
                contextLogger.pushAttr(styleSetName);
                theme.styles[styleSetName] = ThemeLoader.resolveStyleSet(theme.styles[styleSetName], theme.definitions, contextLogger);
                contextLogger.pop();
                contextLogger.pop();
            }
        }
        return theme;
    }
    /**
     * Expand all `ref` in [[StyleSet]] basing on `definitions`.
     */
    static resolveStyleSet(styleSet, definitions, contextLogger) {
        const result = [];
        for (let index = 0; index < styleSet.length; ++index) {
            const currentStyle = styleSet[index];
            contextLogger.pushIndex(index);
            const resolvedStyle = ThemeLoader.resolveStyle(currentStyle, definitions, contextLogger);
            if (resolvedStyle !== undefined) {
                result.push(resolvedStyle);
            }
            else {
                contextLogger.warn("invalid style, ignored");
            }
            contextLogger.pop();
        }
        return result;
    }
    /**
     * Expand all `ref` in [[Style]] instance basing on `definitions`.
     */
    static resolveStyle(style, definitions, contextLogger) {
        if (Theme_1.isJsonExprReference(style)) {
            // expand and instantiate references to style definitions.
            const def = definitions && definitions[style[1]];
            if (!def) {
                contextLogger.warn(`invalid reference '${style[1]}' - not found`);
                return undefined;
            }
            if (!Theme_1.isActualSelectorDefinition(def)) {
                contextLogger.warn(`invalid reference '${style[1]}' - expected style definition`);
                return undefined;
            }
            // instantiate the style
            style = harp_utils_1.cloneDeep(def);
        }
        style = style;
        if (Array.isArray(style.when)) {
            contextLogger.pushAttr("when");
            const resolvedWhen = this.resolveExpressionReferences(style.when, definitions, contextLogger);
            contextLogger.pop();
            if (resolvedWhen === undefined) {
                return undefined;
            }
            style.when = resolvedWhen;
        }
        if (style.attr !== undefined) {
            const attr = style.attr;
            contextLogger.pushAttr("attr");
            for (const prop in attr) {
                if (!attr.hasOwnProperty(prop)) {
                    continue;
                }
                const value = attr[prop];
                if (!Array.isArray(value)) {
                    continue; // nothing to do
                }
                contextLogger.pushAttr(prop);
                const resolvedValue = this.resolveExpressionReferences(value, definitions, contextLogger);
                contextLogger.pop();
                if (resolvedValue !== undefined) {
                    attr[prop] = resolvedValue;
                }
                else {
                    delete attr[prop];
                }
            }
            contextLogger.pop();
        }
        return style;
    }
    /**
     * Resolve `[ref, ...]` in expressions.
     *
     * Returns `undefined` some reference was invalid (missing or wrong type).
     */
    static resolveExpressionReferences(value, definitions, contextLogger) {
        let failed = false;
        function resolveInternal(node) {
            if (Theme_1.isJsonExprReference(node)) {
                const defName = node[1];
                const def = definitions && definitions[defName];
                if (def === undefined) {
                    contextLogger.warn(`invalid reference '${defName}' - not found`);
                    failed = true;
                    return undefined;
                }
                if (Theme_1.isLiteralDefinition(def) || harp_datasource_protocol_1.isJsonExpr(def)) {
                    return def;
                }
                if (Theme_1.isBoxedDefinition(def)) {
                    return def.value;
                }
                contextLogger.warn(`invalid reference '${defName}' - expected value definition`);
                failed = true;
                return undefined;
            }
            else if (Array.isArray(node)) {
                const result = [...node];
                for (let i = 1; i < result.length; ++i) {
                    result[i] = resolveInternal(result[i]);
                }
                return result;
            }
            else {
                return node;
            }
        }
        const r = resolveInternal(value);
        if (failed) {
            return undefined;
        }
        return r;
    }
    /**
     * Realize `extends` clause by merging `theme` with its base [[Theme]].
     *
     * @param theme [Theme] object
     * @param options Optional, a [[ThemeLoadOptions]] objects containing any custom settings for
     *    this load request.
     */
    static async resolveBaseThemes(theme, options) {
        options = options || {};
        if (theme.extends === undefined) {
            return theme;
        }
        const maxInheritanceDepth = harp_utils_1.getOptionValue(options.maxInheritanceDepth, exports.DEFAULT_MAX_THEME_INTHERITANCE_DEPTH);
        if (maxInheritanceDepth <= 0) {
            throw new Error(`maxInheritanceDepth reached when attempting to load base theme`);
        }
        const baseThemes = !Array.isArray(theme.extends) ? [theme.extends] : theme.extends;
        delete theme.extends;
        let baseThemesMerged = {};
        for (const baseTheme of baseThemes) {
            const actualBaseTheme = await ThemeLoader.load(baseTheme, Object.assign(Object.assign({}, options), { resolveDefinitions: false, maxInheritanceDepth: maxInheritanceDepth - 1 }));
            baseThemesMerged = ThemeLoader.mergeThemes(actualBaseTheme, baseThemesMerged);
        }
        return ThemeLoader.mergeThemes(theme, baseThemesMerged);
    }
    static mergeThemes(theme, baseTheme) {
        const definitions = Object.assign(Object.assign({}, baseTheme.definitions), theme.definitions);
        let styles;
        if (baseTheme.styles && theme.styles) {
            const currentStyleSets = Object.keys(baseTheme.styles);
            const incomingStyleSets = Object.keys(theme.styles);
            styles = {};
            currentStyleSets.forEach(styleSetName => {
                const index = incomingStyleSets.indexOf(styleSetName);
                if (index !== -1) {
                    // merge the current and incoming styleset
                    // and add the result to `styles`.
                    styles[styleSetName] = [
                        ...baseTheme.styles[styleSetName],
                        ...theme.styles[styleSetName]
                    ];
                    // remove the styleset from the incoming list
                    incomingStyleSets.splice(index, 1);
                }
                else {
                    // copy the existing style set to `styles`.
                    styles[styleSetName] = baseTheme.styles[styleSetName];
                }
            });
            // add the remaining stylesets to styles.
            incomingStyleSets.forEach(p => {
                styles[p] = theme.styles[p];
            });
        }
        else if (baseTheme.styles) {
            styles = Object.assign({}, baseTheme.styles);
        }
        else if (theme.styles) {
            styles = Object.assign({}, theme.styles);
        }
        return Object.assign(Object.assign(Object.assign({}, baseTheme), theme), { definitions, styles });
    }
    static convertFlatTheme(theme) {
        if (Array.isArray(theme.styles)) {
            // Convert the flat theme to a standard theme.
            const styles = {};
            theme.styles.forEach(style => {
                if (harp_datasource_protocol_1.isJsonExpr(style)) {
                    throw new Error("invalid usage of theme reference");
                }
                const styleSetName = style.styleSet;
                if (styleSetName === undefined) {
                    throw new Error("missing reference to style set");
                }
                if (!styles[styleSetName]) {
                    styles[styleSetName] = [];
                }
                styles[styleSetName].push(style);
            });
            theme.styles = styles;
        }
        return true;
    }
    static resolveResources(theme, childUrlResolver) {
        if (theme.sky && theme.sky.type === "cubemap") {
            for (let i = 0; i < SkyCubemapTexture_1.SKY_CUBEMAP_FACE_COUNT; ++i) {
                const faceUrl = theme.sky[SkyCubemapTexture_1.SkyCubemapFaceId[i]];
                if (faceUrl !== undefined) {
                    theme.sky[SkyCubemapTexture_1.SkyCubemapFaceId[i]] = childUrlResolver.resolveUri(faceUrl);
                }
            }
        }
        if (theme.images) {
            for (const name of Object.keys(theme.images)) {
                const image = theme.images[name];
                image.url = childUrlResolver.resolveUri(image.url);
                if (image.atlas !== undefined) {
                    image.atlas = childUrlResolver.resolveUri(image.atlas);
                }
            }
        }
        if (theme.fontCatalogs) {
            for (const font of theme.fontCatalogs) {
                font.url = childUrlResolver.resolveUri(font.url);
            }
        }
        if (theme.poiTables) {
            for (const poiTable of theme.poiTables) {
                poiTable.url = childUrlResolver.resolveUri(poiTable.url);
            }
        }
        if (theme.styles) {
            for (const styleSetName in theme.styles) {
                if (!theme.styles.hasOwnProperty(styleSetName)) {
                    continue;
                }
                const styleSet = theme.styles[styleSetName];
                for (const style of styleSet) {
                    if (!style.attr) {
                        continue;
                    }
                    ["map", "normalMap", "displacementMap", "roughnessMap"].forEach(texturePropertyName => {
                        const textureProperty = style.attr[texturePropertyName];
                        if (textureProperty && typeof textureProperty === "string") {
                            style.attr[texturePropertyName] = childUrlResolver.resolveUri(textureProperty);
                        }
                    });
                }
            }
        }
    }
}
exports.ThemeLoader = ThemeLoader;


/***/ }),

/***/ "../harp-mapview/lib/Tile.ts":
/*!***********************************!*\
  !*** ../harp-mapview/lib/Tile.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const THREE = __webpack_require__(/*! three */ "three");
const Statistics_1 = __webpack_require__(/*! ./Statistics */ "../harp-mapview/lib/Statistics.ts");
const TextElementGroup_1 = __webpack_require__(/*! ./text/TextElementGroup */ "../harp-mapview/lib/text/TextElementGroup.ts");
const TextElementGroupPriorityList_1 = __webpack_require__(/*! ./text/TextElementGroupPriorityList */ "../harp-mapview/lib/text/TextElementGroupPriorityList.ts");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-mapview/lib/Utils.ts");
const logger = harp_utils_1.LoggerManager.instance.create("Tile");
/**
 * Minimum estimated size of a JS object.
 */
const MINIMUM_SMALL_OBJECT_SIZE_ESTIMATION = 16;
const MINIMUM_OBJECT_SIZE_ESTIMATION = 100;
/**
 * Compute the memory footprint of `TileFeatureData`.
 */
function getFeatureDataSize(featureData) {
    let numBytes = MINIMUM_OBJECT_SIZE_ESTIMATION;
    if (featureData.starts !== undefined) {
        numBytes += featureData.starts.length * 8;
    }
    if (featureData.objInfos !== undefined) {
        // 16 (estimated) bytes per objInfos
        numBytes += featureData.objInfos.length * MINIMUM_SMALL_OBJECT_SIZE_ESTIMATION;
    }
    return numBytes;
}
exports.getFeatureDataSize = getFeatureDataSize;
/**
 * Compute the memory footprint of `RoadIntersectionData`.
 */
function getRoadIntersectionDataSize(intersectionData) {
    let numBytes = MINIMUM_OBJECT_SIZE_ESTIMATION;
    // 8 bytes per techniqueIndex
    // 8 bytes per start
    // 8 bytes per width
    // 8 bytes per position
    // 100 (estimated) bytes per technique
    const bytesPerEntry = 8 + 8 + 8 + 8 + MINIMUM_OBJECT_SIZE_ESTIMATION;
    const numEntries = intersectionData.techniqueIndex.length;
    numBytes += intersectionData.techniqueIndex.length * bytesPerEntry;
    if (intersectionData.ids !== undefined) {
        numBytes += numEntries * 8;
    }
    if (intersectionData.objInfos !== undefined) {
        // 16 (estimated) bytes per objInfos
        numBytes += numEntries * MINIMUM_SMALL_OBJECT_SIZE_ESTIMATION;
    }
    return numBytes;
}
/**
 * Missing Typedoc
 */
var TileLoaderState;
(function (TileLoaderState) {
    TileLoaderState[TileLoaderState["Initialized"] = 0] = "Initialized";
    TileLoaderState[TileLoaderState["Loading"] = 1] = "Loading";
    TileLoaderState[TileLoaderState["Loaded"] = 2] = "Loaded";
    TileLoaderState[TileLoaderState["Decoding"] = 3] = "Decoding";
    TileLoaderState[TileLoaderState["Ready"] = 4] = "Ready";
    TileLoaderState[TileLoaderState["Canceled"] = 5] = "Canceled";
    TileLoaderState[TileLoaderState["Failed"] = 6] = "Failed";
})(TileLoaderState = exports.TileLoaderState || (exports.TileLoaderState = {}));
/**
 * The class that holds the tiled data for a [[DataSource]].
 */
class Tile {
    /**
     * Creates a new [[Tile]].
     *
     * @param dataSource The [[DataSource]] that created this [[Tile]].
     * @param tileKey The unique identifier for this [[Tile]]. Currently only up to level 24 is
     * supported, because of the use of the upper bits for the offset.
     * @param offset The optional offset, this is an integer which represents what multiple of 360
     * degrees to shift, only useful for flat projections, hence optional.
     * @param localTangentSpace Whether the tile geometry is in local tangent space or not.
     */
    constructor(dataSource, tileKey, offset = 0, localTangentSpace) {
        this.dataSource = dataSource;
        this.tileKey = tileKey;
        this.offset = offset;
        /**
         * A list of the THREE.js objects stored in this `Tile`.
         */
        this.objects = [];
        /**
         * The optional list of HERE TileKeys of tiles with geometries that cross
         * the boundaries of this `Tile`.
         */
        this.dependencies = new Array();
        /**
         * The bounding box of this `Tile` in world coordinates.
         */
        this.boundingBox = new harp_geoutils_1.OrientedBox3();
        /**
         * Maximum height of geometry on this tile above ground level.
         */
        this.maxGeometryHeight = 0;
        /**
         * Keeping some stats for the individual [[Tile]]s to analyze caching behavior.
         *
         * The frame the [[Tile]] was last requested. This is required to know when the given [[Tile]]
         * can be removed from the cache.
         */
        this.frameNumLastRequested = -1;
        /**
         * The frame the `Tile` was first visible.
         */
        this.frameNumVisible = -1;
        /**
         * The last frame this `Tile` has been rendered (or was in the visible set). Used to determine
         * visibility of `Tile` at the end of a frame, if the number is the current frame number, it is
         * visible.
         */
        this.frameNumLastVisible = -1;
        /**
         * After removing from cache, this is the number of frames the `Tile` was visible.
         */
        this.numFramesVisible = 0;
        /**
         * Version stamp of the visibility set in the [[TileManager]]. If the counter is different, the
         * visibility of the Tile's objects has to be calculated. Optimization to reduce overhead of
         * computing visibility.
         */
        this.visibilityCounter = -1;
        /**
         * @hidden
         *
         * Used to tell if the Tile is used temporarily as a fallback tile.
         *
         * levelOffset is in in the range [-quadTreeSearchDistanceUp,
         * quadTreeSearchDistanceDown], where these values come from the
         * [[VisibleTileSetOptions]]
         */
        this.levelOffset = 0;
        this.m_disposed = false;
        this.m_localTangentSpace = false;
        this.m_forceHasGeometry = undefined;
        // TODO: Delay construction of text element groups until first text element is added.
        // Used for [[TextElement]]s which the developer defines. Group created with maximum priority
        // so that user text elements are placed before others.
        this.m_userTextElements = new TextElementGroup_1.TextElementGroup(Number.MAX_SAFE_INTEGER);
        // Used for [[TextElement]]s that are stored in the data, and that are placed explicitly,
        // fading in and out.
        this.m_textElementGroups = new TextElementGroupPriorityList_1.TextElementGroupPriorityList();
        // Blocks other labels from showing.
        this.m_pathBlockingElements = [];
        this.m_visibleArea = 0;
        this.m_minElevation = 0;
        this.m_maxElevation = 0;
        // List of owned textures for disposal
        this.m_ownedTextures = new WeakSet();
        this.geoBox = this.dataSource.getTilingScheme().getGeoBox(this.tileKey);
        this.projection.projectBox(this.geoBox, this.boundingBox);
        this.m_localTangentSpace = localTangentSpace !== undefined ? localTangentSpace : false;
    }
    /**
     * The visibility status of the [[Tile]]. It is actually visible or planned to become visible.
     */
    get isVisible() {
        // Tiles are not evaluated as invisible until the second frame they aren't requested.
        // This happens in order to prevent that, during [[VisibleTileSet]] visibility evaluation,
        // visible tiles that haven't yet been evaluated for the current frame are preemptively
        // removed from [[DataSourceCache]].
        return this.frameNumLastRequested >= this.dataSource.mapView.frameNumber - 1;
    }
    set isVisible(visible) {
        this.frameNumLastRequested = visible ? this.dataSource.mapView.frameNumber : -1;
    }
    /**
     * The [[Projection]] currently used by the [[MapView]].
     */
    get projection() {
        return this.dataSource.projection;
    }
    /**
     * The [[MapView]] this `Tile` belongs to.
     */
    get mapView() {
        return this.dataSource.mapView;
    }
    /**
     * Whether the data of this tile is in local tangent space or not.
     * If the data is in local tangent space (i.e. up vector is (0,0,1) for high zoomlevels) then
     * [[MapView]] will rotate the objects before rendering using the rotation matrix of the
     * oriented [[boundingBox]].
     */
    get localTangentSpace() {
        return this.m_localTangentSpace;
    }
    /*
     * The size of this Tile in system memory.
     */
    get memoryUsage() {
        if (this.m_resourceInfo === undefined) {
            this.computeResourceInfo();
        }
        return this.m_resourceInfo.heapSize;
    }
    /**
     * The center of this `Tile` in world coordinates.
     */
    get center() {
        return this.boundingBox.position;
    }
    /**
     * Compute [[TileResourceInfo]] of this `Tile`. May be using a cached value. The method
     * `invalidateResourceInfo` can be called beforehand to force a recalculation.
     *
     * @returns `TileResourceInfo` for this `Tile`.
     */
    getResourceInfo() {
        if (this.m_resourceInfo === undefined) {
            this.computeResourceInfo();
        }
        return this.m_resourceInfo;
    }
    /**
     * Force invalidation of the cached [[TileResourceInfo]]. Useful after the `Tile` has been
     * modified.
     */
    invalidateResourceInfo() {
        this.m_resourceInfo = undefined;
    }
    /**
     * Add ownership of a texture to this tile. The texture will be disposed if the `Tile` is
     * disposed.
     * @param texture Texture to be owned by the `Tile`
     */
    addOwnedTexture(texture) {
        this.m_ownedTextures.add(texture);
    }
    /**
     * Gets the list of developer-defined [[TextElement]] in this `Tile`. This list is always
     * rendered first.
     */
    get userTextElements() {
        return this.m_userTextElements;
    }
    /**
     * Adds a developer-defined [[TextElement]] to this `Tile`. The [[TextElement]] is always
     * visible, if it's in the map's currently visible area.
     *
     * @param textElement The Text element to add.
     */
    addUserTextElement(textElement) {
        if (this.m_textElementsChanged === false) {
            // HARP-8733: Text content in the tile is about to change, but it has already been
            // rendered at least once (otherwise m_textElementsChanged would be undefined). Clone
            // the text element group so that it's handled as a new group by TextElementsRenderer
            // and it doesn't reuse the same state stored for the old one.
            // TODO: HARP-8910 Deprecate user text elements.
            this.m_userTextElements = this.m_userTextElements.clone();
        }
        this.m_userTextElements.elements.push(textElement);
        this.textElementsChanged = true;
    }
    /**
     * Removes a developer-defined [[TextElement]] from this `Tile`.
     *
     * @param textElement A developer-defined TextElement to remove.
     * @returns `true` if the element has been removed successfully; `false` otherwise.
     */
    removeUserTextElement(textElement) {
        const foundIndex = this.m_userTextElements.elements.indexOf(textElement);
        if (foundIndex === -1) {
            return false;
        }
        if (this.m_textElementsChanged === false) {
            // HARP-8733: Text content in the tile is about to change, but it has already been
            // rendered at least once (otherwise m_textElementsChanged would be undefined). Clone
            // the text element group so that it's handled as a new group by TextElementsRenderer
            // and it doesn't reuse the same state stored for the old one.
            // TODO: HARP-8910 Deprecate user text elements.
            this.m_userTextElements = this.m_userTextElements.clone();
        }
        this.m_userTextElements.elements.splice(foundIndex, 1);
        this.textElementsChanged = true;
        return true;
    }
    /**
     * Adds a [[TextElement]] to this `Tile`, which is added to the visible set of
     * [[TextElement]]s based on the capacity and visibility. The [[TextElement]]'s priority
     * controls if or when it becomes visible.
     *
     * To ensure that a TextElement is visible, use a high value for its priority, such as
     * `Number.MAX_SAFE_INTEGER`. Since the number of visible TextElements is limited by the
     * screen space, not all TextElements are visible at all times.
     *
     * @param textElement The TextElement to add.
     */
    addTextElement(textElement) {
        this.textElementGroups.add(textElement);
        this.textElementsChanged = true;
    }
    /**
     * Adds a [[PathBlockingElement]] to this `Tile`. This path has the highest priority and blocks
     * all other labels. There maybe in future a use case to give it a priority, but as that isn't
     * yet required, it is left to be implemented later if required.
     * @param blockingElement Element which should block all other labels.
     */
    addBlockingElement(blockingElement) {
        this.m_pathBlockingElements.push(blockingElement);
    }
    /**
     * Removes a [[TextElement]] from this `Tile`. For the element to be removed successfully, the
     * priority of the [[TextElement]] has to be equal to its priority when it was added.
     *
     * @param textElement The TextElement to remove.
     * @returns `true` if the TextElement has been removed successfully; `false` otherwise.
     */
    removeTextElement(textElement) {
        if (this.textElementGroups.remove(textElement)) {
            this.textElementsChanged = true;
            return true;
        }
        return false;
    }
    /**
     * Gets the current [[GroupedPriorityList]] which contains a list of all [[TextElement]]s to be
     * selected and placed for rendering.
     */
    get textElementGroups() {
        return this.m_textElementGroups;
    }
    /**
     * Gets the current modification state for the list of [[TextElement]]s in the `Tile`. If the
     * value is `true` the TextElement is placed for rendering during the next frame.
     */
    get textElementsChanged() {
        var _a;
        return _a = this.m_textElementsChanged, (_a !== null && _a !== void 0 ? _a : false);
    }
    set textElementsChanged(changed) {
        this.m_textElementsChanged = changed;
    }
    /**
     * Returns true if the `Tile` has any text elements to render.
     */
    hasTextElements() {
        return this.m_textElementGroups.count() > 0 || this.m_userTextElements.elements.length > 0;
    }
    /**
     * Get the current blocking elements.
     */
    get blockingElements() {
        return this.m_pathBlockingElements;
    }
    /**
     * Called by [[VisibleTileSet]] to mark that [[Tile]] is visible and it should prepare its road
     * geometry for picking.
     */
    prepareTileInfo() {
        // If the tile is not ready for display, or if it has become invisible while being loaded,
        // for example by moving the camera, the tile is not finished and its geometry is not
        // created. This is an optimization for fast camera movements and zooms.
        if (this.m_decodedTile === undefined || this.m_disposed || !this.isVisible) {
            return;
        }
        if (this.m_decodedTile.tileInfo !== undefined) {
            this.roadIntersectionData = this.dataSource.mapView.pickHandler.registerTile(this);
        }
    }
    /**
     * Called before [[MapView]] starts rendering this `Tile`.
     *
     * @param zoomLevel The current zoom level.
     * @returns Returns `true` if this `Tile` should be rendered.
     */
    willRender(_zoomLevel) {
        return true;
    }
    /**
     * Called after [[MapView]] has rendered this `Tile`.
     */
    didRender() {
        // to be overridden by subclasses
    }
    /**
     * Estimated visible area of tile used for sorting the priorities during loading.
     */
    get visibleArea() {
        return this.m_visibleArea;
    }
    set visibleArea(area) {
        this.m_visibleArea = area;
        if (this.tileLoader !== undefined) {
            this.tileLoader.updatePriority(area);
        }
    }
    /**
     * Estimated tile's minimum elevation above the sea level.
     * @note Negative values indicates depressions.
     */
    get minElevation() {
        return this.m_minElevation;
    }
    set minElevation(elevation) {
        this.m_minElevation = elevation;
    }
    /**
     * Estimated maximum ground elevation above the sea level that may be found on tile.
     * @note Negative values indicates depressions.
     */
    get maxElevation() {
        return this.m_maxElevation;
    }
    set maxElevation(elevation) {
        this.m_maxElevation = elevation;
    }
    /**
     * Gets the decoded tile; it is removed after geometry handling.
     */
    get decodedTile() {
        return this.m_decodedTile;
    }
    /**
     * Applies the decoded tile to the tile.
     * If the geometry is empty, then the tile's forceHasGeometry flag is set.
     * Map is updated.
     * @param decodedTile The decoded tile to set.
     */
    set decodedTile(decodedTile) {
        this.m_decodedTile = decodedTile;
        this.invalidateResourceInfo();
        if (decodedTile === undefined) {
            return;
        }
        if (decodedTile.geometries.length === 0) {
            this.forceHasGeometry(true);
        }
        if (decodedTile.boundingBox !== undefined) {
            // If the decoder provides a more accurate bounding box than the one we computed from
            // the flat geo box we take it instead.
            this.boundingBox.copy(decodedTile.boundingBox);
        }
        const stats = Statistics_1.PerformanceStatistics.instance;
        if (stats.enabled && decodedTile.decodeTime !== undefined) {
            stats.currentFrame.addValue("decode.decodingTime", decodedTile.decodeTime);
            stats.currentFrame.addValue("decode.decodedTiles", 1);
        }
        if (decodedTile.copyrightHolderIds !== undefined) {
            this.copyrightInfo = decodedTile.copyrightHolderIds.map(id => ({ id }));
        }
        this.dataSource.requestUpdate();
    }
    /**
     * Remove the decodedTile when no longer needed.
     */
    removeDecodedTile() {
        this.m_decodedTile = undefined;
        this.invalidateResourceInfo();
    }
    /**
     * Called by the [[TileLoader]] after the `Tile` has finished loading its map data. Can be used
     * to add content to the `Tile`. The [[DecodedTile]] should still be available.
     */
    loadingFinished() {
        // To be used in subclasses.
    }
    /**
     * Called when the default implementation of `dispose()` needs
     * to free the geometry of a `Tile` object.
     *
     * @param object The object that references the geometry.
     * @returns `true` if the geometry can be disposed.
     */
    // tslint:disable-next-line:no-unused-variable
    shouldDisposeObjectGeometry(object) {
        return true;
    }
    /**
     * Called when the default implementation of `dispose()` needs
     * to free a `Tile` object's material.
     *
     * @param object The object referencing the geometry.
     * @returns `true` if the material can be disposed.
     */
    // tslint:disable-next-line:no-unused-variable
    shouldDisposeObjectMaterial(object) {
        return true;
    }
    /**
     * Called when the default implementation of `dispose()` needs
     * to free a Texture that is part of a `Tile` object's material.
     *
     * @param texture The texture about to be disposed.
     * @returns `true` if the texture can be disposed.
     */
    shouldDisposeTexture(texture) {
        return this.m_ownedTextures.has(texture);
    }
    /**
     * Returns `true` if this `Tile` has been disposed.
     */
    get disposed() {
        return this.m_disposed;
    }
    /**
     * Gets the [[TileGeometryLoader]] that manages this tile.
     */
    get tileGeometryLoader() {
        return this.m_tileGeometryLoader;
    }
    /**
     * Sets the [[TileGeometryLoader]] to manage this tile.
     *
     * @param tileGeometryLoader A [[TileGeometryLoader]] instance to manage the geometry creation
     *      for this tile.
     */
    set tileGeometryLoader(tileGeometryLoader) {
        this.m_tileGeometryLoader = tileGeometryLoader;
    }
    /**
     * `True` if the basic geometry has been loaded, and the `Tile` is ready  for display.
     */
    get basicGeometryLoaded() {
        return this.m_tileGeometryLoader === undefined
            ? this.hasGeometry
            : this.m_tileGeometryLoader.basicGeometryLoaded || this.m_tileGeometryLoader.isFinished;
    }
    /**
     * `True` if all geometry of the `Tile` has been loaded.
     */
    get allGeometryLoaded() {
        return this.m_tileGeometryLoader === undefined
            ? this.hasGeometry
            : this.m_tileGeometryLoader.allGeometryLoaded || this.m_tileGeometryLoader.isFinished;
    }
    /**
     * MapView checks if this `Tile` is ready to be rendered while culling.
     *
     * By default, MapView checks if the [[objects]] list is not empty. However, you can override
     * this check by manually setting this property.
     */
    get hasGeometry() {
        if (this.m_forceHasGeometry === undefined) {
            return this.objects.length !== 0;
        }
        else {
            return this.m_forceHasGeometry;
        }
    }
    /**
     * Overrides the default value for [[hasGeometry]] if value is not `undefined`.
     *
     * @param value A new value for the [[hasGeometry]] flag.
     */
    forceHasGeometry(value) {
        this.m_forceHasGeometry = value;
    }
    /**
     * Reset the visibility counter. This will force the visibility check to be rerun on all objects
     * in this `Tile`.
     */
    resetVisibilityCounter() {
        this.visibilityCounter = -1;
    }
    /**
     * Gets the [[ITileLoader]] that manages this tile.
     */
    get tileLoader() {
        return this.m_tileLoader;
    }
    /**
     * Sets the [[ITileLoader]] to manage this tile.
     *
     * @param tileLoader A [[ITileLoader]] instance to manage the loading process for this tile.
     */
    set tileLoader(tileLoader) {
        this.m_tileLoader = tileLoader;
    }
    /**
     * Loads this `Tile` geometry.
     */
    load() {
        const tileLoader = this.tileLoader;
        if (tileLoader === undefined) {
            return;
        }
        tileLoader
            .loadAndDecode()
            .then(tileLoaderState => {
            harp_utils_1.assert(tileLoaderState === TileLoaderState.Ready);
            const decodedTile = tileLoader.decodedTile;
            this.decodedTile = decodedTile;
        })
            .catch(tileLoaderState => {
            if (tileLoaderState !== TileLoaderState.Canceled &&
                tileLoaderState !== TileLoaderState.Failed) {
                logger.error("Unknown error" + tileLoaderState);
            }
        });
    }
    /**
     * Handler for animation of `Tile` geometries.
     */
    get animatedExtrusionTileHandler() {
        return this.m_animatedExtrusionTileHandler;
    }
    set animatedExtrusionTileHandler(handler) {
        this.m_animatedExtrusionTileHandler = handler;
    }
    /**
     * Frees the rendering resources allocated by this `Tile`.
     *
     * The default implementation of this method frees the geometries and the materials for all the
     * reachable objects.
     * Textures are freed if they are owned by this `Tile` (i.e. if they where created by this
     * `Tile`or if the ownership was explicitely set to this `Tile` by [[addOwnedTexture]]).
     */
    clear() {
        const disposeMaterial = (material) => {
            Object.getOwnPropertyNames(material).forEach((property) => {
                const materialProperty = material[property];
                if (materialProperty !== undefined && materialProperty instanceof THREE.Texture) {
                    const texture = materialProperty;
                    if (this.shouldDisposeTexture(texture)) {
                        texture.dispose();
                    }
                }
            });
            material.dispose();
        };
        const disposeObject = (object) => {
            if (object.geometry !== undefined && this.shouldDisposeObjectGeometry(object)) {
                object.geometry.dispose();
            }
            if (object.material !== undefined && this.shouldDisposeObjectMaterial(object)) {
                if (object.material instanceof Array) {
                    object.material.forEach((material) => {
                        if (material !== undefined) {
                            disposeMaterial(material);
                        }
                    });
                }
                else {
                    disposeMaterial(object.material);
                }
            }
        };
        this.objects.forEach((rootObject) => {
            rootObject.traverse((object) => {
                disposeObject(object);
            });
            disposeObject(rootObject);
        });
        this.objects.length = 0;
        if (this.preparedTextPaths) {
            this.preparedTextPaths = [];
        }
        if (this.m_animatedExtrusionTileHandler !== undefined) {
            this.m_animatedExtrusionTileHandler.dispose();
        }
        this.clearTextElements();
        this.invalidateResourceInfo();
    }
    /**
     * Removes all [[TextElement]] from the tile.
     */
    clearTextElements() {
        this.textElementsChanged = this.hasTextElements();
        this.m_pathBlockingElements.splice(0);
        this.textElementGroups.clear();
        this.userTextElements.elements.length = 0;
    }
    /**
     * Disposes this `Tile`, freeing all geometries and materials for the reachable objects.
     */
    dispose() {
        if (this.m_disposed) {
            return;
        }
        if (this.m_tileLoader) {
            this.m_tileLoader.cancel();
            this.m_tileLoader = undefined;
        }
        if (this.m_tileGeometryLoader !== undefined) {
            this.m_tileGeometryLoader.dispose();
            this.m_tileGeometryLoader = undefined;
        }
        this.clear();
        this.userTextElements.elements.length = 0;
        this.m_disposed = true;
        // Ensure that tile is removable from tile cache.
        this.frameNumLastRequested = 0;
    }
    /**
     * Computes the offset in the x world coordinates corresponding to this tile, based on
     * its [[offset]].
     * @returns The x offset.
     */
    computeWorldOffsetX() {
        return this.projection.worldExtent(0, 0).max.x * this.offset;
    }
    computeResourceInfo() {
        let heapSize = 0;
        let num3dObjects = 0;
        let numTextElements = 0;
        let numUserTextElements = 0;
        const aggregatedObjSize = {
            heapSize: 0,
            gpuSize: 0
        };
        // Keep a map of the uuids of the larger objects, like Geometries, Materials and Attributes.
        // They should be counted only once even if they are shared.
        const visitedObjects = new Map();
        for (const object of this.objects) {
            if (object.visible) {
                num3dObjects++;
            }
            Utils_1.MapViewUtils.estimateObject3dSize(object, aggregatedObjSize, visitedObjects);
        }
        for (const group of this.textElementGroups.groups) {
            numTextElements += group[1].elements.length;
        }
        numUserTextElements = this.userTextElements.elements.length;
        // 216 was the shallow size of a single TextElement last time it has been checked, 312 bytes
        // was the minimum retained size of a TextElement that was not being rendered. If a
        // TextElement is actually rendered, the size may be _much_ bigger.
        heapSize += (numTextElements + numUserTextElements) * 312;
        if (this.m_decodedTile !== undefined && this.m_decodedTile.tileInfo !== undefined) {
            aggregatedObjSize.heapSize += this.m_decodedTile.tileInfo.numBytes;
        }
        if (this.roadIntersectionData !== undefined) {
            heapSize += getRoadIntersectionDataSize(this.roadIntersectionData);
        }
        this.m_resourceInfo = {
            heapSize: aggregatedObjSize.heapSize + heapSize,
            gpuSize: aggregatedObjSize.gpuSize,
            num3dObjects,
            numTextElements,
            numUserTextElements
        };
    }
}
exports.Tile = Tile;


/***/ }),

/***/ "../harp-mapview/lib/Utils.ts":
/*!************************************!*\
  !*** ../harp-mapview/lib/Utils.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const EarthConstants_1 = __webpack_require__(/*! @here/harp-geoutils/lib/projection/EarthConstants */ "../harp-geoutils/lib/projection/EarthConstants.ts");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const MapView_1 = __webpack_require__(/*! ./MapView */ "../harp-mapview/lib/MapView.ts");
const Tile_1 = __webpack_require__(/*! ./Tile */ "../harp-mapview/lib/Tile.ts");
const logger = harp_utils_1.LoggerManager.instance.create("MapViewUtils");
// Estimation of the size of an Object3D with all the simple properties, like matrices and flags.
// There may be cases where it is possible to construct Object3Ds with considerable less memory
// consumption, but this value is used to simplify the estimation.
const MINIMUM_OBJECT3D_SIZE_ESTIMATION = 1000;
const MINIMUM_ATTRIBUTE_SIZE_ESTIMATION = 56;
// Caching those for performance reasons.
const groundNormalPlanarProj = new THREE.Vector3(0, 0, 1);
const groundPlane = new THREE.Plane(groundNormalPlanarProj.clone());
const groundSphere = new THREE.Sphere(undefined, EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS);
const rayCaster = new THREE.Raycaster();
const maxTiltAngleAllowed = THREE.Math.degToRad(MapView_1.MAX_TILT_ANGLE);
const epsilon = 1e-5;
/**
 * Cached ThreeJS instances for realtime maths.
 */
const space = {
    x: new THREE.Vector3(),
    y: new THREE.Vector3(),
    z: new THREE.Vector3()
};
const tangentSpace = {
    x: new THREE.Vector3(),
    y: new THREE.Vector3(),
    z: new THREE.Vector3()
};
const cache = {
    quaternions: [new THREE.Quaternion(), new THREE.Quaternion()],
    vector3: [new THREE.Vector3(), new THREE.Vector3()],
    matrix4: [new THREE.Matrix4(), new THREE.Matrix4()],
    transforms: [
        {
            xAxis: new THREE.Vector3(),
            yAxis: new THREE.Vector3(),
            zAxis: new THREE.Vector3(),
            position: new THREE.Vector3()
        }
    ]
};
var MapViewUtils;
(function (MapViewUtils) {
    MapViewUtils.MAX_TILT_DEG = 89;
    /**
     * Zooms and moves the map in such a way that the given target position remains at the same
     * position after the zoom.
     *
     * @param mapView Instance of MapView.
     * @param targetPositionOnScreenXinNDC Target x position in NDC space.
     * @param targetPositionOnScreenYinNDC Target y position in NDC space.
     * @param zoomLevel The desired zoom level.
     * @param maxTiltAngle The maximum tilt angle to comply by, in globe projection, in radian.
     */
    function zoomOnTargetPosition(mapView, targetPositionOnScreenXinNDC, targetPositionOnScreenYinNDC, zoomLevel, maxTiltAngle = maxTiltAngleAllowed) {
        // Get current target position in world space before we zoom.
        const targetPosition = rayCastWorldCoordinates(mapView, targetPositionOnScreenXinNDC, targetPositionOnScreenYinNDC);
        const groundDistance = calculateDistanceToGroundFromZoomLevel(mapView, zoomLevel);
        // Set the cameras height according to the given zoom level.
        if (mapView.projection.type === harp_geoutils_1.ProjectionType.Planar) {
            mapView.camera.position.setZ(groundDistance);
        }
        else if (mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            mapView.camera.position.setLength(EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS + groundDistance);
        }
        // In sphere, we may have to also orbit the camera around the position located at the
        // center of the screen, in order to limit the tilt to `maxTiltAngle`, as we change
        // this tilt by changing the camera's height above.
        if (mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            const tilt = extractCameraTilt(mapView.camera, mapView.projection);
            const deltaTilt = tilt - maxTiltAngle;
            if (deltaTilt > 0) {
                orbitFocusPoint(mapView, 0, deltaTilt, maxTiltAngle);
            }
        }
        // Get new target position after the zoom
        const newTargetPosition = rayCastWorldCoordinates(mapView, targetPositionOnScreenXinNDC, targetPositionOnScreenYinNDC);
        if (!targetPosition || !newTargetPosition) {
            return;
        }
        if (mapView.projection.type === harp_geoutils_1.ProjectionType.Planar) {
            // Calculate the difference and pan the map to maintain the map relative to the target
            // position.
            targetPosition.sub(newTargetPosition);
            panCameraAboveFlatMap(mapView, targetPosition.x, targetPosition.y);
        }
        else if (mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            panCameraAroundGlobe(mapView, targetPosition, newTargetPosition);
        }
    }
    MapViewUtils.zoomOnTargetPosition = zoomOnTargetPosition;
    /**
     * Orbits the camera around the focus point of the camera.
     *
     * @param mapView The [[MapView]] instance to manipulate.
     * @param deltaAzimuthDeg Delta azimuth in degrees.
     * @param deltaTiltDeg Delta tilt in degrees.
     * @param maxTiltAngleRad The maximum tilt between the camera and its target in radian.
     */
    function orbitFocusPoint(mapView, deltaAzimuthDeg, deltaTiltDeg, maxTiltAngleRad = maxTiltAngleAllowed) {
        const target = mapView.worldTarget;
        const targetCoordinates = mapView.projection.unprojectPoint(target);
        const sphericalCoordinates = extractSphericalCoordinatesFromLocation(mapView, mapView.camera, targetCoordinates);
        const tiltDeg = Math.max(Math.min(THREE.Math.radToDeg(maxTiltAngleRad), deltaTiltDeg + THREE.Math.radToDeg(sphericalCoordinates.tilt)), 0);
        mapView.lookAt(targetCoordinates, target.distanceTo(mapView.camera.position), tiltDeg, THREE.Math.radToDeg(sphericalCoordinates.azimuth + Math.PI) + deltaAzimuthDeg);
    }
    MapViewUtils.orbitFocusPoint = orbitFocusPoint;
    /**
     * Calculate target (focus) point geo-coordinates for given camera.
     * @see getTargetPositionFromCamera
     *
     * @param camera The camera looking on target point.
     * @param projection The geo-projection used.
     * @param elevation Optional elevation above (or below) sea level measured in world units.
     */
    function getGeoTargetFromCamera(camera, projection, elevation) {
        // This function does almost the same as:
        // rayCastGeoCoordinates(mapView, 0, 0)
        // but in more gentle and performance wise manner
        const targetWorldPos = getWorldTargetFromCamera(camera, projection, elevation);
        if (targetWorldPos !== null) {
            return projection.unprojectPoint(targetWorldPos);
        }
        return null;
    }
    MapViewUtils.getGeoTargetFromCamera = getGeoTargetFromCamera;
    /**
     * Calculate target (focus) point world coordinates for given camera position and orientation.
     * @param camera The camera looking on target point.
     * @param projection The geo-projection used.
     * @param elevation Optional elevation above (or below) sea level in world units.
     */
    function getWorldTargetFromCamera(camera, projection, elevation) {
        const cameraPos = cache.vector3[0].copy(camera.position);
        const cameraLookAt = camera.getWorldDirection(cache.vector3[1]);
        rayCaster.set(cameraPos, cameraLookAt);
        if (elevation !== undefined) {
            groundPlane.constant -= elevation;
            groundSphere.radius += elevation;
        }
        const targetWorldPos = new THREE.Vector3();
        const result = projection.type === harp_geoutils_1.ProjectionType.Planar
            ? rayCaster.ray.intersectPlane(groundPlane, targetWorldPos)
            : rayCaster.ray.intersectSphere(groundSphere, targetWorldPos);
        if (elevation !== undefined) {
            groundPlane.constant = 0;
            groundSphere.radius = EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS;
        }
        return result;
    }
    MapViewUtils.getWorldTargetFromCamera = getWorldTargetFromCamera;
    /**
     * Returns the [[GeoCoordinates]] of the camera, given its target coordinates on the map and its
     * zoom, yaw and pitch.
     *
     * @param targetCoordinates Coordinates of the center of the view.
     * @param distance Distance to the target in meters.
     * @param yawDeg Camera yaw in degrees.
     * @param pitchDeg Camera pitch in degrees.
     * @param projection Active MapView, needed to get the camera fov and map projection.
     * @param result Optional output vector.
     * @returns Camera position in world space.
     */
    function getCameraPositionFromTargetCoordinates(targetCoordinates, distance, yawDeg, pitchDeg, projection, result = new THREE.Vector3()) {
        const pitchRad = THREE.Math.degToRad(pitchDeg);
        const altitude = Math.cos(pitchRad) * distance;
        const yawRad = THREE.Math.degToRad(yawDeg);
        projection.projectPoint(targetCoordinates, result);
        const groundDistance = distance * Math.sin(pitchRad);
        if (projection.type === harp_geoutils_1.ProjectionType.Planar) {
            result.x = result.x + Math.sin(yawRad) * groundDistance;
            result.y = result.y - Math.cos(yawRad) * groundDistance;
            result.z = result.z + altitude;
        }
        else if (projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            // In globe yaw and pitch are understood to be in tangent space. The approach below is
            // to find the Z and Y tangent space axes, then rotate Y around Z by the given yaw, and
            // set its new length (groundDistance). Finally the up vector's length is set to the
            // camera height and added to the transformed Y above.
            // Get the Z axis in tangent space: it is the normalized position vector of the target.
            tangentSpace.z.copy(result).normalize();
            // Get the Y axis (north axis in tangent space):
            tangentSpace.y
                .set(0, 0, 1)
                .projectOnPlane(tangentSpace.z)
                .normalize();
            // Rotate this north axis by the given yaw, giving the camera direction relative to
            // the target.
            cache.quaternions[0].setFromAxisAngle(tangentSpace.z, yawRad - Math.PI);
            tangentSpace.y.applyQuaternion(cache.quaternions[0]);
            // Push the camera to the specified distance.
            tangentSpace.y.setLength(groundDistance);
            // Now get the actual camera position vector: from the target position, add the
            // previous computation to get the projection of the camera on the ground, then add
            // the height of the camera in the tangent space.
            const height = distance * Math.cos(pitchRad);
            result.add(tangentSpace.y).add(tangentSpace.z.setLength(height));
            const a = EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS + altitude;
            const b = Math.sin(pitchRad) * distance;
            const cameraHeight = Math.sqrt(a * a + b * b);
            result.setLength(cameraHeight);
        }
        return result;
    }
    MapViewUtils.getCameraPositionFromTargetCoordinates = getCameraPositionFromTargetCoordinates;
    /**
     * @deprecated use getCameraPositionFromTargetCoordinates instead
     */
    function getCameraCoordinatesFromTargetCoordinates(targetCoordinates, distance, yawDeg, pitchDeg, mapView) {
        return mapView.projection.unprojectPoint(getCameraPositionFromTargetCoordinates(targetCoordinates, distance, yawDeg, pitchDeg, mapView.projection, cache.vector3[1]));
    }
    MapViewUtils.getCameraCoordinatesFromTargetCoordinates = getCameraCoordinatesFromTargetCoordinates;
    /**
     * Casts a ray in NDC space from the current map view and returns the intersection point of that
     * ray wih the map in world space.
     *
     * @param mapView Instance of MapView.
     * @param pointOnScreenXinNDC X coordinate in NDC space.
     * @param pointOnScreenYinNDC Y coordinate in NDC space.
     * @param elevation Optional param used to offset the ground plane. Used when wanting to pan
     * based on a plane at some altitude. Necessary for example when panning with terrain.
     *
     * @returns Intersection coordinates, or `null` if raycast failed.
     */
    function rayCastWorldCoordinates(mapView, pointOnScreenXinNDC, pointOnScreenYinNDC, elevation) {
        const pointInNDCPosition = cache.vector3[0].set(pointOnScreenXinNDC, pointOnScreenYinNDC, 0);
        const cameraPos = cache.vector3[1].copy(mapView.camera.position);
        cache.matrix4[0].extractRotation(mapView.camera.matrixWorld);
        // Prepare the unprojection matrix which projects from NDC space to camera space
        // and takes the current rotation of the camera into account.
        cache.matrix4[1].multiplyMatrices(cache.matrix4[0], cache.matrix4[1].getInverse(mapView.camera.projectionMatrix));
        // Unproject the point via the unprojection matrix.
        const pointInCameraSpace = pointInNDCPosition.applyMatrix4(cache.matrix4[1]);
        // Use the point in camera space as the vector towards this point.
        rayCaster.set(cameraPos, pointInCameraSpace.normalize());
        if (elevation !== undefined) {
            groundPlane.constant -= elevation;
            groundSphere.radius += elevation;
        }
        const worldPosition = new THREE.Vector3();
        const result = mapView.projection.type === harp_geoutils_1.ProjectionType.Planar
            ? rayCaster.ray.intersectPlane(groundPlane, worldPosition)
            : rayCaster.ray.intersectSphere(groundSphere, worldPosition);
        if (elevation !== undefined) {
            groundPlane.constant = 0;
            groundSphere.radius = EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS;
        }
        return result;
    }
    MapViewUtils.rayCastWorldCoordinates = rayCastWorldCoordinates;
    /**
     * Pans the camera according to the projection.
     *
     * @param mapView Instance of MapView.
     * @param xOffset In world space. Value > 0 will pan the map to the right, value < 0 will pan
     * the map to the left in default camera orientation.
     * @param yOffset In world space. Value > 0 will pan the map upwards, value < 0 will pan the map
     * downwards in default camera orientation.
     */
    function panCameraAboveFlatMap(mapView, offsetX, offsetY) {
        mapView.camera.position.x += offsetX;
        mapView.camera.position.y += offsetY;
    }
    MapViewUtils.panCameraAboveFlatMap = panCameraAboveFlatMap;
    /**
     * The function doing a pan in the spherical space when [[MapView]]'s active [[ProjectionType]]
     * is spherical. In other words, the function that rotates the camera around the globe.
     *
     * @param mapView MapView instance.
     * @param fromWorld Start vector representing the scene position of a geolocation.
     * @param toWorld End vector representing the scene position of a geolocation.
     */
    function panCameraAroundGlobe(mapView, fromWorld, toWorld) {
        cache.quaternions[0]
            .setFromUnitVectors(fromWorld.normalize(), toWorld.normalize())
            .inverse();
        cache.matrix4[0].makeRotationFromQuaternion(cache.quaternions[0]);
        mapView.camera.applyMatrix(cache.matrix4[0]);
        mapView.camera.updateMatrixWorld();
    }
    MapViewUtils.panCameraAroundGlobe = panCameraAroundGlobe;
    /**
     * Rotates the camera by the given delta yaw and delta pitch. The pitch will be clamped to the
     * maximum possible tilt to the new target, and under the horizon in sphere projection.
     *
     * @param mapView The [[MapView]] instance in use.
     * @param deltaYawDeg Delta yaw in degrees.
     * @param deltaPitchDeg Delta pitch in degrees.
     * @param maxTiltAngleRad Max tilt angle in radians.
     */
    function rotate(mapView, deltaYawDeg, deltaPitchDeg = 0, maxTiltAngleRad = Math.PI / 4) {
        // 1. Apply yaw: rotate around the vertical axis.
        mapView.camera.rotateOnWorldAxis(mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical
            ? cache.vector3[0].copy(mapView.camera.position).normalize()
            : cache.vector3[0].set(0, 0, 1), harp_geoutils_1.MathUtils.degToRad(-deltaYawDeg));
        mapView.camera.updateMatrixWorld();
        // 2. Apply pitch: rotate around the camera's local X axis.
        if (deltaPitchDeg === 0) {
            return;
        }
        const pitch = MapViewUtils.extractAttitude(mapView, mapView.camera).pitch;
        // `maxTiltAngle` is equivalent to a `maxPitchAngle` in flat projections.
        let newPitch = THREE.Math.clamp(pitch + THREE.Math.degToRad(deltaPitchDeg), 0, maxTiltAngleRad);
        // In sphere projection, the value of a maximum pitch is smaller than the value of the
        // maximum tilt, as the curvature of the surface adds up to it.
        if (mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            // Deduce max pitch from max tilt. To this end the sine law of triangles is used below.
            const maxPitch = Math.asin((EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS * Math.sin(Math.PI - maxTiltAngleRad)) /
                mapView.camera.position.length());
            newPitch = Math.min(newPitch, maxPitch);
        }
        mapView.camera.rotateX(newPitch - pitch);
    }
    MapViewUtils.rotate = rotate;
    /**
     * Computes the rotation of the camera according to yaw and pitch in degrees. The computations
     * hinge on the current `projection` and `target`, because yaw and pitch are defined in
     * tangent space of the target point.
     *
     * **Note:** `yaw == 0 && pitch == 0` will north up the map and you will look downwards onto the
     * map.
     *
     * @param projection Current projection.
     * @param target The camera target.
     * @param yawDeg Yaw in degrees, counter-clockwise (as opposed to azimuth), starting north.
     * @param pitchDeg Pitch in degrees.
     */
    function getCameraRotationAtTarget(projection, target, yawDeg, pitchDeg, result = new THREE.Quaternion()) {
        const transform = cache.transforms[0];
        projection.localTangentSpace(target, transform);
        cache.matrix4[0].makeBasis(transform.xAxis, transform.yAxis, transform.zAxis);
        result.setFromRotationMatrix(cache.matrix4[0]);
        cache.quaternions[0].setFromAxisAngle(cache.vector3[1].set(0, 0, 1), THREE.Math.degToRad(yawDeg));
        cache.quaternions[1].setFromAxisAngle(cache.vector3[1].set(1, 0, 0), THREE.Math.degToRad(pitchDeg));
        result.multiply(cache.quaternions[0]);
        result.multiply(cache.quaternions[1]);
        return result;
    }
    MapViewUtils.getCameraRotationAtTarget = getCameraRotationAtTarget;
    /**
     * Sets the rotation of the camera according to yaw and pitch in degrees. The computations hinge
     * on the current projection and `geoCenter`, because yaw and pitch are defined in tangent
     * space. In particular, `MapView#geoCenter` needs to be set before calling `setRotation`.
     *
     * **Note:** `yaw == 0 && pitch == 0` will north up the map and you will look downwards onto the
     * map.
     *
     * @param mapView Instance of MapView.
     * @param yawDeg Yaw in degrees, counter-clockwise (as opposed to azimuth), starting north.
     * @param pitchDeg Pitch in degrees.
     */
    function setRotation(mapView, yawDeg, pitchDeg) {
        getCameraRotationAtTarget(mapView.projection, mapView.geoCenter, yawDeg, pitchDeg, mapView.camera.quaternion);
    }
    MapViewUtils.setRotation = setRotation;
    /**
     * Extracts current camera tilt angle in radians.
     *
     * @param camera The [[Camera]] in use.
     * @param projection The [[Projection]] used to convert between geo and world coordinates.
     */
    function extractCameraTilt(camera, projection) {
        // For planar projections the camera target point local tangent is the same
        // at every point on the ground (ignoring terrain fluctuations), so we may
        // simply use inverted ground normal for tilt calculation. This simplifies
        // the more generic calculus used for spherical projections.
        if (projection.type === harp_geoutils_1.ProjectionType.Planar) {
            const lookAt = camera.getWorldDirection(cache.vector3[0]).normalize();
            const normal = projection
                .surfaceNormal(camera.position, cache.vector3[1])
                .negate();
            const cosTheta = lookAt.dot(normal);
            return Math.acos(THREE.Math.clamp(cosTheta, -1, 1));
        }
        else {
            // Sanity check if new projection type is introduced.
            harp_utils_1.assert(projection.type === harp_geoutils_1.ProjectionType.Spherical);
            const targetGeoCoords = MapViewUtils.getGeoTargetFromCamera(camera, projection);
            // If focus point is lost we then expose maximum allowable tilt value.
            if (targetGeoCoords !== null) {
                return MapViewUtils.extractTiltAngleFromLocation(projection, camera, targetGeoCoords);
            }
            else {
                logger.warn("MapView camera is pointing in the void, using maxTilt: ", maxTiltAngleAllowed);
                return maxTiltAngleAllowed;
            }
        }
    }
    MapViewUtils.extractCameraTilt = extractCameraTilt;
    /**
     * Extracts yaw, pitch, and roll rotation in radians.
     * - Yaw : Rotation around the vertical axis, counter-clockwise (as opposed to azimuth),
     * starting north.
     * - Pitch :Rotation around the horizontal axis.
     * - Roll : Rotation around the view axis.
     *
     * @see https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles
     *
     * @param options Subset of necessary [[MapView]] properties.
     * @param object The [[THREE.Object3D]] instance to extract the rotations from.
     */
    function extractAttitude(options, object) {
        // 1. Build the matrix of the tangent space of the object.
        cache.vector3[1].setFromMatrixPosition(object.matrixWorld); // Ensure using world position.
        options.projection.localTangentSpace(options.projection.unprojectPoint(cache.vector3[1]), {
            xAxis: tangentSpace.x,
            yAxis: tangentSpace.y,
            zAxis: tangentSpace.z,
            position: cache.vector3[0]
        });
        cache.matrix4[1].makeBasis(tangentSpace.x, tangentSpace.y, tangentSpace.z);
        // 2. Change the basis of matrixWorld to the tangent space to get the new base axes.
        cache.matrix4[0].getInverse(cache.matrix4[1]).multiply(object.matrixWorld);
        space.x.setFromMatrixColumn(cache.matrix4[0], 0);
        space.y.setFromMatrixColumn(cache.matrix4[0], 1);
        space.z.setFromMatrixColumn(cache.matrix4[0], 2);
        // 3. Deduce orientation from the base axes.
        let yaw = 0;
        let pitch = 0;
        let roll = 0;
        // Decompose rotation matrix into Z0 X Z1 Euler angles.
        const d = space.z.dot(cache.vector3[1].set(0, 0, 1));
        if (d < 1.0 - epsilon) {
            if (d > -1.0 + epsilon) {
                yaw = Math.atan2(space.z.x, -space.z.y);
                pitch = Math.acos(space.z.z);
                roll = Math.atan2(space.x.z, space.y.z);
            }
            else {
                // Looking bottom-up with space.z.z == -1.0
                yaw = -Math.atan2(-space.y.x, space.x.x);
                pitch = 180;
                roll = 0;
            }
        }
        else {
            // Looking top-down with space.z.z == 1.0
            yaw = Math.atan2(-space.y.x, space.x.x);
            pitch = 0.0;
            roll = 0.0;
        }
        return {
            yaw,
            pitch,
            roll
        };
    }
    MapViewUtils.extractAttitude = extractAttitude;
    /**
     * Gets the spherical coordinates in radian of the object to the coordinates of `point`.
     *
     * Note: this method can be used to get the direction that an object points to, when `location`
     * is the target of that object, by adding PI to it. Otherwise it only returns the spherical
     * coordinates of `object` in the tangent space of `location`.
     *
     * @param mapView The [[MapView]] instance to consider.
     * @param object The object to get the coordinates from.
     * @param location The reference point.
     */
    function extractSphericalCoordinatesFromLocation(mapView, object, location) {
        mapView.projection.localTangentSpace(location, {
            xAxis: tangentSpace.x,
            yAxis: tangentSpace.y,
            zAxis: tangentSpace.z,
            position: cache.vector3[0]
        });
        let tilt = 0;
        let azimuth = 0;
        // Get point to object vector in `cache.vector3[1]` and deduce `tilt` from the angle with
        // tangent Z.
        cache.vector3[1]
            .copy(object.position)
            .sub(cache.vector3[0])
            .normalize();
        if (cache.vector3[1].dot(tangentSpace.z) > 1 - epsilon) {
            // Top down view: the azimuth of the object would be opposite the yaw, and clockwise.
            azimuth = Math.PI - extractAttitude(mapView, object).yaw;
            // Wrap between -PI and PI.
            azimuth = Math.atan2(Math.sin(azimuth), Math.cos(azimuth));
            tilt = 0;
            return { tilt, azimuth };
        }
        tilt = cache.vector3[1].angleTo(tangentSpace.z);
        // Tilted view: the azimuth is the direction of the object from the origin.
        cache.vector3[1]
            .copy(object.position)
            .sub(cache.vector3[0])
            .projectOnPlane(tangentSpace.z)
            .normalize();
        azimuth = cache.vector3[1].angleTo(tangentSpace.y);
        if (cache.vector3[1].cross(tangentSpace.y).dot(tangentSpace.z) < 0) {
            azimuth = -azimuth;
        }
        return { tilt, azimuth };
    }
    MapViewUtils.extractSphericalCoordinatesFromLocation = extractSphericalCoordinatesFromLocation;
    /**
     * Gets the tilt angle (in radians) of the object relative to the coordinates of `location`.
     *
     * Note: this method can be used to get the direction that an object points to, when `location`
     * is the target of that object, by adding PI to it. Otherwise it only returns the tilt angle
     * (in radians) of `object` in the tangent space of `location`.
     *
     * @param projection The [[Projection]] used when converting from geo to world coordinates.
     * @param object The object to get the coordinates from.
     * @param location The reference point.
     */
    function extractTiltAngleFromLocation(projection, object, location) {
        projection.localTangentSpace(location, {
            xAxis: tangentSpace.x,
            yAxis: tangentSpace.y,
            zAxis: tangentSpace.z,
            position: cache.vector3[0]
        });
        // Get point to object vector (dirVec) and compute the `tilt` as the angle with tangent Z.
        const dirVec = cache.vector3[1].copy(object.position).sub(cache.vector3[0]);
        const dirLen = dirVec.length();
        if (dirLen < epsilon) {
            logger.error("Can not calculate tilt for the zero length vector!");
            return 0;
        }
        dirVec.divideScalar(dirLen);
        const cosTheta = dirVec.dot(tangentSpace.z);
        if (cosTheta > 1 - epsilon) {
            // Top down view.
            return 0;
        }
        return Math.acos(THREE.Math.clamp(cosTheta, -1, 1));
    }
    MapViewUtils.extractTiltAngleFromLocation = extractTiltAngleFromLocation;
    /**
     * Get perspective camera frustum planes distances.
     * @return all plane distances in helper object.
     */
    function getCameraFrustumPlanes(camera) {
        const near = camera.near;
        const far = camera.far;
        let top = (near * Math.tan(THREE.Math.degToRad(0.5 * camera.fov))) / camera.zoom;
        let height = 2 * top;
        let width = camera.aspect * height;
        let left = -0.5 * width;
        const view = camera.view;
        if (view !== null && view.enabled) {
            const fullWidth = view.fullWidth;
            const fullHeight = view.fullHeight;
            left += (view.offsetX * width) / fullWidth;
            top -= (view.offsetY * height) / fullHeight;
            width *= view.width / fullWidth;
            height *= view.height / fullHeight;
        }
        // Correct by skew factor
        left += camera.filmOffset !== 0 ? (near * camera.filmOffset) / camera.getFilmWidth() : 0;
        return {
            left,
            right: left + width,
            top,
            bottom: top - height,
            near,
            far
        };
    }
    MapViewUtils.getCameraFrustumPlanes = getCameraFrustumPlanes;
    /**
     * Casts a ray in NDC space from the current view of the camera and returns the intersection
     * point of that ray against the map in geo coordinates. The return value can be `null` when
     * the raycast is above the horizon.
     *
     * @param mapView Instance of MapView.
     * @param pointOnScreenXNDC  Abscissa in NDC space.
     * @param pointOnScreenYNDC  Ordinate in NDC space.
     * @returns Intersection geo coordinates, or `null` if raycast is above the horizon.
     */
    function rayCastGeoCoordinates(mapView, pointOnScreenXinNDC, pointOnScreenYinNDC) {
        const worldCoordinates = rayCastWorldCoordinates(mapView, pointOnScreenXinNDC, pointOnScreenYinNDC);
        if (!worldCoordinates) {
            return null;
        }
        return mapView.projection.unprojectPoint(worldCoordinates);
    }
    MapViewUtils.rayCastGeoCoordinates = rayCastGeoCoordinates;
    /**
     * Calculates and returns the distance from the ground, which is needed to put the camera to
     * this height, to see the size of the area that would be covered by one tile for the given zoom
     * level.
     *
     * @param mapView Instance of MapView.
     * @param options Subset of necessary [[MapView]] properties.
     */
    function calculateDistanceToGroundFromZoomLevel(options, zoomLevel) {
        const cameraPitch = extractAttitude(options, options.camera).pitch;
        const tileSize = EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE / Math.pow(2, zoomLevel);
        return ((options.focalLength * tileSize) / 256) * Math.cos(cameraPitch);
    }
    MapViewUtils.calculateDistanceToGroundFromZoomLevel = calculateDistanceToGroundFromZoomLevel;
    /**
     * Calculates and returns the distance to the target point.
     *
     * @param options Necessary subset of MapView properties to compute the distance.
     * @param zoomLevel The zoom level to get the equivalent height to.
     */
    function calculateDistanceFromZoomLevel(options, zoomLevel) {
        const tileSize = EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE / Math.pow(2, zoomLevel);
        return (options.focalLength * tileSize) / 256;
    }
    MapViewUtils.calculateDistanceFromZoomLevel = calculateDistanceFromZoomLevel;
    /**
     * Calculates the zoom level, which corresponds to the current distance from
     * camera to lookAt point.
     * Therefore the zoom level is a `float` and not an `int`. The height of the camera can be in
     * between zoom levels. By setting the zoom level, you change the height position of the camera
     * in away that the field of view of the camera should be able to cover one tile for the given
     * zoom level.
     *
     * As an example for this, when you have a tile of zoom level 14 in front of the camera and you
     * set the zoom level of the camera to 14, then you are able to see the whole tile in front of
     * you.
     *
     * @param options Subset of necessary [[MapView]] properties.
     * @param distance The distance in meters, which are scene units in [[MapView]].
     */
    function calculateZoomLevelFromDistance(options, distance) {
        const tileSize = (256 * distance) / options.focalLength;
        const zoomLevel = THREE.Math.clamp(Math.log2(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE / tileSize), options.minZoomLevel, options.maxZoomLevel);
        // Round to avoid modify the zoom level without distance change, with the imprecision
        // introduced by raycasting.
        return Math.round(zoomLevel * 10e15) / 10e15;
    }
    MapViewUtils.calculateZoomLevelFromDistance = calculateZoomLevelFromDistance;
    /**
     * Translates a linear clip-space distance value to the actual value stored in the depth buffer.
     * This is useful as the depth values are not stored in the depth buffer linearly, and this can
     * lead into confusing behavior when not taken into account.
     *
     * @param clipDistance Distance from the camera in clip space (range: [0, 1]).
     * @param camera Camera applying the perspective projection.
     */
    function calculateDepthFromClipDistance(clipDistance, camera) {
        const perspCam = camera;
        const cameraRange = perspCam.far - perspCam.near;
        const viewSpaceDistance = clipDistance * perspCam.far;
        return (1.0 - perspCam.near / viewSpaceDistance) * (perspCam.far / cameraRange);
    }
    MapViewUtils.calculateDepthFromClipDistance = calculateDepthFromClipDistance;
    /**
     * Translates a linear distance value [0..1], where 1 is the distance to the far plane, into
     * [0..cameraFar].
     *
     * @param distance Distance from the camera (range: [0, 1]).
     * @param camera Camera applying the perspective projection.
     */
    function cameraToWorldDistance(distance, camera) {
        const perspCam = camera;
        return distance * perspCam.far;
    }
    MapViewUtils.cameraToWorldDistance = cameraToWorldDistance;
    /**
     * Calculates vertical field of view for given horizontal field of vision and aspect ratio.
     *
     * @param hFov Horizontal field of view in rad.
     * @param aspect Aspect ratio.
     */
    function calculateVerticalFovByHorizontalFov(hFov, aspect) {
        return 2 * Math.atan(Math.tan(hFov / 2) / aspect);
    }
    MapViewUtils.calculateVerticalFovByHorizontalFov = calculateVerticalFovByHorizontalFov;
    /**
     * Calculates horizontal field of view for given vertical field of vision and aspect ratio.
     *
     * @param hFov Vertical field of view in rad.
     * @param aspect Aspect ratio.
     */
    function calculateHorizontalFovByVerticalFov(vFov, aspect) {
        return 2 * Math.atan(Math.tan(vFov / 2) * aspect);
    }
    MapViewUtils.calculateHorizontalFovByVerticalFov = calculateHorizontalFovByVerticalFov;
    /**
     * Calculates the focal length based on the vertical FOV and height.
     *
     * @param vFov Vertical field of view in rad.
     * @param height Height of canvas in pixels.
     */
    function calculateFocalLengthByVerticalFov(vFov, height) {
        return height / 2 / Math.tan(vFov / 2);
    }
    MapViewUtils.calculateFocalLengthByVerticalFov = calculateFocalLengthByVerticalFov;
    /**
     * Calculates the vertical field of view based on the focal length and the height.
     *
     * @param focalLength Focal length in pixels (see [[calculateFocalLengthByVerticalFov]])
     * @param height Height of canvas in pixels.
     */
    function calculateFovByFocalLength(focalLength, height) {
        return THREE.Math.radToDeg(2 * Math.atan(height / 2 / focalLength));
    }
    MapViewUtils.calculateFovByFocalLength = calculateFovByFocalLength;
    /**
     * Calculates object's screen size based on the focal length and it's camera distance.
     *
     * @param focalLength Focal length in pixels (see [[calculateFocalLengthByVerticalFov]])
     * @param distance Object distance in world space.
     * @param worldSize Object size in world space.
     * @return object size in screen space.
     */
    function calculateScreenSizeByFocalLength(focalLength, distance, worldSize) {
        return (focalLength * worldSize) / distance;
    }
    MapViewUtils.calculateScreenSizeByFocalLength = calculateScreenSizeByFocalLength;
    /**
     * Calculates object's world size based on the focal length and it's camera distance.
     *
     * @param focalLength Focal length in pixels (see [[calculateFocalLengthByVerticalFov]])
     * @param distance Object distance in world space.
     * @param screenSize Object size in screen space.
     * @return object size in world space.
     */
    function calculateWorldSizeByFocalLength(focalLength, distance, screenSize) {
        return (distance * screenSize) / focalLength;
    }
    MapViewUtils.calculateWorldSizeByFocalLength = calculateWorldSizeByFocalLength;
    /**
     * Computes estimate for size of a THREE.Object3D object and its children. Shared materials
     * and/or attributes will be counted multiple times.
     *
     * @param object The mesh object to evaluate
     * @param size The [[MemoryUsage]] to update.
     * @param visitedObjects Optional map to store large objects that could be shared.
     *
     * @returns Estimate of object size in bytes for heap and GPU.
     */
    function estimateObject3dSize(object, parentSize, visitedObjects) {
        const size = parentSize !== undefined
            ? parentSize
            : {
                heapSize: 0,
                gpuSize: 0
            };
        if (visitedObjects === undefined) {
            visitedObjects = new Map();
        }
        estimateMeshSize(object, size, visitedObjects);
        if (object.children.length > 0) {
            for (const child of object.children) {
                estimateObject3dSize(child, size, visitedObjects);
            }
        }
        return size;
    }
    MapViewUtils.estimateObject3dSize = estimateObject3dSize;
    /**
     * Check if tiles or other content is currently being loaded.
     *
     * This method can be removed once HARP-7932 is implemented.
     *
     * @returns `true` if MapView has visible tiles or other content that is being loaded.
     */
    function mapViewIsLoading(mapView) {
        let numTilesLoading = 0;
        for (const tileList of mapView.visibleTileSet.dataSourceTileList) {
            numTilesLoading += tileList.numTilesLoading;
            for (const tile of tileList.visibleTiles) {
                if (tile.tileLoader !== undefined && !tile.tileLoader.isFinished) {
                    numTilesLoading++;
                }
                if (tile.tileGeometryLoader !== undefined && !tile.tileGeometryLoader.isFinished) {
                    numTilesLoading++;
                }
            }
        }
        let isLoading = numTilesLoading > 0;
        if (mapView.textElementsRenderer !== undefined) {
            isLoading = isLoading || mapView.textElementsRenderer.loading;
        }
        isLoading =
            isLoading ||
                !mapView.poiTableManager.finishedLoading ||
                !mapView.visibleTileSet.allVisibleTilesLoaded;
        return isLoading;
    }
    MapViewUtils.mapViewIsLoading = mapViewIsLoading;
    function estimateTextureSize(texture, objectSize, visitedObjects) {
        if (texture === null || texture === undefined || texture.image === undefined) {
            return;
        }
        if (texture.uuid !== undefined && visitedObjects.get(texture.uuid) === true) {
            return;
        }
        visitedObjects.set(texture.uuid, true);
        // May be HTMLImage or ImageData
        const image = texture.image;
        // Assuming RGBA
        const imageBytes = 4 * image.width * image.height;
        objectSize.heapSize += imageBytes;
        objectSize.gpuSize += imageBytes;
    }
    function estimateMaterialSize(material, objectSize, visitedObjects) {
        if (material.uuid !== undefined && visitedObjects.get(material.uuid) === true) {
            return;
        }
        visitedObjects.set(material.uuid, true);
        if (material instanceof THREE.RawShaderMaterial ||
            material instanceof THREE.ShaderMaterial) {
            const rawMaterial = material;
            for (const name in rawMaterial.uniforms) {
                if (rawMaterial.uniforms[name] !== undefined) {
                    const uniform = rawMaterial.uniforms[name];
                    if (uniform instanceof THREE.Texture) {
                        estimateTextureSize(uniform, objectSize, visitedObjects);
                    }
                }
            }
        }
        else if (material instanceof THREE.MeshBasicMaterial ||
            material instanceof harp_materials_1.MapMeshBasicMaterial) {
            const meshMaterial = material;
            estimateTextureSize(meshMaterial.map, objectSize, visitedObjects);
            estimateTextureSize(meshMaterial.aoMap, objectSize, visitedObjects);
            estimateTextureSize(meshMaterial.specularMap, objectSize, visitedObjects);
            estimateTextureSize(meshMaterial.alphaMap, objectSize, visitedObjects);
            estimateTextureSize(meshMaterial.envMap, objectSize, visitedObjects);
        }
        else if (material instanceof harp_materials_1.MapMeshStandardMaterial) {
            const standardMaterial = material;
            estimateTextureSize(standardMaterial.map, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.lightMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.aoMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.emissiveMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.bumpMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.normalMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.displacementMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.roughnessMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.metalnessMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.alphaMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.envMap, objectSize, visitedObjects);
        }
        else if (material instanceof THREE.LineBasicMaterial ||
            material instanceof THREE.LineDashedMaterial) {
            // Nothing to be done here
        }
        else {
            logger.warn("estimateMeshSize: unidentified material: ", material);
        }
    }
    function estimateAttributeSize(attribute, attrName, objectSize, visitedObjects) {
        // Attributes (apparently) do not have their uuid set up.
        if (attribute.uuid === undefined) {
            attribute.uuid = THREE.Math.generateUUID();
        }
        if (visitedObjects.get(attribute.uuid) === true) {
            return;
        }
        visitedObjects.set(attribute.uuid, true);
        let attrBytes = 0;
        let bytesPerElement = 4;
        if (attribute.array.BYTES_PER_ELEMENT !== undefined) {
            bytesPerElement = attribute.array.BYTES_PER_ELEMENT;
        }
        if (attribute instanceof THREE.InterleavedBufferAttribute ||
            attribute instanceof THREE.BufferAttribute) {
            attrBytes = bytesPerElement * attribute.count * attribute.itemSize;
        }
        else {
            logger.warn("estimateMeshSize: unidentified attribute: ", attrName);
        }
        objectSize.heapSize += attrBytes + MINIMUM_ATTRIBUTE_SIZE_ESTIMATION;
        objectSize.gpuSize += attrBytes;
    }
    function estimateGeometrySize(geometry, objectSize, visitedObjects) {
        const isNewObject = geometry.uuid === undefined || visitedObjects.get(geometry.uuid) !== true;
        if (!isNewObject) {
            return;
        }
        visitedObjects.set(geometry.uuid, true);
        let bufferGeometry;
        if (geometry instanceof THREE.Geometry) {
            // Each vertex is represented as 3 floats vector (24 bytes).
            objectSize.heapSize += geometry.vertices.length * 24;
            // Face: 3 indices (24 byte), 1 normal (3 floats = 24). Vertex normals and
            // colors are not counted here.
            objectSize.heapSize += geometry.faces.length * (24 + 24);
            // Additionally, the internal _bufferGeometry is also counted:
            bufferGeometry = geometry._bufferGeometry;
        }
        else if (geometry instanceof THREE.BufferGeometry) {
            bufferGeometry = geometry;
        }
        if (bufferGeometry === undefined) {
            // Nothing more to calculate.
            return;
        }
        const attributes = bufferGeometry.attributes;
        if (attributes === undefined) {
            logger.warn("estimateGeometrySize: unidentified geometry: ", geometry);
            return;
        }
        for (const property in attributes) {
            if (attributes[property] !== undefined) {
                estimateAttributeSize(attributes[property], property, objectSize, visitedObjects);
            }
        }
        if (bufferGeometry.index !== null) {
            estimateAttributeSize(bufferGeometry.index, "index", objectSize, visitedObjects);
        }
    }
    function estimateMeshSize(object, objectSize, visitedObjects) {
        if (!object.isObject3D || object instanceof THREE.Scene) {
            return;
        }
        if (object.uuid !== undefined && visitedObjects.get(object.uuid) === true) {
            return;
        }
        visitedObjects.set(object.uuid, true);
        if (object.isMesh || object.isLine || object.isPoints) {
            // Estimated minimum impact on heap.
            let heapSize = MINIMUM_OBJECT3D_SIZE_ESTIMATION;
            const gpuSize = 0;
            // Cast to Points class which contains the minimal required properties sub-set.
            const mesh = object;
            // Calculate material(s) impact.
            if (mesh.material !== undefined) {
                if (Array.isArray(mesh.material)) {
                    const materials = mesh.material;
                    for (const material of materials) {
                        estimateMaterialSize(material, objectSize, visitedObjects);
                    }
                }
                else {
                    const material = mesh.material;
                    estimateMaterialSize(material, objectSize, visitedObjects);
                }
            }
            // Calculate cost of geometry.
            if (mesh.geometry !== undefined) {
                estimateGeometrySize(mesh.geometry, objectSize, visitedObjects);
            }
            // Add info that is required for picking (parts of) objects and match them to
            // the featureID in the map data.
            const featureData = object.userData !== undefined
                ? object.userData.feature
                : undefined;
            if (featureData !== undefined) {
                heapSize += Tile_1.getFeatureDataSize(featureData);
            }
            objectSize.heapSize += heapSize;
            objectSize.gpuSize += gpuSize;
        }
        else {
            logger.warn("estimateMeshSize: unidentified object", object);
        }
    }
    /**
     * Gets language list used by the browser
     *
     * @returns Array of iso language codes
     */
    function getBrowserLanguages() {
        if (navigator.languages !== undefined && navigator.languages.length > 0) {
            const languageList = [];
            for (const lang of navigator.languages) {
                languageList.push(getIsoLanguageCode(lang));
            }
            return languageList;
        }
        if (navigator.language !== undefined) {
            return [getIsoLanguageCode(navigator.language)];
        }
        return undefined;
    }
    MapViewUtils.getBrowserLanguages = getBrowserLanguages;
    /**
     * Gets ISO-639-1 language code from browser's code (ex. en for en-US)
     */
    function getIsoLanguageCode(language) {
        return language.substring(0, 2);
    }
})(MapViewUtils = exports.MapViewUtils || (exports.MapViewUtils = {}));
/** @hidden */
const powerOfTwo = [
    0x1,
    0x2,
    0x4,
    0x8,
    0x10,
    0x20,
    0x40,
    0x80,
    0x100,
    0x200,
    0x400,
    0x800,
    0x1000,
    0x2000,
    0x4000,
    0x8000,
    0x10000,
    0x20000,
    0x40000,
    0x80000,
    0x100000,
    0x200000,
    0x400000,
    0x800000,
    0x1000000,
    0x2000000,
    0x4000000,
    0x8000000,
    0x10000000,
    0x20000000,
    0x40000000,
    0x80000000,
    0x100000000,
    0x200000000,
    0x400000000,
    0x800000000,
    0x1000000000,
    0x2000000000,
    0x4000000000,
    0x8000000000,
    0x10000000000,
    0x20000000000,
    0x40000000000,
    0x80000000000,
    0x100000000000,
    0x200000000000,
    0x400000000000,
    0x800000000000,
    0x1000000000000,
    0x2000000000000,
    0x4000000000000,
    0x8000000000000,
    0x10000000000000
];
var TileOffsetUtils;
(function (TileOffsetUtils) {
    /**
     * Creates a unique key based on the supplied parameters. Note, the uniqueness is bounded by the
     * bitshift. The [[TileKey.mortonCode()]] supports currently up to 26 levels (this is because
     * 26*2 equals 52, and 2^52 is the highest bit that can be set in an integer in Javascript), the
     * bitshift reduces this accordingly, so given the default bitshift of four, we support up to 24
     * levels. Given the current support up to level 19 this should be fine.
     *
     * @param tileKey The unique [[TileKey]] from which to compute the unique key.
     * @param offset How much the given [[TileKey]] is offset
     * @param bitshift How much space we have to store the offset. The default of 4 means we have
     *      enough space to store 16 unique tiles in a single view.
     */
    function getKeyForTileKeyAndOffset(tileKey, offset, bitshift = 4) {
        const shiftedOffset = getShiftedOffset(offset, bitshift);
        return tileKey.mortonCode() + shiftedOffset;
    }
    TileOffsetUtils.getKeyForTileKeyAndOffset = getKeyForTileKeyAndOffset;
    /**
     * Extracts the offset and morton key from the given key (must be created by:
     * [[getKeyForTileKeyAndOffset]])
     *
     * Note, we can't use bitshift operators in Javascript because they work on 32-bit integers, and
     * would truncate the numbers, hence using powers of two.
     *
     * @param key Key to extract offset and morton key.
     * @param bitshift How many bits to shift by, must be the same as was used when creating the
     * key.
     */
    function extractOffsetAndMortonKeyFromKey(key, bitshift = 4) {
        let offset = 0;
        let mortonCode = key;
        let i = 0;
        // Compute the offset
        for (; i < bitshift; i++) {
            // Note, we use 52, because 2^53-1 is the biggest value, the highest value
            // that can be set is the bit in the 52th position.
            const num = powerOfTwo[52 - i];
            if (mortonCode >= num) {
                mortonCode -= num;
                offset += powerOfTwo[bitshift - 1 - i];
            }
        }
        // We subtract half of the total amount, this undoes what is computed in getShiftedOffset
        offset -= powerOfTwo[bitshift - 1];
        return { offset, mortonCode };
    }
    TileOffsetUtils.extractOffsetAndMortonKeyFromKey = extractOffsetAndMortonKeyFromKey;
    /**
     * Returns the key of the parent. Key must have been computed using the function
     * [[getKeyForTileKeyAndOffset]].
     *
     * @param calculatedKey Key to decompose
     * @param bitshift Bit shift used to create the key
     */
    function getParentKeyFromKey(calculatedKey, bitshift = 4) {
        const { offset, mortonCode } = extractOffsetAndMortonKeyFromKey(calculatedKey, bitshift);
        const parentTileKey = harp_geoutils_1.TileKey.fromMortonCode(harp_geoutils_1.TileKey.parentMortonCode(mortonCode));
        return getKeyForTileKeyAndOffset(parentTileKey, offset, bitshift);
    }
    TileOffsetUtils.getParentKeyFromKey = getParentKeyFromKey;
    /**
     * Packs the supplied offset into the high bits, where the highbits are between 2^52 and
     * 2^(52-bitshift).
     *
     * Offsets are wrapped around, to fit in the offsetBits. In practice, this doesn't really
     * matter, this is primarily used to find a unique id, if there is an offset 10, which is
     * wrapped to 2, it doesn't matter, because the offset of 10 is still stored in the tile.
     * What can be a problem though is that the cache gets filled up and isn't emptied.
     *
     * Note, because bit shifting in JavaScript works on 32 bit integers, we use powers of 2 to set
     * the high bits instead.
     *
     * @param offset Offset to pack into the high bits.
     * @param offsetBits How many bits to use to pack the offset.
     */
    function getShiftedOffset(offset, offsetBits = 4) {
        let result = 0;
        const totalOffsetsToStore = powerOfTwo[offsetBits];
        //Offsets are stored by adding half 2 ^ (bitshift - 1), i.e.half of the max amount stored,
        //and then wrapped based on this value.For example, given a bitshift of 3, and an offset -
        //3, it would have 4 added(half of 2 ^ 3), and be stored as 1, 3 would have 4 added and be
        //stored as 7, 4 would be added with 4 and be stored as 0 (it wraps around).
        offset += totalOffsetsToStore / 2;
        while (offset < 0) {
            offset += totalOffsetsToStore;
        }
        while (offset >= totalOffsetsToStore) {
            offset -= totalOffsetsToStore;
        }
        // Offset is now a number between >= 0 and < totalOffsetsToStore
        for (let i = 0; i < offsetBits && offset > 0; i++) {
            // tslint:disable: no-bitwise
            // 53 is used because 2^53-1 is the biggest number that Javascript can represent as an
            // integer safely.
            if (offset & 0x1) {
                result += powerOfTwo[53 - offsetBits + i];
            }
            offset >>>= 1;
            // tslint:enable: no-bitwise
        }
        harp_utils_1.assert(offset === 0);
        return result;
    }
})(TileOffsetUtils = exports.TileOffsetUtils || (exports.TileOffsetUtils = {}));


/***/ }),

/***/ "../harp-mapview/lib/VisibleTileSet.ts":
/*!*********************************************!*\
  !*** ../harp-mapview/lib/VisibleTileSet.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_lrucache_1 = __webpack_require__(/*! @here/harp-lrucache */ "../harp-lrucache/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const THREE = __webpack_require__(/*! three */ "three");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-mapview/lib/Utils.ts");
/**
 * Way the memory consumption of a tile is computed. Either in number of tiles, or in MegaBytes. If
 * it is in MB, an estimation is used.
 */
var ResourceComputationType;
(function (ResourceComputationType) {
    ResourceComputationType[ResourceComputationType["EstimationInMb"] = 0] = "EstimationInMb";
    ResourceComputationType[ResourceComputationType["NumberOfTiles"] = 1] = "NumberOfTiles";
})(ResourceComputationType = exports.ResourceComputationType || (exports.ResourceComputationType = {}));
const MB_FACTOR = 1.0 / (1024.0 * 1024.0);
/**
 * Wrapper for LRU cache that encapsulates tiles caching for any [[DataSource]] used.
 *
 * Provides LRU based caching mechanism where each tile is identified by its tile key
 * (morton code) and data source name.
 * Tiles are kept in the cache based on last recently used policy, cached tile may be evicted
 * only when cache reaches full saturation and tile is no longer visible.
 * @note Currently cached entries (tiles) are identified by unique tile code (morton code) and
 * data source name, thus it is required that each [[DataSource]] used should have unique
 * name, but implementation could be improved to omit this limitation.
 */
class DataSourceCache {
    constructor(cacheSize, rct = ResourceComputationType.EstimationInMb) {
        this.m_disposedTiles = [];
        this.m_resourceComputationType = rct;
        this.m_tileCache = new harp_lrucache_1.LRUCache(cacheSize, (tile) => {
            if (this.m_resourceComputationType === ResourceComputationType.EstimationInMb) {
                // Default is size in MB.
                return tile.memoryUsage * MB_FACTOR;
            }
            else {
                return 1;
            }
        });
        this.m_tileCache.evictionCallback = (_, tile) => {
            if (tile.tileLoader !== undefined) {
                // Cancel downloads as early as possible.
                tile.tileLoader.cancel();
            }
            this.m_disposedTiles.push(tile);
        };
        this.m_tileCache.canEvict = (_, tile) => {
            // Tiles can be evicted that weren't requested in the last frame.
            return !tile.isVisible;
        };
    }
    /**
     * Creates unique tile key for caching based on morton code, tile offset and its data source.
     *
     * @param mortonCode The tile morton code.
     * @param offset The tile offset.
     * @param dataSource The [[DataSource]] from which tile was loaded.
     */
    static getKey(mortonCode, offset, dataSource) {
        return `${dataSource.name}_${mortonCode}_${offset}`;
    }
    /**
     * Create unique tile identifier for caching, based on tile object passed in.
     *
     * @param tile The tile for which key is generated.
     */
    static getKeyForTile(tile) {
        return DataSourceCache.getKey(tile.tileKey.mortonCode(), tile.offset, tile.dataSource);
    }
    /**
     * Get information how cached tiles affects cache space available.
     *
     * The way how cache evaluates the __resources size__ have a big influence on entire
     * caching mechanism, if [[resourceComputationType]] is set to:
     * [[ResourceComputationType.EstimationInMb]] then each tiles contributes to cache size
     * differently depending on the memory consumed, on other side
     * [[ResourceComputationType.NumberOfTiles]] says each tile occupies single slot in cache,
     * so its real memory consumed does not matter affect caching behavior. Of course in
     * the second scenario cache may grow significantly in terms of memory usage and thus it
     * is out of control.
     *
     * @return [[ResourceComputationType]] enum that describes if resources are counted by
     * space occupied in memory or just by number of them.
     */
    get resourceComputationType() {
        return this.m_resourceComputationType;
    }
    /**
     * Get the cache capacity measured as number if megabytes or number of entries.
     *
     * The total cached tiles size determines cache saturation, if it reaches the capacity value
     * then the resources becomes evicted (released) starting from the oldest (the latest used).
     *
     * @see size.
     * @see resourceComputationType.
     */
    get capacity() {
        return this.m_tileCache.capacity;
    }
    /**
     * Get total cache size described as number of megabytes consumed or number of tiles stored.
     *
     * @see capacity.
     * @see resourceComputationType.
     */
    get size() {
        return this.m_tileCache.size;
    }
    /**
     * Set cache capacity and the algorithm used for cache size calculation.
     *
     * @see capacity.
     * @see resourceComputationType.
     * @param size The new capacity declared in megabytes or number of entires.
     * @param rct The enum value that determines how size and capacity are evaluated.
     */
    setCapacity(size, rct) {
        this.m_resourceComputationType = rct;
        this.m_tileCache.setCapacityAndMeasure(size, (tile) => {
            if (this.m_resourceComputationType === ResourceComputationType.EstimationInMb) {
                // Default is size in MB.
                return tile.memoryUsage * MB_FACTOR;
            }
            else {
                return 1;
            }
        });
    }
    /**
     * Get tile cached or __undefined__ if tile is not yet in cache.
     *
     * @param mortonCode En unique tile morton code.
     * @param offset Tile offset.
     * @param dataSource A [[DataSource]] the tile comes from.
     */
    get(mortonCode, offset, dataSource) {
        return this.m_tileCache.get(DataSourceCache.getKey(mortonCode, offset, dataSource));
    }
    /**
     * Add new tile to the cache.
     *
     * @param mortonCode En unique tile code (morton code).
     * @param offset The tile offset.
     * @param dataSource A [[DataSource]] the tile comes from.
     * @param tile The tile reference.
     */
    set(mortonCode, offset, dataSource, tile) {
        this.m_tileCache.set(DataSourceCache.getKey(mortonCode, offset, dataSource), tile);
    }
    /**
     * Delete tile from cache.
     *
     * @note This method will not call eviction callback.
     * @param tile The tile reference to be removed from cache.
     */
    delete(tile) {
        const tileKey = DataSourceCache.getKeyForTile(tile);
        this.deleteByKey(tileKey);
    }
    /**
     * Delete tile using its unique identifier.
     *
     * @note Tile identifier its constructed using information about tile code (morton code) and its
     * [[DataSource]].
     * @note This is explicit removal thus eviction callback will not be processed.
     * @see DataSourceCache.getKey.
     * @param tileKey The unique tile identifier.
     */
    deleteByKey(tileKey) {
        this.m_tileCache.delete(tileKey);
    }
    /**
     * Dispose all tiles releasing their internal data.
     */
    disposeTiles() {
        this.m_disposedTiles.forEach(tile => {
            tile.dispose();
        });
        this.m_disposedTiles.length = 0;
    }
    /**
     * Shrink cache to its allowed capacity.
     *
     * This method should be called each time after operations are performed on the cache entries,
     * in order to keep cache size consistent. It informs caching mechanism to invalidate memory
     * consumed by its entries and check if cache is overgrown, is such case some tiles will be
     * evicted.
     */
    shrinkToCapacity() {
        this.m_tileCache.shrinkToCapacity();
    }
    /**
     * Evict all cached tiles implicitly even without checking if still in use.
     */
    evictAll() {
        this.m_tileCache.evictAll();
    }
    /**
     * Evict selected tiles implicitly.
     *
     * @param selector The callback used to determine if tile should be evicted.
     */
    evictSelected(selector) {
        this.m_tileCache.evictSelected(selector);
    }
    /**
     * Call functor (callback) on each tile store in cache.
     *
     * Optionally you may specify from which [[DataSource]] tiles should be processed.
     * This limits the tiles visited to a sub-set originating from single [[DataSource]].
     * @param callback The function to be called for each visited tile.
     * @param inDataSource The optional [[DataSource]] to which tiles should belong.
     */
    forEach(callback, inDataSource) {
        this.m_tileCache.forEach((entry, key) => {
            if (inDataSource === undefined || entry.dataSource === inDataSource) {
                callback(entry, key);
            }
        });
    }
}
/**
 * Manages visible [[Tile]]s for [[MapView]].
 *
 * Responsible for election of rendered tiles:
 *  - quad-tree traversal
 *  - frustum culling
 *  - sorting tiles by relevance (visible area) to prioritize load
 *  - limiting number of visible tiles
 *  - caching tiles
 *  - searching cache to replace visible but yet empty tiles with already loaded siblings in nearby
 *    zoom levels
 */
class VisibleTileSet {
    constructor(m_frustumIntersection, m_tileGeometryManager, options) {
        this.m_frustumIntersection = m_frustumIntersection;
        this.m_tileGeometryManager = m_tileGeometryManager;
        this.dataSourceTileList = [];
        this.allVisibleTilesLoaded = false;
        this.m_projectionMatrixOverride = new THREE.Matrix4();
        this.m_viewRange = { near: 0.1, far: Infinity, minimum: 0.1, maximum: Infinity };
        this.m_resourceComputationType = ResourceComputationType.EstimationInMb;
        this.options = options;
        this.m_resourceComputationType =
            options.resourceComputationType === undefined
                ? ResourceComputationType.EstimationInMb
                : options.resourceComputationType;
        this.m_dataSourceCache = new DataSourceCache(this.options.tileCacheSize, this.m_resourceComputationType);
    }
    /**
     * Returns cache size.
     */
    getDataSourceCacheSize() {
        return this.options.tileCacheSize;
    }
    /**
     * Sets cache size.
     *
     * @param size cache size
     * @param computationType Optional value specifying the way a [[Tile]]s cache usage is computed,
     *      either based on size in MB (mega bytes) or in number of tiles. Defaults to
     *      `ResourceComputationType.EstimationInMb`.
     */
    setDataSourceCacheSize(size, computationType = ResourceComputationType.EstimationInMb) {
        this.options.tileCacheSize = size;
        // This effectively invalidates DataSourceCache
        this.resourceComputationType = computationType;
    }
    /**
     * Retrieves maximum number of visible tiles.
     */
    getNumberOfVisibleTiles() {
        return this.options.maxVisibleDataSourceTiles;
    }
    /**
     * Sets maximum number of visible tiles.
     *
     * @param size size of visible tiles array
     */
    setNumberOfVisibleTiles(size) {
        this.options.maxVisibleDataSourceTiles = size;
    }
    /**
     * The way the cache usage is computed, either based on size in MB (mega bytes) or in number of
     * tiles.
     */
    get resourceComputationType() {
        return this.m_resourceComputationType;
    }
    /**
     * Sets the way tile cache is managing its elements.
     *
     * Cache may be either keeping number of elements stored or the memory consumed by them.
     *
     * @param computationType Type of algorith used in cache for checking full saturation,
     * may be counting number of elements or memory consumed by them.
     */
    set resourceComputationType(computationType) {
        this.m_resourceComputationType = computationType;
        this.m_dataSourceCache.setCapacity(this.options.tileCacheSize, computationType);
    }
    /**
     * Evaluate frustum near/far clip planes and visibility ranges.
     */
    updateClipPlanes(maxElevation, minElevation) {
        if (maxElevation !== undefined) {
            this.options.clipPlanesEvaluator.maxElevation = maxElevation;
        }
        if (minElevation !== undefined) {
            this.options.clipPlanesEvaluator.minElevation = minElevation;
        }
        this.m_viewRange = this.options.clipPlanesEvaluator.evaluateClipPlanes(this.m_frustumIntersection.mapView);
        return this.m_viewRange;
    }
    /**
     * Calculates a new set of visible tiles.
     * @param storageLevel The camera storage level, see [[MapView.storageLevel]].
     * @param zoomLevel The camera zoom level.
     * @param dataSources The data sources for which the visible tiles will be calculated.
     * @param elevationRangeSource Source of elevation range data if any.
     * @returns view ranges and their status since last update (changed or not).
     */
    updateRenderList(storageLevel, zoomLevel, dataSources, elevationRangeSource) {
        let allVisibleTilesLoaded = true;
        const visibleTileKeysResult = this.getVisibleTileKeysForDataSources(zoomLevel, dataSources, elevationRangeSource);
        this.dataSourceTileList = [];
        for (const { dataSource, visibleTileKeys } of visibleTileKeysResult.tileKeys) {
            // Sort by distance to camera, now the tiles that are further away are at the end
            // of the list.
            //
            // Sort is unstable if distance is equal, which happens a lot when looking top-down.
            // Unstable sorting makes label placement unstable at tile borders, leading to
            // flickering.
            visibleTileKeys.sort((a, b) => {
                const distanceDiff = a.distance - b.distance;
                // Take care or numerical precision issues
                const minDiff = (a.distance + b.distance) * 0.000001;
                return Math.abs(distanceDiff) < minDiff
                    ? a.tileKey.mortonCode() - b.tileKey.mortonCode()
                    : distanceDiff;
            });
            const actuallyVisibleTiles = [];
            let allDataSourceTilesLoaded = true;
            let numTilesLoading = 0;
            // Create actual tiles only for the allowed number of visible tiles
            const displayZoomLevel = dataSource.getDisplayZoomLevel(zoomLevel);
            for (let i = 0; i < visibleTileKeys.length &&
                actuallyVisibleTiles.length < this.options.maxVisibleDataSourceTiles; i++) {
                const tileEntry = visibleTileKeys[i];
                const tile = this.getTile(dataSource, tileEntry.tileKey, tileEntry.offset);
                if (tile === undefined) {
                    continue;
                }
                tile.prepareTileInfo();
                allDataSourceTilesLoaded = allDataSourceTilesLoaded && tile.allGeometryLoaded;
                if (!tile.allGeometryLoaded) {
                    numTilesLoading++;
                }
                else {
                    tile.numFramesVisible++;
                    if (tile.frameNumVisible < 0) {
                        // Store the fist frame the tile became visible.
                        tile.frameNumVisible = dataSource.mapView.frameNumber;
                    }
                }
                // Update the visible area of the tile. This is used for those tiles that are
                // currently loaded and are waiting to be decoded to sort the jobs by area.
                tile.visibleArea = tileEntry.area;
                tile.minElevation = tileEntry.minElevation;
                tile.maxElevation = tileEntry.maxElevation;
                actuallyVisibleTiles.push(tile);
            }
            this.m_tileGeometryManager.updateTiles(actuallyVisibleTiles);
            this.dataSourceTileList.push({
                dataSource,
                storageLevel,
                zoomLevel: displayZoomLevel,
                allVisibleTileLoaded: allDataSourceTilesLoaded,
                numTilesLoading,
                visibleTiles: actuallyVisibleTiles,
                renderedTiles: new Map()
            });
            allVisibleTilesLoaded = allVisibleTilesLoaded && allDataSourceTilesLoaded;
        }
        this.allVisibleTilesLoaded =
            allVisibleTilesLoaded && visibleTileKeysResult.allBoundingBoxesFinal;
        this.fillMissingTilesFromCache();
        this.forEachCachedTile(tile => {
            // Remove all tiles that are still being loaded, but are no longer visible. They have to
            // be reloaded when they become visible again. Hopefully, they are still in the browser
            // cache by then.
            if (!tile.isVisible && tile.tileLoader !== undefined && !tile.tileLoader.isFinished) {
                // The internal TileLoader is cancelled automatically when the Tile is disposed.
                this.disposeTile(tile);
            }
        });
        this.m_dataSourceCache.shrinkToCapacity();
        let minElevation;
        let maxElevation;
        this.dataSourceTileList.forEach(renderListEntry => {
            // Calculate min/max elevation from every data source tiles,
            // data sources without elevationRangeSource will contribute to
            // values with zero levels for both elevations.
            const tiles = renderListEntry.renderedTiles;
            tiles.forEach(tile => {
                minElevation = harp_utils_1.MathUtils.min2(minElevation, tile.minElevation);
                maxElevation = harp_utils_1.MathUtils.max2(maxElevation, tile.maxElevation + tile.maxGeometryHeight);
            });
        });
        if (minElevation === undefined) {
            minElevation = 0;
        }
        if (maxElevation === undefined) {
            maxElevation = 0;
        }
        // If clip planes evaluator depends on the tiles elevation re-calculate
        // frustum planes and update the camera near/far plane distances.
        let viewRangesChanged = false;
        const oldViewRanges = this.m_viewRange;
        const newViewRanges = this.updateClipPlanes(maxElevation, minElevation);
        viewRangesChanged = viewRangesEqual(newViewRanges, oldViewRanges) === false;
        return {
            viewRanges: newViewRanges,
            viewRangesChanged
        };
    }
    /**
     * Gets the tile corresponding to the given data source, key and offset, creating it if
     * necessary.
     *
     * @param dataSource The data source the tile belongs to.
     * @param tileKey The key identifying the tile.
     * @param offset Tile offset.
     * @return The tile if it was found or created, undefined otherwise.
     */
    getTile(dataSource, tileKey, offset = 0) {
        const cacheOnly = false;
        return this.getTileImpl(dataSource, tileKey, offset, cacheOnly);
    }
    /**
     * Gets the tile corresponding to the given data source, key and offset from the cache.
     *
     * @param dataSource The data source the tile belongs to.
     * @param tileKey The key identifying the tile.
     * @param offset Tile offset.
     * @return The tile if found in cache, undefined otherwise.
     */
    getCachedTile(dataSource, tileKey, offset = 0) {
        harp_utils_1.assert(dataSource.cacheable);
        const cacheOnly = true;
        return this.getTileImpl(dataSource, tileKey, offset, cacheOnly);
    }
    /**
     * Gets the tile corresponding to the given data source, key and offset from the rendered tiles.
     *
     * @param dataSource The data source the tile belongs to.
     * @param tileKey The key identifying the tile.
     * @param offset Tile offset.
     * @return The tile if found among the rendered tiles, undefined otherwise.
     */
    getRenderedTile(dataSource, tileKey, offset = 0) {
        const dataSourceVisibleTileList = this.dataSourceTileList.find(list => {
            return list.dataSource === dataSource;
        });
        if (dataSourceVisibleTileList === undefined) {
            return undefined;
        }
        return dataSourceVisibleTileList.renderedTiles.get(Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(tileKey, offset));
    }
    /**
     * Gets the tile corresponding to the given data source and location from the rendered tiles.
     *
     * @param dataSource The data source the tile belongs to.
     * @param geoPoint The geolocation included within the tile.
     * @return The tile if found among the rendered tiles, undefined otherwise.
     */
    getRenderedTileAtLocation(dataSource, geoPoint, offset = 0) {
        const dataSourceVisibleTileList = this.dataSourceTileList.find(list => {
            return list.dataSource === dataSource;
        });
        if (dataSourceVisibleTileList === undefined) {
            return undefined;
        }
        const tilingScheme = dataSource.getTilingScheme();
        const visibleLevel = dataSourceVisibleTileList.zoomLevel;
        const visibleTileKey = tilingScheme.getTileKey(geoPoint, visibleLevel);
        if (!visibleTileKey) {
            return undefined;
        }
        let tile = dataSourceVisibleTileList.renderedTiles.get(Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(visibleTileKey, offset));
        if (tile !== undefined) {
            return tile;
        }
        const { searchLevelsUp, searchLevelsDown } = this.getCacheSearchLevels(dataSource, visibleLevel);
        let parentTileKey = visibleTileKey;
        for (let levelOffset = 1; levelOffset <= searchLevelsUp; ++levelOffset) {
            parentTileKey = parentTileKey.parent();
            tile = dataSourceVisibleTileList.renderedTiles.get(Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(parentTileKey, offset));
            if (tile !== undefined) {
                return tile;
            }
        }
        const worldPoint = tilingScheme.projection.projectPoint(geoPoint);
        for (let levelOffset = 1; levelOffset <= searchLevelsDown; ++levelOffset) {
            const childLevel = visibleLevel + levelOffset;
            const childTileKey = harp_geoutils_1.TileKeyUtils.worldCoordinatesToTileKey(tilingScheme, worldPoint, childLevel);
            if (childTileKey) {
                tile = dataSourceVisibleTileList.renderedTiles.get(Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(childTileKey, offset));
                if (tile !== undefined) {
                    return tile;
                }
            }
        }
        return undefined;
    }
    /**
     * Removes all internal bookkeeping entries and cache related to specified datasource.
     *
     * Called by [[MapView]] when [[DataSource]] has been removed from [[MapView]].
     */
    removeDataSource(dataSource) {
        this.clearTileCache(dataSource);
        this.dataSourceTileList = this.dataSourceTileList.filter(tileList => tileList.dataSource !== dataSource);
    }
    /**
     * Clear the tile cache.
     *
     * Remove the [[Tile]] objects created by cacheable [[DataSource]]. If a [[DataSource]] name is
     * provided, this method restricts the eviction the [[DataSource]] with the given name.
     *
     * @param dataSourceName The name of the [[DataSource]].
     */
    clearTileCache(dataSource) {
        if (dataSource !== undefined) {
            this.m_dataSourceCache.evictSelected((tile, _) => {
                return tile.dataSource === dataSource;
            });
        }
        else {
            this.m_dataSourceCache.evictAll();
        }
    }
    /**
     * Visit each tile in visible, rendered, and cached sets.
     *
     *  * Visible and temporarily rendered tiles will be marked for update and retained.
     *  * Cached but not rendered/visible will be evicted.
     *
     * @param dataSource If passed, only the tiles from this [[DataSource]] instance are processed.
     *     If `undefined`, tiles from all [[DataSource]]s are processed.
     */
    markTilesDirty(dataSource) {
        if (dataSource === undefined) {
            this.dataSourceTileList.forEach(renderListEntry => {
                this.markDataSourceTilesDirty(renderListEntry);
            });
        }
        else {
            const renderListEntry = this.dataSourceTileList.find(e => e.dataSource === dataSource);
            if (renderListEntry === undefined) {
                return;
            }
            this.markDataSourceTilesDirty(renderListEntry);
        }
    }
    /**
     * Dispose tiles that are marked for removal by [[LRUCache]] algorithm.
     */
    disposePendingTiles() {
        this.m_dataSourceCache.disposeTiles();
    }
    /**
     * Process callback function [[fun]] with each visible tile in set.
     *
     * @param fun The callback function to be called.
     */
    forEachVisibleTile(fun) {
        for (const listEntry of this.dataSourceTileList) {
            listEntry.renderedTiles.forEach(fun);
        }
    }
    /**
     * Process callback function [[fun]] with each tile in the cache.
     *
     * Optional [[dataSource]] parameter limits processing to the tiles that belongs to
     * DataSource passed in.
     *
     * @param fun The callback function to be called.
     * @param dataSource The optional DataSource reference for tiles selection.
     */
    forEachCachedTile(fun, dataSource) {
        this.m_dataSourceCache.forEach((tile, _) => fun(tile), dataSource);
    }
    /**
     * Dispose a `Tile` from cache, 'dispose()' is also called on the tile to free its resources.
     */
    disposeTile(tile) {
        // TODO: Consider using evict here!
        this.m_dataSourceCache.delete(tile);
        tile.dispose();
    }
    getCacheSearchLevels(dataSource, visibleLevel) {
        const searchLevelsUp = Math.min(this.options.quadTreeSearchDistanceUp, Math.max(0, visibleLevel - dataSource.minZoomLevel));
        const searchLevelsDown = Math.min(this.options.quadTreeSearchDistanceDown, Math.max(0, dataSource.maxZoomLevel - visibleLevel));
        return { searchLevelsUp, searchLevelsDown };
    }
    /**
     * Search cache to replace visible but yet empty tiles with already loaded siblings in nearby
     * zoom levels.
     *
     * Useful, when zooming in/out and when "newly elected" tiles are not yet loaded. Prevents
     * flickering by rendering already loaded tiles from upper/higher zoom levels.
     */
    fillMissingTilesFromCache() {
        this.dataSourceTileList.forEach(renderListEntry => {
            const dataSource = renderListEntry.dataSource;
            const displayZoomLevel = renderListEntry.zoomLevel;
            const renderedTiles = renderListEntry.renderedTiles;
            // Direction in quad tree to search: up -> shallower levels, down -> deeper levels.
            let SearchDirection;
            (function (SearchDirection) {
                SearchDirection[SearchDirection["NONE"] = 0] = "NONE";
                SearchDirection[SearchDirection["UP"] = 1] = "UP";
                SearchDirection[SearchDirection["DOWN"] = 2] = "DOWN";
                SearchDirection[SearchDirection["BOTH"] = 3] = "BOTH";
            })(SearchDirection || (SearchDirection = {}));
            let defaultSearchDirection = SearchDirection.NONE;
            const { searchLevelsUp, searchLevelsDown } = this.getCacheSearchLevels(dataSource, displayZoomLevel);
            defaultSearchDirection =
                searchLevelsDown > 0 && searchLevelsUp > 0
                    ? SearchDirection.BOTH
                    : searchLevelsDown > 0
                        ? SearchDirection.DOWN
                        : searchLevelsUp > 0
                            ? SearchDirection.UP
                            : SearchDirection.NONE;
            const incompleteTiles = new Map();
            renderListEntry.visibleTiles.forEach(tile => {
                const tileCode = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(tile.tileKey, tile.offset);
                tile.levelOffset = 0;
                if (tile.hasGeometry || defaultSearchDirection === SearchDirection.NONE) {
                    renderedTiles.set(tileCode, tile);
                }
                else {
                    // if dataSource supports cache and it was existing before this render
                    // then enable searching for loaded tiles in cache
                    incompleteTiles.set(tileCode, defaultSearchDirection);
                }
            });
            if (incompleteTiles.size === 0) {
                // short circuit, nothing to be done
                return;
            }
            // Minor optimization for the fallback search, only check parent tiles once, otherwise
            // the recursive algorithm checks all parent tiles multiple times, the key is the code
            // of the tile that is checked and the value is whether a parent was found or not.
            const checkedTiles = new Map();
            // Iterate over incomplete (not loaded tiles) and find their parents or children that
            // are in cache that can be rendered temporarily until tile is loaded. Note, we favour
            // falling back to parent tiles rather than children.
            for (const [tileKeyCode, searchDirection] of incompleteTiles) {
                if (searchDirection === SearchDirection.BOTH ||
                    searchDirection === SearchDirection.UP) {
                    if (this.findUp(tileKeyCode, displayZoomLevel, renderedTiles, checkedTiles, dataSource)) {
                        // Continue to next entry so we don't search down.
                        continue;
                    }
                }
                if (searchDirection === SearchDirection.BOTH ||
                    searchDirection === SearchDirection.DOWN) {
                    this.findDown(tileKeyCode, displayZoomLevel, renderedTiles, dataSource);
                }
            }
        });
    }
    findDown(tileKeyCode, displayZoomLevel, renderedTiles, dataSource) {
        const { offset, mortonCode } = Utils_1.TileOffsetUtils.extractOffsetAndMortonKeyFromKey(tileKeyCode);
        const tileKey = harp_geoutils_1.TileKey.fromMortonCode(mortonCode);
        const tilingScheme = dataSource.getTilingScheme();
        for (const childTileKey of tilingScheme.getSubTileKeys(tileKey)) {
            const childTileCode = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(childTileKey, offset);
            const childTile = this.m_dataSourceCache.get(childTileKey.mortonCode(), offset, dataSource);
            const nextLevelDiff = Math.abs(childTileKey.level - displayZoomLevel);
            if (childTile !== undefined && childTile.hasGeometry) {
                // childTile has geometry, so can be reused as fallback
                renderedTiles.set(childTileCode, childTile);
                childTile.levelOffset = nextLevelDiff;
                continue;
            }
            // Recurse down until the max distance is reached.
            if (nextLevelDiff < this.options.quadTreeSearchDistanceDown) {
                this.findDown(childTileCode, displayZoomLevel, renderedTiles, dataSource);
            }
        }
    }
    /**
     * Returns true if a tile was found in the cache which is a parent
     * @param tileKeyCode Morton code of the current tile that should be searched for.
     * @param displayZoomLevel The current zoom level of tiles that are to be displayed.
     * @param renderedTiles The list of tiles that are shown to the user.
     * @param checkedTiles Used to map a given code to a boolean which tells us if an ancestor is
     * displayed or not.
     * @param dataSource The provider of tiles.
     * @returns Whether a parent tile exists.
     */
    findUp(tileKeyCode, displayZoomLevel, renderedTiles, checkedTiles, dataSource) {
        const parentCode = Utils_1.TileOffsetUtils.getParentKeyFromKey(tileKeyCode);
        // Check if another sibling has already added the parent.
        if (renderedTiles.get(parentCode) !== undefined) {
            return true;
        }
        const exists = checkedTiles.get(parentCode);
        if (exists !== undefined) {
            return exists;
        }
        const { offset, mortonCode } = Utils_1.TileOffsetUtils.extractOffsetAndMortonKeyFromKey(parentCode);
        const parentTile = this.m_dataSourceCache.get(mortonCode, offset, dataSource);
        const parentTileKey = parentTile ? parentTile.tileKey : harp_geoutils_1.TileKey.fromMortonCode(mortonCode);
        const nextLevelDiff = Math.abs(displayZoomLevel - parentTileKey.level);
        if (parentTile !== undefined && parentTile.hasGeometry) {
            checkedTiles.set(parentCode, true);
            // parentTile has geometry, so can be reused as fallback
            renderedTiles.set(parentCode, parentTile);
            // We want to have parent tiles as -ve, hence the minus.
            parentTile.levelOffset = -nextLevelDiff;
            return true;
        }
        else {
            checkedTiles.set(parentCode, false);
        }
        // Recurse up until the max distance is reached or we go to the parent of all parents.
        if (nextLevelDiff < this.options.quadTreeSearchDistanceUp && parentTileKey.level !== 0) {
            const foundUp = this.findUp(parentCode, displayZoomLevel, renderedTiles, checkedTiles, dataSource);
            // If there was a tile upstream found, then add it to the list, so we can
            // early skip checkedTiles.
            checkedTiles.set(parentCode, foundUp);
            if (foundUp) {
                return true;
            }
        }
        return false;
    }
    getTileImpl(dataSource, tileKey, offset, cacheOnly) {
        function updateTile(tileToUpdate) {
            if (tileToUpdate === undefined) {
                return;
            }
            // Keep the tile from being removed from the cache.
            tileToUpdate.frameNumLastRequested = dataSource.mapView.frameNumber;
        }
        if (!dataSource.cacheable && !cacheOnly) {
            const resultTile = dataSource.getTile(tileKey);
            updateTile(resultTile);
            return resultTile;
        }
        const tileCache = this.m_dataSourceCache;
        let tile = tileCache.get(tileKey.mortonCode(), offset, dataSource);
        if (tile !== undefined && tile.offset === offset) {
            updateTile(tile);
            return tile;
        }
        if (cacheOnly) {
            return undefined;
        }
        tile = dataSource.getTile(tileKey);
        // TODO: Update all tile information including area, min/max elevation from TileKeyEntry
        if (tile !== undefined) {
            tile.offset = offset;
            updateTile(tile);
            tileCache.set(tileKey.mortonCode(), offset, dataSource, tile);
            this.m_tileGeometryManager.initTile(tile);
        }
        return tile;
    }
    markDataSourceTilesDirty(renderListEntry) {
        const dataSourceCache = this.m_dataSourceCache;
        const retainedTiles = new Set();
        function markTileDirty(tile, tileGeometryManager) {
            const tileKey = DataSourceCache.getKeyForTile(tile);
            if (!retainedTiles.has(tileKey)) {
                retainedTiles.add(tileKey);
                if (tile.tileGeometryLoader !== undefined) {
                    tile.tileGeometryLoader.reset();
                }
                // Prevent label rendering issues when the style set is changing. Prevent Text
                // element rendering that depends on cleaned font catalog data.
                tile.clearTextElements();
                tile.load();
            }
        }
        renderListEntry.visibleTiles.forEach(tile => {
            markTileDirty(tile, this.m_tileGeometryManager);
        });
        renderListEntry.renderedTiles.forEach(tile => {
            markTileDirty(tile, this.m_tileGeometryManager);
        });
        dataSourceCache.forEach((tile, key) => {
            if (!retainedTiles.has(key)) {
                dataSourceCache.deleteByKey(key);
                tile.dispose();
            }
        }, renderListEntry.dataSource);
    }
    // Computes the visible tile keys for each supplied data source.
    getVisibleTileKeysForDataSources(zoomLevel, dataSources, elevationRangeSource) {
        const tileKeys = Array();
        let allBoundingBoxesFinal = true;
        if (dataSources.length === 0) {
            return { tileKeys, allBoundingBoxesFinal };
        }
        const dataSourceBuckets = new Map();
        dataSources.forEach(dataSource => {
            const tilingScheme = dataSource.getTilingScheme();
            const bucket = dataSourceBuckets.get(tilingScheme);
            if (bucket === undefined) {
                dataSourceBuckets.set(tilingScheme, [dataSource]);
            }
            else {
                bucket.push(dataSource);
            }
        });
        // If elevation is to be taken into account create extended frustum:
        // (near ~0, far: maxVisibilityRange) that allows to consider tiles that
        // are far below ground plane and high enough to intersect the frustum.
        if (elevationRangeSource !== undefined) {
            const fp = Utils_1.MapViewUtils.getCameraFrustumPlanes(this.m_frustumIntersection.camera);
            fp.near = this.m_viewRange.minimum;
            fp.far = this.m_viewRange.maximum;
            this.m_projectionMatrixOverride.makePerspective(fp.left, fp.right, fp.bottom, fp.top, fp.near, fp.far);
            this.m_frustumIntersection.updateFrustum(this.m_projectionMatrixOverride);
        }
        else {
            this.m_frustumIntersection.updateFrustum();
        }
        // For each bucket of data sources with same tiling scheme, calculate frustum intersection
        // once using the maximum display level.
        for (const [tilingScheme, bucket] of dataSourceBuckets) {
            const zoomLevels = bucket.map(dataSource => dataSource.getDisplayZoomLevel(zoomLevel));
            const result = this.m_frustumIntersection.compute(tilingScheme, elevationRangeSource, zoomLevels, bucket);
            allBoundingBoxesFinal = allBoundingBoxesFinal && result.calculationFinal;
            for (const dataSource of bucket) {
                // For each data source check what tiles from the intersection should be rendered
                // at this zoom level.
                const visibleTileKeys = [];
                const displayZoomLevel = dataSource.getDisplayZoomLevel(zoomLevel);
                for (const tileKeyEntry of result.tileKeyEntries.get(displayZoomLevel).values()) {
                    if (dataSource.canGetTile(displayZoomLevel, tileKeyEntry.tileKey)) {
                        visibleTileKeys.push(tileKeyEntry);
                    }
                }
                tileKeys.push({ dataSource, visibleTileKeys });
            }
        }
        return { tileKeys, allBoundingBoxesFinal };
    }
}
exports.VisibleTileSet = VisibleTileSet;
function viewRangesEqual(a, b) {
    return (a.far === b.far && a.maximum === b.maximum && a.minimum === b.minimum && a.near === b.near);
}


/***/ }),

/***/ "../harp-mapview/lib/WorkerBasedDecoder.ts":
/*!*************************************************!*\
  !*** ../harp-mapview/lib/WorkerBasedDecoder.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
/**
 * Identifier of next decoder worker-service. Used to ensure uniqueness of service ids of decoders
 * dedicated to different datasources.
 */
let nextUniqueServiceId = 0;
/**
 * Decoder based on [[ConcurrentWorkerSet]].
 *
 * Decodes tiles using workers running in separate contexts (also known as `WebWorkers`):
 * - connection establishment,
 * - sends decode requests,
 * - configuration.
 */
class WorkerBasedDecoder {
    /**
     * Creates a new `WorkerBasedDecoder`.
     *
     * @param workerSet [[ConcurrentWorkerSet]] this tiler will live in.
     * @param decoderServiceType Service type identifier.
     */
    constructor(workerSet, decoderServiceType) {
        this.workerSet = workerSet;
        this.decoderServiceType = decoderServiceType;
        this.m_serviceCreated = false;
        this.workerSet.addReference();
        this.serviceId = `${this.decoderServiceType}-${nextUniqueServiceId++}`;
    }
    /**
     * Dispose of dedicated tile decoder services in workers and remove reference to underlying
     * [[ConcurrentWorkerSet]].
     */
    dispose() {
        if (this.m_serviceCreated) {
            this.workerSet
                .broadcastRequest(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {
                type: harp_datasource_protocol_1.WorkerServiceProtocol.Requests.DestroyService,
                targetServiceId: this.serviceId
            })
                .catch(() => {
                /* Ignoring these errors as underlying workers possibly do not exist anymore. */
            });
        }
        this.workerSet.removeReference();
    }
    /**
     * Connects to [[WorkerServiceManager]]s in underlying [[ConcurrentWorkerSet]] and creates
     * dedicated [[TileDecoderService]]s in all workers to serve decode requests.
     */
    async connect() {
        await this.workerSet.connect(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID);
        if (!this.m_serviceCreated) {
            await this.workerSet.broadcastRequest(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {
                type: harp_datasource_protocol_1.WorkerServiceProtocol.Requests.CreateService,
                targetServiceType: this.decoderServiceType,
                targetServiceId: this.serviceId
            });
            this.m_serviceCreated = true;
        }
    }
    /**
     * Get [[Tile]] from tile decoder service in worker.
     *
     * Invokes [[DecodeTileRequest]] on [[TileDecoderService]] running in worker pool.
     */
    decodeTile(data, tileKey, projection, requestController) {
        const tileKeyCode = tileKey.mortonCode();
        const message = {
            type: harp_datasource_protocol_1.WorkerDecoderProtocol.Requests.DecodeTileRequest,
            tileKey: tileKeyCode,
            data,
            projection: harp_datasource_protocol_1.getProjectionName(projection)
        };
        const transferList = data instanceof ArrayBuffer ? [data] : undefined;
        return this.workerSet.invokeRequest(this.serviceId, message, transferList, requestController);
    }
    /**
     * Get [[TileInfo]] from tile decoder service in worker.
     *
     * Invokes [[TileInfoRequest]] on [[TileDecoderService]] running in worker pool.
     */
    getTileInfo(data, tileKey, projection, requestController) {
        const tileKeyCode = tileKey.mortonCode();
        const message = {
            type: harp_datasource_protocol_1.WorkerDecoderProtocol.Requests.TileInfoRequest,
            tileKey: tileKeyCode,
            data,
            projection: harp_datasource_protocol_1.getProjectionName(projection)
        };
        const transferList = data instanceof ArrayBuffer ? [data] : undefined;
        return this.workerSet.invokeRequest(this.serviceId, message, transferList, requestController);
    }
    /**
     * Configure tile decoder service in workers.
     *
     * Broadcasts [[ConfigurationMessage]] to all [[TileDecoderService]]s running in worker pool.
     *
     * @param styleSet  new [[StyleSet]], undefined means no change
     * @param languages new list of languages
     * @param options   new options, undefined options are not changed
     */
    configure(styleSet, definitions, languages, options) {
        const message = {
            service: this.serviceId,
            type: harp_datasource_protocol_1.WorkerDecoderProtocol.DecoderMessageName.Configuration,
            styleSet,
            definitions,
            options,
            languages
        };
        this.workerSet.broadcastMessage(message);
    }
    /**
     * The number of workers started for this decoder. The value is `undefined` until the workers
     * have been created.
     */
    get workerCount() {
        return this.workerSet.workerCount;
    }
}
exports.WorkerBasedDecoder = WorkerBasedDecoder;


/***/ }),

/***/ "../harp-mapview/lib/WorkerBasedTiler.ts":
/*!***********************************************!*\
  !*** ../harp-mapview/lib/WorkerBasedTiler.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
/**
 * Identifier of next tiler worker-service. Used to ensure uniqueness of service ids of tilers
 * dedicated to different datasources.
 */
let nextUniqueServiceId = 0;
/**
 * Tiler based on [[ConcurrentWorkerSet]].
 *
 * Tiles payloads using workers running in separate contexts (also known as `WebWorkers`):
 * - connection establishment,
 * - sends tile requests,
 * - configuration.
 */
class WorkerBasedTiler {
    /**
     * Creates a new `WorkerBasedTiler`.
     *
     * @param workerSet [[ConcurrentWorkerSet]] this tiler will live in.
     * @param tilerServiceType Service type identifier.
     */
    constructor(workerSet, tilerServiceType) {
        this.workerSet = workerSet;
        this.tilerServiceType = tilerServiceType;
        this.m_serviceCreated = false;
        this.workerSet.addReference();
        this.serviceId = `${this.tilerServiceType}-${nextUniqueServiceId++}`;
    }
    /**
     * Dispose of dedicated tiler services in workers and remove reference to underlying
     * [[ConcurrentWorkerSet]].
     */
    dispose() {
        if (this.m_serviceCreated) {
            this.workerSet
                .broadcastRequest(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {
                type: harp_datasource_protocol_1.WorkerServiceProtocol.Requests.DestroyService,
                targetServiceId: this.serviceId
            })
                .catch(() => {
                /* Ignoring these errors as underlying workers possibly do not exist anymore. */
            });
        }
        this.workerSet.removeReference();
    }
    /**
     * Connects to [[WorkerServiceManager]]s in underlying [[ConcurrentWorkerSet]] and creates
     * dedicated [[TilerService]]s in all workers to serve tiling requests.
     */
    async connect() {
        await this.workerSet.connect(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID);
        if (!this.m_serviceCreated) {
            await this.workerSet.broadcastRequest(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {
                type: harp_datasource_protocol_1.WorkerServiceProtocol.Requests.CreateService,
                targetServiceType: this.tilerServiceType,
                targetServiceId: this.serviceId
            });
            this.m_serviceCreated = true;
        }
    }
    /**
     * Register index in the tiler. Indexes registered in the tiler can be later used to retrieved
     * tiled payloads using `getTile`.
     *
     * @param indexId Index identifier.
     * @param input Url to the index payload, or direct GeoJSON.
     */
    registerIndex(indexId, input) {
        const message = {
            type: harp_datasource_protocol_1.WorkerTilerProtocol.Requests.RegisterIndex,
            id: indexId,
            input: input instanceof URL ? input.href : input
        };
        return this.workerSet.invokeRequest(this.serviceId, message);
    }
    /**
     * Update index in the tiler. Indexes registered in the tiler can be later used to retrieved
     * tiled payloads using `getTile`.
     *
     * @param indexId Index identifier.
     * @param input Url to the index payload, or direct GeoJSON.
     */
    updateIndex(indexId, input) {
        const message = {
            type: harp_datasource_protocol_1.WorkerTilerProtocol.Requests.UpdateIndex,
            id: indexId,
            input: input instanceof URL ? input.href : input
        };
        return this.workerSet.invokeRequest(this.serviceId, message);
    }
    /**
     * Retrieves a tile for a previously registered index.
     *
     * @param indexId Index identifier.
     * @param tileKey The [[TileKey]] that identifies the tile.
     */
    getTile(indexId, tileKey) {
        const tileKeyCode = tileKey.mortonCode();
        const message = {
            type: harp_datasource_protocol_1.WorkerTilerProtocol.Requests.TileRequest,
            index: indexId,
            tileKey: tileKeyCode
        };
        return this.workerSet.invokeRequest(this.serviceId, message);
    }
}
exports.WorkerBasedTiler = WorkerBasedTiler;


/***/ }),

/***/ "../harp-mapview/lib/composing/LowResRenderPass.ts":
/*!*********************************************************!*\
  !*** ../harp-mapview/lib/composing/LowResRenderPass.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const Pass_1 = __webpack_require__(/*! ./Pass */ "../harp-mapview/lib/composing/Pass.ts");
/**
 * The `LowResRenderPass` renders the scene at a lower resolution into an internal
 * `WebGLRenderTarget`, and then copies the result into the frame buffer. The size of the internal
 * buffer is determined by the current frame buffer size multiplied by `pixelRatio`.
 *
 * @note Since no anti-aliasing is applied during dynamic rendering, visual artifacts may be
 * visible.
 */
class LowResRenderPass extends Pass_1.Pass {
    /**
     * The constructor for `LowResRenderPass`. It builds an internal scene with a camera looking at
     * a quad.
     *
     * @param lowResPixelRatio The `pixelRatio` determines the resolution of the internal
     *  `WebGLRenderTarget`. Values between 0.5 and `window.devicePixelRatio` can be tried to give
     * good results. A value of `undefined` disables the low res render pass. The value should not
     * be larger than`window.devicePixelRatio`.
     */
    constructor(lowResPixelRatio) {
        super();
        this.lowResPixelRatio = lowResPixelRatio;
        this.m_renderTarget = null;
        this.m_localCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.m_quadScene = new THREE.Scene();
        this.m_quadUniforms = harp_materials_1.CopyShader.uniforms;
        this.m_quadMaterial = new harp_materials_1.CopyMaterial(this.m_quadUniforms);
        this.m_quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), this.m_quadMaterial);
        this.m_savedWidth = 0;
        this.m_savedHeight = 0;
        this.m_quad.frustumCulled = false;
        this.m_quadScene.add(this.m_quad);
        this.m_pixelRatio = lowResPixelRatio;
    }
    /**
     * Releases all used resources.
     */
    dispose() {
        this.m_quadMaterial.dispose();
        this.m_quad.geometry.dispose();
        if (this.m_renderTarget !== null) {
            this.m_renderTarget.dispose();
            this.m_renderTarget = null;
        }
    }
    /**
     * If a value is specified, a low resolution render pass is used to render the scene into a
     * low resolution render target, before it is copied to the screen.
     *
     * A value of `undefined` disables the low res render pass. The value should not be larger than
     * `window.devicePixelRatio`.
     *
     * @default `undefined`
     */
    set pixelRatio(ratio) {
        this.m_pixelRatio = ratio;
        if (this.m_renderTarget && this.pixelRatio !== undefined) {
            this.m_renderTarget.setSize(Math.floor(this.m_savedWidth * this.pixelRatio), Math.floor(this.m_savedHeight * this.pixelRatio));
        }
    }
    get pixelRatio() {
        return this.m_pixelRatio;
    }
    /**
     * The render function of `LowResRenderPass`. It renders the whole scene into an internal
     * `WebGLRenderTarget` instance with a lower resolution, using the passed in `WebGLRenderer`.
     * The low resolution image is then copied to the `writeBuffer`, which is `undefined` in case it
     * is the screen.
     *
     * @param renderer The ThreeJS WebGLRenderer instance to render the scene with.
     * @param scene The ThreeJS Scene instance to render the scene with.
     * @param camera The ThreeJS Camera instance to render the scene with.
     * @param writeBuffer A ThreeJS WebGLRenderTarget instance to render the scene to.
     * @param readBuffer A ThreeJS WebGLRenderTarget instance to render the scene.
     * @override
     */
    render(renderer, scene, camera, writeBuffer, readBuffer) {
        if (!this.enabled || this.pixelRatio === undefined) {
            return;
        }
        // Initiates the local render target with the read buffer's dimensions, if not available.
        if (this.m_renderTarget === null) {
            this.m_savedWidth = readBuffer.width;
            this.m_savedHeight = readBuffer.height;
            this.m_renderTarget = new THREE.WebGLRenderTarget(Math.floor(this.m_savedWidth * this.pixelRatio), Math.floor(this.m_savedHeight * this.pixelRatio), {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat,
                depthBuffer: true,
                stencilBuffer: true
            });
            this.m_renderTarget.texture.name = "LowResRenderPass.sample";
        }
        this.m_quadUniforms.tDiffuse.value = this.m_renderTarget.texture;
        this.m_quadUniforms.opacity.value = 1.0;
        const oldRenderTarget = renderer.getRenderTarget();
        renderer.setRenderTarget(this.m_renderTarget);
        renderer.clear();
        // Render into the low resolution internal render target.
        renderer.render(scene, camera);
        // Render the low resolution target into the screen.
        // NOTE: three.js doesn't like undefined as renderTarget, but works with `null`
        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
        renderer.clear();
        renderer.render(this.m_quadScene, this.m_localCamera);
        renderer.setRenderTarget(oldRenderTarget);
    }
    /**
     * Resize the internal render target to match the new size specified. The size of internal
     * buffer depends on the `pixelRatio`.
     *
     * @param width New width to apply to the render target.
     * @param height New height to apply to the render target.
     * @override
     */
    setSize(width, height) {
        this.m_savedWidth = width;
        this.m_savedHeight = height;
        if (this.m_renderTarget && this.pixelRatio !== undefined) {
            this.m_renderTarget.setSize(Math.floor(width * this.pixelRatio), Math.floor(height * this.pixelRatio));
        }
    }
}
exports.LowResRenderPass = LowResRenderPass;


/***/ }),

/***/ "../harp-mapview/lib/composing/MSAARenderPass.ts":
/*!*******************************************************!*\
  !*** ../harp-mapview/lib/composing/MSAARenderPass.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const Pass_1 = __webpack_require__(/*! ./Pass */ "../harp-mapview/lib/composing/Pass.ts");
/**
 * This enum represents the sampling level to apply to a [[MSAARenderPass]] instance. At level 0,
 * only one sample is performed, which is like disabling the MSAA pass.
 */
var MSAASampling;
(function (MSAASampling) {
    MSAASampling[MSAASampling["Level_0"] = 0] = "Level_0";
    MSAASampling[MSAASampling["Level_1"] = 1] = "Level_1";
    MSAASampling[MSAASampling["Level_2"] = 2] = "Level_2";
    MSAASampling[MSAASampling["Level_3"] = 3] = "Level_3";
    MSAASampling[MSAASampling["Level_4"] = 4] = "Level_4";
    MSAASampling[MSAASampling["Level_5"] = 5] = "Level_5";
})(MSAASampling = exports.MSAASampling || (exports.MSAASampling = {}));
/**
 * [[MapView]]'s MSAA implementation. MSAA stands for Multi Sampling Anti-Aliasing, and its concept
 * is to provide a rendering engine with additional color values for each pixel, so they can include
 * the missing bits between them on a screen. WebGL already comes with a native MSAA implementation
 * with four samples. Because of its native nature, it is more efficient and one may not want to use
 * MapView's MSAA implementation when these four samples are satisfying. However in some situations
 * they are not: on low devices, MSAA can impact the framerate and we may desire to reduce the
 * number of samples at runtime. On the other hand, when the interaction stops, the engine also
 * stops rendering the map, and because a map relies on many line-like patterns, aliasing can then
 * turn very noticeable. In such static renders, the number of samples could be dramatically
 * increased on a last frame to render.
 */
class MSAARenderPass extends Pass_1.Pass {
    /**
     * The constructor for `MSAARenderPass`. It builds an internal scene with a camera looking at a
     * quad.
     *
     * @param m_scene The scene to render.
     * @param m_camera The camera to render the scene through.
     */
    constructor() {
        super();
        /**
         * The sampling level determines the number of samples that will be performed per frame.
         * Renders will happen `2 ^ samplingLevel` time(s). `samplingLevel` stands between `0` and `5`.
         * Therefore there can be between 1 and 32 samples.
         *
         * @default `SamplingLevel.Level_1`
         */
        this.samplingLevel = MSAASampling.Level_1;
        this.m_renderTarget = null;
        this.m_localCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.m_quadScene = new THREE.Scene();
        this.m_quadUniforms = harp_materials_1.CopyShader.uniforms;
        this.m_quadMaterial = new harp_materials_1.MSAAMaterial(this.m_quadUniforms);
        this.m_quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), this.m_quadMaterial);
        this.m_quad.frustumCulled = false;
        this.m_quadScene.add(this.m_quad);
    }
    /**
     * Releases all used resources.
     */
    dispose() {
        if (this.m_renderTarget !== null) {
            this.m_renderTarget.dispose();
            this.m_renderTarget = null;
        }
    }
    /**
     * The render function of `MSAARenderPass`. At each call of this method, and for each sample,
     * the [[MapView]] camera provided in the `render` method is offset within the dimension of a
     * pixel on screen. It then renders the whole scene with this offset to a local
     * `WebGLRenderTarget` instance, via a `WebGLRenderer` instance. Finally the local camera
     * created in the constructor shoots the quad and renders to the write buffer or to the frame
     * buffer. The quad material's opacity is modified so the renders can accumulate in the
     * targetted buffer.
     *
     * The number of samples can be modified at runtime through the enum [[SamplingLevel]].
     *
     * If there is no further pass, the [[Pass.renderToScreen]] flag can be set to `true` to
     * output directly to the framebuffer.
     *
     * @param renderer The ThreeJS WebGLRenderer instance to render the scene with.
     * @param scene The ThreeJS Scene instance to render the scene with.
     * @param camera The ThreeJS Camera instance to render the scene with.
     * @param writeBuffer A ThreeJS WebGLRenderTarget instance to render the scene to.
     * @param readBuffer A ThreeJS WebGLRenderTarget instance to render the scene.
     * @override
     */
    render(renderer, scene, camera, writeBuffer, readBuffer) {
        if (!this.enabled) {
            return;
        }
        // Initiates the local render target with the read buffer's dimensions, if not available.
        if (this.m_renderTarget === null) {
            this.m_renderTarget = new THREE.WebGLRenderTarget(readBuffer.width, readBuffer.height, {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat
            });
            this.m_renderTarget.texture.name = "MSAARenderPass.sample";
        }
        this.m_quadUniforms.tDiffuse.value = this.m_renderTarget.texture;
        const offsets = MSAARenderPass.OffsetVectors[this.samplingLevel];
        const rendererClearColor = renderer.getClearColor();
        const oldClearColor = rendererClearColor !== undefined ? rendererClearColor.getHex() : 0;
        // The method `camera.setViewOffset` will be called in the next loop. In order to maintain
        // its usability externally (like for the triple view in mosaic demo) we must cache the
        // previous values stored in `camera.view` and re-assign them at the end of the pass.
        // 1. Create a default cache object, with default dimensions the size of our read buffer.
        const oldView = {
            enabled: camera.view !== null && camera.view.enabled,
            fullWidth: readBuffer.width,
            fullHeight: readBuffer.height,
            x: 0,
            y: 0,
            width: readBuffer.width,
            height: readBuffer.height
        };
        // 2. If `camera.view` has been enabled previously, then `setViewOffset` has been called
        // externally: copy the existing `camera.view` values in the cache. Override the cache
        // object with the values provided externally.
        if (oldView.enabled && camera.view !== null) {
            oldView.fullWidth = camera.view.fullWidth;
            oldView.fullHeight = camera.view.fullHeight;
            oldView.x = camera.view.offsetX;
            oldView.y = camera.view.offsetY;
            oldView.width = camera.view.width;
            oldView.height = camera.view.height;
        }
        const oldRenderTarget = renderer.getRenderTarget();
        for (let i = 0; i < offsets.length; i++) {
            // 4. Then for each sample, call `setViewOffset` with our object. This also updates the
            // `camera.view` object in Three.js.
            const offset = offsets[i];
            camera.setViewOffset(oldView.fullWidth, oldView.fullHeight, oldView.x + offset[0] / 16, oldView.y + offset[1] / 16, oldView.width, oldView.height);
            // 5. Divide the opacity of the quad by the number of samples to accumulate on the
            // target buffer, and reduce the impact of the offset on color to reduce banding. Then
            // render.
            const uniformCenteredDistribution = -0.5 + (i + 0.5) / offsets.length;
            const sampleWeight = 1.0 / offsets.length + uniformCenteredDistribution / 32;
            this.m_quadUniforms.opacity.value = sampleWeight;
            renderer.setRenderTarget(this.m_renderTarget);
            renderer.clear();
            renderer.render(scene, camera);
            // 6. Render the quad on top of the previous renders.
            // NOTE: three.js doesn't like undefined as renderTarget, but works with `null`
            renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
            if (i === 0) {
                renderer.setClearColor(0x000000);
                renderer.clear();
            }
            renderer.render(this.m_quadScene, this.m_localCamera);
            if (i === 0 && rendererClearColor !== undefined) {
                renderer.setClearColor(oldClearColor);
            }
        }
        renderer.setRenderTarget(oldRenderTarget);
        // 7. Restore `camera.view` as set externally (or not).
        if (camera.view !== null) {
            camera.view.enabled = oldView.enabled;
            camera.view.offsetX = oldView.x;
            camera.view.offsetY = oldView.y;
        }
    }
    /**
     * Resize the internal render target to match the new size specified.
     *
     * @param width New width to apply to the render target.
     * @param height New height to apply to the render target.
     * @override
     */
    setSize(width, height) {
        if (this.m_renderTarget) {
            this.m_renderTarget.setSize(width, height);
        }
    }
}
exports.MSAARenderPass = MSAARenderPass;
// tslint:disable:max-line-length
/**
 * The list of offsets to apply to the camera, per sampling level, adapted from :
 *
 * @see https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396
 */
// tslint:enable:max-line-length
// tslint:disable-next-line:member-ordering
MSAARenderPass.OffsetVectors = [
    [[0, 0]],
    [
        [4, 4],
        [-4, -4]
    ],
    [
        [-2, -6],
        [6, -2],
        [-6, 2],
        [2, 6]
    ],
    [
        [1, -3],
        [-1, 3],
        [5, 1],
        [-3, -5],
        [-5, 5],
        [-7, -1],
        [3, 7],
        [7, -7]
    ],
    [
        [1, 1],
        [-1, -3],
        [-3, 2],
        [4, -1],
        [-5, -2],
        [2, 5],
        [5, 3],
        [3, -5],
        [-2, 6],
        [0, -7],
        [-4, -6],
        [-6, 4],
        [-8, 0],
        [7, -4],
        [6, 7],
        [-7, -8]
    ],
    [
        [-4, -7],
        [-7, -5],
        [-3, -5],
        [-5, -4],
        [-1, -4],
        [-2, -2],
        [-6, -1],
        [-4, 0],
        [-7, 1],
        [-1, 2],
        [-6, 3],
        [-3, 3],
        [-7, 6],
        [-3, 6],
        [-5, 7],
        [-1, 7],
        [5, -7],
        [1, -6],
        [6, -5],
        [4, -4],
        [2, -3],
        [7, -2],
        [1, -1],
        [4, -1],
        [2, 1],
        [6, 2],
        [0, 4],
        [4, 4],
        [2, 5],
        [7, 5],
        [5, 6],
        [3, 7]
    ]
];


/***/ }),

/***/ "../harp-mapview/lib/composing/MapRenderingManager.ts":
/*!************************************************************!*\
  !*** ../harp-mapview/lib/composing/MapRenderingManager.ts ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const THREE = __webpack_require__(/*! three */ "three");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const LowResRenderPass_1 = __webpack_require__(/*! ./LowResRenderPass */ "../harp-mapview/lib/composing/LowResRenderPass.ts");
const MSAARenderPass_1 = __webpack_require__(/*! ./MSAARenderPass */ "../harp-mapview/lib/composing/MSAARenderPass.ts");
const Outline_1 = __webpack_require__(/*! ./Outline */ "../harp-mapview/lib/composing/Outline.ts");
const Pass_1 = __webpack_require__(/*! ./Pass */ "../harp-mapview/lib/composing/Pass.ts");
const UnrealBloomPass_1 = __webpack_require__(/*! ./UnrealBloomPass */ "../harp-mapview/lib/composing/UnrealBloomPass.ts");
const DEFAULT_DYNAMIC_MSAA_SAMPLING_LEVEL = MSAARenderPass_1.MSAASampling.Level_1;
const DEFAULT_STATIC_MSAA_SAMPLING_LEVEL = MSAARenderPass_1.MSAASampling.Level_4;
/**
 * The implementation of [[IMapRenderingManager]] to instantiate in [[MapView]] and manage the map
 * rendering.
 */
class MapRenderingManager {
    /**
     * The constructor of `MapRenderingManager`.
     *
     * @param width Width of the frame buffer.
     * @param height Height of the frame buffer.
     * @param lowResPixelRatio The `pixelRatio` determines the resolution of the internal
     *  `WebGLRenderTarget`. Values between 0.5 and `window.devicePixelRatio` can be tried to give
     * good results. A value of `undefined` disables the low res render pass. The value should not
     * be larger than`window.devicePixelRatio`.
     * @param antialiasSetting The object defining the demeanor of MSAA.
     */
    constructor(width, height, lowResPixelRatio, antialiasSettings = { msaaEnabled: false }) {
        this.bloom = {
            enabled: false,
            strength: 1.5,
            radius: 0.4,
            threshold: 0.85
        };
        this.outline = {
            enabled: false,
            thickness: 0.005,
            color: "#000000",
            ghostExtrudedPolygons: false,
            needsUpdate: false
        };
        this.vignette = {
            enabled: false,
            offset: 1.0,
            darkness: 1.0
        };
        this.sepia = {
            enabled: false,
            amount: 0.5
        };
        this.m_width = 1;
        this.m_height = 1;
        this.m_renderPass = new Pass_1.RenderPass();
        this.m_target1 = new THREE.WebGLRenderTarget(1, 1);
        this.m_target2 = new THREE.WebGLRenderTarget(1, 1);
        this.m_sepiaPass = new Pass_1.ShaderPass(harp_materials_1.SepiaShader);
        this.m_vignettePass = new Pass_1.ShaderPass(harp_materials_1.VignetteShader);
        this.m_readBuffer = new THREE.WebGLRenderTarget(width, height);
        this.m_msaaPass = new MSAARenderPass_1.MSAARenderPass();
        this.m_msaaPass.enabled =
            antialiasSettings !== undefined ? antialiasSettings.msaaEnabled === true : false;
        this.m_dynamicMsaaSamplingLevel =
            antialiasSettings.dynamicMsaaSamplingLevel === undefined
                ? DEFAULT_DYNAMIC_MSAA_SAMPLING_LEVEL
                : antialiasSettings.dynamicMsaaSamplingLevel;
        this.m_staticMsaaSamplingLevel =
            antialiasSettings.staticMsaaSamplingLevel === undefined
                ? DEFAULT_STATIC_MSAA_SAMPLING_LEVEL
                : antialiasSettings.staticMsaaSamplingLevel;
        this.m_lowResPass = new LowResRenderPass_1.LowResRenderPass(lowResPixelRatio);
        this.m_lowResPass.enabled = lowResPixelRatio !== undefined;
    }
    updateOutline(options) {
        this.outline.color = options.color;
        this.outline.thickness = options.thickness;
        this.outline.ghostExtrudedPolygons = options.ghostExtrudedPolygons;
        this.outline.needsUpdate = true;
    }
    /**
     * The method to call to render the map with the `MapRenderingManager` instance. It contains the
     * chain of sub-passes that can transfer the write and read buffers, and other sheer rendering
     * conditions as disabling AA when a high DPI device is in use.
     *
     * @param renderer The ThreeJS WebGLRenderer instance to render the map with.
     * @param scene The ThreeJS Scene instance containing the map objects to render.
     * @param camera The ThreeJS Camera instance to render the scene through.
     * @param isStaticFrame Whether the frame to render is static or dynamic. Selects level of
     * antialiasing.
     */
    render(renderer, scene, camera, isStaticFrame) {
        const target = null;
        if (!isStaticFrame && this.m_lowResPass.pixelRatio !== undefined) {
            // Not designed to be combined with our own MSAA
            this.m_lowResPass.renderToScreen = true;
            this.m_lowResPass.render(renderer, scene, camera, target, this.m_readBuffer);
            return;
        }
        const usePostEffects = this.bloom.enabled ||
            this.outline.enabled ||
            this.vignette.enabled ||
            this.sepia.enabled;
        let activeTarget = null;
        // 1. If the bloom is enabled, clear the depth.
        if (this.bloom.enabled || this.vignette.enabled || this.sepia.enabled) {
            renderer.setRenderTarget(this.m_target1);
            renderer.clearDepth();
        }
        // 2. Render the map.
        if (this.m_msaaPass.enabled) {
            // Use a higher MSAA sampling level for static rendering.
            this.m_msaaPass.samplingLevel = isStaticFrame
                ? this.m_staticMsaaSamplingLevel
                : this.m_dynamicMsaaSamplingLevel;
            // MSAA is the only effect for the moment.
            this.m_msaaPass.renderToScreen = !usePostEffects;
            // Render to the specified target with the MSAA pass.
            this.m_msaaPass.render(renderer, scene, camera, target, this.m_readBuffer);
        }
        else {
            if (this.bloom.enabled || this.vignette.enabled || this.sepia.enabled) {
                activeTarget = this.m_target1;
                this.m_renderPass.render(renderer, scene, camera, this.m_target1, null);
            }
            else if (!this.outline.enabled || (this.outline.enabled && !this.bloom.enabled)) {
                renderer.render(scene, camera);
            }
        }
        // 3. Apply effects
        if (this.outline.enabled) {
            if (this.m_outlineEffect === undefined) {
                this.m_outlineEffect = new Outline_1.OutlineEffect(renderer);
            }
            if (this.outline.needsUpdate) {
                this.m_outlineEffect.color = this.outline.color;
                this.m_outlineEffect.thickness = this.outline.thickness;
                this.m_outlineEffect.ghostExtrudedPolygons = this.outline.ghostExtrudedPolygons;
                this.outline.needsUpdate = false;
            }
            const nextEffectEnabled = this.bloom.enabled || this.vignette.enabled || this.sepia.enabled;
            if (nextEffectEnabled) {
                activeTarget = this.m_target1;
            }
            renderer.setRenderTarget(nextEffectEnabled ? activeTarget : null);
            this.m_outlineEffect.render(scene, camera);
        }
        if (this.bloom.enabled) {
            if (this.m_bloomPass === undefined) {
                this.m_bloomPass = new UnrealBloomPass_1.BloomPass(new THREE.Vector2(this.m_width, this.m_height), this.bloom.strength, this.bloom.radius, this.bloom.threshold);
            }
            const nextEffectEnabled = this.vignette.enabled || this.sepia.enabled;
            this.m_bloomPass.renderToScreen = !nextEffectEnabled;
            this.m_bloomPass.radius = this.bloom.radius;
            this.m_bloomPass.strength = this.bloom.strength;
            this.m_bloomPass.threshold = this.bloom.threshold;
            this.m_bloomPass.render(renderer, scene, camera, null, activeTarget);
        }
        else if (this.m_bloomPass !== undefined) {
            this.m_bloomPass.dispose();
            this.m_bloomPass = undefined;
        }
        if (this.vignette.enabled) {
            const oldTarget = activeTarget;
            const nextEffectEnabled = this.sepia.enabled;
            this.m_vignettePass.uniforms.offset.value = this.vignette.offset;
            this.m_vignettePass.uniforms.darkness.value = this.vignette.darkness;
            this.m_vignettePass.renderToScreen = !nextEffectEnabled;
            if (nextEffectEnabled) {
                activeTarget = activeTarget === this.m_target1 ? this.m_target2 : this.m_target1;
            }
            this.m_vignettePass.render(renderer, scene, camera, activeTarget, oldTarget);
        }
        if (this.sepia.enabled) {
            this.m_sepiaPass.renderToScreen = true;
            this.m_sepiaPass.uniforms.amount.value = this.sepia.amount;
            this.m_sepiaPass.render(renderer, scene, camera, null, activeTarget);
        }
    }
    /**
     * The resize function to call on resize events to resize the render targets. It shall include
     * the resize methods of all the sub-passes used in `MapRenderingManager`.
     *
     * @param width New width to use.
     * @param height New height to use.
     */
    setSize(width, height) {
        this.m_readBuffer.setSize(width, height);
        this.m_msaaPass.setSize(width, height);
        if (this.m_bloomPass !== undefined) {
            this.m_bloomPass.setSize(width, height);
        }
        this.m_lowResPass.setSize(width, height);
        this.m_target1.setSize(width, height);
        this.m_target2.setSize(width, height);
        this.m_width = width;
        this.m_height = height;
    }
    /**
     * The `lowResPixelRatio` determines the resolution of the internal `WebGLRenderTarget`. Values
     * between 0.5 and `window.devicePixelRatio` can be tried to give  good results. A value of
     * `undefined` disables the low res render pass. The value should not be larger than
     * `window.devicePixelRatio`.
     */
    get lowResPixelRatio() {
        return this.m_lowResPass.pixelRatio;
    }
    set lowResPixelRatio(pixelRatio) {
        this.m_lowResPass.pixelRatio = pixelRatio;
        this.m_lowResPass.enabled = pixelRatio !== undefined;
    }
    /**
     * Set the level of sampling while the user interacts.
     *
     * @param samplingLevel The sampling level.
     */
    set dynamicMsaaSamplingLevel(samplingLevel) {
        this.m_dynamicMsaaSamplingLevel = samplingLevel;
    }
    /**
     * Return the sampling level defined during continuous rendering.
     */
    get dynamicMsaaSamplingLevel() {
        return this.m_dynamicMsaaSamplingLevel;
    }
    /**
     * Enable or disable the MSAA. If disabled, `MapRenderingManager` will use the renderer provided
     * in the [[MapRenderingManager.render]] method to render the scene.
     *
     * @param value If `true`, MSAA is enabled, disabled otherwise.
     */
    set msaaEnabled(value) {
        this.m_msaaPass.enabled = value;
    }
    /**
     * Return whether the MSAA is enabled.
     */
    get msaaEnabled() {
        return this.m_msaaPass.enabled;
    }
    /**
     * Set the sampling level for rendering static frames.
     *
     * @param samplingLevel The sampling level.
     */
    set staticMsaaSamplingLevel(samplingLevel) {
        this.m_staticMsaaSamplingLevel = samplingLevel;
    }
    /**
     * Return the sampling level defined for rendering static frames.
     */
    get staticMsaaSamplingLevel() {
        return this.m_staticMsaaSamplingLevel;
    }
}
exports.MapRenderingManager = MapRenderingManager;


/***/ }),

/***/ "../harp-mapview/lib/composing/Outline.ts":
/*!************************************************!*\
  !*** ../harp-mapview/lib/composing/Outline.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const THREE = __webpack_require__(/*! three */ "three");
const vertexShaderChunk = `
    uniform float outlineThickness;

    vec4 calculateOutline( vec4 pos, vec3 objectNormal, vec4 skinned ) {

        float thickness = outlineThickness;
        const float ratio = 1.0;
        vec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + objectNormal, 1.0 );
        vec4 norm = normalize( pos - pos2 );
        return pos + norm * thickness * pos.w * ratio;

    }`;
const vertexShaderChunk2 = `
    #if ! defined( LAMBERT ) && ! defined( PHONG ) && ! defined( TOON ) && ! defined( STANDARD )
        #ifndef USE_ENVMAP
            vec3 objectNormal = normalize( normal );
        #endif
    #endif

    #ifdef FLIP_SIDED
        objectNormal = -objectNormal;
    #endif

    #ifdef DECLARE_TRANSFORMED
        vec3 transformed = vec3( position );
    #endif

    gl_Position = calculateOutline( gl_Position, objectNormal, vec4( transformed, 1.0 ) );

    #include <fog_vertex>`;
const fragmentShader = `
    #include <common>
    #include <fog_pars_fragment>

    uniform vec3 outlineColor;
    uniform float outlineAlpha;

    void main() {

        gl_FragColor = vec4( outlineColor, outlineAlpha );

        #include <fog_fragment>

    }`;
class OutlineEffect {
    constructor(m_renderer) {
        this.m_renderer = m_renderer;
        this.enabled = true;
        this.m_defaultThickness = 0.02;
        this.m_defaultColor = new THREE.Color(0, 0, 0);
        this.m_defaultAlpha = 1;
        this.m_defaultKeepAlive = false;
        this.m_ghostExtrudedPolygons = false;
        this.m_cache = {};
        this.m_removeThresholdCount = 60;
        this.m_originalMaterials = {};
        this.m_originalOnBeforeRenders = {};
        this.m_shaderIDs = {
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "phong",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical"
        };
        this.m_uniformsChunk = {
            outlineThickness: { value: this.m_defaultThickness },
            outlineColor: { value: this.m_defaultColor },
            outlineAlpha: { value: this.m_defaultAlpha }
        };
        this.autoClear = m_renderer.autoClear;
        this.domElement = m_renderer.domElement;
        this.shadowMap = m_renderer.shadowMap;
    }
    set thickness(thickness) {
        this.m_defaultThickness = thickness;
        this.m_uniformsChunk.outlineThickness.value = thickness;
        this.m_cache = {};
    }
    set color(color) {
        this.m_defaultColor.set(color);
        this.m_cache = {};
    }
    set ghostExtrudedPolygons(ghost) {
        this.m_ghostExtrudedPolygons = ghost;
    }
    clear(color, depth, stencil) {
        this.m_renderer.clear(color, depth, stencil);
    }
    getPixelRatio() {
        return this.m_renderer.getPixelRatio();
    }
    setPixelRatio(value) {
        this.m_renderer.setPixelRatio(value);
    }
    getSize(target) {
        return this.m_renderer.getSize(target);
    }
    setSize(width, height, updateStyle) {
        this.m_renderer.setSize(width, height, updateStyle);
    }
    setViewport(x, y, width, height) {
        this.m_renderer.setViewport(x, y, width, height);
    }
    setScissor(x, y, width, height) {
        this.m_renderer.setScissor(x, y, width, height);
    }
    setScissorTest(boolean) {
        this.m_renderer.setScissorTest(boolean);
    }
    setRenderTarget(renderTarget) {
        this.m_renderer.setRenderTarget(renderTarget);
    }
    render(scene, camera) {
        // Re-rendering the scene with the outline effect enables to hide the
        // extruded polygons and show only the outlines (it is a hack and should be
        // implemented another way!).
        if (this.m_ghostExtrudedPolygons) {
            if (!this.enabled) {
                this.m_renderer.render(scene, camera);
                return;
            }
            const currentAutoClear = this.m_renderer.autoClear;
            this.m_renderer.autoClear = this.autoClear;
            this.m_renderer.render(scene, camera);
            this.m_renderer.autoClear = currentAutoClear;
        }
        this.renderOutline(scene, camera);
    }
    renderOutline(scene, camera) {
        const currentAutoClear = this.m_renderer.autoClear;
        const currentSceneAutoUpdate = scene.autoUpdate;
        const currentSceneBackground = scene.background;
        const currentShadowMapEnabled = this.m_renderer.shadowMap.enabled;
        scene.autoUpdate = false;
        scene.background = null;
        this.m_renderer.autoClear = false;
        this.m_renderer.shadowMap.enabled = false;
        scene.traverse(this.setOutlineMaterial.bind(this));
        this.m_renderer.render(scene, camera);
        scene.traverse(this.restoreOriginalMaterial.bind(this));
        this.cleanupCache();
        scene.autoUpdate = currentSceneAutoUpdate;
        scene.background = currentSceneBackground;
        this.m_renderer.autoClear = currentAutoClear;
        this.m_renderer.shadowMap.enabled = currentShadowMapEnabled;
    }
    createInvisibleMaterial() {
        return new THREE.ShaderMaterial({ name: "invisible", visible: false });
    }
    createMaterial(originalMaterial) {
        const shaderID = this.m_shaderIDs[originalMaterial.type];
        let originalUniforms;
        let originalVertexShader;
        if (shaderID !== undefined) {
            const shader = THREE.ShaderLib[shaderID];
            originalUniforms = shader.uniforms;
            originalVertexShader = shader.vertexShader;
        }
        else if (originalMaterial.isRawShaderMaterial === true) {
            originalUniforms = originalMaterial.uniforms;
            originalVertexShader = originalMaterial.vertexShader;
            if (!/attribute\s+vec3\s+position\s*;/.test(originalVertexShader) ||
                !/attribute\s+vec3\s+normal\s*;/.test(originalVertexShader)) {
                return this.createInvisibleMaterial();
            }
        }
        else if (originalMaterial.isShaderMaterial === true) {
            originalUniforms = originalMaterial.uniforms;
            originalVertexShader = originalMaterial.vertexShader;
        }
        else {
            return this.createInvisibleMaterial();
        }
        const uniforms = Object.assign(Object.assign({}, originalUniforms), this.m_uniformsChunk);
        const vertexShader = originalVertexShader
            // put vertexShaderChunk right before "void main() {...}"
            .replace(/void\s+main\s*\(\s*\)/, vertexShaderChunk + "\nvoid main()")
            // put vertexShaderChunk2 the end of "void main() {...}"
            // Note: here assums originalVertexShader ends with "}" of "void main() {...}"
            .replace(/\}\s*$/, vertexShaderChunk2 + "\n}")
            // remove any light related lines
            // Note: here is very sensitive to originalVertexShader
            // TODO: consider safer way
            .replace(/#include\s+<[\w_]*light[\w_]*>/g, "");
        const defines = {};
        if (!/vec3\s+transformed\s*=/.test(originalVertexShader) &&
            !/#include\s+<begin_vertex>/.test(originalVertexShader)) {
            defines.DECLARE_TRANSFORMED = true;
        }
        return new THREE.ShaderMaterial({
            defines,
            uniforms,
            vertexShader,
            fragmentShader,
            side: THREE.BackSide,
            //wireframe: true,
            skinning: false,
            morphTargets: false,
            morphNormals: false,
            fog: false
        });
    }
    getOutlineMaterialFromCache(originalMaterial) {
        let data = this.m_cache[originalMaterial.uuid];
        if (data === undefined) {
            data = {
                material: this.createMaterial(originalMaterial),
                used: true,
                keepAlive: this.m_defaultKeepAlive,
                count: 0
            };
            this.m_cache[originalMaterial.uuid] = data;
        }
        data.used = true;
        return data.material;
    }
    getOutlineMaterial(originalMaterial) {
        const outlineMaterial = this.getOutlineMaterialFromCache(originalMaterial);
        this.m_originalMaterials[outlineMaterial.uuid] = originalMaterial;
        this.updateOutlineMaterial(outlineMaterial, originalMaterial);
        return outlineMaterial;
    }
    setOutlineMaterial(object) {
        if (object.material === undefined) {
            return;
        }
        if (Array.isArray(object.material)) {
            for (let i = 0, il = object.material.length; i < il; i++) {
                object.material[i] = this.getOutlineMaterial(object.material[i]);
            }
        }
        else {
            object.material = this.getOutlineMaterial(object.material);
        }
        this.m_originalOnBeforeRenders[object.uuid] = object.onBeforeRender;
        object.onBeforeRender = harp_utils_1.chainCallbacks(object.onBeforeRender, this.onBeforeRender.bind(this));
    }
    restoreOriginalMaterial(object) {
        if (object.material === undefined) {
            return;
        }
        if (Array.isArray(object.material)) {
            for (let i = 0, il = object.material.length; i < il; i++) {
                object.material[i] = this.m_originalMaterials[object.material[i].uuid];
            }
        }
        else {
            object.material = this.m_originalMaterials[object.material.uuid];
        }
        object.onBeforeRender = this.m_originalOnBeforeRenders[object.uuid];
    }
    onBeforeRender(renderer, scene, camera, geometry, material, group) {
        const originalMaterial = this.m_originalMaterials[material.uuid];
        // just in case
        if (originalMaterial === undefined) {
            return;
        }
        this.updateUniforms(material, originalMaterial);
    }
    updateUniforms(material, originalMaterial) {
        const outlineParameters = originalMaterial.userData.outlineParameters;
        material.uniforms.outlineAlpha.value = originalMaterial.opacity;
        if (outlineParameters !== undefined) {
            if (outlineParameters.thickness !== undefined) {
                material.uniforms.outlineThickness.value = outlineParameters.thickness;
            }
            if (outlineParameters.color !== undefined) {
                material.uniforms.outlineColor.value.fromArray(outlineParameters.color);
            }
            if (outlineParameters.alpha !== undefined) {
                material.uniforms.outlineAlpha.value = outlineParameters.alpha;
            }
        }
    }
    updateOutlineMaterial(material, originalMaterial) {
        if (material.name === "invisible") {
            return;
        }
        const outlineParameters = originalMaterial.userData.outlineParameters;
        material.skinning = originalMaterial.skinning;
        material.morphTargets = originalMaterial.morphTargets;
        material.morphNormals = originalMaterial.morphNormals;
        material.fog = originalMaterial.fog;
        if (outlineParameters !== undefined) {
            material.visible =
                originalMaterial.visible === false
                    ? false
                    : outlineParameters.visible !== undefined
                        ? outlineParameters.visible
                        : true;
            material.transparent =
                outlineParameters.alpha !== undefined && outlineParameters.alpha < 1.0
                    ? true
                    : originalMaterial.transparent;
            if (outlineParameters.keepAlive !== undefined) {
                this.m_cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive;
            }
        }
        else {
            material.transparent = originalMaterial.transparent;
            material.visible = originalMaterial.visible;
        }
        if (originalMaterial.wireframe === true || originalMaterial.depthTest === false) {
            material.visible = false;
        }
    }
    cleanupCache() {
        let keys;
        // clear originialMaterials
        keys = Object.keys(this.m_originalMaterials);
        for (let i = 0, il = keys.length; i < il; i++) {
            this.m_originalMaterials[keys[i]] = undefined;
        }
        // clear originalOnBeforeRenders
        keys = Object.keys(this.m_originalOnBeforeRenders);
        for (let i = 0, il = keys.length; i < il; i++) {
            this.m_originalOnBeforeRenders[keys[i]] = undefined;
        }
        // remove unused outlineMaterial from cache
        keys = Object.keys(this.m_cache);
        for (const key of keys) {
            if (this.m_cache[key].used === false) {
                this.m_cache[key].count++;
                if (this.m_cache[key].keepAlive === false &&
                    this.m_cache[key].count > this.m_removeThresholdCount) {
                    delete this.m_cache[key];
                }
            }
            else {
                this.m_cache[key].used = false;
                this.m_cache[key].count = 0;
            }
        }
    }
}
exports.OutlineEffect = OutlineEffect;


/***/ }),

/***/ "../harp-mapview/lib/composing/Pass.ts":
/*!*********************************************!*\
  !*** ../harp-mapview/lib/composing/Pass.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * The base class to extend for further passes in [[MapView]], like the [[MSAARenderPass]], possibly
 * a text pass, an AO effect etc. `Pass` provides the core logic for both :
 * - render passes (proper scene renders),
 * - and shader passes (quad renders, i.e. effects added on top of the render output as a
 * postprocess).
 *
 * Even some shader passes still actually fall within the render pass category as they need to
 * re-render the scene to then deduce an effect, such as masking, AO, DoF etc. Others just need the
 * previous input image to apply a shader on top of it, as for bloom or NVIDIA's FXAA for example.
 * These only are proper shader passes.
 */
class Pass {
    constructor() {
        this.enabled = false;
        this.renderToScreen = false;
        // tslint:enable:no-unused-variable
    }
    // tslint:disable-next-line:no-unused-variable
    setSize(width, height) {
        // Implemented in sub-classes.
    }
    // tslint:disable:no-unused-variable
    render(renderer, scene, camera, writeBuffer, readBuffer, delta) {
        // Implemented in sub-classes.
    }
}
exports.Pass = Pass;
/**
 * The pass that does a default normal scene rendering for further post-effects.
 */
class RenderPass extends Pass {
    constructor() {
        super();
    }
    /** @override */
    render(renderer, scene, camera, writeBuffer, readBuffer) {
        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
        renderer.render(scene, camera);
    }
}
exports.RenderPass = RenderPass;
/**
 * The base class to extend for post-effects on the final render (like Vignette, Sepia, color
 * correction...)
 */
class ShaderPass extends Pass {
    constructor(shader, textureID = "tDiffuse") {
        super();
        this.textureID = textureID;
        if (shader instanceof THREE.ShaderMaterial) {
            this.uniforms = shader.uniforms;
            this.material = shader;
        }
        else {
            this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);
            this.material = new THREE.ShaderMaterial({
                defines: Object.assign({}, shader.defines),
                uniforms: this.uniforms,
                vertexShader: shader.vertexShader,
                fragmentShader: shader.fragmentShader
            });
        }
        this.fsQuad = new FullScreenQuad(this.material);
    }
    /** @override */
    render(renderer, scene, camera, writeBuffer, readBuffer, delta) {
        if (this.uniforms[this.textureID]) {
            this.uniforms[this.textureID].value = readBuffer.texture;
        }
        this.fsQuad.material = this.material;
        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
        this.fsQuad.render(renderer);
    }
}
exports.ShaderPass = ShaderPass;
class FullScreenQuad {
    constructor(material) {
        this.m_camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const geometry = new THREE.PlaneBufferGeometry(2, 2);
        this.m_mesh = new THREE.Mesh(geometry, material);
    }
    get material() {
        return this.m_mesh.material;
    }
    set material(value) {
        this.m_mesh.material = value;
    }
    render(renderer) {
        renderer.render(this.m_mesh, this.m_camera);
    }
}


/***/ }),

/***/ "../harp-mapview/lib/composing/UnrealBloomPass.ts":
/*!********************************************************!*\
  !*** ../harp-mapview/lib/composing/UnrealBloomPass.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const Pass_1 = __webpack_require__(/*! ./Pass */ "../harp-mapview/lib/composing/Pass.ts");
const BlurDirectionX = new THREE.Vector2(1.0, 0.0);
const BlurDirectionY = new THREE.Vector2(0.0, 1.0);
/**
 * The TS version of ThreeJS's UnrealBloomPass.
 */
class BloomPass extends Pass_1.Pass {
    constructor(resolution, strength, radius, threshold) {
        super();
        this.resolution = new THREE.Vector2(256, 256);
        this.m_renderTargetsHorizontal = [];
        this.m_renderTargetsVertical = [];
        this.m_nMips = 5;
        this.m_separableBlurMaterials = [];
        this.m_camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.m_scene = new THREE.Scene();
        this.m_basic = new THREE.MeshBasicMaterial();
        this.m_quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2));
        this.m_bloomTintColors = [
            new THREE.Vector3(1, 1, 1),
            new THREE.Vector3(1, 1, 1),
            new THREE.Vector3(1, 1, 1),
            new THREE.Vector3(1, 1, 1),
            new THREE.Vector3(1, 1, 1)
        ];
        this.strength = strength;
        this.radius = radius;
        this.threshold = threshold;
        this.resolution = resolution;
        this.m_quad.frustumCulled = false;
        this.m_scene.add(this.m_quad);
        const pars = {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: THREE.RGBAFormat
        };
        let resx = Math.round(this.resolution.x / 2);
        let resy = Math.round(this.resolution.y / 2);
        this.m_renderTargetBright = new THREE.WebGLRenderTarget(resx, resy, pars);
        this.m_renderTargetBright.texture.name = "UnrealBloomPass.bright";
        this.m_renderTargetBright.texture.generateMipmaps = false;
        for (let i = 0; i < this.m_nMips; i++) {
            const renderTargetHorizonal = new THREE.WebGLRenderTarget(resx, resy, pars);
            renderTargetHorizonal.texture.name = "UnrealBloomPass.h" + i;
            renderTargetHorizonal.texture.generateMipmaps = false;
            this.m_renderTargetsHorizontal.push(renderTargetHorizonal);
            const renderTargetVertical = new THREE.WebGLRenderTarget(resx, resy, pars);
            renderTargetVertical.texture.name = "UnrealBloomPass.v" + i;
            renderTargetVertical.texture.generateMipmaps = false;
            this.m_renderTargetsVertical.push(renderTargetVertical);
            resx = Math.round(resx / 2);
            resy = Math.round(resy / 2);
        }
        this.m_highPassUniforms = THREE.UniformsUtils.clone(harp_materials_1.LuminosityHighPassShader.uniforms);
        // tslint:disable:no-string-literal
        this.m_highPassUniforms["luminosityThreshold"].value = threshold;
        this.m_highPassUniforms["smoothWidth"].value = 0.01;
        this.m_materialHighPassFilter = new THREE.ShaderMaterial({
            uniforms: this.m_highPassUniforms,
            vertexShader: harp_materials_1.LuminosityHighPassShader.vertexShader,
            fragmentShader: harp_materials_1.LuminosityHighPassShader.fragmentShader,
            defines: {}
        });
        // Gaussian Blur Materials
        const kernelSizeArray = [3, 5, 7, 9, 11];
        resx = Math.round(this.resolution.x / 2);
        resy = Math.round(this.resolution.y / 2);
        for (let i = 0; i < this.m_nMips; i++) {
            this.m_separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));
            this.m_separableBlurMaterials[i].uniforms["texSize"].value = new THREE.Vector2(resx, resy);
            resx = Math.round(resx / 2);
            resy = Math.round(resy / 2);
        }
        // Composite material
        this.m_compositeMaterial = this.getCompositeMaterial(this.m_nMips);
        this.m_compositeMaterial.uniforms["blurTexture1"].value = this.m_renderTargetsVertical[0].texture;
        this.m_compositeMaterial.uniforms["blurTexture2"].value = this.m_renderTargetsVertical[1].texture;
        this.m_compositeMaterial.uniforms["blurTexture3"].value = this.m_renderTargetsVertical[2].texture;
        this.m_compositeMaterial.uniforms["blurTexture4"].value = this.m_renderTargetsVertical[3].texture;
        this.m_compositeMaterial.uniforms["blurTexture5"].value = this.m_renderTargetsVertical[4].texture;
        this.m_compositeMaterial.uniforms["bloomStrength"].value = strength;
        this.m_compositeMaterial.uniforms["bloomRadius"].value = 0.1;
        this.m_compositeMaterial.needsUpdate = true;
        const bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];
        this.m_compositeMaterial.uniforms["bloomFactors"].value = bloomFactors;
        this.m_compositeMaterial.uniforms["bloomTintColors"].value = this.m_bloomTintColors;
        this.m_copyUniforms = THREE.UniformsUtils.clone(harp_materials_1.CopyShader.uniforms);
        this.m_copyUniforms["opacity"].value = 1.0;
        // tslint:enable:no-string-literal
        this.m_materialCopy = new THREE.ShaderMaterial({
            uniforms: this.m_copyUniforms,
            vertexShader: harp_materials_1.CopyShader.vertexShader,
            fragmentShader: harp_materials_1.CopyShader.fragmentShader,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            depthWrite: false,
            transparent: true
        });
    }
    dispose() {
        for (const rt of this.m_renderTargetsHorizontal) {
            rt.dispose();
        }
        for (const rt of this.m_renderTargetsVertical) {
            rt.dispose();
        }
        this.m_renderTargetBright.dispose();
    }
    /** @override */
    setSize(width, height) {
        let resx = Math.round(width / 2);
        let resy = Math.round(height / 2);
        this.m_renderTargetBright.setSize(resx, resy);
        for (let i = 0; i < this.m_nMips; i++) {
            this.m_renderTargetsHorizontal[i].setSize(resx, resy);
            this.m_renderTargetsVertical[i].setSize(resx, resy);
            // tslint:disable-next-line:no-string-literal
            this.m_separableBlurMaterials[i].uniforms["texSize"].value = new THREE.Vector2(resx, resy);
            resx = Math.round(resx / 2);
            resy = Math.round(resy / 2);
        }
    }
    /** @override */
    render(renderer, scene, camera, writeBuffer, readBuffer) {
        // tslint:disable:no-string-literal
        // Render input to screen
        if (this.renderToScreen) {
            this.m_quad.material = this.m_basic;
            this.m_basic.map = readBuffer.texture;
            renderer.setRenderTarget(null);
            renderer.clear();
            renderer.render(this.m_scene, this.m_camera);
        }
        // 1. Extract bright areas
        this.m_highPassUniforms["tDiffuse"].value = readBuffer.texture;
        this.m_highPassUniforms["luminosityThreshold"].value = this.threshold;
        this.m_quad.material = this.m_materialHighPassFilter;
        renderer.setRenderTarget(this.m_renderTargetBright);
        renderer.clear();
        renderer.render(this.m_scene, this.m_camera);
        // 2. Blur all the mips progressively
        let inputRenderTarget = this.m_renderTargetBright;
        for (let i = 0; i < this.m_nMips; i++) {
            this.m_quad.material = this.m_separableBlurMaterials[i];
            this.m_separableBlurMaterials[i].uniforms["colorTexture"].value =
                inputRenderTarget.texture;
            this.m_separableBlurMaterials[i].uniforms["direction"].value = BlurDirectionX;
            renderer.setRenderTarget(this.m_renderTargetsHorizontal[i]);
            renderer.clear();
            renderer.render(this.m_scene, this.m_camera);
            this.m_separableBlurMaterials[i].uniforms["colorTexture"].value = this.m_renderTargetsHorizontal[i].texture;
            this.m_separableBlurMaterials[i].uniforms["direction"].value = BlurDirectionY;
            renderer.setRenderTarget(this.m_renderTargetsVertical[i]);
            renderer.clear();
            renderer.render(this.m_scene, this.m_camera);
            inputRenderTarget = this.m_renderTargetsVertical[i];
        }
        // Composite all the mips
        this.m_quad.material = this.m_compositeMaterial;
        this.m_compositeMaterial.uniforms["bloomStrength"].value = this.strength;
        this.m_compositeMaterial.uniforms["bloomRadius"].value = this.radius;
        this.m_compositeMaterial.uniforms["bloomTintColors"].value = this.m_bloomTintColors;
        renderer.setRenderTarget(this.m_renderTargetsHorizontal[0]);
        renderer.clear();
        renderer.render(this.m_scene, this.m_camera);
        // Blend it additively over the input texture
        this.m_quad.material = this.m_materialCopy;
        this.m_copyUniforms["tDiffuse"].value = this.m_renderTargetsHorizontal[0].texture;
        if (this.renderToScreen) {
            renderer.setRenderTarget(null);
            renderer.render(this.m_scene, this.m_camera);
        }
        else {
            renderer.setRenderTarget(readBuffer);
            renderer.render(this.m_scene, this.m_camera);
        }
        // tslint:enable:no-string-literal
    }
    getSeperableBlurMaterial(kernelRadius) {
        return new THREE.ShaderMaterial({
            defines: {
                KERNEL_RADIUS: kernelRadius,
                SIGMA: kernelRadius
            },
            uniforms: {
                colorTexture: { value: null },
                texSize: { value: new THREE.Vector2(0.5, 0.5) },
                direction: { value: new THREE.Vector2(0.5, 0.5) }
            },
            vertexShader: `varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
            }`,
            fragmentShader: `#include <common>
            varying vec2 vUv;
            uniform sampler2D colorTexture;
            uniform vec2 texSize;
            uniform vec2 direction;

            float gaussianPdf(in float x, in float sigma) {
                return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
            }
            void main() {\n\
                vec2 invSize = 1.0 / texSize;
                float fSigma = float(SIGMA);
                float weightSum = gaussianPdf(0.0, fSigma);
                vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;
                for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
                    float x = float(i);
                    float w = gaussianPdf(x, fSigma);
                    vec2 uvOffset = direction * invSize * x;
                    vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;
                    vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;
                    diffuseSum += (sample1 + sample2) * w;
                    weightSum += 2.0 * w;
                }
                gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
            }`
        });
    }
    getCompositeMaterial(nMips) {
        return new THREE.ShaderMaterial({
            defines: {
                NUM_MIPS: nMips
            },
            uniforms: {
                blurTexture1: { value: null },
                blurTexture2: { value: null },
                blurTexture3: { value: null },
                blurTexture4: { value: null },
                blurTexture5: { value: null },
                dirtTexture: { value: null },
                bloomStrength: { value: 1.0 },
                bloomFactors: { value: null },
                bloomTintColors: { value: null },
                bloomRadius: { value: 0.0 }
            },
            vertexShader: `varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }`,
            fragmentShader: `varying vec2 vUv;
                uniform sampler2D blurTexture1;
                uniform sampler2D blurTexture2;
                uniform sampler2D blurTexture3;
                uniform sampler2D blurTexture4;
                uniform sampler2D blurTexture5;
                uniform sampler2D dirtTexture;
                uniform float bloomStrength;
                uniform float bloomRadius;
                uniform float bloomFactors[NUM_MIPS];
                uniform vec3 bloomTintColors[NUM_MIPS];

                float lerpBloomFactor(const in float factor) {
                    float mirrorFactor = 1.2 - factor;
                    return mix(factor, mirrorFactor, bloomRadius);
                }

                void main() {
                    gl_FragColor = bloomStrength * (
lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
                }`
        });
    }
}
exports.BloomPass = BloomPass;


/***/ }),

/***/ "../harp-mapview/lib/composing/index.ts":
/*!**********************************************!*\
  !*** ../harp-mapview/lib/composing/index.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
var MapRenderingManager_1 = __webpack_require__(/*! ./MapRenderingManager */ "../harp-mapview/lib/composing/MapRenderingManager.ts");
exports.MapRenderingManager = MapRenderingManager_1.MapRenderingManager;
var Pass_1 = __webpack_require__(/*! ./Pass */ "../harp-mapview/lib/composing/Pass.ts");
exports.Pass = Pass_1.Pass;
var MSAARenderPass_1 = __webpack_require__(/*! ./MSAARenderPass */ "../harp-mapview/lib/composing/MSAARenderPass.ts");
exports.MSAARenderPass = MSAARenderPass_1.MSAARenderPass;
exports.MSAASampling = MSAARenderPass_1.MSAASampling;


/***/ }),

/***/ "../harp-mapview/lib/copyrights/CopyrightCoverageProvider.ts":
/*!*******************************************************************!*\
  !*** ../harp-mapview/lib/copyrights/CopyrightCoverageProvider.ts ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
// tslint:disable-next-line:no-var-requires
const RBush = __webpack_require__(/*! rbush */ "../../node_modules/rbush/rbush.min.js");
/**
 * Base class to provide copyrights based on copyright coverage information, defined by geographical
 * bounding boxes and relevant zoom level ranges.
 */
class CopyrightCoverageProvider {
    constructor() {
        /** Logger instance. */
        this.logger = harp_utils_1.LoggerManager.instance.create("CopyrightCoverageProvider");
    }
    /** @inheritdoc */
    getTree() {
        if (this.m_cachedTreePromise !== undefined) {
            return this.m_cachedTreePromise;
        }
        this.m_cachedTreePromise = this.getCopyrightCoverageData()
            .then(coverageInfo => this.initRBush(coverageInfo))
            .catch(error => {
            this.logger.error(error);
            return new RBush();
        });
        return this.m_cachedTreePromise;
    }
    /** @inheritdoc */
    async getCopyrights(geoBox, level) {
        const tree = await this.getTree();
        const result = [];
        const matchingEntries = tree.search({
            minX: geoBox.west,
            minY: geoBox.south,
            maxX: geoBox.east,
            maxY: geoBox.north
        });
        for (const entry of matchingEntries) {
            const minLevel = harp_utils_1.getOptionValue(entry.minLevel, 0);
            const maxLevel = harp_utils_1.getOptionValue(entry.maxLevel, Infinity);
            if (level >= minLevel && level <= maxLevel) {
                if (result.find(item => item.id === entry.label) === undefined) {
                    result.push({ id: entry.label });
                }
            }
        }
        return result;
    }
    /**
     * Initializes RBush.
     *
     * @param entries Entries for tree.
     * @returns RBush instance.
     */
    initRBush(entries) {
        const tree = new RBush();
        if (!entries) {
            this.logger.warn("No copyright coverage data provided");
            return tree;
        }
        for (const entry of entries) {
            const { minLevel, maxLevel, label, alt } = entry;
            if (!entry.boxes) {
                tree.insert({
                    minX: -180,
                    minY: -90,
                    maxX: 180,
                    maxY: 180,
                    minLevel,
                    maxLevel,
                    label,
                    alt
                });
            }
            else {
                for (const box of entry.boxes) {
                    const [minY, minX, maxY, maxX] = box;
                    tree.insert({
                        minX,
                        minY,
                        maxX,
                        maxY,
                        minLevel,
                        maxLevel,
                        label,
                        alt
                    });
                }
            }
        }
        return tree;
    }
}
exports.CopyrightCoverageProvider = CopyrightCoverageProvider;


/***/ }),

/***/ "../harp-mapview/lib/copyrights/CopyrightElementHandler.ts":
/*!*****************************************************************!*\
  !*** ../harp-mapview/lib/copyrights/CopyrightElementHandler.ts ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const MapView_1 = __webpack_require__(/*! ../MapView */ "../harp-mapview/lib/MapView.ts");
const CopyrightInfo_1 = __webpack_require__(/*! ./CopyrightInfo */ "../harp-mapview/lib/copyrights/CopyrightInfo.ts");
/**
 * Helper class that maintains up-to-date [[MapView]] copyright information in DOM element.
 *
 * @example
 *
 *     // HTML snippet
 *     <div id="copyrightNotice" style="position:absolute; right:0; bottom:0; z-index:100"></div>
 *
 *     // JavaScript
 *     const mapView = new MapView({ ... });
 *     CopyrightElementHandler.install("copyrightNotice", mapView);
 */
class CopyrightElementHandler {
    /**
     * Creates a new `CopyrightElementHandler` that updates the DOM element with the copyright info
     * of the given `mapView`.
     *
     * Note: Generally, the static [[install]] method can be used to create and attach a new
     * `CopyrightElementHandler` to a [[MapView]]
     *
     * @param element HTML DOM element or a HTML DOM element id
     * @param mapView optional, [[attach]] to this [[MapView]] instance
     */
    constructor(element, mapView) {
        this.m_defaults = new Map();
        this.m_mapViews = [];
        /**
         * Update copyright info text in controlled HTML element.
         */
        this.update = () => {
            const mergedCopyrightInfo = this.m_mapViews
                .map(mapView => mapView.copyrightInfo)
                .reduce(CopyrightInfo_1.CopyrightInfo.mergeArrays, this.staticInfo || []);
            // Conditionally hiding of element with copyright information.
            // If nothing to show we schould to avoid empty white rectangle in right bottom corner.
            if (mergedCopyrightInfo.length === 0) {
                this.m_element.style.display = "none";
                return;
            }
            else {
                this.m_element.style.display = "block";
            }
            if (this.m_defaults.size !== 0) {
                for (const sourceInfo of mergedCopyrightInfo) {
                    const defaults = this.m_defaults.get(sourceInfo.id);
                    if (defaults !== undefined) {
                        sourceInfo.year = harp_utils_1.getOptionValue(sourceInfo.year, defaults.year);
                        sourceInfo.label = harp_utils_1.getOptionValue(sourceInfo.label, defaults.label);
                        sourceInfo.link = harp_utils_1.getOptionValue(sourceInfo.link, defaults.link);
                    }
                }
            }
            const deduped = CopyrightInfo_1.CopyrightInfo.mergeArrays(mergedCopyrightInfo);
            this.m_element.innerHTML = CopyrightInfo_1.CopyrightInfo.formatAsHtml(deduped);
        };
        if (typeof element === "string") {
            const htmlElement = document.getElementById(element);
            if (!htmlElement) {
                throw new Error(`CopyrightElementHandler: unable to find DOM element #${element}`);
            }
            this.m_element = htmlElement;
        }
        else {
            this.m_element = element;
        }
        if (mapView !== undefined) {
            this.attach(mapView);
        }
    }
    /**
     * Install [[CopyrightElementHandler]] on DOM element and - optionally - attach to a [[MapView]]
     * instance.
     *
     * @param element HTML DOM element or a HTML DOM element id
     * @param mapView, optional, [[attach]] to this [[MapView]]
     */
    static install(element, mapView) {
        return new CopyrightElementHandler(element, mapView);
    }
    /**
     * Destroys this object by removing all event listeners from the attached [[MapView]]s.
     */
    destroy() {
        for (const mapView of this.m_mapViews) {
            mapView.removeEventListener(MapView_1.MapViewEventNames.CopyrightChanged, this.update);
        }
    }
    /**
     * Attaches this [[CopyrightInfo]] updates from [[MapView]] instance.
     */
    attach(mapView) {
        this.m_mapViews.push(mapView);
        mapView.addEventListener(MapView_1.MapViewEventNames.CopyrightChanged, this.update);
        this.update();
        return this;
    }
    /**
     * Stop following [[CopyrightInfo]] updates from [[MapView]] instance.
     */
    detach(mapView) {
        mapView.removeEventListener(MapView_1.MapViewEventNames.CopyrightChanged, this.update);
        this.m_mapViews = this.m_mapViews.filter(item => item !== mapView);
        this.update();
        return this;
    }
    /**
     * Set [[CopyrightInfo]] defaults to be used in case [[DataSource]] does not provide deatailed
     * copyright information.
     *
     * The defaults will applied to all undefined `year`, `label` and `link` values in the copyright
     * information retrieved from [[MapView]].
     */
    setDefaults(defaults) {
        this.m_defaults.clear();
        if (defaults !== undefined) {
            for (const item of defaults) {
                this.m_defaults.set(item.id, item);
            }
        }
        return this;
    }
    /**
     * Sets the [[staticInfo]] property.
     *
     * A `CopyrightElementHandler` always displays a deduplicated sum of static copyright info and
     * copyright information obtained from attached [[MapView]]s.
     *
     * This information is used when [[DataSource]] instances of given [[MapView]] do not provide
     * copyright information.
     */
    setStaticCopyightInfo(staticInfo) {
        this.staticInfo = staticInfo;
        return this;
    }
}
exports.CopyrightElementHandler = CopyrightElementHandler;


/***/ }),

/***/ "../harp-mapview/lib/copyrights/CopyrightInfo.ts":
/*!*******************************************************!*\
  !*** ../harp-mapview/lib/copyrights/CopyrightInfo.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
var CopyrightInfo;
(function (CopyrightInfo) {
    /**
     * Merge [[CopyrightInfo]] arrays, removing duplicates.
     *
     * `id` and `label` are considered keys in deduplication algorithm.
     *
     * @param sources non-duplicate elements from this array are added to `target`
     * @returns merge of all copyright infos in `sources`
     */
    function mergeArrays(a, b) {
        const result = [];
        for (const source of [a, b]) {
            if (source === undefined) {
                continue;
            }
            for (const sourceInfo of source) {
                const existingInfo = result.find(findItem => findItem.id === sourceInfo.id ||
                    (findItem.label !== undefined && findItem.label === sourceInfo.label));
                if (existingInfo === undefined) {
                    result.push(Object.assign({}, sourceInfo));
                }
                else {
                    existingInfo.year = harp_utils_1.MathUtils.max2(sourceInfo.year, existingInfo.year);
                    existingInfo.label = harp_utils_1.getOptionValue(sourceInfo.label, existingInfo.label);
                    existingInfo.link = harp_utils_1.getOptionValue(sourceInfo.link, existingInfo.link);
                }
            }
        }
        return result;
    }
    CopyrightInfo.mergeArrays = mergeArrays;
    /**
     * Format copyright information to a HTML string that can be displayed in the UI.
     *
     * * Empty list returns empty string.
     * * Entries with empty (but defined) labels are skipped.
     *
     * @param copyrightInfo Array of copyrights to format.
     */
    function formatAsHtml(copyrightInfo) {
        if (copyrightInfo.length === 0) {
            return "";
        }
        const filtered = copyrightInfo.filter(entry => entry.label !== "");
        if (filtered.length === 0) {
            return "";
        }
        return ("© " +
            filtered
                .map(entry => {
                var _a;
                const label = (_a = entry.label, (_a !== null && _a !== void 0 ? _a : entry.id));
                const text = entry.year !== undefined ? `${entry.year} ${label}` : label;
                const link = entry.link;
                return link
                    ? `<a href="${link}" target="_blank" rel="noreferrer noopener">${text}</a>`
                    : `${text}`;
            })
                .join(", "));
    }
    CopyrightInfo.formatAsHtml = formatAsHtml;
})(CopyrightInfo = exports.CopyrightInfo || (exports.CopyrightInfo = {}));


/***/ }),

/***/ "../harp-mapview/lib/copyrights/UrlCopyrightProvider.ts":
/*!**************************************************************!*\
  !*** ../harp-mapview/lib/copyrights/UrlCopyrightProvider.ts ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_transfer_manager_1 = __webpack_require__(/*! @here/harp-transfer-manager */ "../harp-transfer-manager/index.ts");
const CopyrightCoverageProvider_1 = __webpack_require__(/*! ./CopyrightCoverageProvider */ "../harp-mapview/lib/copyrights/CopyrightCoverageProvider.ts");
/**
 * Copyright provider which retrieves copyright coverage information from provided URL.
 */
class UrlCopyrightProvider extends CopyrightCoverageProvider_1.CopyrightCoverageProvider {
    /**
     * Default constructor.
     *
     * @param m_fetchURL URL to fetch copyrights data from.
     * @param m_baseScheme Scheme to get copyrights from.
     */
    constructor(m_fetchURL, m_baseScheme) {
        super();
        this.m_fetchURL = m_fetchURL;
        this.m_baseScheme = m_baseScheme;
    }
    /**
     * @inheritdoc
     * @override
     */
    getCopyrightCoverageData() {
        if (this.m_cachedCopyrightResponse !== undefined) {
            return this.m_cachedCopyrightResponse;
        }
        this.m_cachedCopyrightResponse = new harp_transfer_manager_1.TransferManager()
            .downloadJson(this.m_fetchURL)
            .then(json => json[this.m_baseScheme])
            .catch(error => {
            this.logger.error(error);
            return [];
        });
        return this.m_cachedCopyrightResponse;
    }
}
exports.UrlCopyrightProvider = UrlCopyrightProvider;


/***/ }),

/***/ "../harp-mapview/lib/geometry/PhasedTileGeometryLoader.ts":
/*!****************************************************************!*\
  !*** ../harp-mapview/lib/geometry/PhasedTileGeometryLoader.ts ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const Statistics_1 = __webpack_require__(/*! ../Statistics */ "../harp-mapview/lib/Statistics.ts");
const TileGeometryCreator_1 = __webpack_require__(/*! ./TileGeometryCreator */ "../harp-mapview/lib/geometry/TileGeometryCreator.ts");
const TileGeometryLoader_1 = __webpack_require__(/*! ./TileGeometryLoader */ "../harp-mapview/lib/geometry/TileGeometryLoader.ts");
/**
 * The `PhasedTileGeometryLoader` loads the geometry of a [[Tile]] using a list of [[Phase]]s.
 *
 */
class PhasedTileGeometryLoader {
    /**
     * Creates an instance of PhasedTileGeometryLoader of a [[Tile]]. It stores the phases in which
     * its geometry should be created.
     *
     * @param {Tile} m_tile Tile the loader manages.
     * @param {Phase[]} m_loadPhaseDefinitions The definitions of the loading phases.
     * @param {GeometryKindSet} m_basicGeometryKinds The set of [[GeometryKind]] s that have to be
     *      created before the [[Tile]] is made visible.
     */
    constructor(m_tile, m_loadPhaseDefinitions, m_basicGeometryKinds) {
        this.m_tile = m_tile;
        this.m_loadPhaseDefinitions = m_loadPhaseDefinitions;
        this.m_basicGeometryKinds = m_basicGeometryKinds;
        this.m_isFinished = false;
        this.m_geometryKindsLoaded = new harp_datasource_protocol_1.GeometryKindSet();
        this.m_currentPhaseIndex = 0;
    }
    /**
     * The [[Tile]] this loader is managing.
     */
    get tile() {
        return this.m_tile;
    }
    /**
     * The index into the array of loading phases.
     */
    get currentPhase() {
        return this.m_currentPhaseIndex;
    }
    /**
     * The number of phases defined.
     */
    get numberOfPhases() {
        return this.m_loadPhaseDefinitions.length;
    }
    /**
     * The set of [[GeometryKind]]s already created in this [[Tile]].
     */
    get geometryKindsCreated() {
        return this.m_geometryKindsLoaded;
    }
    /**
     * The set of [[GeometryKind]]s available in this [[Tile]].
     */
    get availableGeometryKinds() {
        return this.m_availableGeometryKinds;
    }
    /**
     * Returns `true` if all basic [[GeometryKind]]s have been loaded. The set of basic
     * [[GeometryKind]]s is defined in the constructor of `PhasedTileGeometryLoader`.
     */
    get basicGeometryLoaded() {
        for (const kind of this.m_basicGeometryKinds) {
            if (!this.m_geometryKindsLoaded.has(kind)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Returns `true` if all [[GeometryKind]]s have been loaded.
     */
    get allGeometryLoaded() {
        return this.currentPhase >= this.m_loadPhaseDefinitions.length;
    }
    /**
     * Set the [[DecodedTile]] of the tile. Is called after the decoded tile has been loaded, and
     * prepares its content for later processing in the 'updateXXX' methods.
     *
     * @param {DecodedTile} decodedTile The decoded tile with the flat geometry data belonging to
     *      this tile.
     * @returns {DecodedTile} The processed decoded tile.
     */
    setDecodedTile(decodedTile) {
        this.m_decodedTile = decodedTile;
        this.m_currentPhaseIndex = 0;
        this.m_geometryKindsLoaded.clear();
        if (this.m_decodedTile !== undefined) {
            this.m_availableGeometryKinds = TileGeometryLoader_1.TileGeometryLoader.prepareDecodedTile(this.m_decodedTile);
        }
        return this.m_decodedTile;
    }
    /**
     * Update the tile to have all the content in its decoded tile. Load phases will be ignored.
     *
     * @param {(GeometryKindSet | undefined)} enabledKinds The [[GeometryKind]]s that should be
     *      enabled.
     * @param {(GeometryKindSet | undefined)} disabledKinds The [[GeometryKind]]s that should be
     *      disabled.
     * @returns {boolean} `true` if actual geometry has been created.
     */
    updateCompletely(enabledKinds, disabledKinds) {
        return this.update(enabledKinds, disabledKinds, true);
    }
    /**
     * Update the tile to the specified phase (index). All intermediate phases between the current
     * and the specified phase will be processed.
     *
     * @param toPhase A value between 0 and `numberOfPhases`.
     * @param {(GeometryKindSet | undefined)} enabledKinds The [[GeometryKind]]s that should be
     *      enabled.
     * @param {(GeometryKindSet | undefined)} disabledKinds The [[GeometryKind]]s that should be
     *      disabled.
     * @returns {boolean} `true` if `updateToPhase` was successful.
     */
    updateToPhase(toPhase, enabledKinds, disabledKinds) {
        let didUpdate = false;
        toPhase = Math.min(toPhase, this.numberOfPhases);
        while (this.currentPhase < toPhase) {
            if (!this.update(enabledKinds, disabledKinds)) {
                break;
            }
            didUpdate = true;
        }
        return didUpdate;
    }
    /**
     * Create all geometries in the current phase, or ignore the phases and create all remaining
     * geometries if `doFullUpdate` is `true`.
     *
     * @param {(GeometryKindSet | undefined)} enabledKinds The [[GeometryKind]]s that should be
     *      enabled.
     * @param {(GeometryKindSet | undefined)} disabledKinds The [[GeometryKind]]s that should be
     *      disabled.
     * @param doFullUpdate If a value of `true` is specified, the current phase is ignored and all
     *      remaining geometries are created.
     * @returns {boolean} `true` if `update` was successful. If `currentPhase` is smaller than
     *      `numberOfPhases`, `update` can be called again. If `false` is returned, another call to
     *      `update` is not required.
     */
    update(enabledKinds, disabledKinds, doFullUpdate = false) {
        const tile = this.tile;
        const loadPhaseDefinitions = this.m_loadPhaseDefinitions;
        if (!tile.dataSource.cacheable) {
            this.m_currentPhaseIndex = loadPhaseDefinitions.length;
            return false;
        }
        let decodedTile = this.m_decodedTile;
        const currentPhase = this.currentPhase;
        // First time this tile is handled:
        if (decodedTile === undefined && tile.decodedTile !== undefined) {
            decodedTile = this.setDecodedTile(tile.decodedTile);
            TileGeometryCreator_1.TileGeometryCreator.instance.processTechniques(tile, enabledKinds, disabledKinds);
            tile.clear();
        }
        if (decodedTile === undefined || currentPhase >= this.numberOfPhases) {
            return false;
        }
        const geometryCreator = TileGeometryCreator_1.TileGeometryCreator.instance;
        const stats = Statistics_1.PerformanceStatistics.instance;
        let now = 0;
        if (stats.enabled) {
            now = harp_utils_1.PerformanceTimer.now();
        }
        if (doFullUpdate) {
            geometryCreator.createAllGeometries(tile, decodedTile);
            // Mark it as finished.
            this.m_currentPhaseIndex = loadPhaseDefinitions.length;
        }
        else {
            const currentPhaseDefinition = loadPhaseDefinitions[currentPhase];
            for (const kind of currentPhaseDefinition) {
                this.createKind(geometryCreator, kind);
            }
        }
        if (stats.enabled) {
            stats.currentFrame.addValue("geometry.geometryCreationTime", harp_utils_1.PerformanceTimer.now() - now);
        }
        if (this.nextPhase() === undefined) {
            // All done, update the stats
            if (stats.enabled) {
                const currentFrame = stats.currentFrame;
                currentFrame.addValue("geometryCount.numGeometries", decodedTile.geometries.length);
                currentFrame.addValue("geometryCount.numTechniques", decodedTile.techniques.length);
                currentFrame.addValue("geometryCount.numPoiGeometries", decodedTile.poiGeometries !== undefined ? decodedTile.poiGeometries.length : 0);
                currentFrame.addValue("geometryCount.numTextGeometries", decodedTile.textGeometries !== undefined ? decodedTile.textGeometries.length : 0);
                currentFrame.addValue("geometryCount.numTextPathGeometries", decodedTile.textPathGeometries !== undefined
                    ? decodedTile.textPathGeometries.length
                    : 0);
                currentFrame.addValue("geometryCount.numPathGeometries", decodedTile.pathGeometries !== undefined ? decodedTile.pathGeometries.length : 0);
                currentFrame.addMessage(`Decoded tile: ${tile.dataSource.name} # lvl=${tile.tileKey.level} ` +
                    `col=${tile.tileKey.column} row=${tile.tileKey.row}`);
            }
            this.finish();
        }
        return true;
    }
    get isFinished() {
        return this.m_isFinished;
    }
    dispose() {
        this.m_decodedTile = undefined;
    }
    reset() {
        this.m_decodedTile = undefined;
        this.m_isFinished = false;
        this.m_availableGeometryKinds = undefined;
        this.m_geometryKindsLoaded.clear();
        this.m_currentPhaseIndex = 0;
    }
    finish() {
        this.m_decodedTile = undefined;
        this.m_tile.loadingFinished();
        this.m_tile.removeDecodedTile();
        this.m_isFinished = true;
    }
    /**
     * Increment the current phase to activate the next phase of geometries.
     *
     * @returns {(number | undefined)} The index into the now active current pase, or `undefined` if
     *      the last phase has been reached.
     */
    nextPhase() {
        if (this.m_currentPhaseIndex < this.m_loadPhaseDefinitions.length) {
            this.m_currentPhaseIndex++;
        }
        return this.m_currentPhaseIndex < this.m_loadPhaseDefinitions.length
            ? this.m_currentPhaseIndex
            : undefined;
    }
    /**
     * Create all geometries of the specified [[GeometryKind]] `kindToCreate`.
     *
     * @param {TileGeometryCreator} geometryCreator
     * @param {GeometryKind} kindToCreate
     */
    createKind(geometryCreator, kindToCreate) {
        if (this.m_geometryKindsLoaded.has(kindToCreate)) {
            return;
        }
        this.m_geometryKindsLoaded.add(kindToCreate);
        const tile = this.tile;
        const decodedTile = this.m_decodedTile;
        if (decodedTile !== undefined) {
            const filter = (technique) => {
                if (technique.enabled === false) {
                    return false;
                }
                const techniqueKind = technique.kind;
                // All kinds are allowed, except those which are explicitly disabled.
                if (kindToCreate === harp_datasource_protocol_1.GeometryKind.All) {
                    return true;
                }
                if (techniqueKind instanceof Set) {
                    const techniqueKinds = techniqueKind;
                    // Check if that technique fits the expected kindToCreate.
                    return techniqueKinds.has(kindToCreate);
                }
                else {
                    return techniqueKind === kindToCreate;
                }
            };
            geometryCreator.createObjects(tile, decodedTile, filter);
            const textFilter = (technique) => {
                if (!harp_datasource_protocol_1.isPoiTechnique(technique) &&
                    !harp_datasource_protocol_1.isLineMarkerTechnique(technique) &&
                    !harp_datasource_protocol_1.isTextTechnique(technique)) {
                    return false;
                }
                return filter(technique);
            };
            // TextElements do not get their geometry created by Tile, but are managed on a
            // higher level.
            geometryCreator.createTextElements(tile, decodedTile, textFilter);
            geometryCreator.preparePois(tile, decodedTile);
        }
    }
}
exports.PhasedTileGeometryLoader = PhasedTileGeometryLoader;


/***/ }),

/***/ "../harp-mapview/lib/geometry/PhasedTileGeometryManager.ts":
/*!*****************************************************************!*\
  !*** ../harp-mapview/lib/geometry/PhasedTileGeometryManager.ts ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const PhasedTileGeometryLoader_1 = __webpack_require__(/*! ./PhasedTileGeometryLoader */ "../harp-mapview/lib/geometry/PhasedTileGeometryLoader.ts");
const TileGeometryManager_1 = __webpack_require__(/*! ./TileGeometryManager */ "../harp-mapview/lib/geometry/TileGeometryManager.ts");
/**
 * The default phases to load geometry.
 */
const DefaultPhases = [
    [harp_datasource_protocol_1.GeometryKind.Background, harp_datasource_protocol_1.GeometryKind.Terrain, harp_datasource_protocol_1.GeometryKind.Area, harp_datasource_protocol_1.GeometryKind.Border],
    [harp_datasource_protocol_1.GeometryKind.Line],
    [harp_datasource_protocol_1.GeometryKind.Building],
    [harp_datasource_protocol_1.GeometryKind.Label],
    [harp_datasource_protocol_1.GeometryKind.All]
];
// FIXME: This should (always) be the first phase, no?
const DefaultBasicGeometryKinds = new harp_datasource_protocol_1.GeometryKindSet(DefaultPhases[0]);
/**
 * Manages the loading of [[Tile]] geometry in phases.
 */
class PhasedTileGeometryManager extends TileGeometryManager_1.TileGeometryManagerBase {
    /**
     * Creates an instance of PhasedTileGeometryManager. Keeps the reference to the [[MapView]].
     *
     * @param {MapView} mapView
     */
    constructor(mapView) {
        super(mapView);
        this.m_maxUpdatedTilePerFrame = 5;
        this.m_loadPhaseDefinitions = DefaultPhases;
        this.m_basicGeometryKinds = DefaultBasicGeometryKinds;
    }
    /** @override */
    initTile(tile) {
        if (tile.dataSource.useGeometryLoader) {
            tile.tileGeometryLoader = new PhasedTileGeometryLoader_1.PhasedTileGeometryLoader(tile, this.m_loadPhaseDefinitions, this.m_basicGeometryKinds);
        }
    }
    /** @override */
    updateTiles(tiles) {
        let needUpdate = this.mapView.isDynamicFrame
            ? this.updateSomeTiles(tiles)
            : this.updateAllTilesTogether(tiles);
        if (this.m_tileUpdateCallback) {
            for (const tile of tiles) {
                this.m_tileUpdateCallback(tile);
            }
        }
        // updateTileObjectVisibility() has always to be called.
        needUpdate = this.updateTileObjectVisibility(tiles) || needUpdate;
        if (needUpdate || !this.checkTilesFinished(tiles)) {
            this.mapView.update();
        }
    }
    checkTilesFinished(tiles) {
        for (const tile of tiles) {
            const phasedGeometryLoader = tile.tileGeometryLoader;
            if (phasedGeometryLoader !== undefined && !phasedGeometryLoader.allGeometryLoaded) {
                return false;
            }
        }
        return true;
    }
    /**
     * Update the tiles during dynamic frames. Number of tiles to update may be limited.
     *
     * @param {Tile[]} tiles
     */
    updateSomeTiles(tiles) {
        let numTilesUpdated = 0;
        for (const tile of tiles) {
            const phasedGeometryLoader = tile.tileGeometryLoader;
            if (phasedGeometryLoader !== undefined) {
                if (phasedGeometryLoader.update(this.enableFilterByKind ? this.enabledGeometryKinds : undefined, this.enableFilterByKind ? this.disabledGeometryKinds : undefined)) {
                    numTilesUpdated++;
                    if (this.m_maxUpdatedTilePerFrame > 0 &&
                        numTilesUpdated >= this.m_maxUpdatedTilePerFrame) {
                        break;
                    }
                }
            }
        }
        return numTilesUpdated > 0;
    }
    /**
     * Update the tiles during static frames. Before advancing to the next phase, any tiles lagging
     * behind are allowed to catch up to their next phase. Only then all tiles will advance to the
     * next phase together.
     *
     * @param {Tile[]} tiles
     */
    updateAllTilesTogether(tiles) {
        let lowestPhase;
        let needUpdate = false;
        for (const tile of tiles) {
            const phasedGeometryLoader = tile.tileGeometryLoader;
            if (phasedGeometryLoader !== undefined &&
                (lowestPhase === undefined || phasedGeometryLoader.currentPhase < lowestPhase)) {
                lowestPhase = phasedGeometryLoader.currentPhase;
            }
        }
        if (lowestPhase !== undefined && lowestPhase < this.m_loadPhaseDefinitions.length) {
            const nextPhase = lowestPhase + 1;
            needUpdate = this.updateTilesIfNeeded(tiles, nextPhase);
        }
        return needUpdate;
    }
    /**
     * Update the tiles during static frames only if their phase is lower than the `toPhase`.
     *
     * @param {Tile[]} tiles
     */
    updateTilesIfNeeded(tiles, toPhase) {
        let needUpdate = false;
        for (const tile of tiles) {
            const phasedGeometryLoader = tile.tileGeometryLoader;
            if (phasedGeometryLoader !== undefined) {
                if (phasedGeometryLoader.updateToPhase(toPhase, this.enableFilterByKind ? this.enabledGeometryKinds : undefined, this.enableFilterByKind ? this.disabledGeometryKinds : undefined)) {
                    needUpdate = true;
                }
            }
        }
        return needUpdate;
    }
}
exports.PhasedTileGeometryManager = PhasedTileGeometryManager;


/***/ }),

/***/ "../harp-mapview/lib/geometry/TileDataAccessor.ts":
/*!********************************************************!*\
  !*** ../harp-mapview/lib/geometry/TileDataAccessor.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const TileGeometry_1 = __webpack_require__(/*! ./TileGeometry */ "../harp-mapview/lib/geometry/TileGeometry.ts");
const logger = harp_utils_1.LoggerManager.instance.create("TileDataAccessor");
/**
 * An accessor for all geometries in a tile. This class uses a client-provided [[ITileDataVisitor]]
 * to visit all objects, based on filtering options specified by both, the `TileDataAccessor` and
 * the visitor itself.
 */
class TileDataAccessor {
    /**
     * Constructs a `TileDataAccessor` instance.
     *
     * @param tile The tile to access.
     * @param visitor The visitor.
     * @param options Options for the tile.
     */
    constructor(tile, visitor, options) {
        this.tile = tile;
        this.visitor = visitor;
        this.m_wantsPoints = true;
        this.m_wantsLines = true;
        this.m_wantsAreas = true;
        this.m_wantsObject3D = true;
        const wantsAll = options.wantsAll === true;
        this.m_wantsPoints = wantsAll || !(options.wantsPoints === false);
        this.m_wantsLines = wantsAll || !(options.wantsLines === false);
        this.m_wantsAreas = wantsAll || !(options.wantsAreas === false);
        this.m_wantsObject3D = wantsAll || !(options.wantsObject3D === false);
    }
    /**
     * Calls the visitor on all objects in the tile.
     */
    visitAll() {
        const objects = this.tile.objects;
        for (const object of objects) {
            this.visitObject(object);
        }
    }
    /**
     * Visits a single object. This function should normally be called during visiting.
     *
     * @param object The object to visit.
     */
    visitObject(object) {
        const featureData = object.userData !== undefined
            ? object.userData.feature
            : undefined;
        // early opt out if there is no feature data, or if the feature data has only a single id
        // and the visitor wants to ignore that featureId
        if (featureData === undefined ||
            (featureData.objInfos !== undefined &&
                featureData.objInfos.length === 1 &&
                !this.visitor.wantsFeature(harp_datasource_protocol_1.getFeatureId(featureData.objInfos[0])))) {
            return;
        }
        const geometryType = featureData.geometryType;
        if (geometryType === undefined) {
            logger.warn("#visitObject: visiting object failed, no geometryType", object);
            return;
        }
        harp_utils_1.assert(featureData.objInfos !== undefined, "featureData.ids missing");
        harp_utils_1.assert(featureData.starts !== undefined, "featureData.starts missing");
        harp_utils_1.assert(Array.isArray(featureData.starts), "featureData.starts is not an array");
        if (featureData.objInfos !== undefined && featureData.starts !== undefined) {
            harp_utils_1.assert(featureData.objInfos.length === featureData.starts.length, "featureData.ids and featureData.starts have unequal length");
        }
        switch (geometryType) {
            case harp_datasource_protocol_1.GeometryType.Point:
            case harp_datasource_protocol_1.GeometryType.Text:
                if (!this.m_wantsPoints) {
                    return;
                }
                break;
            case harp_datasource_protocol_1.GeometryType.SolidLine:
            case harp_datasource_protocol_1.GeometryType.ExtrudedLine:
            case harp_datasource_protocol_1.GeometryType.TextPath:
                if (!this.m_wantsLines) {
                    return;
                }
                break;
            case harp_datasource_protocol_1.GeometryType.Polygon:
            case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:
                if (!this.m_wantsAreas) {
                    return;
                }
                break;
            case harp_datasource_protocol_1.GeometryType.Object3D:
                if (!this.m_wantsObject3D) {
                    return;
                }
                break;
            default:
                logger.warn("#visitObject: invalid geometryType");
        }
        if (object.type !== "Mesh") {
            logger.warn("#visitObject: visiting object failed, not of type 'Mesh'", object);
            return;
        }
        const mesh = object;
        this.visitMesh(mesh, featureData);
    }
    /**
     * Gets the `BufferGeometry` from the specified object. This function requires the
     * attribute `position` in `BufferGeometry` to be set.
     *
     * @param object The object from which to get the geometry.
     * @returns the geometry of the object, or `undefined`.
     */
    getBufferGeometry(object) {
        const geometry = object.geometry;
        if (geometry.type !== "BufferGeometry") {
            logger.warn("#visitObject: object does not have BufferGeometry");
            return undefined;
        }
        const bufferGeometry = geometry;
        // we know its a BufferAttribute because it is a BufferGeometry
        const position = bufferGeometry.getAttribute("position");
        if (!position) {
            logger.warn("#visitLines: BufferGeometry has no position attribute");
            return undefined;
        }
        return bufferGeometry;
    }
    /**
     * Obtains an accessor for the nonindexed geometry. This function may return `undefined`
     * if the accessor is not implemented.
     *
     * @param geometryType The type of geometry.
     * @param object The object for which to access the attributes and geometry.
     * @param bufferGeometry The object's `BufferGeometry`.
     * @returns an accessor for a specified object, if available.
     */
    getGeometryAccessor(geometryType, object, bufferGeometry) {
        switch (geometryType) {
            case harp_datasource_protocol_1.GeometryType.Point:
            case harp_datasource_protocol_1.GeometryType.Text:
                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
                return undefined;
            case harp_datasource_protocol_1.GeometryType.SolidLine:
            case harp_datasource_protocol_1.GeometryType.ExtrudedLine:
            case harp_datasource_protocol_1.GeometryType.TextPath:
                return new TileGeometry_1.BufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
            case harp_datasource_protocol_1.GeometryType.Polygon:
            case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:
                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
                return undefined;
            case harp_datasource_protocol_1.GeometryType.Object3D:
                return new TileGeometry_1.BufferedGeometryObject3dAccessor(object, geometryType, bufferGeometry);
            default:
                logger.warn("#getGeometryAccessor: invalid geometryType");
        }
        return undefined;
    }
    /**
     * Obtains an accessor for the indexed geometry. This function may return `undefined`
     * if the accessor is not implemented.
     *
     * @param geometryType The type of geometry.
     * @param object The object for which to access the attributes and geometry.
     * @param bufferGeometry The object's `BufferGeometry`.
     * @returns an accessor for a specified object, if available.
     */
    getIndexedGeometryAccessor(geometryType, object, bufferGeometry) {
        switch (geometryType) {
            case harp_datasource_protocol_1.GeometryType.Point:
            case harp_datasource_protocol_1.GeometryType.Text:
                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
                return undefined;
            case harp_datasource_protocol_1.GeometryType.SolidLine:
            case harp_datasource_protocol_1.GeometryType.ExtrudedLine:
            case harp_datasource_protocol_1.GeometryType.TextPath:
                return new TileGeometry_1.IndexedBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
            case harp_datasource_protocol_1.GeometryType.Polygon:
            case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:
                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
                return undefined;
            case harp_datasource_protocol_1.GeometryType.Object3D:
                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
                return undefined;
            default:
                logger.warn("#getIndexedGeometryAccessor: invalid geometryType");
        }
        return undefined;
    }
    /**
     * Visit the object.
     *
     * @param meshObject Object of type `Mesh`.
     * @param featureData Dataset stored along with the object.
     */
    visitMesh(meshObject, featureData) {
        const { objInfos, starts } = featureData;
        const geometryType = featureData.geometryType;
        // make linter happy: we already know that these both are valid
        if (objInfos === undefined || starts === undefined || geometryType === undefined) {
            return;
        }
        let geometryAccessor;
        for (let featureIndex = 0; featureIndex < objInfos.length; featureIndex++) {
            const featureId = harp_datasource_protocol_1.getFeatureId(objInfos[featureIndex]);
            if (!this.visitor.wantsFeature(featureId)) {
                continue;
            }
            const featureStart = starts[featureIndex];
            let featureEnd = -1;
            // lazy creation of accessor, in case featureId was not wanted...
            if (geometryAccessor === undefined) {
                const bufferGeometry = this.getBufferGeometry(meshObject);
                if (bufferGeometry === undefined) {
                    continue;
                }
                if (bufferGeometry.index !== null) {
                    geometryAccessor = this.getIndexedGeometryAccessor(geometryType, meshObject, bufferGeometry);
                }
                else {
                    geometryAccessor = this.getGeometryAccessor(geometryType, meshObject, bufferGeometry);
                }
                if (geometryAccessor === undefined) {
                    logger.warn("#visitObject: no accessor geometryType", geometryType);
                    continue;
                }
            }
            featureEnd =
                featureIndex < starts.length - 1
                    ? starts[featureIndex + 1]
                    : geometryAccessor.getCount();
            // setup/update the accessor for the new range of the object
            geometryAccessor.setRange(featureStart, featureEnd);
            switch (geometryType) {
                case harp_datasource_protocol_1.GeometryType.Point:
                case harp_datasource_protocol_1.GeometryType.Text:
                    this.visitor.visitPoint(featureId);
                    break;
                case harp_datasource_protocol_1.GeometryType.SolidLine:
                case harp_datasource_protocol_1.GeometryType.ExtrudedLine:
                case harp_datasource_protocol_1.GeometryType.TextPath:
                    harp_utils_1.assert(TileGeometry_1.isLineAccessor(geometryAccessor));
                    this.visitor.visitLine(featureId, geometryAccessor);
                    break;
                case harp_datasource_protocol_1.GeometryType.Polygon:
                case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:
                    this.visitor.visitArea(featureId);
                    break;
                case harp_datasource_protocol_1.GeometryType.Object3D:
                    harp_utils_1.assert(TileGeometry_1.isObject3dAccessor(geometryAccessor));
                    this.visitor.visitObject3D(featureId, geometryAccessor);
                    break;
                default:
                    logger.warn("#visitObject: invalid geometryType");
            }
        }
    }
}
exports.TileDataAccessor = TileDataAccessor;


/***/ }),

/***/ "../harp-mapview/lib/geometry/TileGeometry.ts":
/*!****************************************************!*\
  !*** ../harp-mapview/lib/geometry/TileGeometry.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_lines_1 = __webpack_require__(/*! @here/harp-lines */ "../harp-lines/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const logger = harp_utils_1.LoggerManager.instance.create("TileGeometry");
/**
 * Helper function to check if an accessor is of type `ILineAccessor`.
 *
 * @param arg `true` if `arg` is `ILineAccessor`.
 */
function isLineAccessor(arg) {
    /**
     * Get vertices from the object.
     *
     * @param mode Specifies which part of the vertices should be returned.
     */
    return typeof arg.isLineAccessor === "function" && arg.isLineAccessor() === true;
}
exports.isLineAccessor = isLineAccessor;
/**
 * Helper function to check if an accessor is of type `IObject3dAccessor`.
 *
 * @param arg `true` if `arg` is `IObject3dAccessor`.
 */
function isObject3dAccessor(arg) {
    return typeof arg.isObject3dAccessor === "function" && arg.isObject3dAccessor() === true;
}
exports.isObject3dAccessor = isObject3dAccessor;
/**
 * Geometry accessor for both indexed and nonindexed `BufferedGeometry`.
 */
class BufferedGeometryAccessorBase {
    constructor(object, geometryType, bufferGeometry) {
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
        this.start = -1;
        this.end = -1;
        this.startCapSize = 0;
        this.endCapSize = 0;
        harp_utils_1.assert(!!object);
        if (bufferGeometry.type !== "BufferGeometry") {
            logger.error("IndexedBufferedGeometryAccessor#constructor: BufferGeometry has wrong " + "type");
        }
        harp_utils_1.assert(bufferGeometry.type === "BufferGeometry", "IndexedBufferedGeometryAccessor#constructor: BufferGeometry has wrong type");
        // we know its a BufferAttribute because it is a BufferGeometry
        this.position = this.bufferGeometry.getAttribute("position");
        this.itemSize = this.position.itemSize;
        if (!this.position) {
            logger.warn("BufferedGeometryAccessor#constructor: BufferGeometry has no position " +
                "attribute");
        }
        if (this.position.array.constructor !== Float32Array) {
            logger.warn("BufferedGeometryAccessor#constructor: BufferGeometry.position: " +
                "unsupported ArrayBuffer");
        }
    }
    /**
     * Get the number of accessible geometries in this buffer.
     *
     * @returns Number of primitives in this geometry.
     */
    getCount() {
        return this.position.count;
    }
    /**
     * Get `renderOrder` of object.
     *
     * @returns `renderOrder` of the object.
     */
    get renderOrder() {
        return this.object.renderOrder;
    }
    setRange(start, end, startCapSize = 0, endCapSize = 0) {
        harp_utils_1.assert(start >= 0);
        harp_utils_1.assert(end >= 0);
        harp_utils_1.assert(start <= end);
        this.start = start;
        this.end = end;
        this.startCapSize = startCapSize;
        this.endCapSize = endCapSize;
    }
    /**
     * Get one or more colors from materials.
     */
    get color() {
        /**
         * TODO: Get color(s) from vertex colors
         */
        const getColor = (material) => {
            const meshMaterial = material;
            if (meshMaterial.type === "MeshBasicMaterial" ||
                meshMaterial.type === "MeshStandardMaterial") {
                return meshMaterial.color;
            }
            else if (meshMaterial.type === "RawShaderMaterial") {
                const rawShaderMaterial = material;
                if (rawShaderMaterial.name === "SolidLineMaterial") {
                    return rawShaderMaterial.uniforms.diffuse.value;
                }
                logger.warn("BufferedGeometryAccessor#color: unknown shader material name", rawShaderMaterial.name);
            }
            else {
                logger.warn("BufferedGeometryAccessor#color: unknown material type", meshMaterial.type);
            }
            return undefined;
        };
        if (Array.isArray(this.object.material)) {
            const results = new Array();
            const materials = this.object.material;
            for (const material of materials) {
                results.push(getColor(material));
            }
            return results;
        }
        else {
            return getColor(this.object.material);
        }
    }
}
exports.BufferedGeometryAccessorBase = BufferedGeometryAccessorBase;
/**
 * Abstract base class of an accessor for nonindexed geometry.
 */
class BufferedGeometryAccessor extends BufferedGeometryAccessorBase {
    /**
     * Create an object of type `BufferedGeometryAccessor`
     *
     * @param object - mesh object
     * @param geometryType - type of geometry to be used
     * @param bufferGeometry - which buffer geometry to use
     * @param stride - geometry stride length
     */
    constructor(object, geometryType, bufferGeometry, stride) {
        super(object, geometryType, bufferGeometry);
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
        this.stride = stride;
    }
    clear() {
        harp_utils_1.assert(this.checkSetUp(), "BufferedGeometryAccessor not setup");
        const positionsArray = this.position.array;
        const start = this.start * this.itemSize;
        const end = this.end * this.itemSize;
        for (let i = start; i < end; i++) {
            positionsArray[i] = 0;
        }
        this.position.needsUpdate = true;
    }
    getVertices() {
        harp_utils_1.assert(this.checkSetUp(), "BufferedGeometryAccessor not setup");
        const start = this.start;
        const end = this.end;
        return this.position.array.subarray(start * this.itemSize, end * this.itemSize);
    }
    checkSetUp() {
        return (this.position !== undefined &&
            this.start !== undefined &&
            this.end !== undefined &&
            this.start >= 0 &&
            this.end <= this.position.count &&
            this.start <= this.end);
    }
}
exports.BufferedGeometryAccessor = BufferedGeometryAccessor;
/**
 * Accessor for nonindexed line geometry.
 */
class BufferedGeometryLineAccessor extends BufferedGeometryAccessor {
    constructor(object, geometryType, bufferGeometry) {
        super(object, geometryType, bufferGeometry, 3);
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
    }
    isLineAccessor() {
        return true;
    }
    get width() {
        //TODO: There is no implementation of such a line, yet...
        harp_utils_1.assert(this.checkSetUp(), "RoBufferedGeometryLineAccessor not setup");
        return undefined;
    }
}
exports.BufferedGeometryLineAccessor = BufferedGeometryLineAccessor;
/**
 * Accessor for nonindexed unspecified (`Object3D`) geometry.
 */
class BufferedGeometryObject3dAccessor extends BufferedGeometryAccessor {
    constructor(object, geometryType, bufferGeometry) {
        super(object, geometryType, bufferGeometry, 1);
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
    }
    isObject3dAccessor() {
        return true;
    }
    /** @override */
    getVertices() {
        return super.getVertices();
    }
}
exports.BufferedGeometryObject3dAccessor = BufferedGeometryObject3dAccessor;
/**
 * Abstract base class of indexed geometry.
 */
class IndexedBufferedGeometryAccessor extends BufferedGeometryAccessorBase {
    /**
     * Creates an abstract class `IndexedBufferedGeometryAccessor`.
     *
     * @param object - mesh to be used
     * @param geometryType - type of geometry
     * @param bufferGeometry - geometry used
     * @param start
     * @param end
     */
    constructor(object, geometryType, bufferGeometry, 
    // tslint:disable-next-line:no-unused-variable
    start, 
    // tslint:disable-next-line:no-unused-variable
    end) {
        super(object, geometryType, bufferGeometry);
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
        this.indices =
            this.bufferGeometry.index !== null
                ? this.bufferGeometry.index.array
                : undefined;
        if (!this.indices) {
            logger.warn("IndexedBufferedGeometryAccessor#constructor: BufferGeometry has no " + "index");
            harp_utils_1.assert(!!this.indices);
        }
        else {
            if (!(this.indices instanceof Uint32Array)) {
                logger.warn("IndexedBufferedGeometryAccessor#constructor: BufferGeometry index " +
                    "has wrong type");
                harp_utils_1.assert(this.indices instanceof Uint32Array);
            }
        }
    }
    /**
     * Returns number of primitives, which is not known in this base class, so we return the number
     * of indices.
     *
     * @returns The number of indices in the geometry.
     * @override
     */
    getCount() {
        return this.indices.length;
    }
    checkSetUp() {
        return (!!this.indices &&
            this.start !== undefined &&
            this.end !== undefined &&
            this.start >= 0 &&
            this.end <= this.indices.length &&
            this.start <= this.end);
    }
}
exports.IndexedBufferedGeometryAccessor = IndexedBufferedGeometryAccessor;
/**
 * Accessor for lines in an indexed geometry.
 */
class IndexedBufferedGeometryLineAccessor extends IndexedBufferedGeometryAccessor {
    constructor(object, geometryType, bufferGeometry) {
        super(object, geometryType, bufferGeometry, 3);
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
    }
    isLineAccessor() {
        return true;
    }
    /**
     * Reconstructs line width from triangulated geometry.
     *
     * @returns Line width.
     */
    get width() {
        harp_utils_1.assert(this.checkSetUp(), "RoIndexedBufferedGeometryLineAccessor not setup");
        if (this.geometryType === harp_datasource_protocol_1.GeometryType.ExtrudedLine) {
            const start = this.start + this.startCapSize;
            const positionArray = this.position.array;
            return harp_lines_1.reconstructLineWidth(positionArray, start);
        }
        return undefined;
    }
    clear() {
        harp_utils_1.assert(this.checkSetUp(), "RoIndexedBufferedGeometryLineAccessor not setup");
        const start = this.start;
        const end = this.end;
        for (let i = start; i < end; i++) {
            this.indices[i] = 0;
        }
        if (this.bufferGeometry.index !== null) {
            this.bufferGeometry.index.needsUpdate = true;
        }
    }
    getVertices() {
        harp_utils_1.assert(this.checkSetUp(), "RoIndexedBufferedGeometryLineAccessor not setup");
        const itemSize = this.itemSize;
        const start = this.start;
        const end = this.end;
        const result = new Float32Array((end - start) * itemSize);
        const positionArray = this.position.array;
        if (itemSize === 2) {
            for (let i = start, j = 0; i < end; i++, j += itemSize) {
                const index = this.indices[i];
                result[j + 0] = positionArray[index * itemSize + 0];
                result[j + 1] = positionArray[index * itemSize + 1];
            }
        }
        if (itemSize === 3) {
            for (let i = start, j = 0; i < end; i++, j += itemSize) {
                const index = this.indices[i];
                result[j + 0] = positionArray[index * itemSize + 0];
                result[j + 1] = positionArray[index * itemSize + 1];
                result[j + 2] = positionArray[index * itemSize + 2];
            }
        }
        else {
            for (let i = start, j = 0; i < end; i++, j++) {
                const index = this.indices[i];
                for (let k = 0; k < itemSize; k++) {
                    result[j * itemSize + k] = positionArray[index * itemSize + k];
                }
            }
        }
        return result;
    }
}
exports.IndexedBufferedGeometryLineAccessor = IndexedBufferedGeometryLineAccessor;


/***/ }),

/***/ "../harp-mapview/lib/geometry/TileGeometryCreator.ts":
/*!***********************************************************!*\
  !*** ../harp-mapview/lib/geometry/TileGeometryCreator.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
// tslint:disable:max-line-length
const SphericalGeometrySubdivisionModifier_1 = __webpack_require__(/*! @here/harp-geometry/lib/SphericalGeometrySubdivisionModifier */ "../harp-geometry/lib/SphericalGeometrySubdivisionModifier.ts");
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "../harp-text-canvas/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const THREE = __webpack_require__(/*! three */ "three");
const AnimatedExtrusionHandler_1 = __webpack_require__(/*! ../AnimatedExtrusionHandler */ "../harp-mapview/lib/AnimatedExtrusionHandler.ts");
const DecodedTileHelpers_1 = __webpack_require__(/*! ../DecodedTileHelpers */ "../harp-mapview/lib/DecodedTileHelpers.ts");
const DepthPrePass_1 = __webpack_require__(/*! ../DepthPrePass */ "../harp-mapview/lib/DepthPrePass.ts");
const MapView_1 = __webpack_require__(/*! ../MapView */ "../harp-mapview/lib/MapView.ts");
const PathBlockingElement_1 = __webpack_require__(/*! ../PathBlockingElement */ "../harp-mapview/lib/PathBlockingElement.ts");
const TextElement_1 = __webpack_require__(/*! ../text/TextElement */ "../harp-mapview/lib/text/TextElement.ts");
const TextElementsRenderer_1 = __webpack_require__(/*! ../text/TextElementsRenderer */ "../harp-mapview/lib/text/TextElementsRenderer.ts");
const TileGeometryLoader_1 = __webpack_require__(/*! ./TileGeometryLoader */ "../harp-mapview/lib/geometry/TileGeometryLoader.ts");
const logger = harp_utils_1.LoggerManager.instance.create("TileGeometryCreator");
const tmpVector3 = new THREE.Vector3();
const tmpVector2 = new THREE.Vector2();
/**
 * Support class to create geometry for a [[Tile]] from a [[DecodedTile]].
 */
class TileGeometryCreator {
    /**
     *  Creates an instance of TileGeometryCreator. Access is allowed only through `instance`.
     */
    constructor() {
        //
    }
    /**
     * The `instance` of the `TileGeometryCreator`.
     *
     * @returns TileGeometryCreator
     */
    static get instance() {
        return this.m_instance || (this.m_instance = new TileGeometryCreator());
    }
    /**
     * Apply `enabledKinds` and `disabledKinds` to all techniques in the `decodedTile`. If a
     * technique is identified as disabled, its property `enabled` is set to `false`.
     *
     * @param decodedTile The decodedTile containing the actual tile map data.
     * @param enabledKinds Optional [[GeometryKindSet]] used to specify which object kinds should be
     *      created.
     * @param disabledKinds Optional [[GeometryKindSet]] used to filter objects that should not be
     *      created.
     */
    initDecodedTile(decodedTile, enabledKinds, disabledKinds) {
        for (const technique of decodedTile.techniques) {
            // Already processed
            if (technique.enabled !== undefined) {
                continue;
            }
            // Turn technique.kind from the style, which may be a string or an array of strings,
            // into a GeometryKindSet.
            if (technique.kind !== undefined) {
                if (Array.isArray(technique.kind)) {
                    technique.kind = new harp_datasource_protocol_1.GeometryKindSet(technique.kind);
                }
                else if (typeof technique.kind !== "string") {
                    logger.warn("Technique has unknown type of kind:", technique);
                    technique.kind = undefined;
                }
            }
            // No info about kind, no way to filter it.
            if (technique.kind === undefined ||
                (technique.kind instanceof Set && technique.kind.size === 0)) {
                technique.enabled = true;
                continue;
            }
            // Technique is enabled only if enabledKinds is defined and technique belongs to that set or
            // if that's not the case, disabledKinds must be undefined or technique does not belong to it.
            technique.enabled =
                !(disabledKinds !== undefined && disabledKinds.hasOrIntersects(technique.kind)) ||
                    (enabledKinds !== undefined && enabledKinds.hasOrIntersects(technique.kind));
        }
        for (const srcGeometry of decodedTile.geometries) {
            for (const group of srcGeometry.groups) {
                group.createdOffsets = [];
            }
        }
        // compile the dynamic expressions.
        DecodedTileHelpers_1.compileTechniques(decodedTile.techniques);
    }
    /**
     * Called after the `Tile` has been decoded. It is required to call `initDecodedTile` before
     * calling this method.
     *
     * @see [[TileGeometryCreator#initDecodedTile]]
     *
     * @param tile The [[Tile]] to process.
     * @param decodedTile The decodedTile containing the actual tile map data.
     */
    createAllGeometries(tile, decodedTile) {
        const filter = (technique) => {
            return technique.enabled !== false;
        };
        if (decodedTile.maxGeometryHeight !== undefined) {
            tile.maxGeometryHeight = decodedTile.maxGeometryHeight;
        }
        this.createObjects(tile, decodedTile, filter);
        this.preparePois(tile, decodedTile);
        // TextElements do not get their geometry created by Tile, but are managed on a
        // higher level.
        const textFilter = (technique) => {
            if (!harp_datasource_protocol_1.isPoiTechnique(technique) &&
                !harp_datasource_protocol_1.isLineMarkerTechnique(technique) &&
                !harp_datasource_protocol_1.isTextTechnique(technique)) {
                return false;
            }
            return filter(technique);
        };
        this.createTextElements(tile, decodedTile, textFilter);
        this.createLabelRejectionElements(tile, decodedTile);
        // HARP-7899, disable ground plane for globe
        if (tile.dataSource.addGroundPlane && tile.projection.type === harp_geoutils_1.ProjectionType.Planar) {
            // The ground plane is required for when we change the zoom back and we fall back to the
            // parent, in that case we reduce the renderOrder of the parent tile and this ground
            // place ensures that parent doesn't come through. This value must be above the
            // renderOrder of all objects in the fallback tile, otherwise there won't be a proper
            // covering of the parent tile by the children, hence dividing by 2. To put a bit more
            // concretely, we assume all objects are rendered with a renderOrder between 0 and
            // FALLBACK_RENDER_ORDER_OFFSET / 2, i.e. 10000. The ground plane is put at -10000, and
            // the fallback tiles have their renderOrder set between -20000 and -10000
            TileGeometryCreator.instance.addGroundPlane(tile, -MapView_1.FALLBACK_RENDER_ORDER_OFFSET / 2);
        }
    }
    createLabelRejectionElements(tile, decodedTile) {
        if (decodedTile.pathGeometries === undefined) {
            return;
        }
        for (const path of decodedTile.pathGeometries) {
            tile.addBlockingElement(new PathBlockingElement_1.PathBlockingElement(path.path));
        }
    }
    /**
     * Processes the given tile and assign default values for geometry kinds,
     * render orders and label priorities.
     *
     * @param {Tile} tile
     * @param {(GeometryKindSet | undefined)} enabledKinds
     * @param {(GeometryKindSet | undefined)} disabledKinds
     */
    processTechniques(tile, enabledKinds, disabledKinds) {
        const decodedTile = tile.decodedTile;
        if (decodedTile === undefined) {
            return;
        }
        this.processPriorities(tile);
        for (const technique of decodedTile.techniques) {
            // Make sure that all technique have their geometryKind set, either from the Theme or
            // their default value.
            if (technique.kind === undefined) {
                TileGeometryLoader_1.TileGeometryLoader.setDefaultGeometryKind(technique);
            }
        }
        // Speedup and simplify following code: Test all techniques if they intersect with
        // enabledKinds and disabledKinds, in which case they are flagged. The disabledKinds can be
        // ignored hereafter.
        this.initDecodedTile(decodedTile, enabledKinds, disabledKinds);
    }
    /**
     * Adds a THREE object to the root of the tile. Sets the owning tiles datasource.name and the
     * tileKey in the `userData` property of the object, such that the tile it belongs to can be
     * identified during picking.
     *
     * @param tile The [[Tile]] to add the object to.
     * @param object The object to add to the root of the tile.
     * @param geometryKind The kind of object. Can be used for filtering.
     */
    registerTileObject(tile, object, geometryKind) {
        if (object.userData === undefined) {
            object.userData = {};
        }
        const userData = object.userData;
        userData.tileKey = tile.tileKey;
        userData.dataSource = tile.dataSource.name;
        userData.kind =
            geometryKind instanceof Set
                ? Array.from(geometryKind.values())
                : Array.isArray(geometryKind)
                    ? geometryKind
                    : [geometryKind];
        // Force a visibility check of all objects.
        tile.resetVisibilityCounter();
    }
    /**
     * Splits the text paths that contain sharp corners.
     *
     * @param tile The [[Tile]] to process paths on.
     * @param textPathGeometries The original path geometries that may have defects.
     * @param textFilter: Optional filter. Should return true for any text technique that is
     *      applicable.
     */
    prepareTextPaths(textPathGeometries, decodedTile, textFilter) {
        const processedPaths = new Array();
        const newPaths = textPathGeometries.slice();
        while (newPaths.length > 0) {
            const textPath = newPaths.pop();
            if (textPath === undefined) {
                break;
            }
            const technique = decodedTile.techniques[textPath.technique];
            if (!harp_datasource_protocol_1.isTextTechnique(technique) ||
                (textFilter !== undefined && !textFilter(technique))) {
                continue;
            }
            processedPaths.push(textPath);
        }
        return processedPaths;
    }
    /**
     * Creates [[TextElement]] objects from the decoded tile and list of materials specified. The
     * priorities of the [[TextElement]]s are updated to simplify label placement.
     *
     * @param tile The [[Tile]] to create the testElements on.
     * @param decodedTile The [[DecodedTile]].
     * @param textFilter: Optional filter. Should return true for any text technique that is
     *      applicable.
     */
    createTextElements(tile, decodedTile, textFilter) {
        const mapView = tile.mapView;
        const textElementsRenderer = mapView.textElementsRenderer;
        const worldOffsetX = tile.computeWorldOffsetX();
        const discreteZoomLevel = Math.floor(mapView.zoomLevel);
        const discreteZoomEnv = new harp_datasource_protocol_1.MapEnv({ $zoom: discreteZoomLevel }, mapView.env);
        if (decodedTile.textPathGeometries !== undefined) {
            const textPathGeometries = this.prepareTextPaths(decodedTile.textPathGeometries, decodedTile, textFilter);
            for (const textPath of textPathGeometries) {
                const technique = decodedTile.techniques[textPath.technique];
                if (technique.enabled === false ||
                    !harp_datasource_protocol_1.isTextTechnique(technique) ||
                    (textFilter !== undefined && !textFilter(technique))) {
                    continue;
                }
                const path = [];
                for (let i = 0; i < textPath.path.length; i += 3) {
                    path.push(new THREE.Vector3(textPath.path[i] + worldOffsetX, textPath.path[i + 1], textPath.path[i + 2]));
                }
                // Make sorting stable.
                const priority = technique.priority !== undefined
                    ? harp_datasource_protocol_1.getPropertyValue(technique.priority, discreteZoomEnv)
                    : 0;
                const fadeNear = technique.fadeNear !== undefined
                    ? harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, discreteZoomEnv)
                    : technique.fadeNear;
                const fadeFar = technique.fadeFar !== undefined
                    ? harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, discreteZoomEnv)
                    : technique.fadeFar;
                const userData = textPath.objInfos;
                const featureId = harp_datasource_protocol_1.getFeatureId(userData);
                const textElement = new TextElement_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(textPath.text), path, textElementsRenderer.styleCache.getRenderStyle(tile, technique), textElementsRenderer.styleCache.getLayoutStyle(tile, technique), priority, technique.xOffset !== undefined ? technique.xOffset : 0.0, technique.yOffset !== undefined ? technique.yOffset : 0.0, featureId, technique.style, fadeNear, fadeFar, tile.offset);
                textElement.pathLengthSqr = textPath.pathLengthSqr;
                textElement.minZoomLevel =
                    technique.minZoomLevel !== undefined
                        ? technique.minZoomLevel
                        : mapView.minZoomLevel;
                textElement.maxZoomLevel =
                    technique.maxZoomLevel !== undefined
                        ? technique.maxZoomLevel
                        : mapView.maxZoomLevel;
                textElement.distanceScale =
                    technique.distanceScale !== undefined
                        ? technique.distanceScale
                        : TextElementsRenderer_1.DEFAULT_TEXT_DISTANCE_SCALE;
                textElement.mayOverlap = technique.mayOverlap === true;
                textElement.reserveSpace = technique.reserveSpace !== false;
                textElement.kind = technique.kind;
                // Get the userData for text element picking.
                textElement.userData = textPath.objInfos;
                tile.addTextElement(textElement);
            }
        }
        if (decodedTile.textGeometries !== undefined) {
            for (const text of decodedTile.textGeometries) {
                if (text.technique === undefined || text.stringCatalog === undefined) {
                    continue;
                }
                const technique = decodedTile.techniques[text.technique];
                if (technique.enabled === false ||
                    !harp_datasource_protocol_1.isTextTechnique(technique) ||
                    (textFilter !== undefined && !textFilter(technique))) {
                    continue;
                }
                const positions = new THREE.BufferAttribute(new Float32Array(text.positions.buffer), text.positions.itemCount);
                const numPositions = positions.count;
                if (numPositions < 1) {
                    continue;
                }
                const priority = technique.priority !== undefined
                    ? harp_datasource_protocol_1.getPropertyValue(technique.priority, discreteZoomEnv)
                    : 0;
                const fadeNear = technique.fadeNear !== undefined
                    ? harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, discreteZoomEnv)
                    : technique.fadeNear;
                const fadeFar = technique.fadeFar !== undefined
                    ? harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, discreteZoomEnv)
                    : technique.fadeFar;
                for (let i = 0; i < numPositions; ++i) {
                    const x = positions.getX(i) + worldOffsetX;
                    const y = positions.getY(i);
                    const z = positions.getZ(i);
                    const label = text.stringCatalog[text.texts[i]];
                    if (label === undefined) {
                        // skip missing labels
                        continue;
                    }
                    const userData = text.objInfos !== undefined ? text.objInfos[i] : undefined;
                    const featureId = harp_datasource_protocol_1.getFeatureId(userData);
                    const textElement = new TextElement_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(label), new THREE.Vector3(x, y, z), textElementsRenderer.styleCache.getRenderStyle(tile, technique), textElementsRenderer.styleCache.getLayoutStyle(tile, technique), priority, technique.xOffset || 0.0, technique.yOffset || 0.0, featureId, technique.style, undefined, undefined, tile.offset);
                    textElement.minZoomLevel =
                        technique.minZoomLevel !== undefined
                            ? technique.minZoomLevel
                            : mapView.minZoomLevel;
                    textElement.maxZoomLevel =
                        technique.maxZoomLevel !== undefined
                            ? technique.maxZoomLevel
                            : mapView.maxZoomLevel;
                    textElement.mayOverlap = technique.mayOverlap === true;
                    textElement.reserveSpace = technique.reserveSpace !== false;
                    textElement.kind = technique.kind;
                    textElement.fadeNear = fadeNear;
                    textElement.fadeFar = fadeFar;
                    // Get the userData for text element picking.
                    textElement.userData = userData;
                    tile.addTextElement(textElement);
                }
            }
        }
    }
    /**
     * Creates `Tile` objects from the decoded tile and list of materials specified.
     *
     * @param tile The [[Tile]] to create the geometry on.
     * @param decodedTile The [[DecodedTile]].
     * @param techniqueFilter: Optional filter. Should return true for any technique that is
     *      applicable.
     */
    createObjects(tile, decodedTile, techniqueFilter) {
        var _a;
        const materials = [];
        const mapView = tile.mapView;
        const dataSource = tile.dataSource;
        const discreteZoomLevel = Math.floor(mapView.zoomLevel);
        const discreteZoomEnv = new harp_datasource_protocol_1.MapEnv({ $zoom: discreteZoomLevel }, mapView.env);
        const objects = tile.objects;
        const viewRanges = mapView.viewRanges;
        for (const srcGeometry of decodedTile.geometries) {
            const groups = srcGeometry.groups;
            const groupCount = groups.length;
            for (let groupIndex = 0; groupIndex < groupCount;) {
                const group = groups[groupIndex++];
                const start = group.start;
                const techniqueIndex = group.technique;
                const technique = decodedTile.techniques[techniqueIndex];
                if (group.createdOffsets.indexOf(tile.offset) !== -1 ||
                    technique.enabled === false ||
                    (techniqueFilter !== undefined && !techniqueFilter(technique))) {
                    continue;
                }
                let count = group.count;
                group.createdOffsets.push(tile.offset);
                // compress consecutive groups
                for (; groupIndex < groupCount && groups[groupIndex].technique === techniqueIndex; ++groupIndex) {
                    if (start + count !== groups[groupIndex].start) {
                        break;
                    }
                    count += groups[groupIndex].count;
                    // Mark this group as created, so it does not get processed again.
                    groups[groupIndex].createdOffsets.push(tile.offset);
                }
                const ObjectCtor = DecodedTileHelpers_1.getObjectConstructor(technique);
                if (ObjectCtor === undefined) {
                    continue;
                }
                let material = materials[techniqueIndex];
                if (material === undefined) {
                    const onMaterialUpdated = (texture) => {
                        dataSource.requestUpdate();
                        if (texture !== undefined) {
                            tile.addOwnedTexture(texture);
                        }
                    };
                    material = DecodedTileHelpers_1.createMaterial({
                        technique,
                        env: mapView.env,
                        fog: mapView.scene.fog !== null
                    }, onMaterialUpdated);
                    if (material === undefined) {
                        continue;
                    }
                    materials[techniqueIndex] = material;
                }
                // Modify the standard textured shader to support height-based coloring.
                if (harp_datasource_protocol_1.isTerrainTechnique(technique)) {
                    this.setupTerrainMaterial(technique, material, tile.mapView.clearColor);
                }
                const bufferGeometry = new THREE.BufferGeometry();
                srcGeometry.vertexAttributes.forEach((vertexAttribute) => {
                    const buffer = DecodedTileHelpers_1.getBufferAttribute(vertexAttribute);
                    bufferGeometry.setAttribute(vertexAttribute.name, buffer);
                });
                if (srcGeometry.interleavedVertexAttributes !== undefined) {
                    srcGeometry.interleavedVertexAttributes.forEach((attr) => {
                        const ArrayCtor = harp_datasource_protocol_1.getArrayConstructor(attr.type);
                        const buffer = new THREE.InterleavedBuffer(new ArrayCtor(attr.buffer), attr.stride);
                        attr.attributes.forEach((interleavedAttr) => {
                            const attribute = new THREE.InterleavedBufferAttribute(buffer, interleavedAttr.itemSize, interleavedAttr.offset, false);
                            bufferGeometry.setAttribute(interleavedAttr.name, attribute);
                        });
                    });
                }
                if (srcGeometry.index) {
                    bufferGeometry.setIndex(DecodedTileHelpers_1.getBufferAttribute(srcGeometry.index));
                }
                if (!bufferGeometry.getAttribute("normal") && harp_datasource_protocol_1.needsVertexNormals(technique)) {
                    bufferGeometry.computeVertexNormals();
                }
                bufferGeometry.addGroup(start, count);
                if (harp_datasource_protocol_1.isSolidLineTechnique(technique)) {
                    // TODO: Unify access to shader defines via SolidLineMaterial setters
                    harp_utils_1.assert(!harp_materials_1.isHighPrecisionLineMaterial(material));
                    const lineMaterial = material;
                    if (technique.clipping !== false &&
                        tile.projection.type === harp_geoutils_1.ProjectionType.Planar) {
                        tile.boundingBox.getSize(tmpVector3);
                        tmpVector2.set(tmpVector3.x, tmpVector3.y);
                        lineMaterial.clipTileSize = tmpVector2;
                    }
                    if (bufferGeometry.getAttribute("color")) {
                        harp_materials_1.setShaderMaterialDefine(lineMaterial, "USE_COLOR", true);
                    }
                }
                // Add the solid line outlines as a separate object.
                const hasSolidLinesOutlines = harp_datasource_protocol_1.isSolidLineTechnique(technique) && technique.secondaryWidth !== undefined;
                const object = new ObjectCtor(bufferGeometry, material);
                object.renderOrder = technique.renderOrder;
                if (group.renderOrderOffset !== undefined) {
                    object.renderOrder += group.renderOrderOffset;
                }
                if (srcGeometry.uuid !== undefined) {
                    object.userData.geometryId = srcGeometry.uuid;
                }
                if ((harp_datasource_protocol_1.isCirclesTechnique(technique) || harp_datasource_protocol_1.isSquaresTechnique(technique)) &&
                    technique.enablePicking !== undefined) {
                    // tslint:disable-next-line:max-line-length
                    object.enableRayTesting = technique.enablePicking;
                }
                if (harp_datasource_protocol_1.isLineTechnique(technique) || harp_datasource_protocol_1.isSegmentsTechnique(technique)) {
                    const hasDynamicColor = harp_datasource_protocol_1.Expr.isExpr(technique.color) || harp_datasource_protocol_1.Expr.isExpr(technique.opacity);
                    const fadingParams = this.getFadingParams(discreteZoomEnv, technique);
                    harp_materials_1.FadingFeature.addRenderHelper(object, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, false, hasDynamicColor
                        ? (renderer, mat) => {
                            const lineMaterial = mat;
                            DecodedTileHelpers_1.applyBaseColorToMaterial(lineMaterial, lineMaterial.color, technique, technique.color, mapView.env);
                        }
                        : undefined);
                }
                if (harp_datasource_protocol_1.isSolidLineTechnique(technique)) {
                    const hasDynamicColor = harp_datasource_protocol_1.Expr.isExpr(technique.color) || harp_datasource_protocol_1.Expr.isExpr(technique.opacity);
                    const fadingParams = this.getFadingParams(discreteZoomEnv, technique);
                    harp_materials_1.FadingFeature.addRenderHelper(object, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, false, (renderer, mat) => {
                        const lineMaterial = mat;
                        const unitFactor = technique.metricUnit === "Pixel" ? mapView.pixelToWorld : 1.0;
                        if (hasDynamicColor) {
                            DecodedTileHelpers_1.applyBaseColorToMaterial(lineMaterial, lineMaterial.color, technique, technique.color, mapView.env);
                        }
                        lineMaterial.lineWidth =
                            harp_datasource_protocol_1.getPropertyValue(technique.lineWidth, mapView.env) *
                                unitFactor *
                                0.5;
                        if (technique.outlineWidth !== undefined) {
                            lineMaterial.outlineWidth =
                                harp_datasource_protocol_1.getPropertyValue(technique.outlineWidth, mapView.env) *
                                    unitFactor;
                        }
                        if (technique.dashSize !== undefined) {
                            lineMaterial.dashSize =
                                harp_datasource_protocol_1.getPropertyValue(technique.dashSize, mapView.env) *
                                    unitFactor *
                                    0.5;
                        }
                        if (technique.gapSize !== undefined) {
                            lineMaterial.gapSize =
                                harp_datasource_protocol_1.getPropertyValue(technique.gapSize, mapView.env) *
                                    unitFactor *
                                    0.5;
                        }
                    });
                }
                if (harp_datasource_protocol_1.isExtrudedLineTechnique(technique)) {
                    const hasDynamicColor = harp_datasource_protocol_1.Expr.isExpr(technique.color) || harp_datasource_protocol_1.Expr.isExpr(technique.opacity);
                    // extruded lines are normal meshes, and need transparency only when fading or
                    // dynamic properties is defined.
                    if (technique.fadeFar !== undefined || hasDynamicColor) {
                        const fadingParams = this.getFadingParams(mapView.env, technique);
                        harp_materials_1.FadingFeature.addRenderHelper(object, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, true, hasDynamicColor
                            ? (renderer, mat) => {
                                const extrudedMaterial = mat;
                                DecodedTileHelpers_1.applyBaseColorToMaterial(extrudedMaterial, extrudedMaterial.color, technique, technique.color, mapView.env);
                            }
                            : undefined);
                    }
                }
                this.addUserData(tile, srcGeometry, technique, object);
                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) || harp_datasource_protocol_1.isFillTechnique(technique)) {
                    // filled polygons are normal meshes, and need transparency only when fading or
                    // dynamic properties is defined.
                    const hasDynamicPrimaryColor = harp_datasource_protocol_1.Expr.isExpr(technique.color) || harp_datasource_protocol_1.Expr.isExpr(technique.opacity);
                    const hasDynamicSecondaryColor = harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) && harp_datasource_protocol_1.Expr.isExpr(technique.emissive);
                    const hasDynamicColor = hasDynamicPrimaryColor || hasDynamicSecondaryColor;
                    if (technique.fadeFar !== undefined || hasDynamicColor) {
                        const fadingParams = this.getFadingParams(discreteZoomEnv, technique);
                        harp_materials_1.FadingFeature.addRenderHelper(object, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, true, hasDynamicColor
                            ? (renderer, mat) => {
                                const polygonMaterial = mat;
                                if (hasDynamicPrimaryColor) {
                                    DecodedTileHelpers_1.applyBaseColorToMaterial(polygonMaterial, polygonMaterial.color, technique, technique.color, mapView.env);
                                }
                                if (hasDynamicSecondaryColor &&
                                    // Just to omit compiler warnings
                                    harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {
                                    const standardMat = mat;
                                    DecodedTileHelpers_1.applySecondaryColorToMaterial(standardMat.emissive, technique.emissive, mapView.env);
                                }
                            }
                            : undefined);
                    }
                }
                const extrudedObjects = [];
                const animatedExtrusionHandler = mapView.animatedExtrusionHandler;
                let extrusionAnimationEnabled = false;
                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) &&
                    animatedExtrusionHandler !== undefined) {
                    let animateExtrusionValue = harp_datasource_protocol_1.getPropertyValue(technique.animateExtrusion, discreteZoomEnv);
                    if (animateExtrusionValue !== undefined) {
                        animateExtrusionValue =
                            typeof animateExtrusionValue === "boolean"
                                ? animateExtrusionValue
                                : typeof animateExtrusionValue === "number"
                                    ? animateExtrusionValue !== 0
                                    : false;
                    }
                    extrusionAnimationEnabled =
                        animateExtrusionValue !== undefined &&
                            animatedExtrusionHandler.forceEnabled === false
                            ? animateExtrusionValue
                            : animatedExtrusionHandler.enabled;
                }
                const renderDepthPrePass = harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) && DepthPrePass_1.isRenderDepthPrePassEnabled(technique);
                if (renderDepthPrePass) {
                    const depthPassMesh = DepthPrePass_1.createDepthPrePassMesh(object);
                    // Set geometry kind for depth pass mesh so that it gets the displacement map
                    // for elevation overlay.
                    this.registerTileObject(tile, depthPassMesh, technique.kind);
                    objects.push(depthPassMesh);
                    if (extrusionAnimationEnabled) {
                        extrudedObjects.push({
                            object: depthPassMesh,
                            materialFeature: true
                        });
                    }
                    DepthPrePass_1.setDepthPrePassStencil(depthPassMesh, object);
                }
                this.registerTileObject(tile, object, technique.kind);
                objects.push(object);
                // Add the extruded building edges as a separate geometry.
                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) && srcGeometry.edgeIndex !== undefined) {
                    const edgeGeometry = new THREE.BufferGeometry();
                    edgeGeometry.setAttribute("position", bufferGeometry.getAttribute("position"));
                    const colorAttribute = bufferGeometry.getAttribute("color");
                    if (colorAttribute !== undefined) {
                        edgeGeometry.setAttribute("color", colorAttribute);
                    }
                    const extrusionAttribute = bufferGeometry.getAttribute("extrusionAxis");
                    if (extrusionAttribute !== undefined) {
                        edgeGeometry.setAttribute("extrusionAxis", extrusionAttribute);
                    }
                    const normalAttribute = bufferGeometry.getAttribute("normal");
                    if (normalAttribute !== undefined) {
                        edgeGeometry.setAttribute("normal", normalAttribute);
                    }
                    const uvAttribute = bufferGeometry.getAttribute("uv");
                    if (uvAttribute !== undefined) {
                        edgeGeometry.setAttribute("uv", uvAttribute);
                    }
                    edgeGeometry.setIndex(DecodedTileHelpers_1.getBufferAttribute(srcGeometry.edgeIndex));
                    // Read the uniforms from the technique values (and apply the default values).
                    const extrudedPolygonTechnique = technique;
                    const fadingParams = this.getPolygonFadingParams(discreteZoomEnv, extrudedPolygonTechnique);
                    // Configure the edge material based on the theme values.
                    const materialParams = {
                        color: fadingParams.color,
                        colorMix: fadingParams.colorMix,
                        fadeNear: fadingParams.lineFadeNear,
                        fadeFar: fadingParams.lineFadeFar
                    };
                    const edgeMaterial = new harp_materials_1.EdgeMaterial(materialParams);
                    const edgeObj = new THREE.LineSegments(edgeGeometry, edgeMaterial);
                    // Set the correct render order.
                    edgeObj.renderOrder = object.renderOrder + 0.1;
                    harp_materials_1.FadingFeature.addRenderHelper(edgeObj, viewRanges, fadingParams.lineFadeNear, fadingParams.lineFadeFar, false, extrudedPolygonTechnique.lineColor !== undefined &&
                        harp_datasource_protocol_1.Expr.isExpr(extrudedPolygonTechnique.lineColor)
                        ? () => {
                            DecodedTileHelpers_1.applyBaseColorToMaterial(edgeMaterial, edgeMaterial.color, extrudedPolygonTechnique, extrudedPolygonTechnique.lineColor, mapView.env);
                        }
                        : undefined);
                    if (extrusionAnimationEnabled) {
                        extrudedObjects.push({
                            object: edgeObj,
                            materialFeature: false
                        });
                    }
                    this.registerTileObject(tile, edgeObj, technique.kind);
                    objects.push(edgeObj);
                }
                // animate the extrusion of buildings
                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) && extrusionAnimationEnabled) {
                    extrudedObjects.push({
                        object,
                        materialFeature: true
                    });
                    const extrusionAnimationDuration = technique.animateExtrusionDuration !== undefined &&
                        animatedExtrusionHandler.forceEnabled === false
                        ? technique.animateExtrusionDuration
                        : animatedExtrusionHandler.duration;
                    tile.animatedExtrusionTileHandler = new AnimatedExtrusionHandler_1.AnimatedExtrusionTileHandler(tile, extrudedObjects, extrusionAnimationDuration);
                    mapView.animatedExtrusionHandler.add(tile.animatedExtrusionTileHandler);
                }
                // Add the fill area edges as a separate geometry.
                if (harp_datasource_protocol_1.isFillTechnique(technique) && srcGeometry.edgeIndex !== undefined) {
                    const outlineGeometry = new THREE.BufferGeometry();
                    outlineGeometry.setAttribute("position", bufferGeometry.getAttribute("position"));
                    outlineGeometry.setIndex(DecodedTileHelpers_1.getBufferAttribute(srcGeometry.edgeIndex));
                    const fillTechnique = technique;
                    const fadingParams = this.getPolygonFadingParams(mapView.env, fillTechnique);
                    // Configure the edge material based on the theme values.
                    const materialParams = {
                        color: fadingParams.color,
                        colorMix: fadingParams.colorMix,
                        fadeNear: fadingParams.lineFadeNear,
                        fadeFar: fadingParams.lineFadeFar
                    };
                    const outlineMaterial = new harp_materials_1.EdgeMaterial(materialParams);
                    const outlineObj = new THREE.LineSegments(outlineGeometry, outlineMaterial);
                    outlineObj.renderOrder = object.renderOrder + 0.1;
                    harp_materials_1.FadingFeature.addRenderHelper(outlineObj, viewRanges, fadingParams.lineFadeNear, fadingParams.lineFadeFar, false, fillTechnique.lineColor !== undefined &&
                        harp_datasource_protocol_1.Expr.isExpr(fillTechnique.lineColor)
                        ? (renderer, mat) => {
                            const edgeMaterial = mat;
                            DecodedTileHelpers_1.applyBaseColorToMaterial(edgeMaterial, edgeMaterial.color, fillTechnique, fillTechnique.lineColor, mapView.env);
                        }
                        : undefined);
                    this.registerTileObject(tile, outlineObj, technique.kind);
                    objects.push(outlineObj);
                }
                // Add the fill area edges as a separate geometry.
                if (hasSolidLinesOutlines) {
                    const outlineTechnique = technique;
                    const outlineMaterial = material.clone();
                    DecodedTileHelpers_1.applyBaseColorToMaterial(outlineMaterial, outlineMaterial.color, outlineTechnique, (_a = outlineTechnique.secondaryColor, (_a !== null && _a !== void 0 ? _a : 0x000000)), discreteZoomEnv);
                    if (outlineTechnique.secondaryCaps !== undefined) {
                        outlineMaterial.caps = outlineTechnique.secondaryCaps;
                    }
                    const outlineObj = new ObjectCtor(bufferGeometry, outlineMaterial);
                    outlineObj.renderOrder =
                        outlineTechnique.secondaryRenderOrder !== undefined
                            ? outlineTechnique.secondaryRenderOrder
                            : technique.renderOrder - 0.0000001;
                    if (group.renderOrderOffset !== undefined) {
                        outlineObj.renderOrder += group.renderOrderOffset;
                    }
                    const fadingParams = this.getFadingParams(discreteZoomEnv, technique);
                    harp_materials_1.FadingFeature.addRenderHelper(outlineObj, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, false, (renderer, mat) => {
                        const lineMaterial = mat;
                        const unitFactor = outlineTechnique.metricUnit === "Pixel"
                            ? mapView.pixelToWorld
                            : 1.0;
                        if (outlineTechnique.secondaryColor !== undefined) {
                            DecodedTileHelpers_1.applyBaseColorToMaterial(lineMaterial, lineMaterial.color, outlineTechnique, outlineTechnique.secondaryColor, mapView.env);
                        }
                        if (outlineTechnique.secondaryWidth !== undefined) {
                            const techniqueLineWidth = harp_datasource_protocol_1.getPropertyValue(outlineTechnique.lineWidth, mapView.env);
                            const techniqueSecondaryWidth = harp_datasource_protocol_1.getPropertyValue(outlineTechnique.secondaryWidth, mapView.env);
                            const techniqueOpacity = harp_datasource_protocol_1.getPropertyValue(outlineTechnique.opacity, mapView.env);
                            // hide outline when it's equal or smaller then line to avoid subpixel contour
                            const lineWidth = techniqueSecondaryWidth <= techniqueLineWidth &&
                                (techniqueOpacity === undefined || techniqueOpacity === 1)
                                ? 0
                                : techniqueSecondaryWidth;
                            lineMaterial.lineWidth = lineWidth * unitFactor * 0.5;
                        }
                    });
                    this.registerTileObject(tile, outlineObj, technique.kind);
                    objects.push(outlineObj);
                }
            }
        }
    }
    /**
     * Prepare the [[Tile]]s pois. Uses the [[PoiManager]] in [[MapView]].
     */
    preparePois(tile, decodedTile) {
        if (decodedTile.poiGeometries !== undefined) {
            tile.mapView.poiManager.addPois(tile, decodedTile);
        }
    }
    /**
     * Creates and add a background plane for the tile.
     */
    addGroundPlane(tile, renderOrder) {
        const mapView = tile.mapView;
        const dataSource = tile.dataSource;
        const projection = tile.projection;
        const color = mapView.clearColor;
        const tmpV = new THREE.Vector3();
        if (tile.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            const { east, west, north, south } = tile.geoBox;
            const sourceProjection = dataSource.getTilingScheme().projection;
            const g = new THREE.BufferGeometry();
            const posAttr = new THREE.BufferAttribute(new Float32Array([
                ...sourceProjection
                    .projectPoint(new harp_geoutils_1.GeoCoordinates(south, west), tmpV)
                    .toArray(),
                ...sourceProjection
                    .projectPoint(new harp_geoutils_1.GeoCoordinates(south, east), tmpV)
                    .toArray(),
                ...sourceProjection
                    .projectPoint(new harp_geoutils_1.GeoCoordinates(north, west), tmpV)
                    .toArray(),
                ...sourceProjection
                    .projectPoint(new harp_geoutils_1.GeoCoordinates(north, east), tmpV)
                    .toArray()
            ]), 3);
            g.setAttribute("position", posAttr);
            g.setIndex(new THREE.BufferAttribute(new Uint16Array([0, 1, 2, 2, 1, 3]), 1));
            const modifier = new SphericalGeometrySubdivisionModifier_1.SphericalGeometrySubdivisionModifier(THREE.Math.degToRad(10), sourceProjection);
            modifier.modify(g);
            for (let i = 0; i < posAttr.array.length; i += 3) {
                tmpV.set(posAttr.array[i], posAttr.array[i + 1], posAttr.array[i + 2]);
                projection.reprojectPoint(sourceProjection, tmpV, tmpV);
                tmpV.sub(tile.center);
                posAttr.array[i] = tmpV.x;
                posAttr.array[i + 1] = tmpV.y;
                posAttr.array[i + 2] = tmpV.z;
            }
            posAttr.needsUpdate = true;
            const material = new harp_materials_1.MapMeshBasicMaterial({
                color,
                visible: true,
                depthWrite: true
            });
            const mesh = new THREE.Mesh(g, material);
            mesh.renderOrder = renderOrder;
            this.registerTileObject(tile, mesh, harp_datasource_protocol_1.GeometryKind.Background);
            tile.objects.push(mesh);
        }
        else {
            // Add a ground plane to the tile.
            tile.boundingBox.getSize(tmpV);
            const groundPlane = this.createPlane(tmpV.x, tmpV.y, tile.center, color, true, renderOrder);
            this.registerTileObject(tile, groundPlane, harp_datasource_protocol_1.GeometryKind.Background);
            tile.objects.push(groundPlane);
        }
    }
    /**
     * Process the given [[Tile]] and assign default values to render orders
     * and label priorities.
     *
     * @param tile The [[Tile]] to process.
     */
    processPriorities(tile) {
        const decodedTile = tile.decodedTile;
        if (decodedTile === undefined) {
            return;
        }
        const theme = tile.mapView;
        if (!theme) {
            return;
        }
        const { priorities, labelPriorities } = tile.mapView.theme;
        decodedTile.techniques.forEach(technique => {
            const indexedTechnique = technique;
            if (harp_datasource_protocol_1.isTextTechnique(technique) ||
                harp_datasource_protocol_1.isPoiTechnique(technique) ||
                harp_datasource_protocol_1.isLineMarkerTechnique(technique)) {
                // for screen-space techniques the `category` is used to assign
                // priorities.
                if (labelPriorities && typeof indexedTechnique._category === "string") {
                    // override the `priority` when the technique uses `category`.
                    const priority = labelPriorities.indexOf(indexedTechnique._category);
                    if (priority !== -1) {
                        technique.priority = labelPriorities.length - priority;
                    }
                }
            }
            else if (priorities && indexedTechnique._styleSet !== undefined) {
                // Compute the render order based on the style category and styleSet.
                const computeRenderOrder = (category) => {
                    var _a;
                    const priority = (_a = priorities) === null || _a === void 0 ? void 0 : _a.findIndex(entry => entry.group === indexedTechnique._styleSet &&
                        entry.category === category);
                    return priority !== undefined && priority !== -1
                        ? (priority + 1) * 10
                        : undefined;
                };
                if (typeof indexedTechnique._category === "string") {
                    // override the renderOrder when the technique is using categories.
                    const renderOrder = computeRenderOrder(indexedTechnique._category);
                    if (renderOrder !== undefined) {
                        technique.renderOrder = renderOrder;
                    }
                }
                if (typeof indexedTechnique._secondaryCategory === "string") {
                    // override the secondaryRenderOrder when the technique is using categories.
                    const secondaryRenderOrder = computeRenderOrder(indexedTechnique._secondaryCategory);
                    if (secondaryRenderOrder !== undefined) {
                        technique.secondaryRenderOrder = secondaryRenderOrder;
                    }
                }
            }
        });
    }
    setupTerrainMaterial(technique, material, terrainColor) {
        if (technique.displacementMap === undefined) {
            // Render terrain using the given color.
            const stdMaterial = material;
            stdMaterial.color.set(terrainColor);
            return;
        }
        // Render terrain using height-based colors.
        material.onBeforeCompile = (shader) => {
            shader.fragmentShader = shader.fragmentShader.replace("#include <map_pars_fragment>", `#include <map_pars_fragment>
    uniform sampler2D displacementMap;
    uniform float displacementScale;
    uniform float displacementBias;`);
            shader.fragmentShader = shader.fragmentShader.replace("#include <map_fragment>", `#ifdef USE_MAP
    float minElevation = ${harp_geoutils_1.EarthConstants.MIN_ELEVATION.toFixed(1)};
    float maxElevation = ${harp_geoutils_1.EarthConstants.MAX_ELEVATION.toFixed(1)};
    float elevationRange = maxElevation - minElevation;

    float disp = texture2D( displacementMap, vUv ).x * displacementScale + displacementBias;
    vec4 texelColor = texture2D( map, vec2((disp - minElevation) / elevationRange, 0.0) );
    texelColor = mapTexelToLinear( texelColor );
    diffuseColor *= texelColor;
#endif`);
            // We remove the displacement map from manipulating the vertices, it is
            // however still required for the pixel shader, so it can't be directly
            // removed.
            shader.vertexShader = shader.vertexShader.replace("#include <displacementmap_vertex>", "");
        };
        material.displacementMap.needsUpdate = true;
    }
    /**
     * Create a simple flat plane for a [[Tile]].
     *
     * @param {number} width Width of plane.
     * @param {number} height Height of plane.
     * @param {THREE.Vector3} planeCenter Center of plane.
     * @param {number} colorHex Color of the plane mesh.
     * @param {boolean} isVisible `True` to make the mesh visible.
     * @returns {THREE.Mesh} The created plane.
     */
    createPlane(width, height, planeCenter, colorHex, isVisible, renderOrder) {
        const geometry = new THREE.PlaneGeometry(width, height, 1);
        // TODO cache the material HARP-4207
        const material = new harp_materials_1.MapMeshBasicMaterial({
            color: colorHex,
            visible: isVisible,
            depthWrite: false
        });
        const plane = new THREE.Mesh(geometry, material);
        plane.position.copy(planeCenter);
        // Render before everything else
        plane.renderOrder = renderOrder;
        return plane;
    }
    addUserData(tile, srcGeometry, technique, object) {
        var _a, _b;
        if ((_b = (_a = srcGeometry.objInfos) === null || _a === void 0 ? void 0 : _a.length, (_b !== null && _b !== void 0 ? _b : 0)) === 0) {
            return;
        }
        if (harp_datasource_protocol_1.isTerrainTechnique(technique)) {
            harp_utils_1.assert(Object.keys(object.userData).length === 0, "Unexpected user data in terrain object");
            harp_utils_1.assert(typeof srcGeometry.objInfos[0] === "object", "Wrong attribute map type for terrain geometry");
            const displacementMap = srcGeometry.objInfos[0];
            const tileDisplacementMap = {
                tileKey: tile.tileKey,
                texture: new THREE.DataTexture(displacementMap.buffer, displacementMap.xCountVertices, displacementMap.yCountVertices, THREE.LuminanceFormat, THREE.FloatType),
                displacementMap,
                geoBox: tile.geoBox
            };
            object.userData = tileDisplacementMap;
        }
        else if (harp_datasource_protocol_1.isSolidLineTechnique(technique)) {
            object.userData = srcGeometry.objInfos;
        }
        else {
            // Set the feature data for picking with `MapView.intersectMapObjects()` except for
            // solid-line which uses tile-based picking.
            const featureData = {
                geometryType: srcGeometry.type,
                starts: srcGeometry.featureStarts,
                objInfos: srcGeometry.objInfos
            };
            object.userData.feature = featureData;
            object.userData.technique = technique;
        }
    }
    /**
     * Gets the fading parameters for several kinds of objects.
     */
    getFadingParams(env, technique) {
        const fadeNear = technique.fadeNear !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, env)
            : harp_materials_1.FadingFeature.DEFAULT_FADE_NEAR;
        const fadeFar = technique.fadeFar !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, env)
            : harp_materials_1.FadingFeature.DEFAULT_FADE_FAR;
        return {
            fadeNear,
            fadeFar
        };
    }
    /**
     * Gets the fading parameters for several kinds of objects.
     */
    getPolygonFadingParams(env, technique) {
        let color;
        let colorMix = harp_materials_1.EdgeMaterial.DEFAULT_COLOR_MIX;
        if (technique.lineColor !== undefined) {
            color = harp_datasource_protocol_1.getPropertyValue(technique.lineColor, env);
            if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {
                const extrudedPolygonTechnique = technique;
                colorMix =
                    extrudedPolygonTechnique.lineColorMix !== undefined
                        ? extrudedPolygonTechnique.lineColorMix
                        : harp_materials_1.EdgeMaterial.DEFAULT_COLOR_MIX;
            }
        }
        const fadeNear = technique.fadeNear !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, env)
            : harp_materials_1.FadingFeature.DEFAULT_FADE_NEAR;
        const fadeFar = technique.fadeFar !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, env)
            : harp_materials_1.FadingFeature.DEFAULT_FADE_FAR;
        const lineFadeNear = technique.lineFadeNear !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.lineFadeNear, env)
            : fadeNear;
        const lineFadeFar = technique.lineFadeFar !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.lineFadeFar, env)
            : fadeFar;
        if (color === undefined) {
            color = harp_materials_1.EdgeMaterial.DEFAULT_COLOR;
        }
        return {
            color,
            colorMix,
            fadeNear,
            fadeFar,
            lineFadeNear,
            lineFadeFar
        };
    }
}
exports.TileGeometryCreator = TileGeometryCreator;


/***/ }),

/***/ "../harp-mapview/lib/geometry/TileGeometryLoader.ts":
/*!**********************************************************!*\
  !*** ../harp-mapview/lib/geometry/TileGeometryLoader.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const Statistics_1 = __webpack_require__(/*! ../Statistics */ "../harp-mapview/lib/Statistics.ts");
const TileGeometryCreator_1 = __webpack_require__(/*! ./TileGeometryCreator */ "../harp-mapview/lib/geometry/TileGeometryCreator.ts");
var TileGeometryLoader;
(function (TileGeometryLoader) {
    /**
     * Make sure that all technique have their geometryKind set, either from the theme or their
     * default value.
     *
     * Also gather set of the [[GeometryKind]]s found in the techniques and return it.
     *
     * @param {DecodedTile} decodedTile
     * @returns {GeometryKindSet} The set of kinds used in the decodeTile.
     */
    function prepareDecodedTile(decodedTile) {
        const foundSet = new harp_datasource_protocol_1.GeometryKindSet();
        for (const technique of decodedTile.techniques) {
            let geometryKind = technique.kind;
            // Set default kind based on technique.
            if (geometryKind === undefined) {
                geometryKind = setDefaultGeometryKind(technique);
            }
            if (Array.isArray(geometryKind)) {
                geometryKind = new harp_datasource_protocol_1.GeometryKindSet(geometryKind);
            }
            if (geometryKind instanceof Set) {
                for (const kind of geometryKind) {
                    foundSet.add(kind);
                }
            }
            else {
                foundSet.add(geometryKind);
            }
        }
        return foundSet;
    }
    TileGeometryLoader.prepareDecodedTile = prepareDecodedTile;
    /**
     * Make sure that the technique has its geometryKind set, either from the theme or their default
     * value.
     *
     * @param {Technique} technique
     */
    function setDefaultGeometryKind(technique) {
        let geometryKind = technique.kind;
        // Set default kind based on technique.
        if (geometryKind === undefined) {
            if (harp_datasource_protocol_1.isFillTechnique(technique)) {
                geometryKind = harp_datasource_protocol_1.GeometryKind.Area;
            }
            else if (harp_datasource_protocol_1.isLineTechnique(technique) ||
                harp_datasource_protocol_1.isSolidLineTechnique(technique) ||
                harp_datasource_protocol_1.isSegmentsTechnique(technique) ||
                harp_datasource_protocol_1.isExtrudedLineTechnique(technique)) {
                geometryKind = harp_datasource_protocol_1.GeometryKind.Line;
            }
            else if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {
                geometryKind = harp_datasource_protocol_1.GeometryKind.Building;
            }
            else if (harp_datasource_protocol_1.isPoiTechnique(technique) ||
                harp_datasource_protocol_1.isLineMarkerTechnique(technique) ||
                harp_datasource_protocol_1.isTextTechnique(technique)) {
                geometryKind = harp_datasource_protocol_1.GeometryKind.Label;
            }
            else {
                geometryKind = harp_datasource_protocol_1.GeometryKind.All;
            }
            technique.kind = geometryKind;
        }
        return geometryKind;
    }
    TileGeometryLoader.setDefaultGeometryKind = setDefaultGeometryKind;
})(TileGeometryLoader = exports.TileGeometryLoader || (exports.TileGeometryLoader = {}));
/**
 * Simplest implementation of a [[TileGeometryLoader]]. It loads all geometry in a single step.
 */
class SimpleTileGeometryLoader {
    constructor(m_tile) {
        this.m_tile = m_tile;
        this.m_isFinished = false;
    }
    get tile() {
        return this.m_tile;
    }
    get isFinished() {
        return this.m_isFinished;
    }
    get geometryCreationPending() {
        // Geometry loading not yet finished and timeout already set, but not yet processing
        // (m_timeout !== undefined), or timeout callback already in progress
        // (m_timeout === undefined), but decoded tile still not reset.
        return !this.isFinished && this.m_decodedTile !== undefined;
    }
    get basicGeometryLoaded() {
        return this.m_tile.hasGeometry;
    }
    get allGeometryLoaded() {
        return this.m_isFinished;
    }
    /**
     * Set the [[DecodedTile]] of the tile. Is called after the decoded tile has been loaded, and
     * prepares its content for later processing in the 'updateXXX' methods.
     *
     * @param {DecodedTile} decodedTile The decoded tile with the flat geometry data belonging to
     *      this tile.
     * @returns {DecodedTile} The processed decoded tile.
     */
    setDecodedTile(decodedTile) {
        this.m_decodedTile = decodedTile;
        if (this.m_decodedTile !== undefined) {
            this.m_availableGeometryKinds = TileGeometryLoader.prepareDecodedTile(this.m_decodedTile);
        }
        return this.m_decodedTile;
    }
    get availableGeometryKinds() {
        return this.m_availableGeometryKinds;
    }
    update(enabledKinds, disabledKinds) {
        const tile = this.tile;
        // Cheap sanity check, do it first so no longer processing is needed.
        if (this.isFinished) {
            return;
        }
        // Check if tile should be already discarded (invisible, disposed).
        // If the tile is not ready for display, or if it has become invisible while being loaded,
        // for example by moving the camera, the tile is not finished and its geometry is not
        // created. This is an optimization for fast camera movements and zooms.
        if (this.discardNeedlessTile(tile)) {
            return;
        }
        // Geometry kinds have changed when loading, if so reset entire loading because
        // this geometry loader generates all geometry at once.
        // TODO: Probably the update() interface will change soon, when phased loading support
        // will be removed, then this code may be no longer necessary.
        if (this.geometryCreationPending &&
            !this.compareGeometryKinds(enabledKinds, disabledKinds)) {
            this.reset();
        }
        // First time this tile is handled, or reset has been requested.
        // Note: Finished condition already checked above.
        if (!this.geometryCreationPending && tile.decodedTile !== undefined) {
            TileGeometryCreator_1.TileGeometryCreator.instance.processTechniques(tile, enabledKinds, disabledKinds);
            this.setGeometryKinds(enabledKinds, disabledKinds);
            this.setDecodedTile(tile.decodedTile);
            this.prepareForRender(enabledKinds, disabledKinds);
        }
    }
    dispose() {
        this.m_decodedTile = undefined;
        // TODO: Release other resource: availableGeometryKind, enabled/disabled sets, timeout?
    }
    reset() {
        var _a, _b, _c;
        (_a = this.m_availableGeometryKinds) === null || _a === void 0 ? void 0 : _a.clear();
        (_b = this.m_enabledKinds) === null || _b === void 0 ? void 0 : _b.clear();
        (_c = this.m_disabledKinds) === null || _c === void 0 ? void 0 : _c.clear();
        this.m_decodedTile = undefined;
        this.m_isFinished = false;
        if (this.m_timeout !== undefined) {
            clearTimeout(this.m_timeout);
            this.m_timeout = undefined;
        }
    }
    finish() {
        this.m_tile.loadingFinished();
        this.m_tile.removeDecodedTile();
        this.m_decodedTile = undefined;
        this.m_isFinished = true;
        if (this.m_timeout !== undefined) {
            clearTimeout(this.m_timeout);
            this.m_timeout = undefined;
        }
    }
    /**
     * Called by [[VisibleTileSet]] to mark that [[Tile]] is visible and it should prepare geometry.
     */
    prepareForRender(enabledKinds, disabledKinds) {
        const tile = this.tile;
        const decodedTile = this.m_decodedTile;
        // Just a sanity check that satisfies compiler check below.
        if (decodedTile === undefined) {
            this.finish();
            return;
        }
        this.m_timeout = setTimeout(() => {
            // Reset timeout so it is untouched during processing.
            this.m_timeout = undefined;
            if (this.discardNeedlessTile(tile)) {
                return;
            }
            const stats = Statistics_1.PerformanceStatistics.instance;
            let now = 0;
            if (stats.enabled) {
                now = harp_utils_1.PerformanceTimer.now();
            }
            const geometryCreator = TileGeometryCreator_1.TileGeometryCreator.instance;
            tile.clear();
            // Set up techniques which should be processed.
            geometryCreator.initDecodedTile(decodedTile, enabledKinds, disabledKinds);
            geometryCreator.createAllGeometries(tile, decodedTile);
            if (stats.enabled) {
                const geometryCreationTime = harp_utils_1.PerformanceTimer.now() - now;
                const currentFrame = stats.currentFrame;
                currentFrame.addValue("geometry.geometryCreationTime", geometryCreationTime);
                currentFrame.addValue("geometryCount.numGeometries", decodedTile.geometries.length);
                currentFrame.addValue("geometryCount.numTechniques", decodedTile.techniques.length);
                currentFrame.addValue("geometryCount.numPoiGeometries", decodedTile.poiGeometries !== undefined ? decodedTile.poiGeometries.length : 0);
                currentFrame.addValue("geometryCount.numTextGeometries", decodedTile.textGeometries !== undefined ? decodedTile.textGeometries.length : 0);
                currentFrame.addValue("geometryCount.numTextPathGeometries", decodedTile.textPathGeometries !== undefined
                    ? decodedTile.textPathGeometries.length
                    : 0);
                currentFrame.addValue("geometryCount.numPathGeometries", decodedTile.pathGeometries !== undefined ? decodedTile.pathGeometries.length : 0);
                currentFrame.addMessage(
                // tslint:disable-next-line: max-line-length
                `Decoded tile: ${tile.dataSource.name} # lvl=${tile.tileKey.level} col=${tile.tileKey.column} row=${tile.tileKey.row}`);
            }
            this.finish();
            tile.dataSource.requestUpdate();
        }, 0);
    }
    discardNeedlessTile(tile) {
        // If the tile has become invisible while being loaded, for example by moving the
        // camera, the tile is not finished and its geometry is not created. This is an
        // optimization for fast camera movements and zooms.
        if (!tile.isVisible) {
            // Dispose the tile from the visible set, so it can be reloaded properly next time
            // it is needed.
            tile.mapView.visibleTileSet.disposeTile(tile);
            const stats = Statistics_1.PerformanceStatistics.instance;
            if (stats.enabled) {
                stats.currentFrame.addMessage(
                // tslint:disable-next-line: max-line-length
                `Decoded tile: ${tile.dataSource.name} # lvl=${tile.tileKey.level} col=${tile.tileKey.column} row=${tile.tileKey.row} DISCARDED - invisible`);
            }
            this.finish();
            return true;
        }
        // Tile already disposed (this may potentially happen in timeout callback).
        else if (tile.disposed) {
            const stats = Statistics_1.PerformanceStatistics.instance;
            if (stats.enabled) {
                stats.currentFrame.addMessage(
                // tslint:disable-next-line: max-line-length
                `Decoded tile: ${tile.dataSource.name} # lvl=${tile.tileKey.level} col=${tile.tileKey.column} row=${tile.tileKey.row} DISCARDED - disposed`);
            }
            this.finish();
            return true;
        }
        return false;
    }
    /**
     * Stores geometry kinds used to load decoded tile geometry.
     *
     * This values are stored to detect geometry kind changes during loading.
     *
     * @param enabledKinds Set of geometry kinds to be displayed or undefined.
     * @param disabledKinds Set of geometry kinds that won't be rendered.
     */
    setGeometryKinds(enabledKinds, disabledKinds) {
        var _a, _b;
        if (enabledKinds !== undefined) {
            this.m_enabledKinds = Object.assign((_a = this.m_enabledKinds, (_a !== null && _a !== void 0 ? _a : new harp_datasource_protocol_1.GeometryKindSet())), enabledKinds);
        }
        if (disabledKinds !== undefined) {
            this.m_disabledKinds = Object.assign((_b = this.m_disabledKinds, (_b !== null && _b !== void 0 ? _b : new harp_datasource_protocol_1.GeometryKindSet())), disabledKinds);
        }
    }
    /**
     * Compare enabled and disabled geometry kinds with currently set.
     *
     * Method compares input sets with recently used geometry kinds in performance wise
     * manner, taking special care of undefined and zero size sets.
     *
     * @param enabledKinds Set of geometry kinds to be displayed or undefined.
     * @param disabledKinds Set of geometry kinds that won't be rendered.
     * @return `true` only if sets are logically equal, meaning that undefined and empty sets
     * may result in same geometry (techniques kind) beeing rendered.
     */
    compareGeometryKinds(enabledKinds, disabledKinds) {
        const enabledSame = this.m_enabledKinds === enabledKinds;
        const disabledSame = this.m_disabledKinds === disabledKinds;
        // Same references, no need to compare.
        if (enabledSame && disabledSame) {
            return true;
        }
        const enabledEmpty = (this.m_enabledKinds === undefined || this.m_enabledKinds.size === 0) &&
            (enabledKinds === undefined || enabledKinds.size === 0);
        const disabledEmpty = (this.m_disabledKinds === undefined || this.m_disabledKinds.size === 0) &&
            (disabledKinds === undefined || disabledKinds.size === 0);
        // We deal only with empty, the same or undefined sets - fast return, no need to compare.
        if ((enabledEmpty && disabledEmpty) ||
            (enabledSame && disabledEmpty) ||
            (disabledSame && enabledEmpty)) {
            return true;
        }
        // It is enough that one the the sets are different, try to spot difference otherwise
        // return true. Compare only non-empty sets.
        if (!enabledEmpty) {
            // If one set undefined then other must be non-empty, for sure different.
            if (enabledKinds === undefined || this.m_enabledKinds === undefined) {
                return false;
            }
            // Both defined and non-empty, compare the sets.
            else if (!enabledKinds.has(this.m_enabledKinds)) {
                return false;
            }
        }
        if (!disabledEmpty) {
            // One set defined and non-empty other undefined, for sure different.
            if (disabledKinds === undefined || this.m_disabledKinds === undefined) {
                return false;
            }
            // Both defined and non-empty, compare the sets.
            else if (!disabledKinds.has(this.m_disabledKinds)) {
                return false;
            }
        }
        // No difference found.
        return true;
    }
}
exports.SimpleTileGeometryLoader = SimpleTileGeometryLoader;


/***/ }),

/***/ "../harp-mapview/lib/geometry/TileGeometryManager.ts":
/*!***********************************************************!*\
  !*** ../harp-mapview/lib/geometry/TileGeometryManager.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const TileGeometryLoader_1 = __webpack_require__(/*! ./TileGeometryLoader */ "../harp-mapview/lib/geometry/TileGeometryLoader.ts");
/**
 * Base class for all [[TileGeometryManager]]s. Handles visibility as well as enabling/disabling of
 * kinds of geometry [[GeometryKind]].
 */
class TileGeometryManagerBase {
    /**
     * Creates an instance of `TileGeometryManagerBase` with a reference to the [[MapView]].
     */
    constructor(mapView) {
        this.mapView = mapView;
        this.enableFilterByKind = true;
        this.enabledKinds = new harp_datasource_protocol_1.GeometryKindSet();
        this.disabledKinds = new harp_datasource_protocol_1.GeometryKindSet();
        this.hiddenKinds = new harp_datasource_protocol_1.GeometryKindSet();
        /**
         * Optimization for evaluation in `update()` method. Only if a kind is hidden/unhidden, the
         * visibility of the kinds is applied to their geometries.
         */
        this.m_visibilityCounter = 1;
    }
    get enabledGeometryKinds() {
        return this.enabledKinds;
    }
    set enabledGeometryKinds(kinds) {
        this.enabledKinds = kinds;
    }
    get disabledGeometryKinds() {
        return this.disabledKinds;
    }
    set disabledGeometryKinds(kinds) {
        this.disabledKinds = kinds;
    }
    get hiddenGeometryKinds() {
        return this.hiddenKinds;
    }
    set hiddenGeometryKinds(kinds) {
        this.hiddenKinds = kinds;
        this.incrementVisibilityCounter();
    }
    get visibilityCounter() {
        return this.m_visibilityCounter;
    }
    clear() {
        this.enabledKinds.clear();
        this.disabledKinds.clear();
        this.hiddenKinds.clear();
    }
    enableKind(kind, addOrRemoveToEnabledSet = true) {
        this.enableDisableKinds(this.enabledKinds, kind, addOrRemoveToEnabledSet);
    }
    disableKind(kind, addOrRemoveToDisabledSet = true) {
        this.enableDisableKinds(this.disabledKinds, kind, addOrRemoveToDisabledSet);
    }
    hideKind(kind, addOrRemoveToHiddenSet = true) {
        let visibilityHasChanged = false;
        if (Array.isArray(kind) || kind instanceof Set) {
            for (const oneKind of kind) {
                const visibilityChange = this.addRemove(this.hiddenKinds, oneKind, addOrRemoveToHiddenSet);
                visibilityHasChanged = visibilityHasChanged || visibilityChange;
            }
        }
        else {
            visibilityHasChanged = this.addRemove(this.hiddenKinds, kind, addOrRemoveToHiddenSet);
        }
        // Will be evaluated in the next update()
        if (visibilityHasChanged) {
            this.incrementVisibilityCounter();
        }
    }
    getAvailableKinds(tiles) {
        const visibleKinds = new harp_datasource_protocol_1.GeometryKindSet();
        for (const tile of tiles) {
            const geometryLoader = tile.tileGeometryLoader;
            if (geometryLoader !== undefined) {
                const tileKinds = geometryLoader.availableGeometryKinds;
                if (tileKinds !== undefined) {
                    for (const kind of tileKinds) {
                        visibleKinds.add(kind);
                    }
                }
            }
        }
        return visibleKinds;
    }
    /**
     * Apply the visibility status taken from the `hiddenKinds` to all geometries in the specified
     * tiles.
     *
     * @param {Tile[]} tiles List of [[Tiles]] to process the visibility status of.
     */
    updateTileObjectVisibility(tiles) {
        let needUpdate = false;
        for (const tile of tiles) {
            if (tile.objects.length === 0 || tile.visibilityCounter === this.visibilityCounter) {
                continue;
            }
            tile.visibilityCounter = this.visibilityCounter;
            for (const object of tile.objects) {
                const geometryKind = object.userData !== undefined ? object.userData.kind : undefined;
                if (geometryKind !== undefined) {
                    const nowVisible = !geometryKind.some(kind => this.hiddenKinds.has(kind));
                    needUpdate = needUpdate || object.visible !== nowVisible;
                    object.visible = nowVisible;
                }
            }
        }
        return needUpdate;
    }
    setTileUpdateCallback(callback) {
        this.m_tileUpdateCallback = callback;
    }
    incrementVisibilityCounter() {
        return ++this.m_visibilityCounter;
    }
    /**
     * Add or remove a kind|array of kinds|set of kinds from the specified kind set.
     *
     * @hidden
     * @param {GeometryKindSet} set
     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind
     * @param {boolean} addToSet
     */
    enableDisableKinds(set, kind, addToSet) {
        if (Array.isArray(kind)) {
            for (const oneKind of kind) {
                this.addRemove(set, oneKind, addToSet);
            }
        }
        else if (kind instanceof Set) {
            const kindSet = kind;
            for (const oneKind of kindSet) {
                this.addRemove(set, oneKind, addToSet);
            }
        }
        else if (kind !== undefined) {
            this.addRemove(set, kind, addToSet);
        }
    }
    /**
     * Add or remove a single kind from the specified kind set.
     *
     * @hidden
     * @param {GeometryKindSet} set
     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind
     * @param {boolean} addToSet
     */
    addRemove(kindsSet, kind, addToSet) {
        if (addToSet) {
            if (!kindsSet.has(kind)) {
                kindsSet.add(kind);
                return true;
            }
        }
        else {
            if (kindsSet.has(kind)) {
                kindsSet.delete(kind);
                return true;
            }
        }
        return false;
    }
}
exports.TileGeometryManagerBase = TileGeometryManagerBase;
/**
 * Implements the simplest for of [[TileGeometryManager]]. Uses a [[SimpleTileGeometryLoader]] to
 * load the geometries of the [[Tile]].
 */
class SimpleTileGeometryManager extends TileGeometryManagerBase {
    /**
     * Creates an instance of `SimpleTileGeometryManager` with a reference to the [[MapView]].
     */
    constructor(mapView) {
        super(mapView);
    }
    /** @override */
    initTile(tile) {
        if (tile.dataSource.useGeometryLoader) {
            tile.tileGeometryLoader = new TileGeometryLoader_1.SimpleTileGeometryLoader(tile);
        }
    }
    /** @override */
    updateTiles(tiles) {
        for (const tile of tiles) {
            const geometryLoader = tile.tileGeometryLoader;
            if (geometryLoader !== undefined) {
                geometryLoader.update(this.enableFilterByKind ? this.enabledGeometryKinds : undefined, this.enableFilterByKind ? this.disabledGeometryKinds : undefined);
                if (this.m_tileUpdateCallback) {
                    this.m_tileUpdateCallback(tile);
                }
            }
        }
        // If the visibility status of the kinds changed since the last update, the new visibility
        // status is applied (again).
        if (this.updateTileObjectVisibility(tiles)) {
            this.mapView.update();
        }
    }
}
exports.SimpleTileGeometryManager = SimpleTileGeometryManager;


/***/ }),

/***/ "../harp-mapview/lib/geometry/overlayOnElevation.ts":
/*!**********************************************************!*\
  !*** ../harp-mapview/lib/geometry/overlayOnElevation.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
/**
 * Overlays the specified object's geometry on the elevation represented by the given displacement
 * map .
 *
 * @param object The object to be overlaid.
 * @param displacementMap Texture representing the elevation data used to overlay the object.
 */
function overlayObject(object, displacementMap) {
    if (!("material" in object)) {
        return;
    }
    const material = object.material;
    if (harp_materials_1.hasDisplacementFeature(material)) {
        material.displacementMap = displacementMap;
    }
}
/**
 * Overlays the specified coordinates on top of elevation data if available.
 *
 * @param worldCoords World coordinates to overlay.
 * @param elevationProvider Used to sample elevation data.
 * @param displacementMap Elevation data to be sampled.
 * @param projection Projection from geo to world space.
 * @returns `true` if the position was successfully overlaid, `false` otherwise (e.g. elevation
 * data not available).
 */
function overlayPosition(worldCoords, elevationProvider, displacementMap, projection) {
    // TODO: Move calculation of text element geoCoordinates to decoder.
    const geoCoords = projection.unprojectPoint(worldCoords);
    if (displacementMap.geoBox.contains(geoCoords)) {
        geoCoords.altitude = elevationProvider.sampleHeight(geoCoords, displacementMap);
    }
    else {
        geoCoords.altitude = elevationProvider.getHeight(geoCoords, displacementMap.tileKey.level);
        if (geoCoords.altitude === undefined) {
            return false;
        }
    }
    projection.projectPoint(geoCoords, worldCoords);
    return true;
}
/**
 * Overlays the specified coordinates on top of elevation data if available.
 *
 * @param path World coordinates to overlay.
 * @param elevationProvider Used to sample elevation data.
 * @param displacementMap Elevation data to be sampled.
 * @param projection Projection from geo to world space.
 * @returns `true` if the position was successfully overlaid, `false` otherwise (e.g. elevation
 * data not available).
 */
function overlayPath(path, elevationProvider, displacementMap, projection) {
    for (const position of path) {
        if (!overlayPosition(position, elevationProvider, displacementMap, projection)) {
            return false;
        }
    }
    return true;
}
/**
 * Overlays a text element on top of elevation data if available.
 *
 * @param textElement The text element whose geometry will be overlaid.
 * @param elevationProvider  Used to sample elevation data.
 * @param displacementMap Elevation data to be sampled.
 * @param projection Projection from geo to world space.
 */
function overlayTextElement(textElement, elevationProvider, displacementMap, projection) {
    harp_utils_1.assert(!textElement.elevated);
    if (!displacementMap) {
        return;
    }
    textElement.elevated = textElement.path
        ? overlayPath(textElement.path, elevationProvider, displacementMap, projection)
        : overlayPosition(textElement.position, elevationProvider, displacementMap, projection);
}
exports.overlayTextElement = overlayTextElement;
/**
 * Overlays the geometry in the given tile on top of elevation data if available.
 *
 * @param tile The tile whose geometry will be overlaid.
 */
function overlayOnElevation(tile) {
    const elevationProvider = tile.mapView.elevationProvider;
    if (elevationProvider === undefined || tile.objects.length === 0) {
        return;
    }
    const firstObject = tile.objects[0];
    if (!firstObject.userData ||
        !firstObject.userData.kind ||
        !firstObject.userData.kind.find((kind) => {
            return kind !== harp_datasource_protocol_1.GeometryKind.All && kind !== harp_datasource_protocol_1.GeometryKind.Terrain;
        })) {
        return;
    }
    const displacementMap = elevationProvider.getDisplacementMap(tile.tileKey);
    if (displacementMap === undefined) {
        return;
    }
    // TODO: HARP-8808 Apply displacement maps once per material.
    for (const object of tile.objects) {
        overlayObject(object, displacementMap.texture);
    }
}
exports.overlayOnElevation = overlayOnElevation;


/***/ }),

/***/ "../harp-mapview/lib/image/Image.ts":
/*!******************************************!*\
  !*** ../harp-mapview/lib/image/Image.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
var ImageItem;
(function (ImageItem) {
    /**
     * Missing Typedoc
     */
    function isLoading(imageItem) {
        return imageItem.loadingPromise !== undefined;
    }
    ImageItem.isLoading = isLoading;
})(ImageItem = exports.ImageItem || (exports.ImageItem = {}));


/***/ }),

/***/ "../harp-mapview/lib/image/ImageCache.ts":
/*!***********************************************!*\
  !*** ../harp-mapview/lib/image/ImageCache.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const THREE = __webpack_require__(/*! three */ "three");
const logger = harp_utils_1.LoggerManager.instance.create("ImageCache");
/**
 * Combines an [[ImageItem]] with a list of [[MapViews]] that reference it.
 */
class ImageCacheItem {
    /**
     * Instantiates `ImageCacheItem`.
     *
     * @param imageItem The [[ImageItem]] referenced by the associated [[MapView]]s instances.
     * @param mapView An optional first [[MapView]] referencing the [[ImageItem]].
     */
    constructor(imageItem, mapView) {
        this.imageItem = imageItem;
        /**
         * The list of [[MapView]]s referencing the [[ImageItem]].
         */
        this.mapViews = [];
        if (mapView !== undefined) {
            this.mapViews.push(mapView);
        }
    }
}
/**
 * `ImageCache` is a singleton, so it can be used with multiple MapViews on a single page. This
 * allows to have an image loaded only once for multiple views. THREE is doing something similar,
 * but does not allow to share images that have been loaded from a canvas (which we may need to do
 * if we use SVG images for textures).
 *
 * One application that makes our own cache necessary is the generation of our own textures from
 * data that is not an URL.
 *
 * The `ImageCache` can be improved by adding satistics for memory footprint as well.
 */
class ImageCache {
    constructor() {
        this.m_images = new Map();
    }
    /**
     * Returns the singleton `instance` of the `ImageCache`.
     */
    static get instance() {
        if (ImageCache.m_instance === undefined) {
            ImageCache.m_instance = new ImageCache();
        }
        return ImageCache.m_instance;
    }
    /**
     * Dispose the singleton object. Not normally implemented for singletons, but good for
     * debugging.
     */
    static dispose() {
        ImageCache.m_instance = undefined;
    }
    /**
     * Add an image definition to the global cache. Useful when the image data is already loaded.
     *
     * @param mapView Specifiy which [[MapView]] requests the image.
     * @param url URL of image.
     * @param imageData Optional [ImageData]] containing the image content.
     */
    registerImage(mapView, url, imageData) {
        let imageCacheItem = this.findImageCacheItem(url);
        if (imageCacheItem !== undefined) {
            if (mapView !== undefined && imageCacheItem.mapViews.indexOf(mapView) < 0) {
                imageCacheItem.mapViews.push(mapView);
            }
            return imageCacheItem.imageItem;
        }
        imageCacheItem = this.findImageCacheItem(url);
        if (imageCacheItem !== undefined) {
            if (mapView !== undefined && imageCacheItem.mapViews.indexOf(mapView) < 0) {
                imageCacheItem.mapViews.push(mapView);
            }
            return imageCacheItem.imageItem;
        }
        const mapViews = [];
        if (mapView !== undefined) {
            mapViews.push(mapView);
        }
        imageCacheItem = {
            imageItem: {
                url,
                imageData,
                loaded: false
            },
            mapViews
        };
        this.m_images.set(url, imageCacheItem);
        return imageCacheItem.imageItem;
    }
    /**
     * Add an image definition, and optionally start loading the content.
     *
     * @param mapView [[MapView]] requesting the image.
     * @param url URL of image.
     * @param startLoading Optional flag. If `true` the image will be loaded in the background.
     */
    addImage(mapView, url, startLoading = true) {
        const imageItem = this.registerImage(mapView, url, undefined);
        if (imageItem !== undefined && startLoading === true) {
            return this.loadImage(imageItem);
        }
        return imageItem;
    }
    /**
     * Find [[ImageItem]] for the specified URL.
     *
     * @param url URL of image.
     * @returns `ImageItem` for the URL if the URL is registered, `undefined` otherwise.
     */
    findImage(url) {
        const imageItem = this.m_images.get(url);
        if (imageItem !== undefined) {
            return imageItem.imageItem;
        }
        return undefined;
    }
    /**
     * Clear all [[ImageItem]]s belonging to a [[MapView]]. May remove cached items if no
     * [[MapView]] are registered anymore.
     *
     * @param mapView MapView to remove all [[ImageItem]]s from.
     */
    clear(mapView) {
        const itemsToRemove = [];
        this.m_images.forEach(imageItem => {
            const mapViewIndex = imageItem.mapViews.indexOf(mapView);
            if (mapViewIndex >= 0) {
                imageItem.mapViews.splice(mapViewIndex, 1);
            }
            if (imageItem.mapViews.length === 0) {
                itemsToRemove.push(imageItem.imageItem.url);
            }
        });
        for (const keyToDelete of itemsToRemove) {
            this.m_images.delete(keyToDelete);
        }
    }
    /**
     * Clear all [[ImageItem]]s from all [[MapView]]s.
     */
    clearAll() {
        this.m_images = new Map();
    }
    /**
     * Returns the number of all cached [[ImageItem]]s.
     */
    get size() {
        return this.m_images.size;
    }
    /**
     * Load an [[ImageItem]]. If the loading process is already running, it returns the current
     * promise.
     *
     * @param imageItem `ImageItem` containing the URL to load image from.
     * @returns An [[ImageItem]] if the image has already been loaded, a promise otherwise.
     */
    loadImage(imageItem) {
        if (imageItem.imageData !== undefined) {
            return imageItem;
        }
        if (imageItem.loadingPromise !== undefined) {
            return imageItem.loadingPromise;
        }
        const imageLoader = new THREE.ImageLoader();
        imageItem.loadingPromise = new Promise(resolve => {
            logger.debug(`Loading image: ${imageItem.url}`);
            imageLoader.load(imageItem.url, image => {
                logger.debug(`... finished loading image: ${imageItem.url}`);
                this.renderImage(imageItem, image)
                    .then(() => {
                    imageItem.loadingPromise = undefined;
                    resolve(imageItem);
                })
                    .catch(ex => {
                    logger.error(`... loading image failed: ${imageItem.url} : ${ex}`);
                    resolve(undefined);
                });
            }, 
            // Loading events no longer supported
            undefined, errorEvent => {
                logger.error(`... loading image failed: ${imageItem.url} : ${errorEvent}`);
                imageItem.loadingPromise = undefined;
                resolve(undefined);
            });
        });
        return imageItem.loadingPromise;
    }
    /**
     * Find the cached [[ImageItem]] by URL.
     *
     * @param url URL of image.
     */
    findImageCacheItem(url) {
        return this.m_images.get(url);
    }
    /**
     * Render the `ImageItem` by using `createImageBitmap()` or by rendering the image into a
     * [[HTMLCanvasElement]].
     *
     * @param imageItem [[ImageItem]] to assign image data to.
     * @param image [[HTMLImageElement]] to
     */
    renderImage(imageItem, image) {
        return new Promise((resolve, reject) => {
            // use createImageBitmap if it is available. It should be available in webworkers as
            // well
            if (typeof createImageBitmap === "function") {
                const options = {
                    premultiplyAlpha: "default",
                    imageOrientation: "flipY"
                };
                logger.debug(`Creating bitmap image: ${imageItem.url}`);
                createImageBitmap(image, 0, 0, image.width, image.height, options)
                    .then(imageBitmap => {
                    logger.debug(`... finished creating bitmap image: ${imageItem.url}`);
                    imageItem.loadingPromise = undefined;
                    imageItem.imageData = imageBitmap;
                    imageItem.loaded = true;
                    resolve(imageBitmap);
                })
                    .catch(ex => {
                    logger.error(`... loading image failed: ${imageItem.url} : ${ex}`);
                    resolve(undefined);
                });
            }
            else {
                try {
                    if (typeof document === "undefined") {
                        logger.error("Error: document is not available, cannot generate image");
                        reject(new Error("ImageCache#renderImage: document is not available, cannot " +
                            "render image to create texture"));
                    }
                    // TODO: Extract the rendering to the canvas part and make it configurable for
                    // the client, so it does not rely on the `document`.
                    // use the image, e.g. draw part of it on a canvas
                    const canvas = document.createElement("canvas");
                    canvas.width = image.width;
                    canvas.height = image.height;
                    const context = canvas.getContext("2d");
                    if (context !== null) {
                        logger.debug(
                        // tslint:disable-next-line: max-line-length
                        `... finished creating bitmap image in canvas: ${imageItem.url} ${image}`);
                        context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
                        const imageData = context.getImageData(0, 0, image.width, image.height);
                        imageItem.imageData = imageData;
                        imageItem.loaded = true;
                        resolve(imageData);
                    }
                    else {
                        logger.error(`renderImage: no context found`);
                        reject(new Error(`ImageCache#renderImage: no context found`));
                    }
                }
                catch (ex) {
                    logger.error(`renderImage failed: ${ex}`);
                    imageItem.imageData = undefined;
                    imageItem.loaded = true;
                    reject(new Error(`ImageCache#renderImage failed: ${ex}`));
                }
            }
        });
    }
}
exports.ImageCache = ImageCache;


/***/ }),

/***/ "../harp-mapview/lib/image/MapViewImageCache.ts":
/*!******************************************************!*\
  !*** ../harp-mapview/lib/image/MapViewImageCache.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ImageCache_1 = __webpack_require__(/*! ./ImageCache */ "../harp-mapview/lib/image/ImageCache.ts");
/**
 * Cache images wrapped into [[ImageItem]]s for a [[MapView]]. An image may have multiple names in
 * a theme, the `MapViewImageCache` will take care of that. Registering multiple images with the
 * same name is invalid.
 *
 * The `MapViewImageCache` uses a global [[ImageCache]] to actually store (and generate) the
 * image data.
 */
class MapViewImageCache {
    /**
     * The constructor for `MapViewImageCache`.
     *
     * @param mapView a [[MapView]] instance.
     */
    constructor(mapView) {
        this.mapView = mapView;
        this.m_name2Url = new Map();
        this.m_url2Name = new Map();
    }
    /**
     * Register an existing image by name.
     *
     * @param name Name of the image from [[Theme]].
     * @param url URL of image.
     * @param image Optional [[ImageData]] of image.
     */
    registerImage(name, url, image) {
        if (name !== undefined) {
            if (this.hasName(name)) {
                throw new Error("duplicate name in cache");
            }
            const oldNames = this.m_url2Name.get(url);
            if (oldNames !== undefined) {
                if (oldNames.indexOf(name) < 0) {
                    oldNames.push(name);
                }
            }
            else {
                this.m_url2Name.set(url, [name]);
            }
            this.m_name2Url.set(name, url);
        }
        const imageItem = ImageCache_1.ImageCache.instance.findImage(url);
        if (imageItem === undefined) {
            return ImageCache_1.ImageCache.instance.registerImage(this.mapView, url, image);
        }
        return imageItem;
    }
    /**
     * Add an image and optionally start loading it. Once done, the [[ImageData]] or [[ImageBitmap]]
     * will be stored in the [[ImageItem]].
     *
     * @param name Name of image from [[Theme]].
     * @param url URL of image.
     * @param startLoading Optional. Pass `true` to start loading the image in the background.
     */
    addImage(name, url, startLoading = true) {
        const imageItem = this.registerImage(name, url, undefined);
        if (startLoading === true) {
            return ImageCache_1.ImageCache.instance.loadImage(imageItem);
        }
        return imageItem;
    }
    /**
     * Find [[ImageItem]] by its name.
     *
     * @param name Name of image.
     */
    findImageByName(name) {
        const url = this.m_name2Url.get(name);
        if (url === undefined) {
            return undefined;
        }
        return ImageCache_1.ImageCache.instance.findImage(url);
    }
    /**
     * Find [[ImageItem]] by URL.
     *
     * @param url Url of image.
     */
    findImageByUrl(url) {
        return ImageCache_1.ImageCache.instance.findImage(url);
    }
    /**
     * Load an [[ImageItem]]. Returns a promise or a loaded [[ImageItem]].
     *
     * @param imageItem ImageItem to load.
     */
    loadImage(imageItem) {
        return ImageCache_1.ImageCache.instance.loadImage(imageItem);
    }
    /**
     * Remove all [[ImageItem]]s from the cache. Also removes all [[ImageItem]]s that belong to this
     * [[MapView]] from the global [[ImageCache]].
     */
    clear() {
        ImageCache_1.ImageCache.instance.clear(this.mapView);
        this.m_name2Url = new Map();
        this.m_url2Name = new Map();
    }
    /**
     * Returns number of image names stored in the cache.
     */
    get numberOfNames() {
        return this.m_name2Url.size;
    }
    /**
     * Returns number of image URLs in the cache.
     */
    get numberOfUrls() {
        return this.m_url2Name.size;
    }
    /**
     * Return `true` if an image with the given name is known.
     *
     * @param name Name of the image.
     */
    hasName(name) {
        return this.m_name2Url.get(name) !== undefined;
    }
    /**
     * Return `true` if an image with the given URL is known.
     * @param url URL of image.
     */
    hasUrl(url) {
        return this.m_url2Name.get(url) !== undefined;
    }
    /**
     * Return the names under which an image with the given URL is saved.
     */
    findNames(url) {
        return this.m_url2Name.get(url);
    }
}
exports.MapViewImageCache = MapViewImageCache;


/***/ }),

/***/ "../harp-mapview/lib/poi/BoxBuffer.ts":
/*!********************************************!*\
  !*** ../harp-mapview/lib/poi/BoxBuffer.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const THREE = __webpack_require__(/*! three */ "three");
const PixelPicker_1 = __webpack_require__(/*! ./PixelPicker */ "../harp-mapview/lib/poi/PixelPicker.ts");
/**
 * Initial number of boxes in BoxBuffer.
 */
const START_BOX_BUFFER_SIZE = 0;
/**
 * Maximum number of boxes in BoxBuffer.
 */
const MAX_BOX_BUFFER_SIZE = 32 * 1024;
/**
 * Number of vertices per box/glyph element: 4 corners.
 */
const NUM_VERTICES_PER_ELEMENT = 4;
/**
 * Number of indices added per box/glyph: 2 triangles, 6 indices.
 */
const NUM_INDICES_PER_ELEMENT = 6;
/**
 * Number of values per position.
 */
const NUM_POSITION_VALUES_PER_VERTEX = 3;
/**
 * Number of values per color.
 */
const NUM_COLOR_VALUES_PER_VERTEX = 4;
/**
 * Number of values per UV.
 */
const NUM_UV_VALUES_PER_VERTEX = 4;
/**
 * Number of values per index.
 */
const NUM_INDEX_VALUES_PER_VERTEX = 1;
/**
 * Number of bytes for float in an Float32Array.
 */
const NUM_BYTES_PER_FLOAT = 4;
/**
 * Number of bytes for integer number in an UInt32Array.
 */
const NUM_BYTES_PER_INT32 = 4;
/**
 * SubClass of [[THREE.Mesh]] to identify meshes that have been created by [[BoxBuffer]] and
 * [[TextBuffer]]. Add the isEmpty flag to quickly test for empty meshes.
 */
class BoxBufferMesh extends THREE.Mesh {
    constructor(geometry, material) {
        super(geometry, material);
        this.type = "BoxBufferMesh";
    }
    /**
     * A mesh that has no positions and indices set is defined to be empty.
     *
     * @returns `True` if no indices have been added to the mesh.
     */
    get isEmpty() {
        if (this.geometry === undefined) {
            return true;
        }
        else {
            const bufferGeometry = this.geometry;
            return bufferGeometry.index === null || bufferGeometry.index.count === 0;
        }
    }
}
exports.BoxBufferMesh = BoxBufferMesh;
/**
 * Buffer for (untransformed) `Box2` objects. Can be used to create a single geometry for screen-
 * aligned boxes, like POIs.
 */
class BoxBuffer {
    /**
     * Creates a new `BoxBuffer`.
     *
     * @param material Material to be used for [[Mesh]] of this `BoxBuffer`.
     * @param renderOrder Optional renderOrder of this buffer.
     * @param startElementCount Initial number of elements this `BoxBuffer` can hold.
     * @param maxElementCount Maximum number of elements this `BoxBuffer` can hold.
     */
    constructor(material, renderOrder = 0, startElementCount = START_BOX_BUFFER_SIZE, maxElementCount = MAX_BOX_BUFFER_SIZE) {
        this.material = material;
        this.renderOrder = renderOrder;
        this.startElementCount = startElementCount;
        this.maxElementCount = maxElementCount;
        this.m_size = 0;
        this.resizeBuffer(startElementCount);
        this.pickInfos = new Array();
    }
    /**
     * Duplicate this `BoxBuffer` with same material and renderOrder.
     *
     * @returns A clone of this `BoxBuffer`.
     */
    clone() {
        return new BoxBuffer(this.material, this.renderOrder);
    }
    /**
     * Dispose of the geometry.
     */
    dispose() {
        if (this.geometry !== undefined) {
            this.geometry.dispose();
            this.geometry = undefined;
        }
        this.internalMesh = undefined;
    }
    /**
     * Return the current number of elements the buffer can hold.
     */
    get size() {
        return this.m_size;
    }
    /**
     * Clear's the `BoxBuffer` attribute buffers.
     */
    reset() {
        if (this.positionAttribute !== undefined) {
            this.positionAttribute.count = 0;
            this.colorAttribute.count = 0;
            this.uvAttribute.count = 0;
            this.indexAttribute.count = 0;
            this.pickInfos.length = 0;
        }
    }
    /**
     * Returns `true` if this `BoxBuffer` can hold the specified amount of glyphs. If the buffer
     * can only add the glyph by increasing the buffer size, the resize() method is called, which
     * will then create a new geometry for the mesh.
     *
     * @param glyphCount Number of glyphs to be added to the buffer.
     * @returns `true` if the element (box or glyph) can be added to the buffer, `false` otherwise.
     */
    canAddElements(glyphCount = 1) {
        const indexAttribute = this.indexAttribute;
        if (indexAttribute.count + glyphCount * NUM_INDICES_PER_ELEMENT >=
            indexAttribute.array.length) {
            // Too many elements for the current buffer, check if we can resize the buffer.
            if (indexAttribute.array.length >= this.maxElementCount * NUM_INDICES_PER_ELEMENT) {
                return false;
            }
            const newSize = Math.min(this.maxElementCount, this.size === 0 ? 256 : this.size * 2);
            this.resize(newSize);
        }
        return true;
    }
    /**
     * Returns this `BoxBuffer`'s attribute [[State]].
     */
    saveState() {
        const state = {
            positionAttributeCount: this.positionAttribute.count,
            colorAttributeCount: this.colorAttribute.count,
            uvAttributeCount: this.uvAttribute.count,
            indexAttributeCount: this.indexAttribute.count,
            pickInfoCount: this.pickInfos.length
        };
        return state;
    }
    /**
     * Store this `BoxBuffer`'s attribute [[State]] to a previously stored one.
     *
     * @param state [[State]] struct describing a previous attribute state.
     */
    restoreState(state) {
        this.positionAttribute.count = state.positionAttributeCount;
        this.colorAttribute.count = state.colorAttributeCount;
        this.uvAttribute.count = state.uvAttributeCount;
        this.indexAttribute.count = state.indexAttributeCount;
        this.pickInfos.length = state.pickInfoCount;
    }
    /**
     * Adds a new box to this `BoxBuffer`.
     *
     * @param screenBox [[Math2D.Box]] holding screen coordinates for this box.
     * @param uvBox [[Math2D.UvBox]] holding uv coordinates for this box.
     * @param color Box's color.
     * @param opacity Box's opacity.
     * @param distance Box's distance to camera.
     * @param pickInfo Box's picking information.
     */
    addBox(screenBox, uvBox, color, opacity, distance, pickInfo) {
        if (!this.canAddElements()) {
            return false;
        }
        const { s0, t0, s1, t1 } = uvBox;
        const { x, y, w, h } = screenBox;
        const r = Math.round(color.r * 255);
        const g = Math.round(color.g * 255);
        const b = Math.round(color.b * 255);
        const a = Math.round(opacity * 255);
        const positionAttribute = this.positionAttribute;
        const colorAttribute = this.colorAttribute;
        const uvAttribute = this.uvAttribute;
        const indexAttribute = this.indexAttribute;
        const baseVertex = positionAttribute.count;
        const baseIndex = indexAttribute.count;
        positionAttribute.setXYZ(baseVertex, x, y, distance);
        positionAttribute.setXYZ(baseVertex + 1, x + w, y, distance);
        positionAttribute.setXYZ(baseVertex + 2, x, y + h, distance);
        positionAttribute.setXYZ(baseVertex + 3, x + w, y + h, distance);
        colorAttribute.setXYZW(baseVertex, r, g, b, a);
        colorAttribute.setXYZW(baseVertex + 1, r, g, b, a);
        colorAttribute.setXYZW(baseVertex + 2, r, g, b, a);
        colorAttribute.setXYZW(baseVertex + 3, r, g, b, a);
        uvAttribute.setXY(baseVertex, s0, t0);
        uvAttribute.setXY(baseVertex + 1, s1, t0);
        uvAttribute.setXY(baseVertex + 2, s0, t1);
        uvAttribute.setXY(baseVertex + 3, s1, t1);
        indexAttribute.setX(baseIndex, baseVertex);
        indexAttribute.setX(baseIndex + 1, baseVertex + 1);
        indexAttribute.setX(baseIndex + 2, baseVertex + 2);
        indexAttribute.setX(baseIndex + 3, baseVertex + 2);
        indexAttribute.setX(baseIndex + 4, baseVertex + 1);
        indexAttribute.setX(baseIndex + 5, baseVertex + 3);
        positionAttribute.count += NUM_VERTICES_PER_ELEMENT;
        colorAttribute.count += NUM_VERTICES_PER_ELEMENT;
        uvAttribute.count += NUM_VERTICES_PER_ELEMENT;
        indexAttribute.count += NUM_INDICES_PER_ELEMENT;
        this.pickInfos.push(pickInfo);
        return true;
    }
    /**
     * Updates a [[BufferGeometry]] object to reflect the changes in this `TextBuffer`'s attribute
     * data.
     */
    updateBufferGeometry() {
        const positionAttribute = this.positionAttribute;
        const colorAttribute = this.colorAttribute;
        const uvAttribute = this.uvAttribute;
        const indexAttribute = this.indexAttribute;
        if (positionAttribute.count > 0) {
            positionAttribute.needsUpdate = true;
            positionAttribute.updateRange.offset = 0;
            positionAttribute.updateRange.count =
                positionAttribute.count * NUM_VERTICES_PER_ELEMENT;
        }
        if (colorAttribute.count > 0) {
            colorAttribute.needsUpdate = true;
            colorAttribute.updateRange.offset = 0;
            colorAttribute.updateRange.count = colorAttribute.count * NUM_VERTICES_PER_ELEMENT;
        }
        if (uvAttribute.count > 0) {
            uvAttribute.needsUpdate = true;
            uvAttribute.updateRange.offset = 0;
            uvAttribute.updateRange.count = uvAttribute.count * NUM_VERTICES_PER_ELEMENT;
        }
        if (indexAttribute.count > 0) {
            indexAttribute.needsUpdate = true;
            indexAttribute.updateRange.offset = 0;
            indexAttribute.updateRange.count = indexAttribute.count;
        }
        if (this.geometry !== undefined) {
            this.geometry.clearGroups();
            this.geometry.addGroup(0, this.indexAttribute.count);
        }
    }
    /**
     * Check if the buffer is empty. If it is empty, the memory usage is minimized to reduce
     * footprint.
     */
    cleanUp() {
        // If there is nothing in this buffer, resize it, it may never be used again.
        if (this.indexAttribute.count === 0 && this.size > START_BOX_BUFFER_SIZE) {
            this.clearAttributes();
        }
    }
    /**
     * Determine if the mesh is empty.
     */
    get isEmpty() {
        return this.internalMesh.isEmpty;
    }
    /**
     * Get the [[Mesh]] object. The geometry instance of the mesh may change if the buffers are
     * resized. The mesh, once created, will not change, so it can always be added to the scene.
     */
    get mesh() {
        if (this.internalMesh === undefined) {
            this.resize();
        }
        return this.internalMesh;
    }
    /**
     * Fill the picking results for the pixel with the given screen coordinate. If multiple
     * boxes are found, the order of the results is unspecified.
     *
     * @param screenPosition Screen coordinate of picking position.
     * @param pickCallback Callback to be called for every picked element.
     * @param imageData Image data to test if the pixel is transparent
     */
    pickBoxes(screenPosition, pickCallback, imageData) {
        const n = this.pickInfos.length;
        const pickInfos = this.pickInfos;
        const positions = this.positionAttribute;
        const screenX = screenPosition.x;
        const screenY = screenPosition.y;
        const canvas = document.createElement("canvas");
        for (let pickInfoIndex = 0; pickInfoIndex < n; pickInfoIndex++) {
            const positionIndex = pickInfoIndex * NUM_VERTICES_PER_ELEMENT;
            const minX = positions.getX(positionIndex);
            if (screenX < minX) {
                continue;
            }
            const maxX = positions.getX(positionIndex + 1);
            if (screenX > maxX) {
                continue;
            }
            const minY = positions.getY(positionIndex);
            if (screenY < minY) {
                continue;
            }
            const maxY = positions.getY(positionIndex + 2);
            if (screenY > maxY) {
                continue;
            }
            const box = new harp_utils_1.Math2D.Box(minX, minY, maxX - minX, maxY - minY);
            if (imageData !== undefined &&
                pickInfos[pickInfoIndex].poiInfo !== undefined &&
                pickInfos[pickInfoIndex].poiInfo.uvBox !== undefined &&
                this.isPixelTransparent(imageData, screenX, screenY, box, pickInfos[pickInfoIndex].poiInfo.uvBox, canvas)) {
                continue;
            }
            if (pickInfos[pickInfoIndex] !== undefined) {
                pickCallback(pickInfos[pickInfoIndex]);
            }
        }
    }
    /**
     * Creates a new [[Geometry]] object from all the attribute data stored in this `BoxBuffer`.
     * The [[Mesh]] object may be created if it is not initialized already.
     *
     * @param newSize Optional number of elements to resize the buffer to.
     * @param forceResize Optional flag to force a resize even if new size is smaller than before.
     */
    resize(newSize, forceResize) {
        if (this.geometry !== undefined) {
            this.geometry.dispose();
        }
        this.geometry = new THREE.BufferGeometry();
        if (newSize !== undefined && (forceResize === true || newSize > this.size)) {
            this.resizeBuffer(newSize);
        }
        this.geometry.setAttribute("position", this.positionAttribute);
        this.geometry.setAttribute("color", this.colorAttribute);
        this.geometry.setAttribute("uv", this.uvAttribute);
        this.geometry.setIndex(this.indexAttribute);
        this.geometry.addGroup(0, this.indexAttribute.count);
        if (this.internalMesh === undefined) {
            this.internalMesh = new BoxBufferMesh(this.geometry, this.material);
            this.internalMesh.renderOrder = this.renderOrder;
        }
        else {
            this.internalMesh.geometry = this.geometry;
        }
        return this.internalMesh;
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `BoxBuffer`.
     *
     * @param info The info object to increment with the values from this `BoxBuffer`.
     */
    updateMemoryUsage(info) {
        const numBytes = this.positionAttribute.count * NUM_POSITION_VALUES_PER_VERTEX * NUM_BYTES_PER_FLOAT +
            this.colorAttribute.count * NUM_COLOR_VALUES_PER_VERTEX +
            this.uvAttribute.count * NUM_UV_VALUES_PER_VERTEX * NUM_BYTES_PER_FLOAT +
            this.indexAttribute.count * NUM_BYTES_PER_INT32; // May be UInt16, so we overestimate
        info.heapSize += numBytes;
        info.gpuSize += numBytes;
    }
    /**
     * Check if a pixel is transparent or not.
     *
     * @param imageData Data containing the pixels.
     * @param xScreenPos X position of the pixel.
     * @param yScreenPos Y position of the pixel.
     * @param box Bounding box of the image in screen coordinates.
     * @param uvBox Uv box referred to the given bounding box.
     * @param canvas Canvas element that will be used to draw the image, in case the imageData is an
     *      ImageBitmap
     */
    isPixelTransparent(imageData, xScreenPos, yScreenPos, box, uvBox, canvas) {
        let pixelIsTransparent = false;
        const { u, v } = PixelPicker_1.screenToUvCoordinates(xScreenPos, yScreenPos, box, uvBox);
        const imageWidth = imageData.width;
        const x = imageWidth * u;
        const imageHeight = imageData.height;
        const y = imageHeight * v;
        const pixel = PixelPicker_1.getPixelFromImage(x, y, imageData, canvas);
        if (pixel !== undefined && pixel[3] === 0) {
            pixelIsTransparent = true;
        }
        return pixelIsTransparent;
    }
    /**
     * Remove current attributes and arrays. Minimizes memory footprint.
     */
    clearAttributes() {
        this.positionAttribute = undefined;
        this.colorAttribute = undefined;
        this.uvAttribute = undefined;
        this.indexAttribute = undefined;
        this.resize(START_BOX_BUFFER_SIZE, true);
    }
    /**
     * Resize the attribute buffers. New value must be larger than the previous one.
     *
     * @param newSize New number of elements in the buffer. Number has to be larger than the
     *      previous size.
     */
    resizeBuffer(newSize) {
        const newPositionArray = new Float32Array(newSize * NUM_VERTICES_PER_ELEMENT * NUM_POSITION_VALUES_PER_VERTEX);
        if (this.positionAttribute !== undefined && this.positionAttribute.array.length > 0) {
            const positionAttributeCount = this.positionAttribute.count;
            newPositionArray.set(this.positionAttribute.array);
            this.positionAttribute.array = newPositionArray;
            this.positionAttribute.count = positionAttributeCount;
        }
        else {
            this.positionAttribute = new THREE.BufferAttribute(newPositionArray, NUM_POSITION_VALUES_PER_VERTEX);
            this.positionAttribute.count = 0;
            this.positionAttribute.setUsage(THREE.DynamicDrawUsage);
        }
        const newColorArray = new Uint8Array(newSize * NUM_VERTICES_PER_ELEMENT * NUM_COLOR_VALUES_PER_VERTEX);
        if (this.colorAttribute !== undefined) {
            const colorAttributeCount = this.colorAttribute.count;
            newColorArray.set(this.colorAttribute.array);
            this.colorAttribute.array = newColorArray;
            this.colorAttribute.count = colorAttributeCount;
        }
        else {
            this.colorAttribute = new THREE.BufferAttribute(newColorArray, NUM_COLOR_VALUES_PER_VERTEX, true);
            this.colorAttribute.count = 0;
            this.colorAttribute.setUsage(THREE.DynamicDrawUsage);
        }
        const newUvArray = new Float32Array(newSize * NUM_VERTICES_PER_ELEMENT * NUM_UV_VALUES_PER_VERTEX);
        if (this.uvAttribute !== undefined) {
            const uvAttributeCount = this.uvAttribute.count;
            newUvArray.set(this.uvAttribute.array);
            this.uvAttribute.array = newUvArray;
            this.uvAttribute.count = uvAttributeCount;
        }
        else {
            this.uvAttribute = new THREE.BufferAttribute(newUvArray, NUM_UV_VALUES_PER_VERTEX);
            this.uvAttribute.count = 0;
            this.uvAttribute.setUsage(THREE.DynamicDrawUsage);
        }
        const numIndexValues = newSize * NUM_INDICES_PER_ELEMENT * NUM_INDEX_VALUES_PER_VERTEX;
        const newIndexArray = numIndexValues > 65535
            ? new Uint32Array(numIndexValues)
            : new Uint16Array(numIndexValues);
        if (this.indexAttribute !== undefined) {
            const indexAttributeCount = this.indexAttribute.count;
            newIndexArray.set(this.indexAttribute.array);
            this.indexAttribute.array = newIndexArray;
            this.indexAttribute.count = indexAttributeCount;
        }
        else {
            this.indexAttribute = new THREE.BufferAttribute(newIndexArray, NUM_INDEX_VALUES_PER_VERTEX);
            this.indexAttribute.count = 0;
            this.indexAttribute.setUsage(THREE.DynamicDrawUsage);
        }
        this.m_size = newSize;
    }
}
exports.BoxBuffer = BoxBuffer;


/***/ }),

/***/ "../harp-mapview/lib/poi/PixelPicker.ts":
/*!**********************************************!*\
  !*** ../harp-mapview/lib/poi/PixelPicker.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
/**
 * It returns an array containing the channel colors for the pixel at the given coordinates.
 *
 * @param xPos X value of the pixel.
 * @param yPos Y value of the pixel.
 * @param imageData Data containing the pixels.
 * @param canvas Canvas element that will be used to draw the image, in case the imageData is an
 * ImageBitmap
 */
function getPixelFromImage(xPos, yPos, imageData, canvas) {
    let pickedColor;
    const isImageBitmap = (imgData) => {
        return imgData.close !== undefined;
    };
    if (isImageBitmap(imageData)) {
        if (canvas === undefined) {
            canvas = document.createElement("canvas");
        }
        pickedColor = getPixelFromImageBitmap(imageData, xPos, yPos, canvas);
    }
    else {
        const pixelsData = imageData;
        const stride = pixelsData.data.length / (pixelsData.height * pixelsData.width);
        pickedColor = getPixelFromImageData(pixelsData, xPos, yPos, stride);
    }
    return pickedColor;
}
exports.getPixelFromImage = getPixelFromImage;
/**
 * Given the x and y position in screen coordinates inside the target box, it map them to the UV
 * coordinates.
 * @param screenX X value in screen coordinates.
 * @param screenY Y value in screen coordinates.
 * @param box Bounding box in screen coordinates.
 * @param uvBox Uv box referred to the given bounding box.
 */
function screenToUvCoordinates(screenX, screenY, box, uvBox) {
    const minX = box.x;
    const maxX = box.x + box.w;
    const minY = box.y;
    const maxY = box.y + box.h;
    const u = harp_utils_1.MathUtils.map(screenX, minX, maxX, uvBox.s0, uvBox.s1);
    const v = harp_utils_1.MathUtils.map(screenY, minY, maxY, uvBox.t0, uvBox.t1);
    return { u, v };
}
exports.screenToUvCoordinates = screenToUvCoordinates;
/**
 * It returns an Uint8ClampedArray containing the color channel values for the given pixel
 * coordinates. It returns undefined if the given coordinates are out of range.
 *
 * @param image Bitmap image in which the pixels are stored.
 * @param xPos X value of the pixel.
 * @param yPos Y value of the pixel.
 * @param canvas HTML Canvas element on which the image is drawn.
 */
function getPixelFromImageBitmap(image, xPos, yPos, canvas) {
    if (xPos > image.width || xPos < 0 || yPos > image.height || yPos < 0) {
        return undefined;
    }
    let pixelData;
    canvas.width = image.width;
    canvas.height = image.height;
    const context = canvas.getContext("2d");
    if (context !== null) {
        context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
        pixelData = context.getImageData(xPos, yPos, 1, 1).data;
    }
    return pixelData;
}
exports.getPixelFromImageBitmap = getPixelFromImageBitmap;
/**
 * It returns an Uint8ClampedArray containing the color channel values for the given pixel
 * coordinates. It returns undefined if the given coordinates are out of range.
 *
 * @param image Image data in which the pixels are stored.
 * @param xPos X value of the pixel.
 * @param yPos Y value of the pixel.
 * @param stride The stride value of the image data.
 */
function getPixelFromImageData(imgData, xPos, yPos, stride) {
    const getPixel = (imageData, index, strd) => {
        const i = index * strd;
        const d = imageData.data;
        const pixel = new Uint8ClampedArray(strd);
        for (let s = 0; s < strd; s++) {
            pixel[0] = d[i + s];
        }
        return pixel;
    };
    if (xPos > imgData.width || xPos < 0 || yPos > imgData.height || yPos < 0) {
        return undefined;
    }
    return getPixel(imgData, yPos * imgData.width + xPos, stride);
}
exports.getPixelFromImageData = getPixelFromImageData;


/***/ }),

/***/ "../harp-mapview/lib/poi/Poi.ts":
/*!**************************************!*\
  !*** ../harp-mapview/lib/poi/Poi.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This enum defines the possible origin points for an image.
 */
var ImageOrigin;
(function (ImageOrigin) {
    ImageOrigin[ImageOrigin["TopLeft"] = 0] = "TopLeft";
    ImageOrigin[ImageOrigin["BottomLeft"] = 1] = "BottomLeft";
})(ImageOrigin = exports.ImageOrigin || (exports.ImageOrigin = {}));
/**
 * Defines a part (or all) of an image as a texture.
 */
class IconTexture {
    /**
     * The constructor of an `IconTexture`.
     *
     * @param image An [[ImageItem]] instance.
     * @param options The rendering parameters.
     */
    constructor(image) {
        this.image = image;
    }
}
exports.IconTexture = IconTexture;
// export enum TextAlign {
//     Center,
//     Left,
//     Right,
//     // ??? expands lines to have same length.
//     Justify
// }
// export interface LayoutOptions {
//     paddingH?: number;
//     paddingV: number;
//     transFormCenterX?: number;
//     transFormCenterY?: number;
//     rotation?: number;
//     /** Set to `true` to enlarge the box after rotation to include all rotated corners. */
//     rotationEnlargesBox: boolean;
// }
// export interface TextOptions {
//     bgColor?: THREE.Color;
//     wrapWords?: boolean;
//     maxNumLines?: number;
//     maxWidth?: number;
//     /** Replace with ellipsis if wider than maxWidth. */
//     addEllipsis?: boolean;
//     /** Handle right-to-left texts */
//     isRightToLeft?: boolean;
//     textAlignH?: AlignH; // = AlignH.Center;
//     textAlignV?: AlignV; // = AlignV.Center;
// }
// export class IconLabel {
//     constructor(text: string, options: LayoutOptions | TextOptions) {}
//     /**
//      * Setup a box with size and padding.
//      *
//      * @param box Target box to set up.
//      */
//     getBox(box: THREE.Box2) {}
//     /**
//      * Compute width and height from text and font.
//      */
//     computeBox() {}
//     /**
//      * Generate the glyphs and keep them in a buffer. Generates a fixed layout.
//      */
//     prepareRendering() {}
// }
// export enum AlignH {
//     Center,
//     Left,
//     Right
// }
// export enum AlignV {
//     Center,
//     Top,
//     Bottom
// }
// export enum AnchorTarget {
//     /** Anchor point relative to Icon */
//     Icon,
//     /** Anchor point is transform center of icon */
//     IconCenter,
//     /** Anchor point relative to Icon including padding */
//     IconBox,
//     /** Anchor point relative to Label */
//     Label,
//     /** Anchor point relative to combination of Icon and Label */
//     Box
// }
// export class AnchorPosition {
//     targetH: AnchorTarget = AnchorTarget.Icon;
//     targetV: AnchorTarget = AnchorTarget.Icon;
//     alignH: AlignH = AlignH.Center;
//     alignV: AlignV = AlignV.Center;
// }
// export enum IconPinMode {
//     /** Pinned down, anchor point is the same at all angles. */
//     PinDown,
//     /**
//      * Icon stands up. "StreetLevel"-style. The anchor point moves to the bottom of the icon when
//      * the view direction gets parallel to the ground.
//      */
//     StandUp
// }
// export interface IconScaleOptions {
//     depthScale?: boolean;
//     minimumScale?: number;
// }
// export interface IconOptions {
//     useScreenSpace?: boolean; // = true
//     priority?: number;
//     scaleOptions?: IconScaleOptions;
//     /** Optional offset in screen space */
//     screenOffsetX?: number;
//     screenOffsetY?: number;
//     /** Optional 3D height above terrain. */
//     heightAboveGround?: number;
// }
// export class SimplePoiIcon {
//     constructor(
//         readonly pos: THREE.Vector3,
//         readonly image ?: IconTexture,
//         options ?: IconOptions
//     ) { }
// }
// export class PoiIcon {
//     constructor(
//         readonly pos: THREE.Vector3,
//         readonly image?: IconTexture,
//         readonly label?: IconLabel,
//         options?: IconOptions
//     ) {}
// }
// export interface PoiOptions {
//     featureId?: number;
//     minZoomLevel?: number;
// }
// export class SimplePoi {
//     private m_featureId?: number;
//     private m_minZoomLevel: number = 0;
//     constructor(readonly icon: SimplePoiIcon, options?: PoiOptions) {
//         if (options !== undefined) {
//             this.m_featureId = options.featureId;
//             this.m_minZoomLevel = options.minZoomLevel !== undefined ? options.minZoomLevel : 0;
//         }
//     }
// }
// export class Poi {
//     /** store multiple icons, one for every LOD */
//     private m_icons: PoiIcon[] = [];
//     private m_lod = 0;
//     private m_featureId?: number;
//     private m_minZoomLevel: number = 0;
//     constructor(icon: PoiIcon, options?: PoiOptions) {
//         this.m_icons.push(icon);
//         if (options !== undefined) {
//             this.m_featureId = options.featureId;
//             this.m_minZoomLevel = options.minZoomLevel !== undefined ? options.minZoomLevel : 0;
//         }
//     }
//     icon(): PoiIcon | undefined {
//         return this.m_icons[this.m_lod];
//     }
//     /**
//      * Select the level of detail that should be used.
//      *
//      * @param levelOfDetail Level of detail to render.
//      */
//     selectIcon(levelOfDetail: number) {}
// }


/***/ }),

/***/ "../harp-mapview/lib/poi/PoiManager.ts":
/*!*********************************************!*\
  !*** ../harp-mapview/lib/poi/PoiManager.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "../harp-text-canvas/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const THREE = __webpack_require__(/*! three */ "three");
const TextElement_1 = __webpack_require__(/*! ../text/TextElement */ "../harp-mapview/lib/text/TextElement.ts");
const TextElementsRenderer_1 = __webpack_require__(/*! ../text/TextElementsRenderer */ "../harp-mapview/lib/text/TextElementsRenderer.ts");
const logger = harp_utils_1.LoggerManager.instance.create("PoiManager");
/**
 * POI manager class, responsible for loading the [[PoiGeometry]] objects from the [[DecodedTile]],
 * and preparing them for rendering. Also loads and manages the texture atlases for the icons.
 */
class PoiManager {
    /**
     * The constructor of the `PoiManager`.
     *
     * @param mapView The [[MapView]] instance that should display the POIs.
     */
    constructor(mapView) {
        this.mapView = mapView;
        this.m_imageTextures = new Map();
        this.m_poiShieldGroups = new Map();
    }
    /**
     * Warn about a missing POI table name, but only once.
     * @param poiTableName POI mapping table name.
     * @param poiTable POI table instance.
     */
    static notifyMissingPoiTable(poiTableName, poiTable) {
        if (poiTableName === undefined) {
            poiTableName = "undefined";
        }
        if (PoiManager.m_missingPoiTableName.get(poiTableName) === undefined) {
            PoiManager.m_missingPoiTableName.set(poiTableName, true);
            if (poiTable !== undefined && !poiTable.loadedOk) {
                logger.error(`updatePoiFromPoiTable: Could not load POI table '${poiTableName}'!`);
            }
            else {
                logger.error(`updatePoiFromPoiTable: No POI table with name '${poiTableName}' found!`);
            }
        }
    }
    /**
     * Warn about a missing POI name, but only once.
     * @param poiName name of POI.
     * @param poiTableName POI mapping table name.
     */
    static notifyMissingPoi(poiName, poiTableName) {
        if (poiName === undefined) {
            poiName = "undefined";
        }
        const key = `${poiTableName}[${poiName}]`;
        if (PoiManager.m_missingPoiName.get(key) === undefined) {
            PoiManager.m_missingPoiName.set(key, true);
            logger.warn(`updatePoiFromPoiTable: ` +
                `Cannot find POI info for '${poiName}' in table '${poiTableName}'.`);
        }
    }
    /**
     * Add all POIs from a decoded tile and store them as [[TextElement]]s in the [[Tile]].
     *
     * Also handles LineMarkers, which is a recurring marker along a line (road).
     *
     * @param tile Tile to add POIs to.
     * @param decodedTile DecodedTile containing the raw [[PoiGeometry]] objects describing the
     *  POIs.
     */
    addPois(tile, decodedTile) {
        const poiGeometries = harp_utils_1.assertExists(decodedTile.poiGeometries);
        const worldOffsetX = tile.computeWorldOffsetX();
        for (const poiGeometry of poiGeometries) {
            harp_utils_1.assert(poiGeometry.technique !== undefined);
            const techniqueIndex = harp_utils_1.assertExists(poiGeometry.technique);
            const technique = decodedTile.techniques[techniqueIndex];
            if (technique.enabled === false ||
                (!harp_datasource_protocol_1.isLineMarkerTechnique(technique) && !harp_datasource_protocol_1.isPoiTechnique(technique))) {
                continue;
            }
            // The POI may be in the data, and there may be a Technique, but the technique may
            // specify to not show it.
            if (technique.showOnMap === false) {
                continue;
            }
            const positions = new THREE.BufferAttribute(new Float32Array(poiGeometry.positions.buffer), poiGeometry.positions.itemCount);
            if (harp_datasource_protocol_1.isLineMarkerTechnique(technique) && positions.count > 0) {
                this.addLineMarker(tile, poiGeometry, technique, positions, worldOffsetX);
            }
            else if (harp_datasource_protocol_1.isPoiTechnique(technique)) {
                this.addPoi(tile, poiGeometry, technique, positions, worldOffsetX);
            }
        }
    }
    /**
     * Load the texture atlas that defines the segments of the texture that should be used for
     * specific icons. Creates an [[ImageTexture]] for every element in the atlas, such that it can
     * be addressed in the theme file.
     *
     * @param imageName Name of the image from the theme (NOT the url!).
     * @param atlas URL of the JSON file defining the texture atlas.
     */
    addTextureAtlas(imageName, atlas) {
        fetch(atlas)
            .then(response => {
            if (!response.ok) {
                throw new Error(`addTextureAtlas: Cannot load textureAtlas: ${response.statusText}`);
            }
            return response.json();
        })
            .then((jsonAtlas) => {
            if (jsonAtlas === undefined) {
                logger.info(`addTextureAtlas: TextureAtlas empty: ${atlas}`);
                return;
            }
            try {
                logger.debug(`addTextureAtlas: Loading textureAtlas '${atlas}' for image '${imageName}'`);
                for (const textureName of Object.getOwnPropertyNames(jsonAtlas)) {
                    const imageTextureDef = jsonAtlas[textureName];
                    const imageTexture = {
                        name: textureName,
                        image: imageName,
                        xOffset: imageTextureDef.x,
                        yOffset: imageTextureDef.y,
                        width: imageTextureDef.width,
                        height: imageTextureDef.height
                    };
                    this.addImageTexture(imageTexture);
                }
            }
            catch (ex) {
                logger.error(`addTextureAtlas: Failed to load textureAtlas ` + `'${atlas}' : ${ex}`);
            }
            this.mapView.update();
        })
            .catch((reason) => {
            logger.error(`addTextureAtlas: Failed to load textureAtlas '${atlas}' : ${reason}`);
        });
    }
    /**
     * Add an [[ImageTexture]] such that it is available as a named entity for techniques in theme
     * files.
     *
     * @param imageTexture [[ImageTexture]] that should be available for POIs.
     */
    addImageTexture(imageTexture) {
        if (imageTexture.name === undefined) {
            logger.error("addImageTexture: Name required", imageTexture);
            return;
        }
        if (this.m_imageTextures.get(imageTexture.name) !== undefined) {
            logger.warn(`addImageTexture: Name already used: ${imageTexture.name}` + ` (overriding it)`);
        }
        this.m_imageTextures.set(imageTexture.name, imageTexture);
    }
    /**
     * Return the [[ImageTexture]] registered under the specified name.
     *
     * @param name Name of the [[ImageTexture]].
     */
    getImageTexture(name) {
        return this.m_imageTextures.get(name);
    }
    /**
     * Update the [[TextElement]] with the information taken from the [[PoiTable]] which is
     * referenced in the [[PoiInfo]] of the pointLabel.
     *
     * If the requested [[PoiTable]] is not available yet, the function returns `false`.
     * If the [[PoiTable]] is not defined, or if the references POI has no entry in
     * the [[PoiTable]], no action is taken, and the function returns `false`.
     *
     * If the [[PoiTable]] has been processed, it returns `true`, indicating that this function
     * doesn't have to be called again.
     *
     * @param pointLabel The [[TextElement]] to update.
     *
     * @returns `true` if the [[PoiTable]] has been processed, and the function does not have to be
     *          called again.
     */
    updatePoiFromPoiTable(pointLabel) {
        const poiInfo = pointLabel.poiInfo;
        // PoiTable requires poiName to be defined otherwise mapping via PoiTable is
        // not possible, such as table key is not defined.
        if (poiInfo === undefined ||
            poiInfo.poiTableName === undefined ||
            poiInfo.poiName === undefined) {
            return true;
        }
        // Try to acquire PoiTable
        const poiTableName = poiInfo.poiTableName;
        const poiTable = this.mapView.poiTableManager.getPoiTable(poiTableName);
        // Check if PoiTable is found, but its still loading.
        if (poiTable !== undefined && poiTable.isLoading) {
            // The PoiTable is still loading, we have to try again.
            return false;
        }
        // Remove poiTableName to mark this POI as processed.
        poiInfo.poiTableName = undefined;
        // PoiTable not found or can not be loaded.
        if (poiTable === undefined || !poiTable.loadedOk) {
            PoiManager.notifyMissingPoiTable(poiTableName, poiTable);
            return true;
        }
        // Try to acquire PoiTableEntry.
        const poiName = poiInfo.poiName;
        const poiTableEntry = poiTable.getEntry(poiName);
        if (poiTableEntry === undefined) {
            PoiManager.notifyMissingPoi(poiName, poiTableName);
            return true;
        }
        if (poiTableEntry.iconName !== undefined && poiTableEntry.iconName.length > 0) {
            poiInfo.imageTextureName = harp_datasource_protocol_1.composeTechniqueTextureName(poiTableEntry.iconName, poiInfo.technique);
        }
        pointLabel.visible =
            poiTableEntry.visible !== undefined ? poiTableEntry.visible : pointLabel.visible;
        pointLabel.priority =
            poiTableEntry.priority !== undefined ? poiTableEntry.priority : pointLabel.priority;
        poiInfo.iconMinZoomLevel =
            poiTableEntry.iconMinLevel !== undefined
                ? poiTableEntry.iconMinLevel
                : poiInfo.iconMinZoomLevel;
        poiInfo.iconMaxZoomLevel =
            poiTableEntry.iconMaxLevel !== undefined
                ? poiTableEntry.iconMaxLevel
                : poiInfo.iconMaxZoomLevel;
        poiInfo.textMinZoomLevel =
            poiTableEntry.textMinLevel !== undefined
                ? poiTableEntry.textMinLevel
                : poiInfo.textMinZoomLevel;
        poiInfo.textMaxZoomLevel =
            poiTableEntry.textMaxLevel !== undefined
                ? poiTableEntry.textMaxLevel
                : poiInfo.textMaxZoomLevel;
        pointLabel.updateMinMaxZoomLevelsFromPoiInfo();
        return true;
    }
    /**
     * Clear internal state. Applicable when switching themes.
     */
    clear() {
        this.m_imageTextures.clear();
        this.m_poiShieldGroups.clear();
    }
    /**
     * Add the LineMarker as a POI with a series of positions. Make sure that the LineMarkers
     * having the same visual all get their `shieldGroupIndex` set appropriately, so it can be taken
     * care of later that not too many of them are rendered (obey `minDistance` attribute).
     */
    addLineMarker(tile, poiGeometry, technique, positions, worldOffsetX) {
        let imageTextureName = technique.imageTexture !== undefined
            ? harp_datasource_protocol_1.composeTechniqueTextureName(technique.imageTexture, technique)
            : undefined;
        let text = "";
        let userData;
        let featureId;
        if (poiGeometry.stringCatalog !== undefined) {
            harp_utils_1.assert(poiGeometry.texts.length > 0);
            text = poiGeometry.stringCatalog[poiGeometry.texts[0]] || "";
            if (poiGeometry.objInfos !== undefined) {
                userData = poiGeometry.objInfos[0];
                featureId = harp_datasource_protocol_1.getFeatureId(userData);
            }
            if (poiGeometry.imageTextures !== undefined) {
                harp_utils_1.assert(poiGeometry.imageTextures.length > 0);
                imageTextureName = poiGeometry.stringCatalog[poiGeometry.imageTextures[0]];
            }
        }
        // let the combined image texture name (name of image in atlas, not the URL) and
        // text of the shield be the group key, at worst scenario it may be:
        // "undefined-"
        const groupKey = String(imageTextureName) + "-" + text;
        let shieldGroupIndex = this.m_poiShieldGroups.get(groupKey);
        if (shieldGroupIndex === undefined) {
            shieldGroupIndex = this.m_poiShieldGroups.size;
            this.m_poiShieldGroups.set(groupKey, shieldGroupIndex);
        }
        // Debugging help to identify the group of a shield :
        // text = groupKey + ": " + text;
        const positionArray = [];
        for (let i = 0; i < positions.count; i += 3) {
            const x = positions.getX(i) + worldOffsetX;
            const y = positions.getY(i);
            const z = positions.getZ(i);
            positionArray.push(new THREE.Vector3(x, y, z));
        }
        const textElement = this.checkCreateTextElement(tile, text, technique, imageTextureName, undefined, // TBD for road shields
        undefined, shieldGroupIndex, featureId, positionArray, undefined, undefined, userData);
        // If the poi icon is rendered, the label that shows text should also be rendered.
        // The distance rule of the icon should apply, not the one for text (only) labels.
        textElement.ignoreDistance = false;
        tile.addTextElement(textElement);
    }
    /**
     * Create and add POI [[TextElement]]s to tile with a series of positions.
     */
    addPoi(tile, poiGeometry, technique, positions, worldOffsetX) {
        if (poiGeometry.stringCatalog === undefined) {
            return;
        }
        const techniqueTextureName = technique.imageTexture !== undefined
            ? harp_datasource_protocol_1.composeTechniqueTextureName(technique.imageTexture, technique)
            : undefined;
        const poiTechnique = technique;
        const poiTableName = poiTechnique.poiTable;
        let poiName = poiTechnique.poiName;
        for (let i = 0; i < positions.count; ++i) {
            const x = positions.getX(i) + worldOffsetX;
            const y = positions.getY(i);
            const z = positions.getZ(i);
            harp_utils_1.assert(poiGeometry.texts.length > i);
            let imageTextureName = techniqueTextureName;
            const text = poiGeometry.stringCatalog[poiGeometry.texts[i]] || "";
            const userData = poiGeometry.objInfos !== undefined ? poiGeometry.objInfos[i] : undefined;
            const featureId = harp_datasource_protocol_1.getFeatureId(userData);
            if (poiGeometry.imageTextures !== undefined && poiGeometry.imageTextures[i] >= 0) {
                harp_utils_1.assert(poiGeometry.imageTextures.length > i);
                imageTextureName = poiGeometry.stringCatalog[poiGeometry.imageTextures[i]];
            }
            if (poiTableName !== undefined) {
                // The POI name to be used is taken from the data, since it will
                // specify the name of the texture to use.
                // The POI name in the technique may override the POI name from the
                // data.
                poiName =
                    poiTechnique.poiName === undefined ? imageTextureName : poiTechnique.poiName;
                imageTextureName = undefined;
            }
            const textElement = this.checkCreateTextElement(tile, text, technique, imageTextureName, poiTableName, poiName, 0, featureId, x, y, z, userData);
            tile.addTextElement(textElement);
        }
    }
    /**
     * Create the [[TextElement]] for a POI. Even if the POI has no text, it is required that there
     * is a [[TextElement]], since POIs are hooked onto [[TextElement]]s for sorting.(Sorted by
     * priority attribute).
     */
    checkCreateTextElement(tile, text, technique, imageTextureName, poiTableName, poiName, shieldGroupIndex, featureId, x, y, z, userData) {
        const textElementsRenderer = this.mapView.textElementsRenderer;
        const priority = technique.priority !== undefined ? technique.priority : 0;
        const positions = Array.isArray(x) ? x : new THREE.Vector3(x, y, z);
        // The current zoomlevel of mapview. Since this method is called for all tiles in the
        // VisibleTileSet we can be sure that the current zoomlevel matches the zoomlevel where
        // the tile should be shown.
        const env = this.mapView.env;
        const fadeNear = technique.fadeNear !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, env)
            : technique.fadeNear;
        const fadeFar = technique.fadeFar !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, env)
            : technique.fadeFar;
        const xOffset = harp_datasource_protocol_1.getPropertyValue(technique.xOffset, env);
        const yOffset = harp_datasource_protocol_1.getPropertyValue(technique.yOffset, env);
        const textElement = new TextElement_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(text), positions, textElementsRenderer.styleCache.getRenderStyle(tile, technique), textElementsRenderer.styleCache.getLayoutStyle(tile, technique), harp_datasource_protocol_1.getPropertyValue(priority, env), xOffset !== undefined ? xOffset : 0.0, yOffset !== undefined ? yOffset : 0.0, featureId, technique.style, fadeNear, fadeFar, tile.offset);
        textElement.mayOverlap = technique.textMayOverlap === true;
        textElement.reserveSpace = technique.textReserveSpace !== false;
        textElement.alwaysOnTop = technique.alwaysOnTop === true;
        textElement.userData = userData;
        // imageTextureName may be undefined if a poiTable is used.
        if (imageTextureName === undefined && poiTableName !== undefined) {
            imageTextureName = "";
        }
        else if (imageTextureName !== undefined && poiTableName !== undefined) {
            logger.warn("Possible duplicate POI icon definition via imageTextureName and poiTable!");
        }
        if (imageTextureName !== undefined) {
            const textIsOptional = technique.textIsOptional === true;
            const iconIsOptional = technique.iconIsOptional !== false;
            const renderTextDuringMovements = !(technique.renderTextDuringMovements === false);
            const iconMayOverlap = technique.iconMayOverlap === undefined
                ? textElement.textMayOverlap
                : technique.iconMayOverlap === true;
            const iconReserveSpace = technique.iconReserveSpace === undefined
                ? textElement.textReservesSpace
                : technique.iconReserveSpace !== false;
            textElement.poiInfo = {
                technique,
                imageTextureName,
                poiTableName,
                poiName,
                shieldGroupIndex,
                textElement,
                textIsOptional,
                iconIsOptional,
                renderTextDuringMovements,
                mayOverlap: iconMayOverlap,
                reserveSpace: iconReserveSpace,
                featureId,
                iconMinZoomLevel: technique.iconMinZoomLevel,
                iconMaxZoomLevel: technique.iconMaxZoomLevel,
                textMinZoomLevel: technique.textMinZoomLevel,
                textMaxZoomLevel: technique.textMaxZoomLevel
            };
            textElement.updateMinMaxZoomLevelsFromPoiInfo();
        }
        else {
            // Select the smaller/larger one of the two min/max values, because the TextElement
            // is a container for both.
            if (textElement.minZoomLevel === undefined) {
                textElement.minZoomLevel = technique.textMinZoomLevel;
            }
            if (textElement.maxZoomLevel === undefined) {
                textElement.maxZoomLevel = technique.textMaxZoomLevel;
            }
        }
        textElement.distanceScale =
            technique.distanceScale !== undefined
                ? technique.distanceScale
                : TextElementsRenderer_1.DEFAULT_TEXT_DISTANCE_SCALE;
        return textElement;
    }
}
exports.PoiManager = PoiManager;
// Keep track of the missing POI table names, but only warn once.
PoiManager.m_missingPoiTableName = new Map();
PoiManager.m_missingPoiName = new Map();


/***/ }),

/***/ "../harp-mapview/lib/poi/PoiRenderer.ts":
/*!**********************************************!*\
  !*** ../harp-mapview/lib/poi/PoiRenderer.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const THREE = __webpack_require__(/*! three */ "three");
const ColorCache_1 = __webpack_require__(/*! ../ColorCache */ "../harp-mapview/lib/ColorCache.ts");
const BoxBuffer_1 = __webpack_require__(/*! ./BoxBuffer */ "../harp-mapview/lib/poi/BoxBuffer.ts");
const Poi_1 = __webpack_require__(/*! ./Poi */ "../harp-mapview/lib/poi/Poi.ts");
const logger = harp_utils_1.LoggerManager.instance.create("PoiRenderer");
const INVALID_RENDER_BATCH = -1;
const tempPos = new THREE.Vector3(0);
/**
 * The `PoiRenderBufferBatch` contains the geometry and the material for all POIs that share the
 * same icon image ([[ImageTexture]]). If the image is the same, all the objects in this batch can
 * share the same material, which makes them renderable in the same draw call, whatever the number
 * of actual objects (WebGL limits apply!).
 *
 * There is a `PoiRenderBufferBatch` for every icon in a texture atlas, since the size of the icon
 * in the atlas as well as the texture coordinates are specified in the `PoiRenderBufferBatch`.
 */
class PoiRenderBufferBatch {
    /**
     * Create the `PoiRenderBufferBatch`.
     *
     * @param mapView The [[MapView]] instance.
     * @param scene The three.js scene to add the POIs to.
     * @param imageItem The icon that will have his material shared.
     * @param renderOrder RenderOrder of the batch geometry's [[Mesh]].
     */
    constructor(mapView, scene, imageItem, renderOrder) {
        this.mapView = mapView;
        this.scene = scene;
        this.imageItem = imageItem;
        this.renderOrder = renderOrder;
        this.color = ColorCache_1.ColorCache.instance.getColor("#000000");
    }
    /**
     * Initialize with the [[ImageTexture]]. Loads the image and sets up the icon size, the texture
     * coordinates and material of the batch. Since image loading is done asynchronously, this
     * batch cannot be rendered right away. MapView#update is being triggered if it loaded
     * successfully.
     */
    init() {
        if (this.boxBuffer === undefined) {
            this.setup();
        }
    }
    /**
     * Clean the `PoiRenderBufferBatch`, remove all icon boxes. Called before starting a new frame.
     */
    reset() {
        if (this.boxBuffer === undefined) {
            this.init();
        }
        this.boxBuffer.reset();
    }
    /**
     * Update the geometry with all the added boxes during the frame.
     */
    update() {
        if (this.boxBuffer === undefined) {
            this.init();
        }
        this.boxBuffer.updateBufferGeometry();
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the
     * `PoiRenderBufferBatch`.
     *
     * @param info The info object to increment with the values from this `PoiRenderBufferBatch`.
     */
    updateMemoryUsage(info) {
        if (this.boxBuffer !== undefined) {
            this.boxBuffer.updateMemoryUsage(info);
        }
    }
    /**
     * Setup texture and material for the batch.
     */
    setup() {
        const bilinear = true;
        // Texture images should be generated with premultiplied alpha
        const premultipliedAlpha = true;
        const iconTexture = new Poi_1.IconTexture(this.imageItem);
        const texture = new THREE.Texture(iconTexture.image.imageData, THREE.UVMapping, undefined, undefined, bilinear ? THREE.LinearFilter : THREE.NearestFilter, bilinear ? THREE.LinearFilter : THREE.NearestFilter, THREE.RGBAFormat);
        texture.needsUpdate = true;
        texture.premultiplyAlpha = premultipliedAlpha;
        texture.generateMipmaps = false; // not needed, always rendered in full size
        this.m_material = new harp_materials_1.IconMaterial({
            map: texture
        });
        this.boxBuffer = new BoxBuffer_1.BoxBuffer(this.m_material, this.renderOrder);
        const mesh = this.boxBuffer.mesh;
        mesh.frustumCulled = false;
        this.scene.add(mesh);
        this.mapView.update();
    }
}
/**
 * Contains all [[PoiRenderBufferBatch]]es. Selects (and initializes) the correct batch for a POI.
 */
class PoiRenderBuffer {
    /**
     * Create the `PoiRenderBuffer`.
     *
     * @param mapView The [[MapView]] to be rendered to.
     * @param textCanvas The [[TextCanvas]] to which scenes this `PoiRenderBuffer` adds geometry to.
     * The actual scene a [[TextElement]] is added to is specified by the renderOrder of the
     * [[TextElement]].
     */
    constructor(mapView, textCanvas) {
        this.mapView = mapView;
        this.textCanvas = textCanvas;
        this.batches = [];
        this.m_batchMap = new Map();
    }
    /**
     * Register the POI and prepare the [[PoiRenderBufferBatch]] for the POI at first usage.
     *
     * @param poiInfo Describes the POI icon.
     */
    registerPoi(poiInfo) {
        const { imageItem, imageTexture, imageTextureName } = poiInfo;
        if (imageItem === undefined ||
            imageTextureName === undefined ||
            imageTexture === undefined) {
            // No image -> invisible -> ignore
            return INVALID_RENDER_BATCH;
        }
        const renderOrder = poiInfo.renderOrder;
        // There is a batch for every ImageDefinition, which could be a texture atlas with many
        // ImageTextures in it.
        const batchKey = imageTexture.image;
        let batchSet = this.m_batchMap.get(batchKey);
        let mappedIndex;
        let bufferBatch;
        if (batchSet === undefined) {
            batchSet = new Map();
            this.m_batchMap.set(batchKey, batchSet);
        }
        mappedIndex = batchSet.get(renderOrder);
        if (mappedIndex !== undefined) {
            return mappedIndex;
        }
        mappedIndex = this.batches.length;
        let layer = this.textCanvas.getLayer(renderOrder);
        if (layer === undefined) {
            this.textCanvas.addText("", tempPos, { layer: renderOrder });
            layer = this.textCanvas.getLayer(renderOrder);
        }
        bufferBatch = new PoiRenderBufferBatch(this.mapView, layer.storage.scene, imageItem, renderOrder);
        bufferBatch.init();
        batchSet.set(renderOrder, mappedIndex);
        this.batches.push(bufferBatch);
        return mappedIndex;
    }
    /**
     * Render a POI image at the specified location.
     *
     * @param poiInfo PoiInfo containing information for rendering the POI icon.
     * @param screenBox Box to render icon into in 2D coordinates.
     * @param viewDistance Box's distance to camera.
     * @param opacity Opacity of icon to allow fade in/out.
     */
    addPoi(poiInfo, screenBox, viewDistance, opacity) {
        const poiRegistered = poiInfo.poiRenderBatch !== undefined && poiInfo.poiRenderBatch !== INVALID_RENDER_BATCH;
        const batchIndex = poiRegistered ? poiInfo.poiRenderBatch : this.registerPoi(poiInfo);
        if (batchIndex === INVALID_RENDER_BATCH) {
            return INVALID_RENDER_BATCH;
        }
        harp_utils_1.assert(batchIndex >= 0);
        harp_utils_1.assert(batchIndex < this.batches.length);
        harp_utils_1.assert(poiInfo.uvBox !== undefined);
        if (this.batches[batchIndex].boxBuffer === undefined) {
            this.batches[batchIndex].init();
        }
        this.batches[batchIndex].boxBuffer.addBox(screenBox, poiInfo.uvBox, this.batches[batchIndex].color, opacity, viewDistance, poiInfo.textElement);
        return batchIndex;
    }
    /**
     * Retrieve the [[PoiRenderBufferBatch]] from the array at the specified index. May be invalid
     * if the imageTexture could not be found
     *
     * @param index Index into batch array.
     */
    getBatch(index) {
        if (index >= 0) {
            harp_utils_1.assert(index < this.batches.length);
            return this.batches[index];
        }
        // may be invalid if the imageTexture could not be found
        return undefined;
    }
    /**
     * Reset all batches, removing all content from the [[PoiRenderBufferBatch]]es. Called at the
     * beginning of a frame before the POIs are placed.
     */
    reset() {
        for (const batch of this.batches) {
            batch.reset();
        }
    }
    /**
     * Update the geometry of all [[PoiRenderBufferBatch]]es. Called before rendering.
     */
    update() {
        for (const batch of this.batches) {
            batch.update();
        }
    }
    /**
     * Fill the picking results for the pixel with the given screen coordinate. If multiple
     * [[PoiInfo]]s are found, the order of the results is unspecified.
     *
     * @param screenPosition Screen coordinate of picking position.
     * @param pickCallback Callback to be called for every picked element.
     */
    pickTextElements(screenPosition, pickCallback) {
        for (const batch of this.batches) {
            if (batch.boxBuffer === undefined) {
                batch.init();
            }
            batch.boxBuffer.pickBoxes(screenPosition, pickCallback, batch.imageItem.imageData);
        }
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `PoiRenderBuffer`.
     *
     * @param info The info object to increment with the values from this `PoiRenderBuffer`.
     */
    updateMemoryUsage(info) {
        for (const batch of this.batches) {
            if (batch.imageItem.imageData !== undefined) {
                const imageBytes = batch.imageItem.imageData.width * batch.imageItem.imageData.height * 4;
                info.heapSize += imageBytes;
                info.gpuSize += imageBytes;
            }
            if (batch.boxBuffer !== undefined) {
                batch.boxBuffer.updateMemoryUsage(info);
            }
        }
    }
}
/**
 * Manage POI rendering. Uses a [[PoiRenderBuffer]] to actually create the geometry that is being
 * rendered.
 */
class PoiRenderer {
    /**
     * Create the `PoiRenderer` for the specified [[MapView]].
     *
     * @param mapView The MapView to be rendered to.
     * @param textCanvas The [[TextCanvas]] this `PoiRenderer` is associated to. POIs are added to
     * the different layers of this [[TextCanvas]] based on renderOrder.
     */
    constructor(mapView, textCanvas) {
        this.mapView = mapView;
        this.textCanvas = textCanvas;
        // temporary variable to save allocations
        this.m_tempScreenBox = new harp_utils_1.Math2D.Box();
        this.m_renderBuffer = new PoiRenderBuffer(mapView, textCanvas);
    }
    /**
     * Compute screen box for icon. It is required that `prepareRender` has been successfully called
     * before `computeScreenBox` may be called.
     *
     * @param poiInfo PoiInfo containing information for rendering the POI icon.
     * @param screenPosition Position on screen (2D).
     * @param scale Scale to apply to icon.
     * @param env Current zoom level.
     * @param screenBox Box that will be used to store the result.
     * @returns The computed screen box for the icon.
     */
    static computeIconScreenBox(poiInfo, screenPosition, scale, env, 
    /* out */ screenBox = new harp_utils_1.Math2D.Box()) {
        harp_utils_1.assert(poiInfo.poiRenderBatch !== undefined);
        harp_utils_1.assert(poiInfo.poiRenderBatch !== INVALID_RENDER_BATCH);
        const width = poiInfo.computedWidth * scale;
        const height = poiInfo.computedHeight * scale;
        const technique = poiInfo.technique;
        const iconXOffset = harp_datasource_protocol_1.getPropertyValue(technique.iconXOffset, env);
        const iconYOffset = harp_datasource_protocol_1.getPropertyValue(technique.iconYOffset, env);
        const centerX = screenPosition.x + (typeof iconXOffset === "number" ? iconXOffset : 0);
        const centerY = screenPosition.y + (typeof iconYOffset === "number" ? iconYOffset : 0);
        screenBox.x = centerX - width / 2;
        screenBox.y = centerY - height / 2;
        screenBox.w = width;
        screenBox.h = height;
        return screenBox;
    }
    /**
     * Prepare the POI for rendering, and determine which `poiRenderBatch` should be used. If a
     * `poiRenderBatch` is assigned, the POI is ready to be rendered.
     *
     * @param pointLabel TextElement with PoiInfo for rendering the POI icon.
     * @param env TODO! The current zoomLevel level of [[MapView]]
     *
     * @returns `True` if the space is not already allocated by another object (text label or POI)
     */
    prepareRender(pointLabel, env) {
        const poiInfo = pointLabel.poiInfo;
        if (poiInfo === undefined) {
            return false;
        }
        if (poiInfo.poiRenderBatch === undefined) {
            this.preparePoi(pointLabel, env);
        }
        return poiInfo.poiRenderBatch !== undefined;
    }
    /**
     * Reset all batches, removing all content from the [[PoiRenderBuffer]]es. Called at the
     * beginning of a frame before the POIs are placed.
     */
    reset() {
        this.m_renderBuffer.reset();
    }
    /**
     * Render the icon.
     *
     * @param poiInfo PoiInfo containing information for rendering the POI icon.
     * @param screenPosition Position on screen (2D):
     * @param screenCollisions Object handling the collision checks for screen-aligned 2D boxes.
     * @param viewDistance Box's distance to camera.
     * @param scale Scaling factor to apply to text and icon.
     * @param allocateScreenSpace If `true` screen space will be allocated for the icon.
     * @param opacity Opacity of icon to allow fade in/out.
     */
    renderPoi(poiInfo, screenPosition, screenCollisions, viewDistance, scale, allocateScreenSpace, opacity, env) {
        harp_utils_1.assert(poiInfo.poiRenderBatch !== undefined);
        PoiRenderer.computeIconScreenBox(poiInfo, screenPosition, scale, env, this.m_tempScreenBox);
        if (allocateScreenSpace) {
            screenCollisions.allocate(this.m_tempScreenBox);
        }
        this.m_renderBuffer.addPoi(poiInfo, this.m_tempScreenBox, viewDistance, opacity);
    }
    /**
     * Update the geometry of all [[PoiRenderBuffer]]es. Called before rendering.
     */
    update() {
        this.m_renderBuffer.update();
    }
    /**
     * Fill the picking results for the pixel with the given screen coordinate. If multiple
     * [[PoiInfo]]s are found, the order of the results is unspecified.
     *
     * @param screenPosition Screen coordinate of picking position.
     * @param pickCallback Callback to be called for every picked element.
     */
    pickTextElements(screenPosition, pickCallback) {
        this.m_renderBuffer.pickTextElements(screenPosition, pickCallback);
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `PoiRenderer`.
     *
     * @param info The info object to increment with the values from this `PoiRenderer`.
     */
    getMemoryUsage(info) {
        this.m_renderBuffer.updateMemoryUsage(info);
    }
    /**
     * Register the POI at the [[PoiRenderBuffer]] which may require some setup, for example loading
     * of the actual image.
     */
    preparePoi(pointLabel, env) {
        const poiInfo = pointLabel.poiInfo;
        if (poiInfo === undefined || !pointLabel.visible) {
            return;
        }
        if (poiInfo.poiRenderBatch !== undefined || poiInfo.isValid === false) {
            // Already set up, nothing to be done here.
            return;
        }
        if (poiInfo.poiTableName !== undefined) {
            if (this.mapView.poiManager.updatePoiFromPoiTable(pointLabel)) {
                if (!pointLabel.visible) {
                    // PoiTable set this POI to not visible.
                    return;
                }
            }
            else {
                // PoiTable has not been loaded, but is required to determine visibility.
                return;
            }
        }
        const imageTextureName = poiInfo.imageTextureName;
        const imageTexture = this.mapView.poiManager.getImageTexture(imageTextureName);
        if (imageTexture === undefined) {
            // Warn about a missing texture, but only once.
            if (PoiRenderer.m_missingTextureName.get(imageTextureName) === undefined) {
                PoiRenderer.m_missingTextureName.set(imageTextureName, true);
                logger.error(`preparePoi: No imageTexture with name '${imageTextureName}' found`);
            }
            poiInfo.isValid = false;
            return;
        }
        const imageDefinition = imageTexture.image;
        let imageItem = this.mapView.imageCache.findImageByName(imageDefinition);
        if (imageItem === undefined) {
            logger.error(`init: No imageItem found with name '${imageDefinition}'`);
            poiInfo.isValid = false;
            return;
        }
        if (!imageItem.loaded) {
            if (imageItem.loadingPromise !== undefined) {
                // already being loaded, will be rendered once available
                return;
            }
            const imageUrl = imageItem.url;
            const loading = this.mapView.imageCache.loadImage(imageItem);
            if (loading instanceof Promise) {
                loading
                    .then(loadedImageItem => {
                    if (loadedImageItem === undefined) {
                        logger.error(`preparePoi: Failed to load imageItem: '${imageUrl}`);
                        return;
                    }
                    this.setupPoiInfo(poiInfo, imageTexture, loadedImageItem, env);
                })
                    .catch(error => {
                    logger.error(`preparePoi: Failed to load imageItem: '${imageUrl}`, error);
                    poiInfo.isValid = false;
                });
                return;
            }
            else {
                imageItem = loading;
            }
        }
        this.setupPoiInfo(poiInfo, imageTexture, imageItem, env);
    }
    /**
     * Setup texture and material for the batch.
     *
     * @param poiInfo [[PoiInfo]] to initialize.
     * @param imageTexture Shared [[ImageTexture]], defines used area in atlas.
     * @param imageItem Shared [[ImageItem]], contains cached image for texture.
     * @param env The current zoom level of [[MapView]]
     */
    setupPoiInfo(poiInfo, imageTexture, imageItem, env) {
        harp_utils_1.assert(poiInfo.uvBox === undefined);
        if (imageItem === undefined || imageItem.imageData === undefined) {
            logger.error("setupPoiInfo: No imageItem/imageData found");
            // invalid render batch number
            poiInfo.poiRenderBatch = INVALID_RENDER_BATCH;
            poiInfo.isValid = false;
            return;
        }
        const technique = poiInfo.technique;
        const imageWidth = imageItem.imageData.width;
        const imageHeight = imageItem.imageData.height;
        const iconWidth = imageTexture.width !== undefined ? imageTexture.width : imageWidth;
        const iconHeight = imageTexture.height !== undefined ? imageTexture.height : imageHeight;
        let minS = 0;
        let maxS = 1;
        let minT = 0;
        let maxT = 1;
        let iconScaleH = technique.iconScale !== undefined ? technique.iconScale : 1;
        let iconScaleV = technique.iconScale !== undefined ? technique.iconScale : 1;
        const width = imageTexture.width !== undefined ? imageTexture.width : imageWidth;
        const height = imageTexture.height !== undefined ? imageTexture.height : imageHeight;
        const xOffset = imageTexture.xOffset !== undefined ? imageTexture.xOffset : 0;
        const yOffset = imageTexture.yOffset !== undefined ? imageTexture.yOffset : 0;
        minS = xOffset / imageWidth;
        maxS = (xOffset + width) / imageWidth;
        const flipY = true;
        if (flipY) {
            minT = (imageHeight - yOffset) / imageHeight;
            maxT = (imageHeight - yOffset - height) / imageHeight;
        }
        else {
            minT = yOffset / imageHeight;
            maxT = (yOffset + height) / imageHeight;
        }
        // minS += 0.5 / imageWidth;
        // maxS += 0.5 / imageWidth;
        // minT += 0.5 / imageHeight;
        // maxT += 0.5 / imageHeight;
        // By default, iconScaleV should be equal to iconScaleH, whatever is set in the style.
        const screenWidth = harp_datasource_protocol_1.getPropertyValue(technique.screenWidth, env);
        if (screenWidth !== undefined) {
            iconScaleV = iconScaleH = screenWidth / iconWidth;
        }
        const screenHeight = harp_datasource_protocol_1.getPropertyValue(technique.screenHeight, env);
        if (screenHeight !== undefined) {
            iconScaleV = screenHeight / iconHeight;
            if (screenWidth !== undefined) {
                iconScaleH = iconScaleV;
            }
        }
        // compute stored values in imageTexture
        poiInfo.computedWidth = iconWidth * iconScaleH;
        poiInfo.computedHeight = iconHeight * iconScaleV;
        poiInfo.uvBox = {
            s0: minS,
            t0: maxT,
            s1: maxS,
            t1: minT
        };
        poiInfo.imageItem = imageItem;
        poiInfo.imageTexture = imageTexture;
        poiInfo.poiRenderBatch = this.m_renderBuffer.registerPoi(poiInfo);
        poiInfo.isValid = true;
        harp_utils_1.assert(poiInfo.poiRenderBatch !== undefined);
    }
}
exports.PoiRenderer = PoiRenderer;
// keep track of the missing textures, but only warn once
PoiRenderer.m_missingTextureName = new Map();


/***/ }),

/***/ "../harp-mapview/lib/poi/PoiRendererFactory.ts":
/*!*****************************************************!*\
  !*** ../harp-mapview/lib/poi/PoiRendererFactory.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const PoiRenderer_1 = __webpack_require__(/*! ./PoiRenderer */ "../harp-mapview/lib/poi/PoiRenderer.ts");
class PoiRendererFactory {
    /**
     * Creates an instance of poi renderer factory.
     * @param m_mapView
     */
    constructor(m_mapView) {
        this.m_mapView = m_mapView;
    }
    /**
     * Creates poi renderer
     * @param textCanvas
     * @returns
     */
    createPoiRenderer(textCanvas) {
        return new PoiRenderer_1.PoiRenderer(this.m_mapView, textCanvas);
    }
}
exports.PoiRendererFactory = PoiRendererFactory;


/***/ }),

/***/ "../harp-mapview/lib/poi/PoiTableManager.ts":
/*!**************************************************!*\
  !*** ../harp-mapview/lib/poi/PoiTableManager.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const logger = harp_utils_1.LoggerManager.instance.create("PoiTable");
/**
 * Class to store and maintain individual POI information for the [[PoiTable]].
 */
class PoiTableEntry {
    /**
     * Verify that the JSON description of the POI table entry is valid.
     *
     * @param jsonEntry JSON description of the POI table entry.
     *
     * @returns `true` if the `jsonEntry` is valid.
     */
    static verifyJSON(jsonEntry) {
        let isOK = typeof jsonEntry.name === "string" &&
            jsonEntry.name.length > 0 &&
            (jsonEntry.altNames === undefined || Array.isArray(jsonEntry.altNames)) &&
            (jsonEntry.stackMode === undefined ||
                jsonEntry.stackMode === "yes" ||
                jsonEntry.stackMode === "no" ||
                jsonEntry.stackMode === "parent") &&
            (jsonEntry.visible === undefined || typeof jsonEntry.visible === "boolean") &&
            (jsonEntry.priority === undefined || typeof jsonEntry.priority === "number") &&
            (jsonEntry.iconMinLevel === undefined || typeof jsonEntry.iconMinLevel === "number") &&
            (jsonEntry.iconMaxLevel === undefined || typeof jsonEntry.iconMaxLevel === "number") &&
            (jsonEntry.textMinLevel === undefined || typeof jsonEntry.textMinLevel === "number") &&
            (jsonEntry.textMaxLevel === undefined || typeof jsonEntry.textMaxLevel === "number");
        if (isOK && jsonEntry.altNames !== undefined) {
            const altNames = jsonEntry.altNames;
            for (const str in altNames) {
                if (typeof str !== "string") {
                    isOK = false;
                    break;
                }
            }
        }
        return isOK;
    }
    /**
     * Setup the [[PoiTableEntry]] from the JSON description. It is assumed that the jsonEntry has
     * been verified with [[PoiTableEntry#verifyJSON]].
     *
     * @param jsonEntry JSON description of the POI table entry. Expected to have been verified with
     *          [[PoiTableEntry#verifyJSON]].
     */
    setup(jsonEntry) {
        this.name = jsonEntry.name;
        this.altNames = jsonEntry.altNames;
        this.iconName = jsonEntry.iconName;
        this.visible = jsonEntry.visible;
        this.priority = jsonEntry.priority;
        this.iconMinLevel = jsonEntry.iconMinLevel;
        this.iconMaxLevel = jsonEntry.iconMaxLevel;
        this.textMinLevel = jsonEntry.textMinLevel;
        this.textMaxLevel = jsonEntry.textMaxLevel;
        switch (jsonEntry.stackMode) {
            case "yes":
                this.stackMode = harp_datasource_protocol_1.PoiStackMode.Show;
                break;
            case "no":
                this.stackMode = harp_datasource_protocol_1.PoiStackMode.Hide;
                break;
            case "parent":
                this.stackMode = harp_datasource_protocol_1.PoiStackMode.ShowParent;
                break;
            default:
        }
    }
}
/**
 * The `PoiTable` stores individual information for each POI type. If a [[TextElement]] has a
 * reference to a PoiTable (if TextElement.poiInfo.poiTableName is set), information for the
 * TextElement and its icon are read from the PoiTable.
 *
 * The key to look up the POI is taken from the data, in case of OSM data with TileZen data, the
 * `poiNameField` is set to `kind`, which makes the content of the field `kind` in the data the key
 * to look up the POIs in the [[PoiTable]].
 *
 * On the side of the [[PoiTable]], the key to look up the PoiTableEntry is either the property
 * "name" of the [[PoiTableEntry]] (which should be unique), or the alternative list of names
 * `altNames`, where each value should also be unique. If the property `useAltNamesForKey` is set to
 * `true`, the `altNames` will be used.
 */
class PoiTable {
    /**
     * Creates an instance of PoiTable.
     *
     * @param {string} name Name of the `PoiTable`. Must be unique.
     * @param {boolean} useAltNamesForKey Pass `true` to use the contents of the property `altNames`
     *          to find a [[PoiTableEntry]] in the table.
     */
    constructor(name, useAltNamesForKey) {
        this.name = name;
        this.useAltNamesForKey = useAltNamesForKey;
        /**
         * Stores the list of [[PoiTableEntry]]s.
         */
        this.poiList = new Array();
        /**
         * Dictionary to look up for [[PoiTableEntry]] quickly. The dictionary is either created for
         * the `name` property of the [[PoiTableEntry]], which will identify POI, or for all of
         * alternative the names defined in `altNames` of [[PoiTableEntry]] JSON object.
         * Value assigned to key it is the index to [[poiList]] array which contain actual
         * [[PoiTabelEntry]] objects.
         */
        this.poiDict = new Map();
        this.m_isLoading = false;
        this.m_loadedOk = undefined;
    }
    /**
     * Returns `true` if the table is currently being loaded, `false` otherwise.
     *
     * @readonly
     */
    get isLoading() {
        return this.m_isLoading;
    }
    /**
     * Returns `true` if the table has been loaded correctly, `false` otherwise.
     *
     * @readonly
     */
    get loadedOk() {
        return this.m_loadedOk === true;
    }
    /**
     * Gets [[PoiTableEntry]] for poi name specified.
     *
     * @param poiName poi name or one of its alternative names if [[useAltNamesForKey]] is
     * set to `true`.
     * @returns [[PoiTableEntry]] object or undefined if name was not found in dictionary.
     */
    getEntry(poiName) {
        const entryIdx = this.poiDict.get(poiName);
        if (entryIdx !== undefined) {
            if (entryIdx < this.poiList.length) {
                return this.poiList[entryIdx];
            }
            else {
                throw new Error("Poi table entry index out of stored list!");
            }
        }
        return undefined;
    }
    /**
     * Start to load the PoiTable from the specified URL. Can only be called once per table.
     *
     * @param {string} poiTableUrl URL that points to the JSON file.
     *
     * @returns {Promise<boolean>} Promise is being resolved once the JSON file has been fetched and
     *          the `PoiTable` has been set up.
     */
    async load(poiTableUrl) {
        if (this.m_loadedOk !== undefined) {
            // Only load once.
            return true;
        }
        this.m_loadedOk = false;
        const response = await fetch(poiTableUrl);
        if (!response.ok) {
            throw new Error(`load: Cannot load POI table at ${poiTableUrl}:` + ` ${response.statusText}`);
        }
        const jsonPoiTable = (await response.json());
        if (jsonPoiTable === undefined) {
            logger.info(`load: TextureAtlas empty: ${poiTableUrl}`);
            return true;
        }
        this.startLoading();
        try {
            logger.debug(`load: Loading POI table '${poiTableUrl}' for table '${this.name}'`);
            if (jsonPoiTable.poiList !== undefined && Array.isArray(jsonPoiTable.poiList)) {
                for (const tableEntry of jsonPoiTable.poiList) {
                    if (PoiTableEntry.verifyJSON(tableEntry)) {
                        const newPoiEntry = new PoiTableEntry();
                        newPoiEntry.setup(tableEntry);
                        const entryIdx = this.poiList.push(newPoiEntry) - 1;
                        if (!this.useAltNamesForKey) {
                            // Use actual name of entry as the key
                            if (newPoiEntry.name === undefined) {
                                logger.warn(`load: Invalid entry in POI table '${poiTableUrl}' : ` +
                                    `. No name set in entry: ${tableEntry}.`);
                            }
                            else {
                                this.poiDict.set(newPoiEntry.name, entryIdx);
                            }
                        }
                        else {
                            if (newPoiEntry.altNames !== undefined &&
                                newPoiEntry.altNames.length > 0) {
                                // Use the list of alternative names as keys.
                                for (const altName of newPoiEntry.altNames) {
                                    this.poiDict.set(altName, entryIdx);
                                }
                            }
                            else {
                                logger.warn(`load: Invalid entry in POI table '${poiTableUrl}' : ` +
                                    `No alternative names set in entry: ${JSON.stringify(tableEntry)}.`);
                            }
                        }
                    }
                    else {
                        logger.warn(`load: Invalid entry in POI table '${poiTableUrl}' : ${JSON.stringify(tableEntry)}`);
                    }
                }
            }
            this.m_loadedOk = true;
            this.finishedLoading();
        }
        catch (ex) {
            logger.error(`load: Failed to load POI table ` + `'${poiTableUrl}' : ${ex}`);
            this.m_loadedOk = false;
            this.finishedLoading();
            return false;
        }
        return true;
    }
    startLoading() {
        this.m_isLoading = true;
    }
    finishedLoading() {
        this.m_isLoading = false;
    }
}
exports.PoiTable = PoiTable;
/**
 * The `PoiTableManager` manages the list of [[PoiTables]] that can be defined in the [[Theme]]
 * file.
 */
class PoiTableManager {
    /**
     * Creates an instance of PoiTableManager.
     * @param {MapView} mapView Owning [[MapView]].
     */
    constructor(mapView) {
        this.mapView = mapView;
        this.m_isLoading = false;
        this.m_poiTables = new Map();
    }
    /**
     * Load the [[PoiTable]]s that are stored in the [[MapView]]s [[Theme]]. Note that duplicate
     * names of [[PoiTable]]s in the [[Theme]] will lead to inaccessible [[PoiTable]]s.
     *
     * @param {Theme} theme [[Theme]] containing all [[PoiTable]]s to load.
     *
     * @returns {Promise<void>} Resolved once all the [[PoiTable]]s in the [[Theme]] have been
     *          loaded.
     */
    async loadPoiTables(theme) {
        const finished = new Promise(resolve => {
            this.clear();
            // Add the POI tables defined in the theme.
            if (theme.poiTables !== undefined) {
                this.startLoading();
                // Gather promises to signal the success of having loaded them all
                const loadPromises = new Array();
                theme.poiTables.forEach((poiTableRef) => {
                    if (poiTableRef !== undefined &&
                        poiTableRef.name !== undefined &&
                        typeof poiTableRef.name === "string") {
                        const poiTable = new PoiTable(poiTableRef.name, poiTableRef.useAltNamesForKey !== false);
                        if (poiTableRef.url !== undefined && typeof poiTableRef.url === "string") {
                            this.addTable(poiTable);
                            loadPromises.push(poiTable.load(poiTableRef.url));
                        }
                        else {
                            logger.error(`POI table definition has no valid url: ${poiTableRef}`);
                        }
                    }
                    else {
                        logger.error(`POI table definition has no valid name: ${poiTableRef}`);
                    }
                });
                if (loadPromises.length > 0) {
                    Promise.all(loadPromises).finally(() => {
                        this.finishLoading();
                        resolve();
                    });
                }
                else {
                    this.finishLoading();
                    resolve();
                }
            }
            else {
                this.finishLoading();
                resolve();
            }
        });
        return finished;
    }
    /**
     * Clear the list of [[PoiTable]]s.
     */
    clear() {
        this.m_poiTables = new Map();
    }
    /**
     * Return the map of [[PoiTable]]s.
     */
    get poiTables() {
        return this.m_poiTables;
    }
    /**
     * Manually add a [[PoiTable]]. Normally, the [[PoiTables]]s are specified in the [[Theme]].
     * Ensure that the name is unique.
     */
    addTable(poiTable) {
        this.m_poiTables.set(poiTable.name, poiTable);
    }
    /**
     * Retrieve a [[PoiTable]] by name.
     *
     * @param {(string | undefined)} poiTableName Name of the [[PoiTable]].
     *
     * @returns {(PoiTable | undefined)} The found [[poiTable]] if it could be found, `undefined`
     *          otherwise.
     */
    getPoiTable(poiTableName) {
        return poiTableName === undefined ? undefined : this.m_poiTables.get(poiTableName);
    }
    /**
     * Return `true` if the [[PoiTable]]s have finished loading.
     *
     * @readonly
     */
    get finishedLoading() {
        return !this.m_isLoading;
    }
    startLoading() {
        this.m_isLoading = true;
    }
    finishLoading() {
        this.m_isLoading = false;
    }
}
exports.PoiTableManager = PoiTableManager;


/***/ }),

/***/ "../harp-mapview/lib/text/FontCatalogLoader.ts":
/*!*****************************************************!*\
  !*** ../harp-mapview/lib/text/FontCatalogLoader.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "../harp-text-canvas/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
exports.DEFAULT_FONT_CATALOG_NAME = "default";
const logger = harp_utils_1.LoggerManager.instance.create("FontCatalogLoader");
class FontCatalogLoader {
    constructor(m_theme) {
        this.m_theme = m_theme;
        this.m_catalogsLoading = 0;
    }
    /**
     * Initializes font catalog loader.
     * @param defaultFontCatalogUrl Url of the font catalog that will be used by default if the
     * theme doesn't define any font catalog.
     * @returns Name of the default font catalog.
     */
    initialize(defaultFontCatalogUrl) {
        if (this.m_theme.fontCatalogs === undefined || this.m_theme.fontCatalogs.length === 0) {
            this.m_theme.fontCatalogs = [
                {
                    name: exports.DEFAULT_FONT_CATALOG_NAME,
                    url: defaultFontCatalogUrl
                }
            ];
            return exports.DEFAULT_FONT_CATALOG_NAME;
        }
        const defaultFontCatalogName = this.m_theme.fontCatalogs[0].name;
        return defaultFontCatalogName;
    }
    async loadCatalogs(catalogCallback) {
        harp_utils_1.assert(this.m_theme.fontCatalogs !== undefined);
        harp_utils_1.assert(this.m_theme.fontCatalogs.length > 0);
        const promises = [];
        this.m_theme.fontCatalogs.forEach(fontCatalogConfig => {
            this.m_catalogsLoading += 1;
            const fontCatalogPromise = harp_text_canvas_1.FontCatalog.load(fontCatalogConfig.url, 1024)
                .then(catalogCallback.bind(undefined, fontCatalogConfig.name))
                .catch((error) => {
                logger.error("Failed to load FontCatalog: ", error);
            })
                .finally(() => {
                this.m_catalogsLoading -= 1;
            });
            promises.push(fontCatalogPromise);
        });
        return Promise.all(promises);
    }
    get loading() {
        return this.m_catalogsLoading > 0;
    }
}
exports.FontCatalogLoader = FontCatalogLoader;


/***/ }),

/***/ "../harp-mapview/lib/text/MapViewState.ts":
/*!************************************************!*\
  !*** ../harp-mapview/lib/text/MapViewState.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * View state obtained from a MapView instance.
 */
class MapViewState {
    constructor(m_mapView, m_renderedTilesChangeCheck) {
        this.m_mapView = m_mapView;
        this.m_renderedTilesChangeCheck = m_renderedTilesChangeCheck;
    }
    get worldCenter() {
        return this.m_mapView.worldCenter;
    }
    get cameraIsMoving() {
        return this.m_mapView.cameraIsMoving;
    }
    get maxVisibilityDist() {
        return this.m_mapView.viewRanges.maximum;
    }
    get zoomLevel() {
        return this.m_mapView.zoomLevel;
    }
    get env() {
        return this.m_mapView.env;
    }
    get frameNumber() {
        return this.m_mapView.frameNumber;
    }
    get lookAtDistance() {
        return this.m_mapView.targetDistance;
    }
    get isDynamic() {
        return this.m_mapView.isDynamicFrame;
    }
    get hiddenGeometryKinds() {
        return this.m_mapView.tileGeometryManager === undefined
            ? undefined
            : this.m_mapView.tileGeometryManager.hiddenGeometryKinds;
    }
    get renderedTilesChanged() {
        return this.m_renderedTilesChangeCheck();
    }
    get projection() {
        return this.m_mapView.projection;
    }
    get elevationProvider() {
        return this.m_mapView.elevationProvider;
    }
}
exports.MapViewState = MapViewState;


/***/ }),

/***/ "../harp-mapview/lib/text/Placement.ts":
/*!*********************************************!*\
  !*** ../harp-mapview/lib/text/Placement.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "../harp-text-canvas/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const THREE = __webpack_require__(/*! three */ "three");
const PoiRenderer_1 = __webpack_require__(/*! ../poi/PoiRenderer */ "../harp-mapview/lib/poi/PoiRenderer.ts");
const ScreenCollisions_1 = __webpack_require__(/*! ../ScreenCollisions */ "../harp-mapview/lib/ScreenCollisions.ts");
const TextElement_1 = __webpack_require__(/*! ./TextElement */ "../harp-mapview/lib/text/TextElement.ts");
const TextElementType_1 = __webpack_require__(/*! ./TextElementType */ "../harp-mapview/lib/text/TextElementType.ts");
/**
 * Minimum number of pixels per character. Used during estimation if there is enough screen space
 * available to render a text.
 */
const MIN_AVERAGE_CHAR_WIDTH = 5;
/**
 * Functions related to text element placement.
 */
const tmpPosition = new THREE.Vector3(0, 0, 0);
const tmpCameraDir = new THREE.Vector3(0, 0, 0);
const COS_TEXT_ELEMENT_FALLOFF_ANGLE = 0.5877852522924731; // Math.cos(0.3 * Math.PI)
/**
 * Checks whether the distance of the specified text element to the center of the given view is
 * lower than a maximum threshold.
 * @param textElement The textElement of which the view distance will be checked, with coordinates
 * in world space.
 * @param mapView The view that will be used as reference to calculate the distance.
 * @param maxViewDistance The maximum distance value.
 * @returns The text element view distance if it's lower than the maximum value, otherwise
 * `undefined`.
 */
function checkViewDistance(worldCenter, textElement, projectionType, camera, maxViewDistance) {
    const textDistance = computeViewDistance(worldCenter, textElement);
    if (projectionType !== harp_geoutils_1.ProjectionType.Spherical) {
        return textDistance <= maxViewDistance ? textDistance : undefined;
    }
    // For sphere projection: Filter labels that are close to the horizon
    tmpPosition.copy(textElement.position).normalize();
    camera.getWorldPosition(tmpCameraDir).normalize();
    const cosAlpha = tmpPosition.dot(tmpCameraDir);
    const viewDistance = cosAlpha > COS_TEXT_ELEMENT_FALLOFF_ANGLE && textDistance <= maxViewDistance
        ? textDistance
        : undefined;
    return viewDistance;
}
/**
 * Computes the distance of the specified text element to the given position.
 * @param refPosition The world coordinates used a reference position to calculate the distance.
 * @param textElement The textElement of which the view distance will be checked. It must have
 * coordinates in world space.
 * @returns The text element view distance.
 * `undefined`.
 */
function computeViewDistance(refPosition, textElement) {
    let viewDistance;
    if (Array.isArray(textElement.points) && textElement.points.length > 1) {
        const viewDistance0 = refPosition.distanceTo(textElement.points[0]);
        const viewDistance1 = refPosition.distanceTo(textElement.points[textElement.points.length - 1]);
        viewDistance = Math.min(viewDistance0, viewDistance1);
    }
    else {
        viewDistance = refPosition.distanceTo(textElement.points);
    }
    return viewDistance;
}
exports.computeViewDistance = computeViewDistance;
/**
 * Computes the maximum view distance for text elements as a ratio of the given view's maximum far
 * plane distance.
 * @param viewState The view for which the maximum view distance will be calculated.
 * @param farDistanceLimitRatio The ratio to apply to the maximum far plane distance.
 * @returns Maximum view distance.
 */
function getMaxViewDistance(viewState, farDistanceLimitRatio) {
    return viewState.maxVisibilityDist * farDistanceLimitRatio;
}
exports.getMaxViewDistance = getMaxViewDistance;
/**
 * State of fading.
 */
var PrePlacementResult;
(function (PrePlacementResult) {
    PrePlacementResult[PrePlacementResult["Ok"] = 0] = "Ok";
    PrePlacementResult[PrePlacementResult["NotReady"] = 1] = "NotReady";
    PrePlacementResult[PrePlacementResult["Invisible"] = 2] = "Invisible";
    PrePlacementResult[PrePlacementResult["TooFar"] = 3] = "TooFar";
    PrePlacementResult[PrePlacementResult["Duplicate"] = 4] = "Duplicate";
    PrePlacementResult[PrePlacementResult["Count"] = 5] = "Count";
})(PrePlacementResult = exports.PrePlacementResult || (exports.PrePlacementResult = {}));
/**
 * Applies early rejection tests for a given text element meant to avoid trying to place labels
 * that are not visible, not ready, duplicates etc...
 * @param textElement The Text element to check.
 * @param viewState The view for which the text element will be placed.
 * @param viewCamera The view's camera.
 * @param m_poiManager To prepare pois for rendering.
 * @param [maxViewDistance] If specified, text elements farther than this max distance will be
 * rejected.
 * @returns An object with the result code and the text element view distance
 * ( or `undefined` of the checks failed) as second.
 */
function checkReadyForPlacement(textElement, viewState, viewCamera, poiManager, maxViewDistance) {
    let viewDistance;
    if (!textElement.visible) {
        return { result: PrePlacementResult.Invisible, viewDistance };
    }
    // If a PoiTable is specified in the technique, the table is required to be
    // loaded before the POI can be rendered.
    if (!poiManager.updatePoiFromPoiTable(textElement)) {
        // PoiTable has not been loaded, but is required to determine
        // visibility.
        return { result: PrePlacementResult.NotReady, viewDistance };
    }
    // Text element visibility and zoom level ranges must be checked after calling
    // updatePoiFromPoiTable, since that function may change those values.
    if (!textElement.visible ||
        !harp_utils_1.MathUtils.isClamped(viewState.zoomLevel, textElement.minZoomLevel, textElement.maxZoomLevel)) {
        return { result: PrePlacementResult.Invisible, viewDistance };
    }
    viewDistance =
        maxViewDistance === undefined
            ? computeViewDistance(viewState.worldCenter, textElement)
            : checkViewDistance(viewState.worldCenter, textElement, viewState.projection.type, viewCamera, maxViewDistance);
    if (viewDistance === undefined) {
        return { result: PrePlacementResult.TooFar, viewDistance };
    }
    return { result: PrePlacementResult.Ok, viewDistance };
}
exports.checkReadyForPlacement = checkReadyForPlacement;
/**
 * Computes the offset for a point text accordingly to text alignment (and icon, if any).
 * @param textElement The text element of which the offset will computed. It must be a point
 * label with [[layoutStyle]] and [[bounds]] already computed.
 * @param offset The offset result.
 */
function computePointTextOffset(textElement, offset = new THREE.Vector2()) {
    harp_utils_1.assert(textElement.type === TextElementType_1.TextElementType.PoiLabel);
    harp_utils_1.assert(textElement.layoutStyle !== undefined);
    harp_utils_1.assert(textElement.bounds !== undefined);
    const hAlign = textElement.layoutStyle.horizontalAlignment;
    const vAlign = textElement.layoutStyle.verticalAlignment;
    switch (hAlign) {
        case harp_text_canvas_1.HorizontalAlignment.Right:
            offset.x = -textElement.xOffset;
            break;
        default:
            offset.x = textElement.xOffset;
            break;
    }
    switch (vAlign) {
        case harp_text_canvas_1.VerticalAlignment.Below:
            offset.y = -textElement.yOffset;
            break;
        case harp_text_canvas_1.VerticalAlignment.Above:
            offset.y = textElement.yOffset - textElement.bounds.min.y;
            break;
        default:
            offset.y = textElement.yOffset;
            break;
    }
    if (textElement.poiInfo !== undefined && TextElement_1.poiIsRenderable(textElement.poiInfo)) {
        harp_utils_1.assert(textElement.poiInfo.computedWidth !== undefined);
        harp_utils_1.assert(textElement.poiInfo.computedHeight !== undefined);
        offset.x += textElement.poiInfo.computedWidth * (0.5 + hAlign);
        offset.y += textElement.poiInfo.computedHeight * (0.5 + vAlign);
    }
    return offset;
}
const tmpBox = new THREE.Box2();
const tmpBoxes = [];
const tmpMeasurementParams = {};
const tmpCollisionBoxes = [];
const tmpCollisionBox = new ScreenCollisions_1.CollisionBox();
const tmpScreenPosition = new THREE.Vector2();
const tmpTextOffset = new THREE.Vector2();
const tmp2DBox = new harp_utils_1.Math2D.Box();
const pointLabelMargin = new THREE.Vector2(4, 2);
var PlacementResult;
(function (PlacementResult) {
    PlacementResult[PlacementResult["Ok"] = 0] = "Ok";
    PlacementResult[PlacementResult["Rejected"] = 1] = "Rejected";
    PlacementResult[PlacementResult["Invisible"] = 2] = "Invisible";
})(PlacementResult = exports.PlacementResult || (exports.PlacementResult = {}));
/**
 * Places an icon on screen.
 * @param iconRenderState The icon state.
 * @param poiInfo Icon information necessary to compute its dimensions.
 * @param screenPosition Screen position of the icon.
 * @param scaleFactor Scaling factor to apply to the icon dimensions.
 * @param screenCollisions Used to check the icon visibility and collisions.
 * @param env Current map env.
 * @returns `PlacementResult.Ok` if icon can be placed, `PlacementResult.Rejected` if there's
 * a collision, `PlacementResult.Invisible` if it's not visible.
 */
function placeIcon(iconRenderState, poiInfo, screenPosition, scaleFactor, env, screenCollisions) {
    PoiRenderer_1.PoiRenderer.computeIconScreenBox(poiInfo, screenPosition, scaleFactor, env, tmp2DBox);
    if (!screenCollisions.isVisible(tmp2DBox)) {
        return PlacementResult.Invisible;
    }
    const iconSpaceAvailable = poiInfo.mayOverlap === true || !screenCollisions.isAllocated(tmp2DBox);
    if (!iconSpaceAvailable) {
        return iconRenderState.isVisible() ? PlacementResult.Rejected : PlacementResult.Invisible;
    }
    return PlacementResult.Ok;
}
exports.placeIcon = placeIcon;
/**
 * Places a point label on a specified text canvas.
 * @param labelState State of the point label to place.
 * @param screenPosition Position of the label in screen coordinates.
 * @param scale Scale factor to be applied to label dimensions.
 * @param isRejected Whether the label is already rejected (e.g. because its icon was rejected). If
 * `true`, text won't be checked for collision, result will be either `PlacementResult.Invisible` or
 * `PlacementResult.Rejected`.
 * @param textCanvas The text canvas where the label will be placed.
 * @param screenCollisions Used to check collisions with other labels.
 * @param outScreenPosition The final label screen position after applying any offsets.
 * @returns `PlacementResult.Ok` if path label can be placed, `PlacementResult.Rejected` if there's
 * a collision, `PlacementResult.Invisible` if it's not visible.
 */
function placePointLabel(labelState, screenPosition, scale, textCanvas, screenCollisions, isRejected, outScreenPosition) {
    const label = labelState.element;
    if (label.bounds === undefined) {
        label.bounds = new THREE.Box2();
        tmpMeasurementParams.outputCharacterBounds = undefined;
        tmpMeasurementParams.path = undefined;
        tmpMeasurementParams.pathOverflow = false;
        tmpMeasurementParams.letterCaseArray = label.glyphCaseArray;
        textCanvas.measureText(label.glyphs, label.bounds, tmpMeasurementParams);
    }
    screenPosition.add(computePointTextOffset(label, tmpTextOffset));
    outScreenPosition.set(screenPosition.x, screenPosition.y, labelState.renderDistance);
    // TODO: Make the margin configurable
    tmpBox.copy(label.bounds).expandByVector(pointLabelMargin);
    tmpBox.min.multiplyScalar(scale);
    tmpBox.max.multiplyScalar(scale);
    tmpBox.translate(screenPosition);
    tmp2DBox.set(tmpBox.min.x, tmpBox.min.y, tmpBox.max.x - tmpBox.min.x, tmpBox.max.y - tmpBox.min.y);
    // Check the text visibility.
    if (!screenCollisions.isVisible(tmp2DBox)) {
        return PlacementResult.Invisible;
    }
    if (isRejected || (!label.textMayOverlap && screenCollisions.isAllocated(tmp2DBox))) {
        return labelState.visible ? PlacementResult.Rejected : PlacementResult.Invisible;
    }
    // Don't allocate space for rejected text. When zooming, this allows placement of a
    // lower priority text element that was displaced by a higher priority one (not
    // present in the new zoom level) before an even lower priority one takes the space.
    // Otherwise the lowest priority text will fade in and back out.
    // TODO: Add a unit test for this scenario.
    if (label.textReservesSpace) {
        screenCollisions.allocate(tmp2DBox);
    }
    return PlacementResult.Ok;
}
exports.placePointLabel = placePointLabel;
/**
 * Places a path label along a given path on a specified text canvas.
 * @param labelState The state of the path label to place.
 * @param textPath The text path along which the label will be placed.
 * @param screenPosition Position of the label in screen coordinates.
 * @param textCanvas The text canvas where the label will be placed.
 * @param screenCollisions Used to check collisions with other labels.
 * @returns `PlacementResult.Ok` if path label can be placed, `PlacementResult.Rejected` if there's
 * a collision or text doesn't fit into path, `PlacementResult.Invisible` if it's not visible.
 */
function placePathLabel(labelState, textPath, screenPosition, textCanvas, screenCollisions) {
    // Recalculate the text bounds for this path label. If measurement fails, the whole
    // label doesn't fit the path and should be discarded.
    tmpMeasurementParams.path = textPath;
    tmpMeasurementParams.outputCharacterBounds = tmpBoxes;
    tmpMeasurementParams.letterCaseArray = labelState.element.glyphCaseArray;
    // TODO: HARP-7648. TextCanvas.measureText does the placement as in TextCanvas.addText but
    // without storing the result. If the measurement succeeds, the placement work is done
    // twice.
    // This could be done in one step (e.g measureAndAddText). Collision test could be injected
    // in the middle as a function.
    if (!textCanvas.measureText(labelState.element.glyphs, tmpBox, tmpMeasurementParams)) {
        return PlacementResult.Rejected;
    }
    // Coarse collision check.
    tmpCollisionBox.copy(tmpBox.translate(screenPosition));
    if (!screenCollisions.isVisible(tmpCollisionBox)) {
        return PlacementResult.Invisible;
    }
    let checkGlyphCollision = false;
    let candidateBoxes;
    if (!labelState.element.textMayOverlap) {
        candidateBoxes = screenCollisions.search(tmpCollisionBox);
        checkGlyphCollision = candidateBoxes.length > 0;
    }
    const checkGlyphVisible = !screenCollisions.isFullyVisible(tmpCollisionBox);
    // Perform per-character collision checks.
    tmpCollisionBoxes.length = tmpBoxes.length;
    for (let i = 0; i < tmpBoxes.length; ++i) {
        const glyphBox = tmpBoxes[i].translate(screenPosition);
        let collisionBox = tmpCollisionBoxes[i];
        if (collisionBox === undefined) {
            collisionBox = new ScreenCollisions_1.CollisionBox(glyphBox);
            tmpCollisionBoxes[i] = collisionBox;
        }
        else {
            collisionBox.copy(glyphBox);
        }
        if (checkGlyphVisible && !screenCollisions.isVisible(collisionBox)) {
            return PlacementResult.Invisible;
        }
        if (checkGlyphCollision &&
            screenCollisions.intersectsDetails(collisionBox, candidateBoxes)) {
            return PlacementResult.Rejected;
        }
    }
    // Allocate collision info if needed.
    if (labelState.element.textReservesSpace) {
        const collisionBox = new ScreenCollisions_1.DetailedCollisionBox(tmpCollisionBox, tmpCollisionBoxes.slice());
        tmpCollisionBoxes.length = 0;
        screenCollisions.allocate(collisionBox);
    }
    return PlacementResult.Ok;
}
exports.placePathLabel = placePathLabel;
/**
 * Check if a given path label is too small to be rendered.
 * @param textElement The text element to check.
 * @param screenProjector Used to project coordinates from world to screen space.
 * @param outScreenPoints Label path projected to screen space.
 * @returns `true` if label is too small, `false` otherwise.
 */
function isPathLabelTooSmall(textElement, screenProjector, outScreenPoints) {
    harp_utils_1.assert(textElement.type === TextElementType_1.TextElementType.PathLabel);
    // Get the screen points that define the label's segments and create a path with
    // them.
    outScreenPoints.length = 0;
    let anyPointVisible = false;
    for (const pt of textElement.points) {
        // Skip invisible points at the beginning of the path.
        const screenPoint = anyPointVisible
            ? screenProjector.project(pt, tmpScreenPosition)
            : screenProjector.projectOnScreen(pt, tmpScreenPosition);
        if (screenPoint === undefined) {
            continue;
        }
        anyPointVisible = true;
        outScreenPoints.push(tmpScreenPosition.clone());
    }
    // TODO: (HARP-3515)
    //      The rendering of a path label that contains just a single point that is not
    //      visible is impossible, which is problematic with long paths.
    //      Fix: Skip/clip the invisible points at beginning and end of the path to get
    //      the visible part of the path.
    // If not a single point is visible, skip the path
    if (!anyPointVisible) {
        return true;
    }
    // Check/guess if the screen box can hold a string of that length. It is important
    // to guess that value without measuring the font first to save time.
    const minScreenSpace = textElement.text.length * MIN_AVERAGE_CHAR_WIDTH;
    tmpBox.setFromPoints(outScreenPoints);
    const boxDiagonalSq = tmpBox.max.sub(tmpBox.min).lengthSq();
    if (boxDiagonalSq < minScreenSpace * minScreenSpace) {
        textElement.dbgPathTooSmall = true;
        return true;
    }
    return false;
}
exports.isPathLabelTooSmall = isPathLabelTooSmall;


/***/ }),

/***/ "../harp-mapview/lib/text/PlacementStats.ts":
/*!**************************************************!*\
  !*** ../harp-mapview/lib/text/PlacementStats.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class PlacementStats {
    constructor(m_logger) {
        this.m_logger = m_logger;
        this.totalGroups = 0;
        this.resortedGroups = 0;
        this.total = 0;
        this.uninitialized = 0;
        this.tooFar = 0;
        this.numNotVisible = 0;
        this.numPathTooSmall = 0;
        this.numCannotAdd = 0;
        this.numRenderedPoiIcons = 0;
        this.numRenderedPoiTexts = 0;
        this.numPoiTextsInvisible = 0;
        this.numRenderedTextElements = 0;
    }
    clear() {
        this.totalGroups = 0;
        this.resortedGroups = 0;
        this.total = 0;
        this.uninitialized = 0;
        this.tooFar = 0;
        this.numNotVisible = 0;
        this.numPathTooSmall = 0;
        this.numCannotAdd = 0;
        this.numRenderedPoiIcons = 0;
        this.numRenderedPoiTexts = 0;
        this.numPoiTextsInvisible = 0;
        this.numRenderedTextElements = 0;
    }
    log() {
        const numNotRendered = this.uninitialized +
            this.numPoiTextsInvisible +
            this.tooFar +
            this.numNotVisible +
            this.numCannotAdd;
        this.m_logger.debug("Total groups", this.totalGroups);
        this.m_logger.debug("Resorted groups", this.resortedGroups);
        this.m_logger.debug("Total labels", this.total);
        this.m_logger.debug("Rendered labels", this.numRenderedTextElements);
        this.m_logger.debug("Rejected labels", numNotRendered);
        this.m_logger.debug("Unitialized labels", this.uninitialized);
        this.m_logger.debug("Rendered poi icons", this.numRenderedPoiIcons);
        this.m_logger.debug("Rendered poi texts", this.numRenderedPoiTexts);
        this.m_logger.debug("Poi text invisible", this.numPoiTextsInvisible);
        this.m_logger.debug("Too far", this.tooFar);
        this.m_logger.debug("Not visible", this.numNotVisible);
        this.m_logger.debug("Path too small", this.numPathTooSmall);
        this.m_logger.debug("Rejected, max glyphs reached", this.numCannotAdd);
    }
}
exports.PlacementStats = PlacementStats;


/***/ }),

/***/ "../harp-mapview/lib/text/RenderState.ts":
/*!***********************************************!*\
  !*** ../harp-mapview/lib/text/RenderState.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const THREE = __webpack_require__(/*! three */ "three");
/**
 * State of fading.
 */
var FadingState;
(function (FadingState) {
    FadingState[FadingState["Undefined"] = 0] = "Undefined";
    FadingState[FadingState["FadingIn"] = 1] = "FadingIn";
    FadingState[FadingState["FadedIn"] = 2] = "FadedIn";
    FadingState[FadingState["FadingOut"] = -1] = "FadingOut";
    FadingState[FadingState["FadedOut"] = -2] = "FadedOut";
})(FadingState = exports.FadingState || (exports.FadingState = {}));
/**
 * Time to fade in/fade out the labels in milliseconds.
 */
exports.DEFAULT_FADE_TIME = 800;
/**
 * State of rendering of the icon and text part of the `TextElement`. Mainly for fading the elements
 * in and out, to compute the opacity.
 *
 * @hidden
 */
class RenderState {
    /**
     * Create a `RenderState`.
     *
     * @param value Current fading value [0..1].
     * @param startTime Time stamp the fading started.
     * @param opacity Computed opacity depending on value.
     */
    constructor(value = 0.0, startTime = 0, opacity = 1.0) {
        this.value = value;
        this.startTime = startTime;
        this.opacity = opacity;
        this.m_state = FadingState.Undefined;
    }
    /**
     * Reset existing `RenderState` to appear like a fresh state.
     */
    reset() {
        this.m_state = FadingState.Undefined;
        this.value = 0.0;
        this.startTime = 0.0;
        this.opacity = 1.0;
    }
    /**
     * @returns `true` if element state is `FadingState.Undefined`.
     */
    isUndefined() {
        return this.m_state === FadingState.Undefined;
    }
    /**
     * @returns `true` if element is either fading in or fading out.
     */
    isFading() {
        const fading = this.m_state === FadingState.FadingIn || this.m_state === FadingState.FadingOut;
        return fading;
    }
    /**
     * @returns `true` if element is fading in.
     */
    isFadingIn() {
        const fadingIn = this.m_state === FadingState.FadingIn;
        return fadingIn;
    }
    /**
     * @returns `true` if element is fading out.
     */
    isFadingOut() {
        const fadingOut = this.m_state === FadingState.FadingOut;
        return fadingOut;
    }
    /**
     * @returns `true` if element is done with fading in.
     */
    isFadedIn() {
        const fadedIn = this.m_state === FadingState.FadedIn;
        return fadedIn;
    }
    /**
     * @returns `true` if element is done with fading out.
     */
    isFadedOut() {
        const fadedOut = this.m_state === FadingState.FadedOut;
        return fadedOut;
    }
    /**
     * @returns `true` if state is neither faded out nor undefined.
     */
    isVisible() {
        return this.m_state !== FadingState.FadedOut && this.m_state !== FadingState.Undefined;
    }
    /**
     * Updates the state to [[FadingState.FadingIn]].
     * If previous state is [[FadingState.FadingIn]] or [[FadingState.FadedIn]] it remains
     * unchanged.
     *
     * @param time Current time.
     */
    startFadeIn(time) {
        if (this.m_state === FadingState.FadingIn || this.m_state === FadingState.FadedIn) {
            return;
        }
        if (this.m_state === FadingState.FadingOut) {
            // The fadeout is not complete: compute the virtual fadingStartTime in the past, to get
            // a correct end time:
            this.value = 1.0 - this.value;
            this.startTime = time - this.value * exports.DEFAULT_FADE_TIME;
        }
        else {
            this.startTime = time;
            this.value = 0.0;
            this.opacity = 0;
        }
        this.m_state = FadingState.FadingIn;
    }
    /**
     * Updates the state to [[FadingState.FadingOut]].
     * If previous state is [[FadingState.FadingOut]] or [[FadingState.FadedOut]] it remains
     * unchanged.
     *
     * @param time Current time.
     */
    startFadeOut(time) {
        if (this.m_state === FadingState.FadingOut || this.m_state === FadingState.FadedOut) {
            return;
        }
        if (this.m_state === FadingState.FadingIn) {
            // The fade-in is not complete: compute the virtual fadingStartTime in the past, to get
            // a correct end time:
            this.startTime = time - this.value * exports.DEFAULT_FADE_TIME;
            this.value = 1.0 - this.value;
        }
        else {
            this.startTime = time;
            this.value = 0.0;
            this.opacity = 1;
        }
        this.m_state = FadingState.FadingOut;
    }
    /**
     * Updates opacity to current time, changing the state to [[FadingState.FadedOut]] or
     * [[FadingState.FadedIn]] when the opacity becomes 0 or 1 respectively.
     * It does nothing if [[isFading]] !== `true`.
     *
     * @param time Current time.
     * @param disableFading `true` if fading is disabled, `false` otherwise.
     */
    updateFading(time, disableFading) {
        if (this.m_state !== FadingState.FadingIn && this.m_state !== FadingState.FadingOut) {
            return;
        }
        if (this.startTime === 0) {
            this.startTime = time;
        }
        const fadingTime = time - this.startTime;
        const startValue = this.m_state === FadingState.FadingIn ? 0 : 1;
        const endValue = this.m_state === FadingState.FadingIn ? 1 : 0;
        if (disableFading || fadingTime >= exports.DEFAULT_FADE_TIME) {
            this.value = 1.0;
            this.opacity = endValue;
            this.m_state =
                this.m_state === FadingState.FadingIn ? FadingState.FadedIn : FadingState.FadedOut;
        }
        else {
            // TODO: HARP-7648. Do this once for all labels (calculate the last frame value
            // increment).
            this.value = fadingTime / exports.DEFAULT_FADE_TIME;
            this.opacity = THREE.Math.clamp(harp_utils_1.MathUtils.smootherStep(startValue, endValue, this.value), 0, 1);
            harp_utils_1.assert(this.isFading());
        }
    }
}
exports.RenderState = RenderState;


/***/ }),

/***/ "../harp-mapview/lib/text/SimplePath.ts":
/*!**********************************************!*\
  !*** ../harp-mapview/lib/text/SimplePath.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * @hidden
 */
class SimpleLineCurve extends THREE.LineCurve {
    constructor(v1, v2) {
        super(v1, v2);
    }
    getLengths() {
        if (this.m_lengths === undefined) {
            this.m_lengths = [0, this.v2.distanceTo(this.v1)];
        }
        return this.m_lengths;
    }
}
exports.SimpleLineCurve = SimpleLineCurve;
/**
 * @hidden
 */
class PathParam {
    constructor(path, index, t) {
        this.path = path;
        this.index = index;
        this.t = t;
    }
    get curve() {
        return this.path.curves[this.index];
    }
    get point() {
        if (this.m_point === undefined) {
            this.m_point = this.curve.getPoint(this.t);
        }
        return this.m_point;
    }
}
exports.PathParam = PathParam;
/**
 * @hidden
 */
class SimplePath extends THREE.Path {
    constructor() {
        super();
    }
    getLengths() {
        if (this.m_cache) {
            return this.m_cache;
        }
        let sum = 0;
        const lengths = new Array();
        lengths.push(0);
        this.curves.forEach(curve => {
            const lineCurve = curve;
            sum += lineCurve.v1.distanceTo(lineCurve.v2);
            lengths.push(sum);
        });
        this.m_cache = lengths;
        return lengths;
    }
    getParamAt(t) {
        const distance = t * this.getLength();
        const curveLengths = this.getCurveLengths();
        for (let index = 0; index < curveLengths.length; ++index) {
            if (curveLengths[index] < distance) {
                continue;
            }
            const diff = curveLengths[index] - distance;
            const curve = this.curves[index];
            const segmentLength = curve.getLength();
            const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
            return new PathParam(this, index, u);
        }
        return null;
    }
}
exports.SimplePath = SimplePath;


/***/ }),

/***/ "../harp-mapview/lib/text/TextCanvasFactory.ts":
/*!*****************************************************!*\
  !*** ../harp-mapview/lib/text/TextCanvasFactory.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "../harp-text-canvas/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
class TextCanvasFactory {
    /**
     * Creates an instance of text canvas factory.
     * @param m_renderer
     */
    constructor(m_renderer) {
        this.m_renderer = m_renderer;
        this.m_minGlyphCount = 0; //Min amount of glyphs each [[TextCanvas]] layer can store.
        this.m_maxGlyphCount = 0; //Max amount of glyphs each [[TextCanvas]] layer can store.
    }
    setGlyphCountLimits(min, max) {
        this.m_minGlyphCount = min;
        this.m_maxGlyphCount = max;
    }
    /**
     * Creates text canvas
     * @param fontCatalog Initial [[FontCatalog]].
     */
    createTextCanvas(fontCatalog) {
        harp_utils_1.assert(this.m_maxGlyphCount > 0);
        return new harp_text_canvas_1.TextCanvas({
            renderer: this.m_renderer,
            fontCatalog,
            minGlyphCount: this.m_minGlyphCount,
            maxGlyphCount: this.m_maxGlyphCount
        });
    }
}
exports.TextCanvasFactory = TextCanvasFactory;


/***/ }),

/***/ "../harp-mapview/lib/text/TextElement.ts":
/*!***********************************************!*\
  !*** ../harp-mapview/lib/text/TextElement.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "../harp-text-canvas/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const THREE = __webpack_require__(/*! three */ "three");
const TextElementType_1 = __webpack_require__(/*! ./TextElementType */ "../harp-mapview/lib/text/TextElementType.ts");
/**
 * Return 'true' if the POI has been successfully prepared for rendering.
 *
 * @param poiInfo PoiInfo containing information for rendering the POI icon.
 */
function poiIsRenderable(poiInfo) {
    return poiInfo.poiRenderBatch !== undefined;
}
exports.poiIsRenderable = poiIsRenderable;
/**
 * State of loading.
 */
var LoadingState;
(function (LoadingState) {
    LoadingState[LoadingState["Requested"] = 0] = "Requested";
    LoadingState[LoadingState["Loaded"] = 1] = "Loaded";
    LoadingState[LoadingState["Initialized"] = 2] = "Initialized";
})(LoadingState = exports.LoadingState || (exports.LoadingState = {}));
/**
 * `TextElement` is used to create 2D text elements (for example, labels).
 */
class TextElement {
    /**
     * Creates a new `TextElement`.
     *
     * @param text The text to display.
     * @param points The position or a list of points for a curved text, both in world space.
     * @param renderParams `TextElement` text rendering parameters.
     * @param layoutParams `TextElement` text layout parameters.
     * @param priority The priority of the `TextElement. Elements with the highest priority get
     *              placed first, elements with priority of `0` are placed last, elements with a
     *              negative value are always rendered, ignoring priorities and allowing
     *              overrides.
     * @param xOffset Optional X offset of this `TextElement` in screen coordinates.
     * @param yOffset Optional Y offset of this `TextElement` in screen coordinates.
     * @param featureId Optional number to identify feature (originated from `OmvDataSource`).
     * @param fadeNear Distance to the camera (0.0 = camera position, 1.0 = farPlane) at which the
     *              label starts fading out (opacity decreases).
     * @param fadeFar Distance to the camera (0.0 = camera position, 1.0 = farPlane) at which the
     *              label becomes transparent. A value of <= 0.0 disables fading.
     */
    constructor(text, points, renderParams, layoutParams, priority = 0, xOffset = 0, yOffset = 0, featureId, style, fadeNear, fadeFar, tileOffset) {
        this.text = text;
        this.points = points;
        this.renderParams = renderParams;
        this.layoutParams = layoutParams;
        this.priority = priority;
        this.xOffset = xOffset;
        this.yOffset = yOffset;
        this.featureId = featureId;
        this.style = style;
        this.fadeNear = fadeNear;
        this.fadeFar = fadeFar;
        this.tileOffset = tileOffset;
        /**
         * Determines visibility. If set to `false`, it will not be rendered.
         */
        this.visible = true;
        /**
         * Scaling factor of text. Defaults to 0.5, reducing the size ot 50% in the distance.
         */
        this.distanceScale = 0.5;
        /**
         * If specified, determines the render order between `TextElement`s. The number different
         * renderOrders should be as small as possible, because every specific `renderOrder` may result
         * in one or more draw calls.
         *
         * TextElements with the same integer `renderOrder` will be rendered in the same batch.
         *
         * The `renderOrder` of `TextElement`s are only relative to other `TextElement`s, and not other
         * map elements.
         *
         * A `TextElement` with a higher `renderOrder` will be rendered after a `TextElement` with a
         * lower `renderOrder`.
         */
        this.renderOrder = 0;
        /**
         * If set to `true` the geometry has been already overlaid on elevation.
         */
        this.elevated = false;
        if (renderParams instanceof harp_text_canvas_1.TextRenderStyle) {
            this.renderStyle = renderParams;
        }
        if (layoutParams instanceof harp_text_canvas_1.TextLayoutStyle) {
            this.layoutStyle = layoutParams;
        }
        this.type =
            points instanceof THREE.Vector3 ? TextElementType_1.TextElementType.PoiLabel : TextElementType_1.TextElementType.PathLabel;
    }
    /**
     * The text element position or the first point of the path used to render a curved text, both
     * in world space.
     */
    get position() {
        if (this.points instanceof Array) {
            const p = this.points[0];
            return p;
        }
        return this.points;
    }
    /**
     * The list of points in world space used to render the text along a path or `undefined`.
     */
    get path() {
        if (this.points instanceof Array) {
            return this.points;
        }
        return undefined;
    }
    /**
     * If `true`, `TextElement` is allowed to overlap other labels or icons of lower priority.
     *
     * @default `false`
     */
    get textMayOverlap() {
        return this.mayOverlap === true;
    }
    set textMayOverlap(mayOverlap) {
        this.mayOverlap = mayOverlap;
    }
    /**
     * If `true`, `TextElement` will reserve screen space, other markers of lower priority will not
     * be able to overlap.
     *
     * @default `true`
     */
    get textReservesSpace() {
        return this.reserveSpace !== false;
    }
    set textReservesSpace(reserveSpace) {
        this.reserveSpace = reserveSpace;
    }
    /**
     * Contains additional information about icon to be rendered along with text.
     */
    get poiInfo() {
        return this.m_poiInfo;
    }
    set poiInfo(poiInfo) {
        this.m_poiInfo = poiInfo;
        if (poiInfo !== undefined) {
            if (this.path !== undefined) {
                this.type = TextElementType_1.TextElementType.LineMarker;
            }
            const poiRenderOrder = this.renderOrder !== undefined ? this.renderOrder : 0;
            poiInfo.renderOrder = poiRenderOrder;
        }
    }
    /**
     * @returns The style used to render this text element, undefined if not set yet.
     */
    get renderStyle() {
        return this.m_renderStyle;
    }
    /**
     * Sets style used for text rendering.
     * @param style The style to use.
     */
    set renderStyle(style) {
        this.m_renderStyle = style;
    }
    /**
     * @returns The style used to layout this text element, undefined if not set yet.
     */
    get layoutStyle() {
        return this.m_layoutStyle;
    }
    /**
     * Sets the style used for text layout.
     * @param style The style to use.
     */
    set layoutStyle(style) {
        this.m_layoutStyle = style;
    }
    hasFeatureId() {
        return this.featureId !== undefined && this.featureId !== 0;
    }
    /**
     * Update the minZoomLevel and maxZoomLevel from the values set in [[PoiInfo]].
     * Selects the smaller/larger one of the two min/max values for icon and text, because the
     * TextElement is a container for both.
     */
    updateMinMaxZoomLevelsFromPoiInfo() {
        if (this.poiInfo !== undefined) {
            if (this.minZoomLevel === undefined) {
                this.minZoomLevel = harp_utils_1.MathUtils.min2(this.poiInfo.iconMinZoomLevel, this.poiInfo.textMinZoomLevel);
            }
            if (this.maxZoomLevel === undefined) {
                this.maxZoomLevel = harp_utils_1.MathUtils.max2(this.poiInfo.iconMaxZoomLevel, this.poiInfo.textMaxZoomLevel);
            }
        }
    }
}
exports.TextElement = TextElement;


/***/ }),

/***/ "../harp-mapview/lib/text/TextElementGroup.ts":
/*!****************************************************!*\
  !*** ../harp-mapview/lib/text/TextElementGroup.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
/**
 * Group of [[TextElement]] sharing same priority.
 */
class TextElementGroup extends harp_utils_1.PriorityListGroup {
}
exports.TextElementGroup = TextElementGroup;


/***/ }),

/***/ "../harp-mapview/lib/text/TextElementGroupPriorityList.ts":
/*!****************************************************************!*\
  !*** ../harp-mapview/lib/text/TextElementGroupPriorityList.ts ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
/**
 * List of [[TextElement]] groups sorted by priority.
 */
class TextElementGroupPriorityList extends harp_utils_1.GroupedPriorityList {
}
exports.TextElementGroupPriorityList = TextElementGroupPriorityList;


/***/ }),

/***/ "../harp-mapview/lib/text/TextElementGroupState.ts":
/*!*********************************************************!*\
  !*** ../harp-mapview/lib/text/TextElementGroupState.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const TextElementState_1 = __webpack_require__(/*! ./TextElementState */ "../harp-mapview/lib/text/TextElementState.ts");
/**
 * `TextElementGroupState` keeps the state of a text element group and each element in it while
 * they're being rendered.
 */
class TextElementGroupState {
    /**
     * Creates the state for specified group.
     * @param group The group of which the state will be created.
     * @param tileKey The key of the tile to which this group belongs.
     * @param filter Function used to do early rejection. @see [[TextElementFilter]].
     */
    constructor(group, tileKey, filter) {
        this.group = group;
        this.tileKey = tileKey;
        this.m_visited = false;
        harp_utils_1.assert(group.elements.length > 0);
        const length = group.elements.length;
        this.m_textElementStates = new Array(length);
        this.m_visited = true;
        // TODO: HARP-7648. Reduce number of allocations here:
        // a) Avoid creating the state for labels that don't pass early placement checks and make
        //    this checks more strict.
        // b) Break label state objects into a set of arrays held at group level, one for each
        //    primitive field in the label state.
        for (let i = 0; i < length; ++i) {
            const textElement = group.elements[i];
            const state = new TextElementState_1.TextElementState(textElement);
            const textDistance = filter(state);
            state.update(textDistance);
            this.m_textElementStates[i] = state;
        }
    }
    /**
     * Indicates whether the group has been submitted to the [[TextElementsRenderer]] in the current
     * frame.
     */
    get visited() {
        return this.m_visited;
    }
    set visited(visited) {
        this.m_visited = visited;
    }
    /**
     * @returns the priority of the text elements in the group.
     */
    get priority() {
        return this.group.priority;
    }
    /**
     * Updates the fading state of all text elements within the group to the specified time.
     * @param time The time to which the fading state will be updated.
     * @param disableFading `true` if fading is disabled, `false` otherwise.
     */
    updateFading(time, disableFading) {
        for (const elementState of this.m_textElementStates) {
            if (elementState !== undefined) {
                elementState.updateFading(time, disableFading);
            }
        }
    }
    /**
     * Calls the specified callback for every visible text elements in the group.
     * @param visibleElementsCallback Functions that will be called for every visible text element
     * in the group.
     */
    traverseVisibleElements(visibleElementsCallback) {
        for (const elementState of this.m_textElementStates) {
            if (elementState !== undefined && elementState.visible) {
                visibleElementsCallback(elementState);
            }
        }
    }
    /**
     * Updates the states of elements within the group.
     * @param filter Function used to do early rejection. @see [[TextElementFilter]].
     */
    updateElements(filter) {
        for (const elementState of this.m_textElementStates) {
            const textDistance = filter(elementState);
            elementState.update(textDistance);
        }
    }
    get size() {
        return this.m_textElementStates.length;
    }
    /**
     * Returns text element states.
     * @returns Array of element states.
     */
    get textElementStates() {
        return this.m_textElementStates;
    }
}
exports.TextElementGroupState = TextElementGroupState;


/***/ }),

/***/ "../harp-mapview/lib/text/TextElementState.ts":
/*!****************************************************!*\
  !*** ../harp-mapview/lib/text/TextElementState.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const RenderState_1 = __webpack_require__(/*! ./RenderState */ "../harp-mapview/lib/text/RenderState.ts");
const TextElementType_1 = __webpack_require__(/*! ./TextElementType */ "../harp-mapview/lib/text/TextElementType.ts");
/**
 * `TextElementState` keeps the current state of a text element while it's being rendered.
 */
class TextElementState {
    constructor(element) {
        this.element = element;
    }
    get initialized() {
        return this.m_textRenderState !== undefined || this.m_iconRenderStates !== undefined;
    }
    /**
     * @returns `true` if any component of the element is visible, `false` otherwise.
     */
    get visible() {
        if (this.m_textRenderState !== undefined && this.m_textRenderState.isVisible()) {
            return true;
        }
        const iconRenderState = this.iconRenderState;
        if (iconRenderState !== undefined && iconRenderState.isVisible()) {
            return true;
        }
        const iconRenderStates = this.iconRenderStates;
        if (iconRenderStates === undefined) {
            return false;
        }
        for (const state of iconRenderStates) {
            if (state.isVisible()) {
                return true;
            }
        }
        return false;
    }
    /**
     * Resets the element to an initialized state.
     */
    reset() {
        if (this.m_textRenderState !== undefined) {
            this.m_textRenderState.reset();
        }
        if (this.iconRenderState) {
            this.m_iconRenderStates.reset();
        }
        else if (this.m_iconRenderStates !== undefined) {
            for (const renderState of this.m_iconRenderStates) {
                renderState.reset();
            }
        }
        this.m_viewDistance = undefined;
    }
    /**
     * Replaces given text element, inheriting its current state.
     * The predecessor text element state is erased.
     * @param predecessor Text element state to be replaced.
     */
    replace(predecessor) {
        this.m_textRenderState = predecessor.m_textRenderState;
        this.m_iconRenderStates = predecessor.m_iconRenderStates;
        predecessor.m_textRenderState = undefined;
        predecessor.m_iconRenderStates = undefined;
        if (this.element.glyphs === undefined) {
            // Use the predecessor glyphs, bounds and case array until proper ones are computed.
            this.element.glyphs = predecessor.element.glyphs;
            this.element.bounds = predecessor.element.bounds;
            this.element.glyphCaseArray = predecessor.element.glyphCaseArray;
        }
    }
    /**
     * Returns the last computed distance of the text element to the camera.
     * @returns Distance to camera.
     */
    get viewDistance() {
        return this.m_viewDistance;
    }
    /**
     * Updates the text element state.
     * @param viewDistance The new view distance to set. If `undefined`, element is considered to
     * be out of view.
     */
    update(viewDistance) {
        if (this.initialized) {
            this.setViewDistance(viewDistance);
        }
        else if (viewDistance !== undefined) {
            this.initialize(viewDistance);
        }
    }
    /**
     * Sets the distance of the element to the current view center.
     * @param viewDistance The new view distance to set. If `undefined`, element is considered to
     * be out of view.
     */
    setViewDistance(viewDistance) {
        if (viewDistance === this.m_viewDistance) {
            return;
        }
        this.m_viewDistance = viewDistance;
    }
    /**
     * Return the last distance that has been computed for sorting during placement. This may not be
     * the actual distance if the camera is moving, as the distance is computed only during
     * placement. If the property `alwaysOnTop` is true, the value returned is always `0`.
     *
     * @returns 0 or negative distance to camera.
     */
    get renderDistance() {
        return this.element.alwaysOnTop === true
            ? 0
            : this.m_viewDistance !== undefined
                ? -this.m_viewDistance
                : 0;
    }
    /**
     * @returns The text render state.
     */
    get textRenderState() {
        return this.m_textRenderState;
    }
    /**
     * Returns the icon render state for the case where the text element has only one icon.
     * @returns The icon render state if the text element has a single icon, otherwise undefined.
     */
    get iconRenderState() {
        if (this.m_iconRenderStates === undefined) {
            return undefined;
        }
        return this.m_iconRenderStates instanceof RenderState_1.RenderState ? this.m_iconRenderStates : undefined;
    }
    /**
     * Returns the icon render states for text elements with multiple icons.
     * @returns The icon render states if the text element has multiple icons, otherwise undefined.
     */
    get iconRenderStates() {
        if (this.m_iconRenderStates === undefined) {
            return undefined;
        }
        return this.m_iconRenderStates instanceof RenderState_1.RenderState
            ? undefined
            : this.m_iconRenderStates;
    }
    /**
     * Updates the fading state to the specified time.
     * @param time The current time.
     * @param disableFading If `True` there will be no fading transitions, i.e., state will go
     * directly from FadedIn to FadedOut and viceversa.
     */
    updateFading(time, disableFading) {
        if (this.m_textRenderState !== undefined) {
            this.m_textRenderState.updateFading(time, disableFading);
        }
        if (this.iconRenderState !== undefined) {
            const iconRenderState = this.m_iconRenderStates;
            iconRenderState.updateFading(time, disableFading);
        }
        else if (this.iconRenderStates !== undefined) {
            for (const renderState of this.m_iconRenderStates) {
                renderState.updateFading(time, disableFading);
            }
        }
    }
    /**
     * @param viewDistance Current distance of the element to the view center.
     */
    initialize(viewDistance) {
        harp_utils_1.assert(this.m_textRenderState === undefined);
        harp_utils_1.assert(this.m_iconRenderStates === undefined);
        this.setViewDistance(viewDistance);
        if (this.element.type === TextElementType_1.TextElementType.LineMarker) {
            this.m_iconRenderStates = new Array();
            for (const _point of this.element.points) {
                const iconRenderStates = this.m_iconRenderStates;
                const renderState = new RenderState_1.RenderState();
                iconRenderStates.push(renderState);
            }
            return;
        }
        this.m_textRenderState = new RenderState_1.RenderState();
        if (this.element.type === TextElementType_1.TextElementType.PoiLabel) {
            this.m_iconRenderStates = new RenderState_1.RenderState();
        }
    }
}
exports.TextElementState = TextElementState;


/***/ }),

/***/ "../harp-mapview/lib/text/TextElementStateCache.ts":
/*!*********************************************************!*\
  !*** ../harp-mapview/lib/text/TextElementStateCache.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const TextElementGroupState_1 = __webpack_require__(/*! ./TextElementGroupState */ "../harp-mapview/lib/text/TextElementGroupState.ts");
const TextElementType_1 = __webpack_require__(/*! ./TextElementType */ "../harp-mapview/lib/text/TextElementType.ts");
const logger = harp_utils_1.LoggerManager.instance.create("TextElementsStateCache", { level: harp_utils_1.LogLevel.Log });
/**
 * Label distance tolerance squared in meters. Point labels with the same name that are closer in
 * world space than this value are treated as the same label. Used to identify duplicate labels in
 * overlapping tiles and label replacements at different storage levels.
 */
function getDedupSqDistTolerance(zoomLevel) {
    // Defining here a minimum tolerance of 10m at zoom level 13 or higher.
    const minSqTol = 100;
    const minSqTolLevel = 13;
    const maxLevelDelta = 4;
    const levelDelta = Math.min(maxLevelDelta, minSqTolLevel - Math.min(minSqTolLevel, Math.floor(zoomLevel)));
    // Distance tolerance computed applying a factor over an arbitrary minimum tolerance for a
    // chosen zoom level. The factor is an exponential function on zoom level delta wrt minimum
    // tolerance zoom level.
    // error = sqrt(sqError) = sqrt(minSqError* 2^(4d)) = minError*2^(2d)
    //tslint:disable-next-line: no-bitwise
    return minSqTol << (levelDelta << 2);
}
const tmpCachedDuplicate = {
    entries: [],
    index: -1
};
function getCacheKey(element) {
    return element.hasFeatureId() ? element.featureId : element.text;
}
/**
 * Finds a duplicate for a text element among a list of candidates using their feature ids.
 * @param elementState The state of the text element for which the duplicate will be found.
 * @param candidates The list of candidates to check.
 * @returns The index of the candidate chosen as duplicate, or `undefined` if none was found.
 */
function findDuplicateById(elementState, candidates) {
    // Cached entries with same feature id found, find the entry with the same tile offset.
    const element = elementState.element;
    const duplicateIndex = candidates.findIndex(entry => entry.element.tileOffset === element.tileOffset);
    if (duplicateIndex === -1) {
        return -1;
    }
    const candidate = candidates[duplicateIndex].element;
    harp_utils_1.assert(element.featureId === candidate.featureId);
    if (candidate.text !== element.text) {
        // Labels with different text shouldn't share the same feature id. This points to
        // an issue on the map data side. Submit a ticket to the corresponding map backend
        // issue tracking system if available (e.g. OLPRPS project in JIRA for OMV),
        // indicating affected labels including tile keys, texts and feature id.
        logger.warn(`Text feature id ${element.featureId} collision between "${element.text} and \
             ${candidate.text}`);
        return undefined;
    }
    return duplicateIndex;
}
// Duplicate criteria for path labels. Candidates are better the longer their paths are.
function isBetterPathDuplicate(newCandidate, _newDistance, oldCandidate, _oldDistance) {
    if (newCandidate.pathLengthSqr === undefined) {
        return false;
    }
    if (oldCandidate.pathLengthSqr === undefined) {
        return false;
    }
    return newCandidate.pathLengthSqr > oldCandidate.pathLengthSqr;
}
// Duplicate criteria for point labels. Candidates are better the nearer they are to the label being
// tested for duplicates.
function isBetterPointDuplicate(_newCandidate, newDistance, _oldCandidate, oldDistance) {
    return newDistance < oldDistance;
}
/**
 * Finds a duplicate for a text element among a list of candidates using their text and distances.
 * @param elementState The state of the text element for which the duplicate will be found.
 * @param candidates The list of candidates to check.
 * @param zoomLevel Current zoom level.
 * @returns The index of the candidate chosen as duplicate, or `undefined` if none was found.
 */
function findDuplicateByText(elementState, candidates, zoomLevel) {
    const element = elementState.element;
    const maxSqDistError = getDedupSqDistTolerance(zoomLevel);
    const entryCount = candidates.length;
    const elementPosition = element.position;
    const elementVisible = elementState.visible;
    let dupIndex = -1;
    let duplicate;
    let dupDistSquared = Infinity;
    const isBetterDuplicate = element.type === TextElementType_1.TextElementType.PoiLabel ? isBetterPointDuplicate : isBetterPathDuplicate;
    for (let i = 0; i < entryCount; ++i) {
        const candidateEntry = candidates[i];
        const cachedElement = candidateEntry.element;
        const areDiffType = element.type !== cachedElement.type;
        const areBothVisible = elementVisible && candidateEntry.visible;
        if (areDiffType || areBothVisible) {
            // Two text elements with different type or visible at the same time are always
            // considered distinct.
            continue;
        }
        const distSquared = elementPosition.distanceToSquared(cachedElement.position);
        if (distSquared > maxSqDistError) {
            // Cached text element is too far away to be a duplicate.
            continue;
        }
        if (duplicate === undefined ||
            isBetterDuplicate(cachedElement, distSquared, duplicate, dupDistSquared)) {
            dupIndex = i;
            duplicate = cachedElement;
            dupDistSquared = distSquared;
        }
    }
    return dupIndex;
}
/**
 * Caches the state of text element groups currently rendered as well as the text element states
 * belonging to them, including their fading state and text deduplication information.
 */
class TextElementStateCache {
    constructor() {
        this.m_referenceMap = new Map();
        // Cache for point labels which may have duplicates in same tile or in neighboring tiles.
        this.m_textMap = new Map();
    }
    /**
     * Gets the state corresponding to a given text element group or sets a newly created state if
     * not found. It updates the states of the text elements belonging to the group using the
     * specified parameters.
     * @param textElementGroup The group of which the state will be obtained.
     * @param tileKey The key of the tile to which the group belongs.
     * @param textElementFilter Filter used to decide if a text element must be initialized,
     * @see [[TextElementGroupState]] construction.
     * @returns Tuple with the group state as first element and a boolean indicating whether the
     * state was found in cache (`true`) or newly created (`false`) as second element.
     */
    getOrSet(textElementGroup, tileKey, textElementFilter) {
        let groupState = this.get(textElementGroup);
        if (groupState !== undefined) {
            harp_utils_1.assert(groupState.size === textElementGroup.elements.length);
            groupState.updateElements(textElementFilter);
            return [groupState, true];
        }
        groupState = new TextElementGroupState_1.TextElementGroupState(textElementGroup, tileKey, textElementFilter);
        this.set(textElementGroup, groupState);
        return [groupState, false];
    }
    get size() {
        return this.m_referenceMap.size;
    }
    /**
     * @returns All text element group states in the cache by group priority.
     */
    get sortedGroupStates() {
        if (this.m_sortedGroupStates === undefined) {
            this.m_sortedGroupStates = Array.from(this.m_referenceMap.values());
            this.m_sortedGroupStates.sort((a, b) => {
                return b.group.priority - a.group.priority;
            });
        }
        harp_utils_1.assert(this.m_referenceMap.size === this.m_sortedGroupStates.length);
        return this.m_sortedGroupStates;
    }
    /**
     * Updates state of all cached groups, discarding those that are not needed anymore.
     * @param time The current time.
     * @param disableFading `True` if fading is currently disabled, `false` otherwise.
     * @param findReplacements `True` to replace each visible unvisited text element with a
     * visited duplicate.
     * @param zoomLevel Current zoom level.
     * @returns `True` if any textElementGroup was evicted from cache, false otherwise.
     */
    update(time, disableFading, findReplacements, zoomLevel) {
        const replaceCallback = findReplacements
            ? this.replaceElement.bind(this, zoomLevel)
            : undefined;
        let anyEviction = false;
        for (const [key, groupState] of this.m_referenceMap.entries()) {
            if (groupState.visited) {
                groupState.updateFading(time, disableFading);
            }
            else {
                if (findReplacements) {
                    groupState.traverseVisibleElements(replaceCallback);
                }
                this.m_referenceMap.delete(key);
                this.m_sortedGroupStates = undefined;
                anyEviction = true;
            }
        }
        return anyEviction;
    }
    /**
     * Clears visited state for all text element groups in cache.
     */
    clearVisited() {
        for (const groupState of this.m_referenceMap.values()) {
            groupState.visited = false;
        }
    }
    clearTextCache() {
        this.m_textMap.clear();
    }
    /**
     * Clears the whole cache contents.
     */
    clear() {
        this.m_referenceMap.clear();
        this.m_sortedGroupStates = undefined;
        this.m_textMap.clear();
    }
    /**
     * Removes duplicates for a given text element.
     *
     * @param zoomLevel Current zoom level.
     * @param elementState State of the text element to deduplicate.
     * @returns True if it's the remaining element after deduplication, false if it's been marked
     * as duplicate.
     */
    deduplicateElement(zoomLevel, elementState) {
        const cacheResult = this.findDuplicate(elementState, zoomLevel);
        if (cacheResult === undefined) {
            // Text not found so far, add this element to cache.
            this.m_textMap.set(getCacheKey(elementState.element), [elementState]);
            return true;
        }
        if (cacheResult.index === -1) {
            // No duplicate found among elements with same text,add this one to cache.
            cacheResult.entries.push(elementState);
            return true;
        }
        // Duplicate found, check whether there's a label already visible and keep that one.
        const cachedDuplicate = cacheResult.entries[cacheResult.index];
        if (!cachedDuplicate.visible && elementState.visible) {
            // New label is visible, substitute the cached label.
            cacheResult.entries[cacheResult.index] = elementState;
            cachedDuplicate.reset();
            return true;
        }
        return false;
    }
    /**
     * Replaces a visible unvisited text element with a visited duplicate.
     * @param zoomLevel Current zoom level.
     * @param elementState State of the text element to deduplicate.
     */
    replaceElement(zoomLevel, elementState) {
        harp_utils_1.assert(elementState.visible);
        const cacheResult = this.findDuplicate(elementState, zoomLevel);
        if (cacheResult === undefined || cacheResult.index === -1) {
            // No replacement found;
            return;
        }
        const replacement = cacheResult.entries[cacheResult.index];
        harp_utils_1.assert(!replacement.visible);
        replacement.replace(elementState);
    }
    /**
     * Gets the state corresponding to a given text element group.
     * @param textElementGroup The group of which the state will be obtained.
     * @returns The group state if cached, otherwise `undefined`.
     */
    get(textElementGroup) {
        const groupState = this.m_referenceMap.get(textElementGroup);
        if (groupState !== undefined) {
            groupState.visited = true;
        }
        return groupState;
    }
    /**
     * Sets a specified state for a given text element group.
     * @param textElementGroup  The group of which the state will be set.
     * @param textElementGroupState The state to set for the group.
     */
    set(textElementGroup, textElementGroupState) {
        harp_utils_1.assert(textElementGroup.elements.length > 0);
        this.m_referenceMap.set(textElementGroup, textElementGroupState);
        this.m_sortedGroupStates = undefined;
    }
    findDuplicate(elementState, zoomLevel) {
        // Point labels may have duplicates (as can path labels), Identify them
        // and keep the one we already display.
        const element = elementState.element;
        const cachedEntries = this.m_textMap.get(getCacheKey(element));
        if (cachedEntries === undefined) {
            // No labels found with the same key.
            return undefined;
        }
        tmpCachedDuplicate.entries = cachedEntries;
        const index = element.hasFeatureId()
            ? findDuplicateById(elementState, cachedEntries)
            : findDuplicateByText(elementState, cachedEntries, zoomLevel);
        if (index === undefined) {
            // Feature id collision, try finding duplicates using text as key.
            element.featureId = undefined;
            return this.findDuplicate(elementState, zoomLevel);
        }
        tmpCachedDuplicate.index = index;
        return tmpCachedDuplicate;
    }
}
exports.TextElementStateCache = TextElementStateCache;


/***/ }),

/***/ "../harp-mapview/lib/text/TextElementType.ts":
/*!***************************************************!*\
  !*** ../harp-mapview/lib/text/TextElementType.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Types of text elements.
 */
var TextElementType;
(function (TextElementType) {
    TextElementType[TextElementType["PoiLabel"] = 0] = "PoiLabel";
    TextElementType[TextElementType["PathLabel"] = 1] = "PathLabel";
    TextElementType[TextElementType["LineMarker"] = 2] = "LineMarker";
})(TextElementType = exports.TextElementType || (exports.TextElementType = {}));


/***/ }),

/***/ "../harp-mapview/lib/text/TextElementsRenderer.ts":
/*!********************************************************!*\
  !*** ../harp-mapview/lib/text/TextElementsRenderer.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "../harp-text-canvas/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const THREE = __webpack_require__(/*! three */ "three");
const DebugContext_1 = __webpack_require__(/*! ../DebugContext */ "../harp-mapview/lib/DebugContext.ts");
const overlayOnElevation_1 = __webpack_require__(/*! ../geometry/overlayOnElevation */ "../harp-mapview/lib/geometry/overlayOnElevation.ts");
const PickHandler_1 = __webpack_require__(/*! ../PickHandler */ "../harp-mapview/lib/PickHandler.ts");
const Placement_1 = __webpack_require__(/*! ./Placement */ "../harp-mapview/lib/text/Placement.ts");
const PlacementStats_1 = __webpack_require__(/*! ./PlacementStats */ "../harp-mapview/lib/text/PlacementStats.ts");
const SimplePath_1 = __webpack_require__(/*! ./SimplePath */ "../harp-mapview/lib/text/SimplePath.ts");
const TextElement_1 = __webpack_require__(/*! ./TextElement */ "../harp-mapview/lib/text/TextElement.ts");
const TextElementsRendererOptions_1 = __webpack_require__(/*! ./TextElementsRendererOptions */ "../harp-mapview/lib/text/TextElementsRendererOptions.ts");
const TextElementStateCache_1 = __webpack_require__(/*! ./TextElementStateCache */ "../harp-mapview/lib/text/TextElementStateCache.ts");
const TextElementType_1 = __webpack_require__(/*! ./TextElementType */ "../harp-mapview/lib/text/TextElementType.ts");
const TextStyleCache_1 = __webpack_require__(/*! ./TextStyleCache */ "../harp-mapview/lib/text/TextStyleCache.ts");
const UpdateStats_1 = __webpack_require__(/*! ./UpdateStats */ "../harp-mapview/lib/text/UpdateStats.ts");
var Pass;
(function (Pass) {
    Pass[Pass["PersistentLabels"] = 0] = "PersistentLabels";
    Pass[Pass["NewLabels"] = 1] = "NewLabels";
})(Pass || (Pass = {}));
/**
 * Default distance scale. Will be applied if distanceScale is not defined in the technique.
 * Defines the scale that will be applied to labeled icons (icon and text) in the distance.
 */
exports.DEFAULT_TEXT_DISTANCE_SCALE = 0.5;
/**
 * Maximum number of recommended labels. If more labels are encountered, the "overloaded" mode is
 * set, which modifies the behavior of label placement and rendering, trying to keep delivering an
 * interactive performance. The overloaded mode should not be activated if the [[MapView]] is
 * rendering a static image (camera not moving and no animation running).
 */
const OVERLOAD_LABEL_LIMIT = 20000;
/**
 * If "overloaded" is `true`:
 *
 * Default number of labels/POIs updated in a frame. They are rendered only if they fit. If the
 * camera is not moving, it is ignored. See [[TextElementsRenderer.isDynamicFrame]].
 */
const OVERLOAD_UPDATED_LABEL_LIMIT = 100;
/**
 * If "overloaded" is `true`:
 *
 * Maximum time in milliseconds available for placement. If value is <= 0, or if the camera is not
 * moving, it is ignored. See [[TextElementsRenderer.isDynamicFrame]].
 */
const OVERLOAD_UPDATE_TIME_LIMIT = 5;
/**
 * If "overloaded" is `true`:
 *
 * Maximum time in milliseconds available for rendering. If value is <= 0, or if the camera is not
 * moving, it is ignored. See [[TextElementsRenderer.isDynamicFrame]].
 */
const OVERLOAD_PLACE_TIME_LIMIT = 10;
const logger = harp_utils_1.LoggerManager.instance.create("TextElementsRenderer", { level: harp_utils_1.LogLevel.Log });
// Development flag: Enable debug print.
const PRINT_LABEL_DEBUG_INFO = false;
const updateStats = PRINT_LABEL_DEBUG_INFO ? new UpdateStats_1.UpdateStats(logger) : undefined;
const placementStats = PRINT_LABEL_DEBUG_INFO ? new PlacementStats_1.PlacementStats(logger) : undefined;
const tempPosition = new THREE.Vector3();
const tempScreenPosition = new THREE.Vector2();
const tempScreenPoints = [];
const tempPoiScreenPosition = new THREE.Vector2();
const tmpTextBufferCreationParams = {};
const tmpAdditionParams = {};
const tmpBufferAdditionParams = {};
class TileTextElements {
    constructor(tile, group) {
        this.tile = tile;
        this.group = group;
    }
}
class TextElementLists {
    constructor(lists) {
        this.lists = lists;
    }
    get priority() {
        harp_utils_1.assert(this.lists.length > 0);
        // All text element lists here have the same priority.
        return this.lists[0].group.priority;
    }
    /**
     * Sum up the number of elements in all lists.
     */
    count() {
        let n = 0;
        for (const list of this.lists) {
            n += list.group.elements.length;
        }
        return n;
    }
}
function checkIfTextElementsChanged(dataSourceTileList) {
    let textElementsChanged = false;
    dataSourceTileList.forEach(({ renderedTiles }) => {
        renderedTiles.forEach(tile => {
            if (tile.textElementsChanged) {
                tile.textElementsChanged = false;
                textElementsChanged = true;
            }
        });
    });
    return textElementsChanged;
}
function addTextToCanvas(textElement, canvas, screenPosition, path, pathOverflow) {
    tmpAdditionParams.path = path;
    tmpAdditionParams.pathOverflow = pathOverflow;
    tmpAdditionParams.layer = textElement.renderOrder;
    tmpAdditionParams.letterCaseArray = textElement.glyphCaseArray;
    tmpAdditionParams.pickingData = textElement.userData ? textElement : undefined;
    canvas.addText(textElement.glyphs, screenPosition, tmpAdditionParams);
}
function addTextBufferToCanvas(textElementState, canvas, screenPosition, fadeFactor, scaleFactor) {
    const textElement = textElementState.element;
    const textRenderState = textElementState.textRenderState;
    const opacity = textRenderState.opacity * fadeFactor * textElement.renderStyle.opacity;
    if (opacity === 0) {
        return false;
    }
    // Compute the TextBufferObject when we know we're gonna render this label.
    tmpTextBufferCreationParams.letterCaseArray = textElement.glyphCaseArray;
    if (textElement.textBufferObject === undefined) {
        textElement.textBufferObject = canvas.createTextBufferObject(textElement.glyphs, tmpTextBufferCreationParams);
    }
    const backgroundIsVisible = textElement.renderStyle.backgroundOpacity > 0 &&
        canvas.textRenderStyle.fontSize.backgroundSize > 0;
    tmpBufferAdditionParams.layer = textElement.renderOrder;
    tmpBufferAdditionParams.position = screenPosition;
    tmpBufferAdditionParams.scale = scaleFactor;
    tmpBufferAdditionParams.opacity = opacity;
    tmpBufferAdditionParams.backgroundOpacity = backgroundIsVisible
        ? tmpBufferAdditionParams.opacity * textElement.renderStyle.backgroundOpacity
        : 0.0;
    tmpBufferAdditionParams.pickingData = textElement.userData ? textElement : undefined;
    canvas.addTextBufferObject(textElement.textBufferObject, tmpBufferAdditionParams);
    return true;
}
function shouldRenderPointText(labelState, viewState, options) {
    const textRenderState = labelState.textRenderState;
    const label = labelState.element;
    const poiInfo = label.poiInfo;
    harp_utils_1.assert(label.type !== TextElementType_1.TextElementType.PathLabel);
    const hasText = textRenderState !== undefined && label.text !== "";
    if (!hasText) {
        return false;
    }
    const visibleInZoomLevel = poiInfo === undefined ||
        viewState.zoomLevel === undefined ||
        harp_utils_1.MathUtils.isClamped(viewState.zoomLevel, poiInfo.iconMinZoomLevel, poiInfo.iconMaxZoomLevel);
    if (!visibleInZoomLevel) {
        return false;
    }
    const poiTextMaxDistance = Placement_1.getMaxViewDistance(viewState, options.maxDistanceRatioForPoiLabels);
    const visibleAtDistance = label.ignoreDistance === true ||
        labelState.viewDistance === undefined ||
        labelState.viewDistance < poiTextMaxDistance;
    if (!visibleAtDistance) {
        return false;
    }
    // Do not render text if POI cannot be rendered and is not optional.
    return poiInfo === undefined || poiInfo.isValid === true || poiInfo.iconIsOptional !== false;
}
function shouldRenderPoiText(labelState, viewState) {
    // Do not actually render (just allocate space) if camera is moving and
    // renderTextDuringMovements is not true.
    const poiInfo = labelState.element.poiInfo;
    return (!viewState.cameraIsMoving ||
        poiInfo === undefined ||
        poiInfo.renderTextDuringMovements === true);
}
function isPlacementTimeExceeded(startTime) {
    // startTime is set in overload mode.
    if (startTime === undefined || OVERLOAD_PLACE_TIME_LIMIT <= 0) {
        return false;
    }
    const endTime = harp_utils_1.PerformanceTimer.now();
    const elapsedTime = endTime - startTime;
    if (elapsedTime > OVERLOAD_PLACE_TIME_LIMIT) {
        logger.debug("Placement time limit exceeded.");
        return true;
    }
    return false;
}
/**
 *
 * Internal class to manage all text rendering.
 */
class TextElementsRenderer {
    /**
     * Create the `TextElementsRenderer` which selects which labels should be placed on screen as
     * a preprocessing step, which is not done every frame, and also renders the placed
     * [[TextElement]]s every frame.
     *
     * @param m_viewState State of the view for which this renderer will draw text.
     * @param m_viewCamera Camera used by the view for which this renderer will draw text.
     * @param m_viewUpdateCallback To be called whenever the view needs to be updated.
     * @param m_screenCollisions General 2D screen occlusion management, may be shared between
     *     instances.
     * @param m_screenProjector Projects 3D coordinates into screen space.
     * @param m_textCanvasFactory To create TextCanvas instances.
     * @param m_poiRendererFactory To create PoiRenderer instances.
     * @param m_poiManager To prepare pois for rendering.
     * @param m_fontCatalogLoader To load font catalogs.
     * @param m_theme Theme defining  text styles.
     * @param options Configuration options for the text renderer. See
     * [[TextElementsRendererOptions]].
     */
    constructor(m_viewState, m_viewCamera, m_viewUpdateCallback, m_screenCollisions, m_screenProjector, m_textCanvasFactory, m_poiManager, m_poiRendererFactory, m_fontCatalogLoader, m_theme, options) {
        this.m_viewState = m_viewState;
        this.m_viewCamera = m_viewCamera;
        this.m_viewUpdateCallback = m_viewUpdateCallback;
        this.m_screenCollisions = m_screenCollisions;
        this.m_screenProjector = m_screenProjector;
        this.m_textCanvasFactory = m_textCanvasFactory;
        this.m_poiManager = m_poiManager;
        this.m_poiRendererFactory = m_poiRendererFactory;
        this.m_fontCatalogLoader = m_fontCatalogLoader;
        this.m_theme = m_theme;
        this.m_initialized = false;
        this.m_glyphLoadingCount = 0;
        this.m_textRenderers = [];
        this.m_tmpVector = new THREE.Vector2();
        this.m_overloaded = false;
        this.m_cacheInvalidated = false;
        this.m_forceNewLabelsPass = false;
        this.m_textElementStateCache = new TextElementStateCache_1.TextElementStateCache();
        this.m_textStyleCache = new TextStyleCache_1.TextStyleCache(this.m_theme);
        this.m_options = Object.assign({}, options);
        TextElementsRendererOptions_1.initializeDefaultOptions(this.m_options);
        this.m_textCanvasFactory.setGlyphCountLimits(this.m_options.minNumGlyphs, this.m_options.maxNumGlyphs);
    }
    /**
     * Disable all fading animations (for debugging and performance measurement). Defaults to
     * `false`.
     */
    set disableFading(disable) {
        this.m_options.disableFading = disable;
    }
    get disableFading() {
        return this.m_options.disableFading === true;
    }
    get styleCache() {
        return this.m_textStyleCache;
    }
    /**
     * Render the text using the specified camera into the current canvas.
     *
     * @param camera Orthographic camera to use.
     */
    renderText(camera) {
        if (!this.initialized) {
            return;
        }
        this.updateGlyphDebugMesh();
        for (const textRenderer of this.m_textRenderers) {
            textRenderer.textCanvas.render(camera);
        }
    }
    /**
     * Forces update of text elements in the next call to [[placeText]].
     */
    invalidateCache() {
        this.m_cacheInvalidated = true;
    }
    /**
     * Notify `TextElementsRenderer` that the camera has started a movement.
     */
    movementStarted() {
        // Nothing to do (yet)
    }
    /**
     * Notify `TextElementsRenderer` that the camera has finished its movement.
     */
    movementFinished() {
        this.invalidateCache();
    }
    /**
     * Is `true` if number of [[TextElement]]s in visible tiles is larger than the recommended
     * number `OVERLOAD_LABEL_LIMIT`.
     */
    get overloaded() {
        return this.m_overloaded;
    }
    /**
     * Places text elements for the current frame.
     * @param dataSourceTileList List of tiles to be rendered for each data source.
     * @param time Current frame time.
     * @param elevationProvider
     */
    placeText(dataSourceTileList, time) {
        const tileTextElementsChanged = checkIfTextElementsChanged(dataSourceTileList);
        const textElementsAvailable = this.hasOverlayText() || tileTextElementsChanged;
        if (!this.initialize(textElementsAvailable)) {
            return;
        }
        const updateTextElements = this.m_cacheInvalidated ||
            tileTextElementsChanged ||
            this.m_viewState.renderedTilesChanged;
        logger.debug(`FRAME: ${this.m_viewState.frameNumber}, ZOOM LEVEL: ${this.m_viewState.zoomLevel}`);
        if (updateTextElements) {
            this.m_textElementStateCache.clearVisited();
            this.updateTextElements(dataSourceTileList);
        }
        const findReplacements = updateTextElements;
        const anyTextGroupEvicted = this.m_textElementStateCache.update(time, this.m_options.disableFading, findReplacements, this.m_viewState.zoomLevel);
        this.reset();
        this.prepopulateScreenWithBlockingElements(dataSourceTileList);
        // New text elements must be placed either if text elements were updated in this frame
        // or if any text element group was evicted. The second case happens when the group is not
        // visited anymore and all it's elements just became invisible, which means there's newly
        // available screen space where new text elements could be placed. A common scenario where
        // this happens is zooming in/out: text groups from the old level may still be fading out
        // after all groups in the new level were updated.
        const placeNewTextElements = updateTextElements || anyTextGroupEvicted;
        this.placeTextElements(time, placeNewTextElements);
        this.placeOverlayTextElements();
        this.updateTextRenderers();
    }
    /**
     * Adds new overlay text elements to this `MapView`.
     *
     * @param textElements Array of [[TextElement]] to be added.
     */
    addOverlayText(textElements) {
        if (textElements.length === 0) {
            return;
        }
        this.m_overlayTextElements =
            this.m_overlayTextElements === undefined
                ? textElements.slice()
                : this.m_overlayTextElements.concat(textElements);
    }
    /**
     * Adds new overlay text elements to this `MapView`.
     *
     * @param textElements Array of [[TextElement]] to be added.
     */
    clearOverlayText() {
        this.m_overlayTextElements = [];
    }
    /**
     * @returns Whether there's overlay text to be rendered.
     */
    hasOverlayText() {
        return this.m_overlayTextElements !== undefined && this.m_overlayTextElements.length > 0;
    }
    get overlayText() {
        return this.m_overlayTextElements;
    }
    /**
     * Fill the picking results for the pixel with the given screen coordinate. If multiple
     * [[TextElement]]s are found, the order of the results is unspecified.
     *
     * Note: [[TextElement]]s with identical `featureId` or identical `userData` will only appear
     * once in the list `pickResults`.
     *
     * @param screenPosition Screen coordinate of picking position.
     * @param pickResults Array filled with pick results.
     */
    pickTextElements(screenPosition, pickResults) {
        const pickHandler = (pickData, pickObjectType) => {
            const textElement = pickData;
            if (textElement === undefined) {
                return;
            }
            let isDuplicate = false;
            if (textElement.featureId !== undefined) {
                isDuplicate = pickResults.some(pickResult => {
                    return (pickResult !== undefined &&
                        pickObjectType === pickResult.type &&
                        ((pickResult.featureId !== undefined &&
                            pickResult.featureId === textElement.featureId) ||
                            (pickResult.userData !== undefined &&
                                pickResult.userData === textElement.userData)));
                });
                if (!isDuplicate) {
                    const pickResult = {
                        type: pickObjectType,
                        point: screenPosition,
                        distance: 0,
                        featureId: textElement.featureId,
                        userData: textElement.userData,
                        text: textElement.text
                    };
                    pickResults.push(pickResult);
                }
            }
        };
        for (const textRenderer of this.m_textRenderers) {
            textRenderer.textCanvas.pickText(screenPosition, (pickData) => {
                pickHandler(pickData, PickHandler_1.PickObjectType.Text);
            });
            textRenderer.poiRenderer.pickTextElements(screenPosition, (pickData) => {
                pickHandler(pickData, PickHandler_1.PickObjectType.Icon);
            });
        }
    }
    /**
     * `true` if any resource used by any `FontCatalog` is still loading.
     */
    get loading() {
        return this.m_fontCatalogLoader.loading || this.m_glyphLoadingCount > 0;
    }
    /**
     * Waits till all pending resources from any `FontCatalog` are loaded.
     */
    async waitLoaded() {
        const initialized = await this.waitInitialized();
        if (!initialized) {
            return false;
        }
        if (this.m_loadPromise === undefined) {
            return false;
        }
        await this.m_loadPromise;
        return true;
    }
    /**
     * Reset the current text render states of all visible tiles. All [[TextElement]]s will fade in
     * after that as if they have just been added.
     */
    clearRenderStates() {
        this.m_textElementStateCache.clear();
    }
    /**
     * Return memory used by all objects managed by `TextElementsRenderer`.
     *
     * @returns `MemoryUsage` Heap and GPU memory used by this `TextElementsRenderer`.
     */
    getMemoryUsage() {
        const memoryUsage = {
            heapSize: 0,
            gpuSize: 0
        };
        for (const renderer of this.m_textRenderers) {
            renderer.textCanvas.getMemoryUsage(memoryUsage);
            renderer.poiRenderer.getMemoryUsage(memoryUsage);
        }
        return memoryUsage;
    }
    get initialized() {
        return this.m_initialized;
    }
    get initializing() {
        return this.m_initPromise !== undefined;
    }
    /**
     * Waits until initialization is done.
     * @returns Promise resolved to true if initialization was done, false otherwise.
     */
    async waitInitialized() {
        if (this.initialized) {
            return true;
        }
        if (!this.initializing) {
            return false;
        }
        await this.m_initPromise;
        return true;
    }
    /**
     * Initializes the text renderer once there's any text element available for rendering.
     * @param textElementsAvailable Indicates whether there's any text element to be rendered.
     * @returns Whether the text renderer is initialized.
     */
    initialize(textElementsAvailable) {
        if (!this.initialized && !this.initializing && textElementsAvailable) {
            this.initializeDefaultAssets();
            this.m_initPromise = this.initializeTextCanvases().then(() => {
                this.m_initialized = true;
                this.m_initPromise = undefined;
                this.invalidateCache(); // Force cache update after initialization.
                this.m_viewUpdateCallback();
            });
        }
        return this.initialized;
    }
    /**
     * Reset internal state at the beginning of a frame.
     */
    reset() {
        this.m_screenCollisions.reset();
        for (const textRenderer of this.m_textRenderers) {
            textRenderer.textCanvas.clear();
            textRenderer.poiRenderer.reset();
        }
    }
    /**
     * Update state at the end of a frame.
     */
    updateTextRenderers() {
        for (const textRenderer of this.m_textRenderers) {
            textRenderer.poiRenderer.update();
        }
    }
    /**
     * Fills the screen with lines projected from world space, see [[Tile.blockingElements]].
     * @note These boxes have highest priority, so will block all other labels.
     * @param dataSourceTileList List of tiles to be rendered for each data source.
     */
    prepopulateScreenWithBlockingElements(dataSourceTileList) {
        const boxes = [];
        dataSourceTileList.forEach(renderListEntry => {
            const startLinePointProj = new THREE.Vector3();
            const endLinePointProj = new THREE.Vector3();
            for (const tile of renderListEntry.renderedTiles.values()) {
                for (const pathBlockingElement of tile.blockingElements) {
                    if (pathBlockingElement.points.length < 2) {
                        continue;
                    }
                    this.m_screenProjector.project3(pathBlockingElement.points[0], startLinePointProj);
                    for (let i = 1; i < pathBlockingElement.points.length; i++) {
                        this.m_screenProjector.project3(pathBlockingElement.points[i], endLinePointProj);
                        const line = pathBlockingElement.screenSpaceLines[i - 1];
                        line.start.copy(startLinePointProj);
                        line.end.copy(endLinePointProj);
                        const lineWithBound = {
                            minX: Math.min(startLinePointProj.x, endLinePointProj.x),
                            maxX: Math.max(startLinePointProj.x, endLinePointProj.x),
                            minY: Math.min(startLinePointProj.y, endLinePointProj.y),
                            maxY: Math.max(startLinePointProj.y, endLinePointProj.y),
                            line
                        };
                        boxes.push(lineWithBound);
                        startLinePointProj.copy(endLinePointProj);
                    }
                }
            }
        });
        this.m_screenCollisions.allocateIBoxes(boxes);
    }
    /**
     * @returns True if whole group was processed for placement,
     * false otherwise (e.g. placement limit reached).
     */
    placeTextElementGroup(groupState, renderParams, maxNumPlacedLabels, pass) {
        var _a;
        // Unvisited text elements are never placed.
        harp_utils_1.assert(groupState.visited);
        if (this.m_textRenderers.length === 0) {
            logger.warn("No text renderers initialized.");
            return false;
        }
        const shieldGroups = [];
        const hiddenKinds = this.m_viewState.hiddenGeometryKinds;
        const projection = this.m_viewState.projection;
        const elevationProvider = this.m_viewState.elevationProvider;
        const elevationMap = (_a = elevationProvider) === null || _a === void 0 ? void 0 : _a.getDisplacementMap(groupState.tileKey);
        for (const textElementState of groupState.textElementStates) {
            if (pass === Pass.PersistentLabels) {
                if (placementStats) {
                    ++placementStats.total;
                }
            }
            if (maxNumPlacedLabels >= 0 &&
                renderParams.numRenderedTextElements >= maxNumPlacedLabels) {
                logger.debug("Placement label limit exceeded.");
                return false;
            }
            // Skip all labels that are not initialized (didn't pass early placement tests)
            // or don't belong to this pass.
            if (!textElementState.initialized) {
                if (placementStats) {
                    ++placementStats.uninitialized;
                }
                continue;
            }
            if (textElementState.viewDistance === undefined) {
                if (placementStats) {
                    ++placementStats.tooFar;
                }
                continue;
            }
            const elementVisible = textElementState.visible;
            if ((pass === Pass.PersistentLabels && !elementVisible) ||
                (pass === Pass.NewLabels && elementVisible)) {
                continue;
            }
            const textElement = textElementState.element;
            // Get the TextElementStyle.
            const textElementStyle = this.m_textStyleCache.getTextElementStyle(textElement.style);
            const textCanvas = textElementStyle.textCanvas;
            const poiRenderer = textElementStyle.poiRenderer;
            if (textCanvas === undefined || poiRenderer === undefined) {
                logger.warn("Text canvas or poi renderer not ready.");
                continue;
            }
            // TODO: HARP-7648. Discard hidden kinds sooner, before placement.
            // Check if the label should be hidden.
            if (hiddenKinds !== undefined &&
                textElement.kind !== undefined &&
                hiddenKinds.hasOrIntersects(textElement.kind)) {
                continue;
            }
            if (elevationProvider !== undefined && !textElement.elevated) {
                if (!elevationMap) {
                    this.m_viewUpdateCallback(); // Update view until elevation is loaded.
                    this.m_forceNewLabelsPass = true;
                    continue;
                }
                overlayOnElevation_1.overlayTextElement(textElement, elevationProvider, elevationMap, projection);
            }
            const elementType = textElement.type;
            const isPathLabel = elementType === TextElementType_1.TextElementType.PathLabel;
            // For paths, check if the label may fit.
            if (isPathLabel) {
                if (Placement_1.isPathLabelTooSmall(textElement, this.m_screenProjector, tempScreenPoints)) {
                    if (placementStats) {
                        placementStats.numNotVisible++;
                    }
                    if (textElement.dbgPathTooSmall === true) {
                        if (placementStats) {
                            placementStats.numPathTooSmall++;
                        }
                    }
                    textElementState.textRenderState.reset();
                    continue;
                }
            }
            const forceNewPassOnLoaded = true;
            if (!this.initializeGlyphs(textElement, textElementStyle, forceNewPassOnLoaded)) {
                continue;
            }
            const layer = textCanvas.getLayer(textElement.renderOrder || harp_text_canvas_1.DEFAULT_TEXT_CANVAS_LAYER);
            // Move onto the next TextElement if we cannot continue adding glyphs to this layer.
            if (layer !== undefined) {
                if (layer.storage.drawCount + textElement.glyphs.length > layer.storage.capacity) {
                    if (placementStats) {
                        ++placementStats.numCannotAdd;
                    }
                    logger.warn("layer glyph storage capacity exceeded.");
                    continue;
                }
            }
            // Set the current style for the canvas.
            textCanvas.textRenderStyle = textElement.renderStyle;
            textCanvas.textLayoutStyle = textElement.layoutStyle;
            switch (elementType) {
                case TextElementType_1.TextElementType.PoiLabel:
                    this.addPoiLabel(textElementState, poiRenderer, textCanvas, renderParams);
                    break;
                case TextElementType_1.TextElementType.LineMarker:
                    this.addLineMarkerLabel(textElementState, poiRenderer, shieldGroups, textCanvas, renderParams);
                    break;
                case TextElementType_1.TextElementType.PathLabel:
                    this.addPathLabel(textElementState, tempScreenPoints, textCanvas, renderParams);
            }
        }
        return true;
    }
    initializeGlyphs(textElement, textElementStyle, forceNewPassOnLoaded) {
        // Trigger the glyph load if needed.
        if (textElement.loadingState === TextElement_1.LoadingState.Initialized) {
            return true;
        }
        harp_utils_1.assert(textElementStyle.textCanvas !== undefined);
        const textCanvas = textElementStyle.textCanvas;
        if (textElement.loadingState === undefined) {
            textElement.loadingState = TextElement_1.LoadingState.Requested;
            if (textElement.renderStyle === undefined) {
                textElement.renderStyle = new harp_text_canvas_1.TextRenderStyle(Object.assign(Object.assign({}, textElementStyle.renderParams), textElement.renderParams));
            }
            if (textElement.layoutStyle === undefined) {
                textElement.layoutStyle = new harp_text_canvas_1.TextLayoutStyle(Object.assign(Object.assign({}, textElementStyle.layoutParams), textElement.layoutParams));
            }
            if (textElement.text === "") {
                textElement.loadingState = TextElement_1.LoadingState.Loaded;
            }
            else {
                const newLoadPromise = textCanvas.fontCatalog
                    .loadCharset(textElement.text, textElement.renderStyle)
                    .then(() => {
                    --this.m_glyphLoadingCount;
                    textElement.loadingState = TextElement_1.LoadingState.Loaded;
                    // Ensure that text elements still loading glyphs get a chance to
                    // be rendered if there's no text element updates in the next frames.
                    this.m_forceNewLabelsPass =
                        this.m_forceNewLabelsPass || forceNewPassOnLoaded;
                    this.m_viewUpdateCallback();
                });
                if (this.m_glyphLoadingCount === 0) {
                    this.m_loadPromise = undefined;
                }
                ++this.m_glyphLoadingCount;
                this.m_loadPromise =
                    this.m_loadPromise === undefined
                        ? newLoadPromise
                        : Promise.all([this.m_loadPromise, newLoadPromise]);
            }
        }
        if (textElement.loadingState === TextElement_1.LoadingState.Loaded) {
            textCanvas.textRenderStyle = textElement.renderStyle;
            textCanvas.textLayoutStyle = textElement.layoutStyle;
            textElement.glyphCaseArray = [];
            textElement.bounds = undefined;
            textElement.glyphs = textCanvas.fontCatalog.getGlyphs(textElement.text, textCanvas.textRenderStyle, textElement.glyphCaseArray);
            textElement.loadingState = TextElement_1.LoadingState.Initialized;
        }
        // Return true as soon as a text element has some glyphs assigned so that it's rendered.
        // The glyphs may be either the final ones or some temporal glyphs inherited from a
        // predecessor as part of the text element replacement process.
        // See TextElementState.replace().
        return textElement.glyphs !== undefined;
    }
    initializeDefaultAssets() {
        const defaultFontCatalogName = this.m_fontCatalogLoader.initialize(this.m_options.fontCatalog);
        this.m_textStyleCache.initializeDefaultTextElementStyle(defaultFontCatalogName);
    }
    async initializeTextCanvases() {
        const catalogCallback = (name, catalog) => {
            const loadedTextCanvas = this.m_textCanvasFactory.createTextCanvas(catalog);
            this.m_textRenderers.push({
                fontCatalog: name,
                textCanvas: loadedTextCanvas,
                poiRenderer: this.m_poiRendererFactory.createPoiRenderer(loadedTextCanvas)
            });
        };
        return this.m_fontCatalogLoader.loadCatalogs(catalogCallback).then(() => {
            // Find the default TextCanvas and PoiRenderer.
            let defaultTextCanvas;
            this.m_textRenderers.forEach(textRenderer => {
                if (defaultTextCanvas === undefined) {
                    defaultTextCanvas = textRenderer.textCanvas;
                }
            });
            const defaultPoiRenderer = this.m_poiRendererFactory.createPoiRenderer(defaultTextCanvas);
            this.m_textStyleCache.initializeTextElementStyles(defaultPoiRenderer, defaultTextCanvas, this.m_textRenderers);
        });
    }
    updateGlyphDebugMesh() {
        const debugGlyphs = DebugContext_1.debugContext.getValue("DEBUG_GLYPHS");
        if (debugGlyphs === undefined) {
            return;
        }
        if (debugGlyphs && this.m_debugGlyphTextureCacheMesh === undefined) {
            this.initializeGlyphDebugMesh();
        }
        harp_utils_1.assert(this.m_debugGlyphTextureCacheMesh !== undefined);
        harp_utils_1.assert(this.m_debugGlyphTextureCacheWireMesh !== undefined);
        this.m_debugGlyphTextureCacheMesh.visible = debugGlyphs;
        this.m_debugGlyphTextureCacheWireMesh.visible = debugGlyphs;
    }
    initializeGlyphDebugMesh() {
        const defaultFontCatalog = this.m_textRenderers[0].textCanvas.fontCatalog;
        // Initialize glyph-debugging mesh.
        const planeGeometry = new THREE.PlaneGeometry(defaultFontCatalog.textureSize.width / 2.5, defaultFontCatalog.textureSize.height / 2.5, defaultFontCatalog.textureSize.width / defaultFontCatalog.maxWidth, defaultFontCatalog.textureSize.height / defaultFontCatalog.maxHeight);
        const material = new THREE.MeshBasicMaterial({
            transparent: true,
            depthWrite: false,
            depthTest: false,
            map: defaultFontCatalog.texture
        });
        this.m_debugGlyphTextureCacheMesh = new THREE.Mesh(planeGeometry, material);
        this.m_debugGlyphTextureCacheMesh.renderOrder = 10000;
        this.m_debugGlyphTextureCacheMesh.visible = false;
        this.m_debugGlyphTextureCacheMesh.name = "glyphDebug";
        const wireframe = new THREE.WireframeGeometry(planeGeometry);
        const wireframeMaterial = new THREE.LineBasicMaterial({
            transparent: true,
            color: 0x999999,
            depthWrite: false,
            depthTest: false
        });
        this.m_debugGlyphTextureCacheWireMesh = new THREE.LineSegments(wireframe, wireframeMaterial);
        this.m_debugGlyphTextureCacheWireMesh.renderOrder = 9999;
        this.m_debugGlyphTextureCacheWireMesh.visible = false;
        this.m_debugGlyphTextureCacheWireMesh.name = "glyphDebug";
        this.m_textRenderers[0].textCanvas
            .getLayer(harp_text_canvas_1.DEFAULT_TEXT_CANVAS_LAYER)
            .storage.scene.add(this.m_debugGlyphTextureCacheMesh, this.m_debugGlyphTextureCacheWireMesh);
    }
    /**
     * Visit all visible tiles and add/ their text elements to cache. The update of
     * [[TextElement]]s is a time consuming process, and cannot be done every frame, but should only
     * be done when the camera moved (a lot) of whenever the set of visible tiles change.
     *
     * The actually rendered [[TextElement]]s are stored internally until the next update is done
     * to speed up rendering when no camera movement was detected.
     * @param dataSourceTileList List of tiles to be rendered for each data source.
     */
    updateTextElements(dataSourceTileList) {
        logger.debug("updateTextElements");
        if (updateStats) {
            updateStats.clear();
        }
        this.m_textElementStateCache.clearTextCache();
        this.m_cacheInvalidated = false;
        this.checkIfOverloaded(dataSourceTileList);
        // Used with tile offset to compute the x coordinate offset for tiles.
        const updateStartTime = this.overloaded && this.m_viewState.isDynamic ? harp_utils_1.PerformanceTimer.now() : undefined;
        // TODO: HARP-7648. Skip all data sources that won't contain text.
        // TODO: HARP-7651. Higher priority labels should be updated before lower priority ones
        // across all data sources.
        // TODO: HARP-7373. Use rendered tiles (tiles currently rendered to cover the view,
        // including fallbacks if necessary) instead of visible tiles (target tiles that might not
        // be decoded yet).
        // Otherwise labels persistent when crossing a zoom level boundary will flicker (fade out
        // and back in) due to the delay in decoding the visible tiles.
        dataSourceTileList.forEach(tileList => {
            this.updateTextElementsFromSource(tileList.dataSource, tileList.storageLevel, Array.from(tileList.renderedTiles.values()), updateStartTime);
        });
        if (updateStats) {
            updateStats.log();
        }
    }
    updateTextElementsFromSource(tileDataSource, storageLevel, visibleTiles, updateStartTime) {
        if (updateStats) {
            updateStats.tiles += visibleTiles.length;
        }
        const sortedTiles = visibleTiles;
        // TODO: HARP-7648. Really needed? Should it be done here or in VisibleTileSet?
        sortedTiles.sort((a, b) => {
            return a.tileKey.mortonCode() - b.tileKey.mortonCode();
        });
        // Prepare user text elements.
        for (const tile of sortedTiles) {
            this.prepareTextElementGroup(tile.userTextElements, tile.tileKey);
        }
        const sortedGroups = [];
        this.createSortedGroupsForSorting(tileDataSource, storageLevel, sortedTiles, sortedGroups);
        let numTextElementsUpdated = 0;
        for (const textElementLists of sortedGroups) {
            this.selectTextElementsToUpdateByDistance(textElementLists);
            // The value of updateStartTime is set if this.overloaded is true.
            if (updateStartTime !== undefined) {
                // If overloaded and all time is used up, exit early.
                if (OVERLOAD_UPDATE_TIME_LIMIT > 0) {
                    const endTime = harp_utils_1.PerformanceTimer.now();
                    const elapsedTime = endTime - updateStartTime;
                    if (elapsedTime > OVERLOAD_UPDATE_TIME_LIMIT) {
                        logger.debug("Update time limit exceeded.");
                        break;
                    }
                }
                // Try not to update too many elements. They will be checked for visibility each
                // frame.
                numTextElementsUpdated += textElementLists.count();
                if (numTextElementsUpdated >= OVERLOAD_UPDATED_LABEL_LIMIT) {
                    logger.debug("Update label limit exceeded.");
                    break;
                }
            }
        }
    }
    prepareTextElementGroup(textElementGroup, tileKey, maxViewDistance) {
        if (textElementGroup.elements.length === 0) {
            return;
        }
        const textElementSelection = (textElementState) => {
            let { result, viewDistance } = Placement_1.checkReadyForPlacement(textElementState.element, this.m_viewState, this.m_viewCamera, this.m_poiManager, maxViewDistance);
            if (result === Placement_1.PrePlacementResult.Ok &&
                !this.m_textElementStateCache.deduplicateElement(this.m_viewState.zoomLevel, textElementState)) {
                result = Placement_1.PrePlacementResult.Duplicate;
                viewDistance = undefined;
            }
            if (updateStats) {
                updateStats.totalLabels++;
                updateStats.results[result]++;
            }
            return viewDistance;
        };
        const [, found] = this.m_textElementStateCache.getOrSet(textElementGroup, tileKey, textElementSelection);
        if (updateStats) {
            ++updateStats.totalGroups;
            if (!found) {
                ++updateStats.newGroups;
            }
        }
    }
    createSortedGroupsForSorting(tileDataSource, storageLevel, sortedTiles, sortedGroups) {
        if (sortedTiles.length === 0) {
            return;
        }
        const tilesToRender = [];
        for (const tile of sortedTiles) {
            if (tileDataSource.shouldRenderText(storageLevel, tile.tileKey)) {
                tilesToRender.push(tile);
            }
        }
        const groupedPriorityLists = new Map();
        for (const tile of tilesToRender) {
            for (const group of tile.textElementGroups.groups.values()) {
                if (group.elements.length === 0) {
                    continue;
                }
                const foundGroup = groupedPriorityLists.get(group.priority);
                if (foundGroup === undefined) {
                    groupedPriorityLists.set(group.priority, new TextElementLists([new TileTextElements(tile, group)]));
                }
                else {
                    foundGroup.lists.push(new TileTextElements(tile, group));
                }
            }
        }
        if (groupedPriorityLists.size === 0) {
            return;
        }
        for (const g of groupedPriorityLists) {
            const lists = g[1];
            sortedGroups.push(lists);
        }
        sortedGroups.sort((a, b) => {
            return b.priority - a.priority;
        });
        const printTextInfo = false;
        if (PRINT_LABEL_DEBUG_INFO && printTextInfo) {
            let outString = "";
            for (const textElementLists of sortedGroups) {
                let size = 0;
                for (const tileTextElements of textElementLists.lists) {
                    size += tileTextElements.group.elements.length;
                }
                outString += `priority ${textElementLists.priority} size: ${size}\n`;
            }
            logger.log(outString);
        }
    }
    selectTextElementsToUpdateByDistance(textElementLists) {
        const farDistanceLimitRatio = Math.max(this.m_options.maxDistanceRatioForTextLabels, this.m_options.maxDistanceRatioForPoiLabels);
        const maxViewDistance = Placement_1.getMaxViewDistance(this.m_viewState, farDistanceLimitRatio);
        for (const tileTextElements of textElementLists.lists) {
            this.prepareTextElementGroup(tileTextElements.group, tileTextElements.tile.tileKey, maxViewDistance);
        }
    }
    placeTextElements(time, placeNewTextElements) {
        const renderParams = {
            numRenderedTextElements: 0,
            fadeAnimationRunning: false,
            time
        };
        const placeStartTime = this.overloaded && this.m_viewState.isDynamic ? harp_utils_1.PerformanceTimer.now() : undefined;
        if (placementStats) {
            placementStats.clear();
        }
        if (this.m_textElementStateCache.size === 0) {
            logger.debug("Text element cache empty.");
            return;
        }
        const placeNew = this.m_forceNewLabelsPass || placeNewTextElements;
        if (this.m_forceNewLabelsPass) {
            if (!placeNewTextElements) {
                logger.debug("Force new label pass");
            }
            this.m_forceNewLabelsPass = false;
        }
        const maxNumPlacedTextElements = this.m_options.maxNumVisibleLabels;
        // TODO: HARP-7648. Potential performance improvement. Place persistent labels + rejected
        // candidates from previous frame if there's been no placement in this one.
        const groupStates = this.m_textElementStateCache.sortedGroupStates;
        let currentPriority = groupStates[0].priority;
        let currentPriorityBegin = 0;
        for (let i = 0; i < groupStates.length; ++i) {
            const textElementGroupState = groupStates[i];
            if (placementStats) {
                ++placementStats.totalGroups;
            }
            const newPriority = textElementGroupState.priority;
            if (placeNew && currentPriority !== newPriority) {
                // Place all new labels of the previous priority before placing the persistent
                // labels of this priority.
                this.placeNewTextElements(currentPriorityBegin, i, renderParams);
                if (isPlacementTimeExceeded(placeStartTime)) {
                    break;
                }
                currentPriority = newPriority;
                currentPriorityBegin = i;
            }
            if (!this.placeTextElementGroup(textElementGroupState, renderParams, maxNumPlacedTextElements, Pass.PersistentLabels)) {
                break;
            }
            if (isPlacementTimeExceeded(placeStartTime)) {
                break;
            }
        }
        if (placeNew) {
            // Place new text elements of the last priority.
            this.placeNewTextElements(currentPriorityBegin, groupStates.length, renderParams);
        }
        if (placementStats) {
            placementStats.numRenderedTextElements = renderParams.numRenderedTextElements;
            placementStats.log();
        }
        if (!this.m_options.disableFading && renderParams.fadeAnimationRunning) {
            this.m_viewUpdateCallback();
        }
    }
    placeNewTextElements(beginGroupIndex, endGroupIndex, renderParams) {
        const groupStates = this.m_textElementStateCache.sortedGroupStates;
        for (let i = beginGroupIndex; i < endGroupIndex; ++i) {
            if (!this.placeTextElementGroup(groupStates[i], renderParams, this.m_options.maxNumVisibleLabels, Pass.NewLabels)) {
                break;
            }
        }
    }
    placeOverlayTextElements() {
        if (this.m_overlayTextElements === undefined || this.m_overlayTextElements.length === 0) {
            return;
        }
        const screenSize = this.m_tmpVector.set(this.m_screenProjector.width, this.m_screenProjector.height);
        const screenXOrigin = -screenSize.width / 2.0;
        const screenYOrigin = screenSize.height / 2.0;
        // Place text elements one by one.
        for (const textElement of this.m_overlayTextElements) {
            // Get the TextElementStyle.
            const textElementStyle = this.m_textStyleCache.getTextElementStyle(textElement.style);
            const textCanvas = textElementStyle.textCanvas;
            if (textCanvas === undefined) {
                continue;
            }
            const forceNewPassOnLoaded = false;
            this.initializeGlyphs(textElement, textElementStyle, forceNewPassOnLoaded);
            if (textElement.loadingState !== TextElement_1.LoadingState.Initialized) {
                continue;
            }
            const layer = textCanvas.getLayer(textElement.renderOrder || harp_text_canvas_1.DEFAULT_TEXT_CANVAS_LAYER);
            // Move onto the next TextElement if we cannot continue adding glyphs to this layer.
            if (layer !== undefined) {
                if (layer.storage.drawCount + textElement.glyphs.length > layer.storage.capacity) {
                    continue;
                }
            }
            // Set the current style for the canvas.
            textCanvas.textRenderStyle = textElement.renderStyle;
            textCanvas.textLayoutStyle = textElement.layoutStyle;
            // Place text.
            let textPath;
            if (!(textElement.type === TextElementType_1.TextElementType.PathLabel)) {
                // Adjust the label positioning.
                tempScreenPosition.x = screenXOrigin + textElement.position.x * screenSize.width;
                tempScreenPosition.y = screenYOrigin - textElement.position.y * screenSize.height;
                if (textElement.xOffset !== undefined) {
                    tempScreenPosition.x += textElement.xOffset;
                }
                if (textElement.yOffset !== undefined) {
                    tempScreenPosition.y -= textElement.yOffset;
                }
                tempPosition.x = tempScreenPosition.x;
                tempPosition.y = tempScreenPosition.y;
                tempPosition.z = 0.0;
                addTextToCanvas(textElement, textCanvas, tempPosition);
            }
            else {
                // Adjust the label positioning.
                tempScreenPosition.x = screenXOrigin;
                tempScreenPosition.y = screenYOrigin;
                if (textElement.xOffset !== undefined) {
                    tempScreenPosition.x += textElement.xOffset;
                }
                if (textElement.yOffset !== undefined) {
                    tempScreenPosition.y -= textElement.yOffset;
                }
                // Get the screen points that define the label's segments and create a path with
                // them.
                // TODO: HARP-7648. Optimize array allocations.
                const screenPoints = [];
                for (const pt of textElement.path) {
                    const pX = tempScreenPosition.x + pt.x * screenSize.width;
                    const pY = tempScreenPosition.y - pt.y * screenSize.height;
                    screenPoints.push(new THREE.Vector2(pX, pY));
                }
                textPath = new SimplePath_1.SimplePath();
                for (let i = 0; i < screenPoints.length - 1; ++i) {
                    textPath.add(new THREE.LineCurve(screenPoints[i], screenPoints[i + 1]));
                }
                addTextToCanvas(textElement, textCanvas, tempPosition, textPath, true);
            }
        }
    }
    getDistanceScalingFactor(label, distance, lookAtDistance) {
        // Distance scale is based on relation between camera focus point distance and
        // the actual label distance. For labels close to camera look at point the scale
        // remains unchanged, the farther is label from that point the smaller size it is
        // rendered in screen space. This method is unaffected by near and far clipping planes
        // distances, but may be improved by taking FOV into equation or customizing the
        // focus point screen position based on horizont, actual ground, tilt ets.
        let factor = lookAtDistance / distance;
        // The label.distanceScale property defines the influence ratio at which
        // distance affects the final scaling of label.
        factor = 1.0 + (factor - 1.0) * label.distanceScale;
        // Preserve the constraints
        factor = Math.max(factor, this.m_options.labelDistanceScaleMin);
        factor = Math.min(factor, this.m_options.labelDistanceScaleMax);
        return factor;
    }
    getDistanceFadingFactor(label, state, maxVisibilityDist) {
        let distanceFadeValue = 1.0;
        const textDistance = state.viewDistance;
        if (textDistance !== undefined && label.fadeFar !== undefined && label.fadeFar > 0.0) {
            const fadeNear = label.fadeNear === undefined ? 0.0 : label.fadeNear;
            const fadeFar = label.fadeFar;
            if (fadeFar > fadeNear) {
                distanceFadeValue =
                    1.0 -
                        THREE.Math.clamp((textDistance / maxVisibilityDist - fadeNear) / (fadeFar - fadeNear), 0.0, 1.0);
            }
        }
        return distanceFadeValue;
    }
    addPointLabel(labelState, position, screenPosition, poiRenderer, textCanvas, renderParams, iconIndex) {
        const pointLabel = labelState.element;
        const textRenderState = labelState.textRenderState;
        harp_utils_1.assert(iconIndex === undefined || labelState.iconRenderStates !== undefined);
        const iconRenderState = iconIndex !== undefined
            ? labelState.iconRenderStates[iconIndex]
            : labelState.iconRenderState;
        harp_utils_1.assert(iconRenderState !== undefined);
        // Find the label's original position.
        tempScreenPosition.x = tempPoiScreenPosition.x = screenPosition.x;
        tempScreenPosition.y = tempPoiScreenPosition.y = screenPosition.y;
        // Scale the text depending on the label's distance to the camera.
        const textDistance = this.m_viewState.worldCenter.distanceTo(position);
        if (pointLabel.fadeFar !== undefined &&
            (pointLabel.fadeFar <= 0.0 ||
                pointLabel.fadeFar * this.m_viewState.maxVisibilityDist < textDistance)) {
            // The label is farther away than fadeFar value, which means it is totally
            // transparent.
            if (placementStats) {
                ++placementStats.tooFar;
            }
            return false;
        }
        labelState.setViewDistance(textDistance);
        // Check if there is need to check for screen space for the label's icon.
        const poiInfo = pointLabel.poiInfo;
        let iconRejected = false;
        // Check if icon should be rendered at this zoomLevel
        const renderIcon = poiInfo !== undefined &&
            harp_utils_1.MathUtils.isClamped(this.m_viewState.zoomLevel, poiInfo.iconMinZoomLevel, poiInfo.iconMaxZoomLevel) &&
            poiInfo.isValid !== false;
        const distanceScaleFactor = this.getDistanceScalingFactor(pointLabel, textDistance, this.m_viewState.lookAtDistance);
        const iconReady = renderIcon && poiRenderer.prepareRender(pointLabel, this.m_viewState.env);
        if (iconReady) {
            const result = Placement_1.placeIcon(iconRenderState, poiInfo, tempPoiScreenPosition, distanceScaleFactor, this.m_viewState.env, this.m_screenCollisions);
            if (result === Placement_1.PlacementResult.Invisible) {
                iconRenderState.reset();
                if (placementStats) {
                    ++placementStats.numNotVisible;
                }
                return false;
            }
            iconRejected = result === Placement_1.PlacementResult.Rejected;
        }
        else if (renderIcon && poiInfo.isValid !== false) {
            // Ensure that text elements still loading icons get a chance to be rendered if
            // there's no text element updates in the next frames.
            this.m_forceNewLabelsPass = true;
        }
        const distanceFadeFactor = this.getDistanceFadingFactor(pointLabel, labelState, this.m_viewState.maxVisibilityDist);
        const renderText = shouldRenderPointText(labelState, this.m_viewState, this.m_options);
        // Render the label's text...
        // textRenderState is always defined at this point.
        if (renderText) {
            const placeResult = Placement_1.placePointLabel(labelState, tempScreenPosition, distanceScaleFactor, textCanvas, this.m_screenCollisions, iconRejected, tempPosition);
            if (placeResult === Placement_1.PlacementResult.Invisible) {
                if (placementStats) {
                    placementStats.numPoiTextsInvisible++;
                }
                labelState.reset();
                return false;
            }
            const textRejected = placeResult === Placement_1.PlacementResult.Rejected;
            if (!iconRejected) {
                const textIsOptional = pointLabel.poiInfo !== undefined && pointLabel.poiInfo.textIsOptional === true;
                iconRejected = textRejected && !textIsOptional;
            }
            if (textRejected) {
                textRenderState.startFadeOut(renderParams.time);
            }
            const textNeedsDraw = (!textRejected && shouldRenderPoiText(labelState, this.m_viewState)) ||
                textRenderState.isFading();
            if (textNeedsDraw) {
                if (!textRejected) {
                    textRenderState.startFadeIn(renderParams.time);
                }
                renderParams.fadeAnimationRunning =
                    renderParams.fadeAnimationRunning || textRenderState.isFading();
                if (addTextBufferToCanvas(labelState, textCanvas, tempPosition, distanceFadeFactor, distanceScaleFactor) &&
                    placementStats) {
                    placementStats.numRenderedPoiTexts++;
                }
            }
        }
        // ... and render the icon (if any).
        if (iconReady) {
            if (iconRejected) {
                iconRenderState.startFadeOut(renderParams.time);
            }
            else {
                iconRenderState.startFadeIn(renderParams.time);
            }
            renderParams.fadeAnimationRunning =
                renderParams.fadeAnimationRunning || iconRenderState.isFading();
            const opacity = iconRenderState.opacity * distanceFadeFactor;
            if (opacity > 0) {
                // Same as for text, don't allocate screen space for an icon that's fading out so
                // that any label blocked by it gets a chance to be placed as soon as any other
                // surrounding new labels.
                const allocateSpace = poiInfo.reserveSpace !== false && !iconRejected;
                poiRenderer.renderPoi(poiInfo, tempPoiScreenPosition, this.m_screenCollisions, labelState.renderDistance, distanceScaleFactor, allocateSpace, opacity, this.m_viewState.env);
                if (placementStats) {
                    placementStats.numRenderedPoiIcons++;
                }
            }
        }
        renderParams.numRenderedTextElements++;
        return true;
    }
    addPoiLabel(labelState, poiRenderer, textCanvas, renderParams) {
        const poiLabel = labelState.element;
        const worldPosition = poiLabel.points;
        // Only process labels frustum-clipped labels
        if (this.m_screenProjector.project(worldPosition, tempScreenPosition) === undefined) {
            return false;
        }
        // Add this POI as a point label.
        return this.addPointLabel(labelState, worldPosition, tempScreenPosition, poiRenderer, textCanvas, renderParams);
    }
    addLineMarkerLabel(labelState, poiRenderer, shieldGroups, textCanvas, renderParams) {
        const lineMarkerLabel = labelState.element;
        const path = lineMarkerLabel.points;
        // Early exit if the line marker doesn't have the necessary data.
        const poiInfo = lineMarkerLabel.poiInfo;
        if (path.length === 0 ||
            !poiRenderer.prepareRender(lineMarkerLabel, this.m_viewState.env)) {
            return;
        }
        // Initialize the shield group for this lineMarker.
        let shieldGroup;
        if (poiInfo.shieldGroupIndex !== undefined) {
            shieldGroup = shieldGroups[poiInfo.shieldGroupIndex];
            if (shieldGroup === undefined) {
                shieldGroup = [];
                shieldGroups[poiInfo.shieldGroupIndex] = shieldGroup;
            }
        }
        const lineTechnique = poiInfo.technique;
        const minDistanceSqr = lineTechnique.minDistance !== undefined
            ? lineTechnique.minDistance * lineTechnique.minDistance
            : 0;
        // Process markers (with shield groups).
        if (minDistanceSqr > 0 && shieldGroup !== undefined) {
            for (let pointIndex = 0; pointIndex < path.length; ++pointIndex) {
                const point = path[pointIndex];
                // Only process labels frustum-clipped labels
                if (this.m_screenProjector.project(point, tempScreenPosition) !== undefined) {
                    // Find a suitable location for the lineMarker to be placed at.
                    let tooClose = false;
                    for (let j = 0; j < shieldGroup.length; j += 2) {
                        const distanceSqr = harp_utils_1.Math2D.distSquared(shieldGroup[j], shieldGroup[j + 1], tempScreenPosition.x, tempScreenPosition.y);
                        tooClose = distanceSqr < minDistanceSqr;
                        if (tooClose) {
                            break;
                        }
                    }
                    // Place it as a point label if it's not to close to other marker in the
                    // same shield group.
                    if (!tooClose) {
                        if (this.addPointLabel(labelState, point, tempScreenPosition, poiRenderer, textCanvas, renderParams, pointIndex)) {
                            shieldGroup.push(tempScreenPosition.x, tempScreenPosition.y);
                        }
                    }
                }
            }
        }
        // Process markers (without shield groups).
        else {
            for (let pointIndex = 0; pointIndex < path.length; ++pointIndex) {
                const point = path[pointIndex];
                // Only process labels frustum-clipped labels
                if (this.m_screenProjector.project(point, tempScreenPosition) !== undefined) {
                    this.addPointLabel(labelState, point, tempScreenPosition, poiRenderer, textCanvas, renderParams, pointIndex);
                }
            }
        }
    }
    addPathLabel(labelState, screenPoints, textCanvas, renderParams) {
        // TODO: HARP-7649. Add fade out transitions for path labels.
        const textMaxDistance = Placement_1.getMaxViewDistance(this.m_viewState, this.m_options.maxDistanceRatioForTextLabels);
        const pathLabel = labelState.element;
        // Limit the text rendering of path labels in the far distance.
        if (!(pathLabel.ignoreDistance === true ||
            labelState.viewDistance === undefined ||
            labelState.viewDistance < textMaxDistance)) {
            if (placementStats) {
                ++placementStats.tooFar;
            }
            labelState.textRenderState.reset();
            return false;
        }
        if (pathLabel.fadeFar !== undefined &&
            (pathLabel.fadeFar <= 0.0 ||
                pathLabel.fadeFar * this.m_viewState.maxVisibilityDist < labelState.renderDistance)) {
            // The label is farther away than fadeFar value, which means it is totally
            // transparent
            if (placementStats) {
                ++placementStats.tooFar;
            }
            labelState.textRenderState.reset();
            return false;
        }
        // Get the screen points that define the label's segments and create a path with
        // them.
        let textPath = new THREE.Path();
        tempScreenPosition.copy(screenPoints[0]);
        for (let i = 0; i < screenPoints.length - 1; ++i) {
            textPath.add(new SimplePath_1.SimpleLineCurve(screenPoints[i], screenPoints[i + 1]));
        }
        // Flip the path if the label is gonna be rendered downwards.
        if (textPath.getPoint(0.5).x - textPath.getPoint(0.51).x > 0) {
            tempScreenPosition.copy(screenPoints[screenPoints.length - 1]);
            textPath = new THREE.Path();
            for (let i = screenPoints.length - 1; i > 0; --i) {
                textPath.add(new SimplePath_1.SimpleLineCurve(screenPoints[i], screenPoints[i - 1]));
            }
        }
        // Update the real rendering distance to have smooth fading and scaling
        labelState.setViewDistance(Placement_1.computeViewDistance(this.m_viewState.worldCenter, pathLabel));
        const textRenderDistance = -labelState.renderDistance;
        // Scale the text depending on the label's distance to the camera.
        const distanceScaleFactor = this.getDistanceScalingFactor(pathLabel, textRenderDistance, this.m_viewState.lookAtDistance);
        const prevSize = textCanvas.textRenderStyle.fontSize.size;
        textCanvas.textRenderStyle.fontSize.size *= distanceScaleFactor;
        if (Placement_1.placePathLabel(labelState, textPath, tempScreenPosition, textCanvas, this.m_screenCollisions) !== Placement_1.PlacementResult.Ok) {
            textCanvas.textRenderStyle.fontSize.size = prevSize;
            if (placementStats) {
                ++placementStats.numNotVisible;
            }
            labelState.textRenderState.reset();
            return false;
        }
        labelState.textRenderState.startFadeIn(renderParams.time);
        let opacity = pathLabel.renderStyle.opacity;
        if (labelState.textRenderState.isFading()) {
            opacity *= labelState.textRenderState.opacity;
            renderParams.fadeAnimationRunning = true;
        }
        if (labelState.textRenderState.opacity === 0) {
            textCanvas.textRenderStyle.fontSize.size = prevSize;
            return false;
        }
        const prevOpacity = textCanvas.textRenderStyle.opacity;
        const prevBgOpacity = textCanvas.textRenderStyle.backgroundOpacity;
        const distanceFadeFactor = this.getDistanceFadingFactor(pathLabel, labelState, this.m_viewState.maxVisibilityDist);
        textCanvas.textRenderStyle.opacity = opacity * distanceFadeFactor;
        textCanvas.textRenderStyle.backgroundOpacity =
            textCanvas.textRenderStyle.opacity * pathLabel.renderStyle.backgroundOpacity;
        tempPosition.z = labelState.renderDistance;
        addTextToCanvas(pathLabel, textCanvas, tempPosition, textPath);
        renderParams.numRenderedTextElements++;
        // Restore previous style values for text elements using the same style.
        textCanvas.textRenderStyle.fontSize.size = prevSize;
        textCanvas.textRenderStyle.opacity = prevOpacity;
        textCanvas.textRenderStyle.backgroundOpacity = prevBgOpacity;
        return true;
    }
    checkIfOverloaded(dataSourceTileList) {
        // Count the number of TextElements in the scene to see if we have to switch to
        // "overloadMode".
        let numTextElementsInScene = 0;
        dataSourceTileList.forEach(renderListEntry => {
            for (const tile of renderListEntry.renderedTiles.values()) {
                numTextElementsInScene += tile.textElementGroups.count();
                numTextElementsInScene += tile.userTextElements.elements.length;
            }
        });
        const newOverloaded = numTextElementsInScene > OVERLOAD_LABEL_LIMIT;
        if (newOverloaded && !this.m_overloaded) {
            logger.debug("Overloaded Mode enabled.");
        }
        this.m_overloaded = newOverloaded;
        return this.m_overloaded;
    }
}
exports.TextElementsRenderer = TextElementsRenderer;


/***/ }),

/***/ "../harp-mapview/lib/text/TextElementsRendererOptions.ts":
/*!***************************************************************!*\
  !*** ../harp-mapview/lib/text/TextElementsRendererOptions.ts ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const DEFAULT_FONT_CATALOG = "./resources/fonts/Default_FontCatalog.json";
/**
 * Default number of labels/POIs rendered in the scene
 */
const DEFAULT_MAX_NUM_RENDERED_TEXT_ELEMENTS = 500;
/**
 * Number of elements that are put into second queue. This second chance queue is used to render
 * TextElements that have not been on screen before. This is a quick source for elements that can
 * appear when the camera moves a bit, before new elements are placed.
 */
const DEFAULT_MAX_NUM_SECOND_CHANCE_ELEMENTS = 300;
/**
 * Maximum distance for text labels expressed as a ratio of distance to from the camera (0) to the
 * far plane (1.0). May be synchronized with fog value ?
 */
const DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS = 0.99;
/**
 * Minimum scaling factor that may be applied to labels when their are distant from focus point.
 */
const DEFAULT_LABEL_DISTANCE_SCALE_MIN = 0.7;
/**
 * Maximum scaling factor that may be applied to labels due to their distance from focus point.
 */
const DEFAULT_LABEL_DISTANCE_SCALE_MAX = 1.5;
const MIN_GLYPH_COUNT = 1024;
const MAX_GLYPH_COUNT = 32768;
/**
 * Initializes undefined text renderer options to default values.
 * @param options The options to be initialized.
 */
function initializeDefaultOptions(options) {
    if (options.fontCatalog === undefined) {
        options.fontCatalog = DEFAULT_FONT_CATALOG;
    }
    if (options.minNumGlyphs === undefined) {
        options.minNumGlyphs = MIN_GLYPH_COUNT;
    }
    if (options.maxNumGlyphs === undefined) {
        options.maxNumGlyphs = MAX_GLYPH_COUNT;
    }
    if (options.maxNumVisibleLabels === undefined) {
        options.maxNumVisibleLabels = DEFAULT_MAX_NUM_RENDERED_TEXT_ELEMENTS;
    }
    // TODO: Unused so far.
    if (options.numSecondChanceLabels === undefined) {
        options.numSecondChanceLabels = DEFAULT_MAX_NUM_SECOND_CHANCE_ELEMENTS;
    }
    if (options.labelDistanceScaleMin === undefined) {
        options.labelDistanceScaleMin = DEFAULT_LABEL_DISTANCE_SCALE_MIN;
    }
    if (options.labelDistanceScaleMax === undefined) {
        options.labelDistanceScaleMax = DEFAULT_LABEL_DISTANCE_SCALE_MAX;
    }
    if (options.maxDistanceRatioForTextLabels === undefined) {
        options.maxDistanceRatioForTextLabels = DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS;
    }
    if (options.maxDistanceRatioForPoiLabels === undefined) {
        options.maxDistanceRatioForPoiLabels = DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS;
    }
    if (options.disableFading === undefined) {
        options.disableFading = false;
    }
}
exports.initializeDefaultOptions = initializeDefaultOptions;


/***/ }),

/***/ "../harp-mapview/lib/text/TextStyleCache.ts":
/*!**************************************************!*\
  !*** ../harp-mapview/lib/text/TextStyleCache.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "../harp-text-canvas/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const ColorCache_1 = __webpack_require__(/*! ../ColorCache */ "../harp-mapview/lib/ColorCache.ts");
const DecodedTileHelpers_1 = __webpack_require__(/*! ../DecodedTileHelpers */ "../harp-mapview/lib/DecodedTileHelpers.ts");
const logger = harp_utils_1.LoggerManager.instance.create("TextStyleCache");
/**
 * [[TextStyle]] id for the default value inside a [[TextRenderStyleCache]] or a
 * [[TextLayoutStyleCache]].
 */
exports.DEFAULT_TEXT_STYLE_CACHE_ID = "Default";
/**
 * Calculates the [[TextStyle]] id that identifies either a [[TextRenderStyle]] or a
 * [[TextLayoutStyle]] inside a [[TextRenderStyleCache]] or a [[TextLayoutStyleCache]],
 * respectively.
 *
 * @param technique Technique defining the [[TextStyle]].
 * @param zoomLevel Zoom level for which to interpret the technique.
 *
 * @returns [[TextStyle]] id.
 */
function computeStyleCacheId(datasourceName, technique, zoomLevel) {
    return `${datasourceName}_${technique._key}_${zoomLevel}`;
}
exports.computeStyleCacheId = computeStyleCacheId;
/**
 * Cache storing [[MapView]]'s [[TextRenderStyle]]s.
 */
class TextRenderStyleCache {
    constructor() {
        this.m_map = new Map();
        this.m_map.set(exports.DEFAULT_TEXT_STYLE_CACHE_ID, new harp_text_canvas_1.TextRenderStyle({
            fontSize: {
                unit: harp_text_canvas_1.FontUnit.Pixel,
                size: 32,
                backgroundSize: 8
            },
            color: ColorCache_1.ColorCache.instance.getColor("#6d7477"),
            opacity: 1.0,
            backgroundColor: ColorCache_1.ColorCache.instance.getColor("#f7fbfd"),
            backgroundOpacity: 0.5
        }));
    }
    get size() {
        return this.m_map.size;
    }
    get(id) {
        return this.m_map.get(id);
    }
    set(id, value) {
        this.m_map.set(id, value);
    }
    clear() {
        this.m_map.clear();
        this.m_map.set(exports.DEFAULT_TEXT_STYLE_CACHE_ID, new harp_text_canvas_1.TextRenderStyle({
            fontSize: {
                unit: harp_text_canvas_1.FontUnit.Pixel,
                size: 32,
                backgroundSize: 8
            },
            color: ColorCache_1.ColorCache.instance.getColor("#6d7477"),
            opacity: 1.0,
            backgroundColor: ColorCache_1.ColorCache.instance.getColor("#f7fbfd"),
            backgroundOpacity: 0.5
        }));
    }
}
exports.TextRenderStyleCache = TextRenderStyleCache;
/**
 * Cache storing [[MapView]]'s [[TextLayoutStyle]]s.
 */
class TextLayoutStyleCache {
    constructor() {
        this.m_map = new Map();
        this.m_map.set(exports.DEFAULT_TEXT_STYLE_CACHE_ID, new harp_text_canvas_1.TextLayoutStyle({
            verticalAlignment: harp_text_canvas_1.VerticalAlignment.Center,
            horizontalAlignment: harp_text_canvas_1.HorizontalAlignment.Center
        }));
    }
    get size() {
        return this.m_map.size;
    }
    get(id) {
        return this.m_map.get(id);
    }
    set(id, value) {
        this.m_map.set(id, value);
    }
    clear() {
        this.m_map.clear();
        this.m_map.set(exports.DEFAULT_TEXT_STYLE_CACHE_ID, new harp_text_canvas_1.TextLayoutStyle({
            verticalAlignment: harp_text_canvas_1.VerticalAlignment.Center,
            horizontalAlignment: harp_text_canvas_1.HorizontalAlignment.Center
        }));
    }
}
exports.TextLayoutStyleCache = TextLayoutStyleCache;
const DEFAULT_STYLE_NAME = "default";
class TextStyleCache {
    constructor(m_theme) {
        this.m_theme = m_theme;
        this.m_textRenderStyleCache = new TextRenderStyleCache();
        this.m_textLayoutStyleCache = new TextLayoutStyleCache();
        this.m_textStyles = new Map();
        this.m_defaultStyle = {
            name: DEFAULT_STYLE_NAME,
            fontCatalog: "",
            renderParams: this.m_textRenderStyleCache.get(exports.DEFAULT_TEXT_STYLE_CACHE_ID).params,
            layoutParams: this.m_textLayoutStyleCache.get(exports.DEFAULT_TEXT_STYLE_CACHE_ID).params
        };
    }
    initializeDefaultTextElementStyle(defaultFontCatalogName) {
        if (this.m_theme.textStyles === undefined) {
            this.m_theme.textStyles = [];
        }
        const styles = this.m_theme.textStyles;
        const themedDefaultStyle = styles.find(style => style.name === DEFAULT_STYLE_NAME);
        if (themedDefaultStyle !== undefined) {
            this.m_defaultStyle = this.createTextElementStyle(themedDefaultStyle, DEFAULT_STYLE_NAME);
        }
        else if (this.m_theme.defaultTextStyle !== undefined) {
            this.m_defaultStyle = this.createTextElementStyle(this.m_theme.defaultTextStyle, DEFAULT_STYLE_NAME);
        }
        else if (styles.length > 0) {
            this.m_defaultStyle = this.createTextElementStyle(styles[0], DEFAULT_STYLE_NAME);
        }
        this.m_defaultStyle.fontCatalog = defaultFontCatalogName;
    }
    initializeTextElementStyles(defaultPoiRenderer, defaultTextCanvas, textRenderers) {
        // Initialize default text style.
        if (this.m_defaultStyle.fontCatalog !== undefined) {
            const styledTextRenderer = textRenderers.find(textRenderer => textRenderer.fontCatalog === this.m_defaultStyle.fontCatalog);
            this.m_defaultStyle.textCanvas =
                styledTextRenderer !== undefined ? styledTextRenderer.textCanvas : undefined;
            this.m_defaultStyle.poiRenderer =
                styledTextRenderer !== undefined ? styledTextRenderer.poiRenderer : undefined;
        }
        if (this.m_defaultStyle.textCanvas === undefined) {
            if (this.m_defaultStyle.fontCatalog !== undefined) {
                logger.warn(`FontCatalog '${this.m_defaultStyle.fontCatalog}' set in TextStyle '${this.m_defaultStyle.name}' not found, using default fontCatalog(${defaultTextCanvas.fontCatalog.name}).`);
            }
            this.m_defaultStyle.textCanvas = defaultTextCanvas;
            this.m_defaultStyle.poiRenderer = defaultPoiRenderer;
        }
        // Initialize theme text styles.
        this.m_theme.textStyles.forEach(element => {
            this.m_textStyles.set(element.name, this.createTextElementStyle(element, element.name));
        });
        // tslint:disable-next-line:no-unused-variable
        for (const [, style] of this.m_textStyles) {
            if (style.textCanvas === undefined) {
                if (style.fontCatalog !== undefined) {
                    const styledTextRenderer = textRenderers.find(textRenderer => textRenderer.fontCatalog === style.fontCatalog);
                    style.textCanvas =
                        styledTextRenderer !== undefined
                            ? styledTextRenderer.textCanvas
                            : undefined;
                    style.poiRenderer =
                        styledTextRenderer !== undefined
                            ? styledTextRenderer.poiRenderer
                            : undefined;
                }
                if (style.textCanvas === undefined) {
                    if (style.fontCatalog !== undefined) {
                        logger.warn(`FontCatalog '${style.fontCatalog}' set in TextStyle '${style.name}' not found, using default fontCatalog(${defaultTextCanvas.fontCatalog.name}).`);
                    }
                    style.textCanvas = defaultTextCanvas;
                    style.poiRenderer = defaultPoiRenderer;
                }
            }
        }
    }
    /**
     * Retrieves a [[TextElementStyle]] for [[Theme]]'s [[TextStyle]] id.
     */
    getTextElementStyle(styleId) {
        let result;
        if (styleId === undefined) {
            result = this.m_defaultStyle;
        }
        else {
            result = this.m_textStyles.get(styleId);
            if (result === undefined) {
                result = this.m_defaultStyle;
            }
        }
        return result;
    }
    /**
     * Gets the appropriate [[TextRenderStyle]] to use for a label. Depends heavily on the label's
     * [[Technique]] and the current zoomLevel.
     *
     * @param technique Label's technique.
     * @param techniqueIdx Label's technique index.
     */
    getRenderStyle(tile, technique) {
        const mapView = tile.mapView;
        const dataSource = tile.dataSource;
        const zoomLevel = mapView.zoomLevel;
        const discreteZoomLevel = Math.floor(zoomLevel);
        const cacheId = computeStyleCacheId(dataSource.name, technique, discreteZoomLevel);
        let renderStyle = this.m_textRenderStyleCache.get(cacheId);
        if (renderStyle === undefined) {
            // Environment with $zoom forced to integer to achieve stable interpolated values.
            const discreteZoomEnv = new harp_datasource_protocol_1.MapEnv({ $zoom: discreteZoomLevel }, mapView.env);
            const defaultRenderParams = this.m_defaultStyle.renderParams;
            // Sets opacity to 1.0 if default and technique attribute are undefined.
            const defaultOpacity = harp_utils_1.getOptionValue(defaultRenderParams.opacity, 1.0);
            // Interpolate opacity but only on discreet zoom levels (step interpolation).
            let opacity = harp_datasource_protocol_1.getPropertyValue(harp_utils_1.getOptionValue(technique.opacity, defaultOpacity), discreteZoomEnv);
            let color;
            // Store color (RGB) in cache and multiply opacity value with the color alpha channel.
            if (technique.color !== undefined) {
                let hexColor = DecodedTileHelpers_1.evaluateColorProperty(technique.color, discreteZoomEnv);
                if (harp_datasource_protocol_1.ColorUtils.hasAlphaInHex(hexColor)) {
                    const alpha = harp_datasource_protocol_1.ColorUtils.getAlphaFromHex(hexColor);
                    opacity = opacity * alpha;
                    hexColor = harp_datasource_protocol_1.ColorUtils.removeAlphaFromHex(hexColor);
                }
                color = ColorCache_1.ColorCache.instance.getColor(hexColor);
            }
            // Sets background size to 0.0 if default and technique attribute is undefined.
            const defaultBackgroundSize = harp_utils_1.getOptionValue(defaultRenderParams.fontSize.backgroundSize, 0);
            const backgroundSize = harp_datasource_protocol_1.getPropertyValue(harp_utils_1.getOptionValue(technique.backgroundSize, defaultBackgroundSize), discreteZoomEnv);
            const hasBackgroundDefined = technique.backgroundColor !== undefined &&
                technique.backgroundSize !== undefined &&
                backgroundSize > 0;
            // Sets background opacity to 1.0 if default and technique value is undefined while
            // background size and color is specified, otherwise set value in default render
            // params or 0.0 if neither set. Makes label opaque when backgroundColor and
            // backgroundSize are set.
            const defaultBackgroundOpacity = harp_utils_1.getOptionValue(defaultRenderParams.backgroundOpacity, 0.0);
            let backgroundOpacity = harp_datasource_protocol_1.getPropertyValue(harp_utils_1.getOptionValue(technique.backgroundOpacity, hasBackgroundDefined ? 1.0 : defaultBackgroundOpacity), discreteZoomEnv);
            let backgroundColor;
            // Store background color (RGB) in cache and multiply backgroundOpacity by its alpha.
            if (technique.backgroundColor !== undefined) {
                let hexBgColor = DecodedTileHelpers_1.evaluateColorProperty(technique.backgroundColor, discreteZoomEnv);
                if (harp_datasource_protocol_1.ColorUtils.hasAlphaInHex(hexBgColor)) {
                    const alpha = harp_datasource_protocol_1.ColorUtils.getAlphaFromHex(hexBgColor);
                    backgroundOpacity = backgroundOpacity * alpha;
                    hexBgColor = harp_datasource_protocol_1.ColorUtils.removeAlphaFromHex(hexBgColor);
                }
                backgroundColor = ColorCache_1.ColorCache.instance.getColor(hexBgColor);
            }
            const renderParams = {
                fontName: harp_utils_1.getOptionValue(technique.fontName, defaultRenderParams.fontName),
                fontSize: {
                    unit: harp_text_canvas_1.FontUnit.Pixel,
                    size: harp_datasource_protocol_1.getPropertyValue(harp_utils_1.getOptionValue(technique.size, defaultRenderParams.fontSize.size), discreteZoomEnv),
                    backgroundSize
                },
                fontStyle: technique.fontStyle === "Regular" ||
                    technique.fontStyle === "Bold" ||
                    technique.fontStyle === "Italic" ||
                    technique.fontStyle === "BoldItalic"
                    ? harp_text_canvas_1.FontStyle[technique.fontStyle]
                    : defaultRenderParams.fontStyle,
                fontVariant: technique.fontVariant === "Regular" ||
                    technique.fontVariant === "AllCaps" ||
                    technique.fontVariant === "SmallCaps"
                    ? harp_text_canvas_1.FontVariant[technique.fontVariant]
                    : defaultRenderParams.fontVariant,
                rotation: harp_utils_1.getOptionValue(technique.rotation, defaultRenderParams.rotation),
                color: harp_utils_1.getOptionValue(color, harp_utils_1.getOptionValue(defaultRenderParams.color, harp_text_canvas_1.DefaultTextStyle.DEFAULT_COLOR)),
                backgroundColor: harp_utils_1.getOptionValue(backgroundColor, harp_utils_1.getOptionValue(defaultRenderParams.backgroundColor, harp_text_canvas_1.DefaultTextStyle.DEFAULT_BACKGROUND_COLOR)),
                opacity,
                backgroundOpacity
            };
            const themeRenderParams = this.getTextElementStyle(technique.style).renderParams;
            renderStyle = new harp_text_canvas_1.TextRenderStyle(Object.assign(Object.assign({}, themeRenderParams), renderParams));
            this.m_textRenderStyleCache.set(cacheId, renderStyle);
        }
        return renderStyle;
    }
    /**
     * Gets the appropriate [[TextRenderStyle]] to use for a label. Depends heavily on the label's
     * [[Technique]] and the current zoomLevel.
     *
     * @param tile The [[Tile]] to process.
     * @param technique Label's technique.
     */
    getLayoutStyle(tile, technique) {
        var _a, _b, _c, _d, _e, _f;
        const mapView = tile.mapView;
        const floorZoomLevel = Math.floor(tile.mapView.zoomLevel);
        const cacheId = computeStyleCacheId(tile.dataSource.name, technique, floorZoomLevel);
        let layoutStyle = this.m_textLayoutStyleCache.get(cacheId);
        if (layoutStyle === undefined) {
            // Environment with $zoom forced to integer to achieve stable interpolated values.
            const discreteZoomEnv = new harp_datasource_protocol_1.MapEnv({ $zoom: floorZoomLevel }, mapView.env);
            const defaultLayoutParams = this.m_defaultStyle.layoutParams;
            const hAlignment = harp_datasource_protocol_1.getPropertyValue(technique.hAlignment, discreteZoomEnv);
            const vAlignment = harp_datasource_protocol_1.getPropertyValue(technique.vAlignment, discreteZoomEnv);
            const wrapping = harp_datasource_protocol_1.getPropertyValue(technique.wrappingMode, discreteZoomEnv);
            const horizontalAlignment = hAlignment === "Left" || hAlignment === "Center" || hAlignment === "Right"
                ? harp_text_canvas_1.HorizontalAlignment[hAlignment]
                : defaultLayoutParams.horizontalAlignment;
            const verticalAlignment = vAlignment === "Above" || vAlignment === "Center" || vAlignment === "Below"
                ? harp_text_canvas_1.VerticalAlignment[vAlignment]
                : defaultLayoutParams.verticalAlignment;
            const layoutParams = {
                tracking: (_a = harp_datasource_protocol_1.getPropertyValue(technique.tracking, discreteZoomEnv), (_a !== null && _a !== void 0 ? _a : defaultLayoutParams.tracking)),
                leading: (_b = harp_datasource_protocol_1.getPropertyValue(technique.leading, discreteZoomEnv), (_b !== null && _b !== void 0 ? _b : defaultLayoutParams.leading)),
                maxLines: (_c = harp_datasource_protocol_1.getPropertyValue(technique.maxLines, discreteZoomEnv), (_c !== null && _c !== void 0 ? _c : defaultLayoutParams.maxLines)),
                lineWidth: (_d = harp_datasource_protocol_1.getPropertyValue(technique.lineWidth, discreteZoomEnv), (_d !== null && _d !== void 0 ? _d : defaultLayoutParams.lineWidth)),
                canvasRotation: (_e = harp_datasource_protocol_1.getPropertyValue(technique.canvasRotation, discreteZoomEnv), (_e !== null && _e !== void 0 ? _e : defaultLayoutParams.canvasRotation)),
                lineRotation: (_f = harp_datasource_protocol_1.getPropertyValue(technique.lineRotation, discreteZoomEnv), (_f !== null && _f !== void 0 ? _f : defaultLayoutParams.lineRotation)),
                wrappingMode: wrapping === "None" || wrapping === "Character" || wrapping === "Word"
                    ? harp_text_canvas_1.WrappingMode[wrapping]
                    : defaultLayoutParams.wrappingMode,
                horizontalAlignment,
                verticalAlignment
            };
            const themeLayoutParams = this.getTextElementStyle(technique.style);
            layoutStyle = new harp_text_canvas_1.TextLayoutStyle(Object.assign(Object.assign({}, themeLayoutParams), layoutParams));
            this.m_textLayoutStyleCache.set(cacheId, layoutStyle);
        }
        return layoutStyle;
    }
    createTextElementStyle(style, styleName) {
        return {
            name: styleName,
            fontCatalog: harp_utils_1.getOptionValue(style.fontCatalogName, this.m_defaultStyle.fontCatalog),
            renderParams: {
                fontName: style.fontName,
                fontSize: {
                    unit: harp_text_canvas_1.FontUnit.Pixel,
                    size: 32,
                    backgroundSize: style.backgroundSize || 8
                },
                fontStyle: style.fontStyle === "Regular" ||
                    style.fontStyle === "Bold" ||
                    style.fontStyle === "Italic" ||
                    style.fontStyle === "BoldItalic"
                    ? harp_text_canvas_1.FontStyle[style.fontStyle]
                    : undefined,
                fontVariant: style.fontVariant === "Regular" ||
                    style.fontVariant === "AllCaps" ||
                    style.fontVariant === "SmallCaps"
                    ? harp_text_canvas_1.FontVariant[style.fontVariant]
                    : undefined,
                rotation: style.rotation,
                color: style.color !== undefined
                    ? ColorCache_1.ColorCache.instance.getColor(style.color)
                    : undefined,
                backgroundColor: style.backgroundColor !== undefined
                    ? ColorCache_1.ColorCache.instance.getColor(style.backgroundColor)
                    : undefined,
                opacity: style.opacity,
                backgroundOpacity: style.backgroundOpacity
            },
            layoutParams: {
                tracking: style.tracking,
                leading: style.leading,
                maxLines: style.maxLines,
                lineWidth: style.lineWidth,
                canvasRotation: style.canvasRotation,
                lineRotation: style.lineRotation,
                wrappingMode: style.wrappingMode === "None" ||
                    style.wrappingMode === "Character" ||
                    style.wrappingMode === "Word"
                    ? harp_text_canvas_1.WrappingMode[style.wrappingMode]
                    : harp_text_canvas_1.WrappingMode.Word,
                verticalAlignment: style.vAlignment === "Above" ||
                    style.vAlignment === "Center" ||
                    style.vAlignment === "Below"
                    ? harp_text_canvas_1.VerticalAlignment[style.vAlignment]
                    : harp_text_canvas_1.VerticalAlignment.Center,
                horizontalAlignment: style.hAlignment === "Left" ||
                    style.hAlignment === "Center" ||
                    style.hAlignment === "Right"
                    ? harp_text_canvas_1.HorizontalAlignment[style.hAlignment]
                    : harp_text_canvas_1.HorizontalAlignment.Center
            }
        };
    }
}
exports.TextStyleCache = TextStyleCache;


/***/ }),

/***/ "../harp-mapview/lib/text/UpdateStats.ts":
/*!***********************************************!*\
  !*** ../harp-mapview/lib/text/UpdateStats.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Placement_1 = __webpack_require__(/*! ./Placement */ "../harp-mapview/lib/text/Placement.ts");
class UpdateStats {
    constructor(m_logger) {
        this.m_logger = m_logger;
        this.tiles = 0;
        this.totalGroups = 0;
        this.newGroups = 0;
        this.totalLabels = 0;
        this.results = new Array(Placement_1.PrePlacementResult.Count);
        this.results.fill(0);
    }
    clear() {
        this.tiles = 0;
        this.totalGroups = 0;
        this.newGroups = 0;
        this.totalLabels = 0;
        this.results.fill(0);
    }
    log() {
        this.m_logger.debug("Tiles", this.tiles);
        this.m_logger.debug("Total groups", this.totalGroups);
        this.m_logger.debug("New groups", this.newGroups);
        this.m_logger.debug("Total labels", this.totalLabels);
        this.m_logger.debug("Placed labels", this.results[Placement_1.PrePlacementResult.Ok]);
        this.m_logger.debug("Invisible", this.results[Placement_1.PrePlacementResult.Invisible]);
        this.m_logger.debug("Poi not ready", this.results[Placement_1.PrePlacementResult.NotReady]);
        this.m_logger.debug("Too far", this.results[Placement_1.PrePlacementResult.TooFar]);
        this.m_logger.debug("Duplicate", this.results[Placement_1.PrePlacementResult.Duplicate]);
    }
}
exports.UpdateStats = UpdateStats;


/***/ }),

/***/ "../harp-mapview/lib/workers/WorkerBootstrapDefs.ts":
/*!**********************************************************!*\
  !*** ../harp-mapview/lib/workers/WorkerBootstrapDefs.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
function isWorkerBootstrapRequest(message) {
    return (message &&
        message.type === "worker-bootstrap-request" &&
        Array.isArray(message.dependencies));
}
exports.isWorkerBootstrapRequest = isWorkerBootstrapRequest;
function isWorkerBootstrapResponse(message) {
    return (message &&
        message.type === "worker-bootstrap-response" &&
        Array.isArray(message.resolvedDependencies));
}
exports.isWorkerBootstrapResponse = isWorkerBootstrapResponse;


/***/ }),

/***/ "../harp-mapview/lib/workers/WorkerLoader.ts":
/*!***************************************************!*\
  !*** ../harp-mapview/lib/workers/WorkerLoader.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__(/*! @here/harp-fetch */ "../harp-fetch/index.web.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const WorkerBootstrapDefs_1 = __webpack_require__(/*! ./WorkerBootstrapDefs */ "../harp-mapview/lib/workers/WorkerBootstrapDefs.ts");
const logger = harp_utils_1.LoggerManager.instance.create("WorkerLoader");
/**
 * Set of `Worker` loading and initialization helpers:
 *  - starting Worker from URL with fallback to XHR+blob [[WorkerLoader.startWorker]]
 *  - waiting for proper worker initialization, see [[WorkerLoader.waitWorkerInitialized]]
 */
class WorkerLoader {
    /**
     * Starts worker by first attempting load from `scriptUrl` using native `Worker` constructor.
     * Then waits (using [[waitWorkerInitialized]]) for first message that indicates successful
     * initialization.
     * If `scriptUrl`'s origin is different than `baseUrl`, then in case of error falls back to
     * [[startWorkerBlob]].
     *
     * We must resolve/reject promise at some time, so it is expected that any sane application will
     * be able to load worker code in some amount of time.
     * By default, this method timeouts after 10 seconds (configurable using `timeout` argument).
     *
     * This method is needed as browsers in general forbid to load worker if it's not on 'same
     * origin' regardless of Content-Security-Policy.
     *
     * For blob-based fallback work, one need to ensure that Content Security Policy (CSP) allows
     * loading web worker code from `Blob`s. By default browsers, allow 'blob:' for workers, but
     * this may change.
     *
     * Following snippet setups CSP, so workers can be started from blob urls:
     *
     *     <head>
     *         <meta http-equiv="Content-Security-Policy" content="child-src blob:">
     *     </head>
     *
     * Tested on:
     *   * Chrome 67 / Linux, Window, OSX, Android
     *   * Firefox 60 / Linux, Windows, OSX
     *   * Edge 41 / Windows
     *   * Safari 11 / OSX
     *   * Samsung Internet 7.2
     *
     * See
     *  * https://benohead.com/cross-domain-cross-browser-web-workers/
     *  * MapBox
     *    * https://stackoverflow.com/questions/21913673/execute-web-worker-from-different-origin
     *    * https://github.com/mapbox/mapbox-gl-js/issues/2658
     *    * https://github.com/mapbox/mapbox-gl-js/issues/559
     *    * https://github.com/mapbox/mapbox-gl-js/issues/6058
     *
     * Findings:
     *
     * * Chrome reports CSP by exception when constructing [[Worker]] instance.
     * * Firefox reports CSP errors when loading in first event:
     *   https://bugzilla.mozilla.org/show_bug.cgi?id=1241888
     * * Firefox 62, Chrome 67 obeys `<meta http-equiv="Content-Security-Policy">` with
     *   `worker-src blob:` but doesn't obey `worker-src URL` when used
     * * Chrome 67 doesn't obey CSP `worker-src URL` despite it's documented as supported
     *   (https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Security-Policy/worker-src)
     *
     * @param scriptUrl web worker script URL
     * @param timeout timeout in milliseconds, in which worker should set initial message
     *    (default 10 seconds)
     */
    static startWorker(scriptUrl, timeout = 10000) {
        if (scriptUrl.startsWith("blob:")) {
            return this.startWorkerImmediately(scriptUrl, timeout);
        }
        if (this.directlyFallbackToBlobBasedLoading) {
            return this.startWorkerBlob(scriptUrl, timeout);
        }
        return this.startWorkerImmediately(scriptUrl, timeout).catch(error => {
            if (typeof window !== "undefined") {
                const pageUrl = window.location.href;
                const fullScriptUrl = new URL(scriptUrl, pageUrl).href;
                if (harp_utils_1.getUrlOrigin(fullScriptUrl) === harp_utils_1.getUrlOrigin(pageUrl)) {
                    throw error;
                }
                logger.log("#startWorker: cross-origin worker construction failed, trying load with blob");
                this.directlyFallbackToBlobBasedLoading = true;
                return WorkerLoader.startWorkerBlob(scriptUrl, timeout);
            }
            else {
                throw error;
            }
        });
    }
    /**
     * Start worker, loading it immediately from `scriptUrl`. Waits (using
     * [[waitWorkerInitialized]]) for successful worker start.
     *
     * @param scriptUrl web worker script URL
     */
    static startWorkerImmediately(scriptUrl, timeout) {
        try {
            const worker = new Worker(scriptUrl);
            return this.waitWorkerInitialized(worker, timeout);
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
    /**
     * Start worker "via blob" by first loading worker script code with [[fetch]], creating `Blob`
     * and attempting to start worker from blob url. Waits (using [[waitWorkerInitialized]]) for
     * successful worker start.
     *
     * @param scriptUrl web worker script URL
     */
    static startWorkerBlob(scriptUrl, timeout) {
        return this.fetchScriptSourceToBlobUrl(scriptUrl).then(blobUrl => {
            return this.startWorkerImmediately(blobUrl, timeout);
        });
    }
    /**
     * Fetch script source as `Blob` url.
     *
     * Reuses results, if there are many simultaneous requests.
     *
     * @param scriptUrl web worker script URL
     * @return promise that resolves to url of a `Blob` with script source code
     */
    static fetchScriptSourceToBlobUrl(scriptUrl) {
        let loadingPromise = this.sourceLoaderCache.get(scriptUrl);
        if (loadingPromise !== undefined) {
            return loadingPromise;
        }
        loadingPromise = fetch(scriptUrl)
            .then(response => response.text())
            .catch(error => {
            throw new Error(`WorkerLoader#fetchScriptSourceToBlob: failed to load worker script: ${error}`);
        })
            .then(scriptSource => {
            this.sourceLoaderCache.delete(scriptUrl);
            const blob = new Blob([scriptSource], { type: "application/javascript" });
            return URL.createObjectURL(blob);
        });
        this.sourceLoaderCache.set(scriptUrl, loadingPromise);
        return loadingPromise;
    }
    /**
     * Waits for successful Web Worker start.
     *
     * Expects that worker script sends initial message.
     *
     * If first event is `message` then assumes that worker has been loaded sussesfully and promise
     * resolves to `worker` object passed as argument.
     *
     * If first event is 'error', then it is assumed that worker failed to load and promise is
     * rejected.
     *
     * (NOTE: The initial 'message' - if received - is immediately replayed using worker's
     * `dispatchEvent`, so application code can also consume it as confirmation of successful
     * worker initialization.
     *
     * We must resolve/reject promise at some time, so it is expected that any sane application will
     * be able to load worker code in some amount of time.
     *
     * @param worker [[Worker]] instance to be checked
     * @param timeout timeout in milliseconds, in which worker should set initial message
     * @returns `Promise` that resolves to `worker` on success
     */
    static waitWorkerInitialized(worker, timeout) {
        return new Promise((resolve, reject) => {
            const firstMessageCallback = (event) => {
                const message = event.data;
                if (WorkerBootstrapDefs_1.isWorkerBootstrapRequest(message)) {
                    const dependencies = message.dependencies;
                    const resolvedDependencies = [];
                    for (const dependency of dependencies) {
                        const resolved = this.dependencyUrlMapping[dependency];
                        if (!resolved) {
                            cleanup();
                            reject(new Error(`#waitWorkerInitialized: Unable to resolve '${dependency}'` +
                                ` as needed by worker script.`));
                            return;
                        }
                        resolvedDependencies.push(resolved);
                    }
                    const response = {
                        type: "worker-bootstrap-response",
                        resolvedDependencies
                    };
                    worker.postMessage(response);
                    return;
                }
                cleanup();
                resolve(worker);
                // We've just consumed first message from worker before client has any chance to
                // even call `addEventListener` on it, so here after resolve, we wait next tick and
                // replay message so user has chance to intercept it in its own handler.
                setTimeout(() => {
                    worker.dispatchEvent(event);
                }, 0);
            };
            const errorCallback = (error) => {
                cleanup();
                // Error events do not carry any useful information on tested browsers, so we assume
                // that any error before 'firstMessageCallback' as failed Worker initialization.
                let message = "Error during worker initialization";
                if (error.message) {
                    message = message + `: ${error.message}`;
                }
                if (typeof error.filename === "string" && typeof error.lineno === "number") {
                    message = message + ` in ${error.filename}:${error.lineno}`;
                }
                reject(new Error(message));
            };
            const cleanup = () => {
                clearTimeout(timerId);
                worker.removeEventListener("message", firstMessageCallback);
                worker.removeEventListener("error", errorCallback);
            };
            worker.addEventListener("error", errorCallback);
            worker.addEventListener("message", firstMessageCallback);
            const timerId = setTimeout(() => {
                cleanup();
                reject(new Error("Timeout exceeded when waiting for first message from worker."));
            }, timeout);
        });
    }
}
exports.WorkerLoader = WorkerLoader;
WorkerLoader.directlyFallbackToBlobBasedLoading = false;
WorkerLoader.sourceLoaderCache = new Map();
WorkerLoader.dependencyUrlMapping = {};


/***/ }),

/***/ "../harp-materials/index.ts":
/*!**********************************!*\
  !*** ../harp-materials/index.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/CirclePointsMaterial */ "../harp-materials/lib/CirclePointsMaterial.ts"));
__export(__webpack_require__(/*! ./lib/CopyMaterial */ "../harp-materials/lib/CopyMaterial.ts"));
__export(__webpack_require__(/*! ./lib/DisplacementFeature */ "../harp-materials/lib/DisplacementFeature.ts"));
__export(__webpack_require__(/*! ./lib/EdgeMaterial */ "../harp-materials/lib/EdgeMaterial.ts"));
__export(__webpack_require__(/*! ./lib/HighPrecisionLineMaterial */ "../harp-materials/lib/HighPrecisionLineMaterial.ts"));
__export(__webpack_require__(/*! ./lib/HighPrecisionPointMaterial */ "../harp-materials/lib/HighPrecisionPointMaterial.ts"));
__export(__webpack_require__(/*! ./lib/IconMaterial */ "../harp-materials/lib/IconMaterial.ts"));
__export(__webpack_require__(/*! ./lib/LuminosityHighPassShader */ "../harp-materials/lib/LuminosityHighPassShader.ts"));
__export(__webpack_require__(/*! ./lib/MapMeshMaterialsDefs */ "../harp-materials/lib/MapMeshMaterialsDefs.ts"));
__export(__webpack_require__(/*! ./lib/MapMeshMaterials */ "../harp-materials/lib/MapMeshMaterials.ts"));
__export(__webpack_require__(/*! ./lib/MSAAMaterial */ "../harp-materials/lib/MSAAMaterial.ts"));
__export(__webpack_require__(/*! ./lib/SepiaShader */ "../harp-materials/lib/SepiaShader.ts"));
__export(__webpack_require__(/*! ./lib/SolidLineMaterial */ "../harp-materials/lib/SolidLineMaterial.ts"));
__export(__webpack_require__(/*! ./lib/Utils */ "../harp-materials/lib/Utils.ts"));
__export(__webpack_require__(/*! ./lib/VignetteShader */ "../harp-materials/lib/VignetteShader.ts"));


/***/ }),

/***/ "../harp-materials/lib/CirclePointsMaterial.ts":
/*!*****************************************************!*\
  !*** ../harp-materials/lib/CirclePointsMaterial.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-materials/lib/Utils.ts");
const vertexShader = `
uniform float size;

void main() {
    vec3 transformed = vec3(position);
    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);

    gl_Position = projectionMatrix * mvPosition;
    gl_PointSize = size;
}
`;
const fragmentShader = `
uniform vec3 diffuse;
uniform float opacity;

void main() {
    float alpha = opacity;

    float radius = 0.5;
    vec2 coords = gl_PointCoord.xy - vec2(0.5);
    float len = length(coords);
    float falloff = fwidth(len);
    float threshold = 1.0 - smoothstep(radius - falloff, radius, len);
    alpha *= threshold;

    gl_FragColor = vec4(diffuse, alpha);
}`;
/**
 * Material designed to render circle points. Note that it is always transparent since the circle
 * shape is created with an alpha channel to benefit an antialising that a mere `discard` could
 * not bring.
 */
class CirclePointsMaterial extends THREE.ShaderMaterial {
    /**
     * Constructs a new `CirclePointsMaterial`.
     *
     * @param parameters The constructor's parameters.
     */
    constructor(parameters = {}) {
        const { size, color, opacity } = parameters, shaderParams = __rest(parameters, ["size", "color", "opacity"]);
        shaderParams.name = "CirclePointsMaterial";
        shaderParams.vertexShader = vertexShader;
        shaderParams.fragmentShader = fragmentShader;
        shaderParams.uniforms = {
            size: new THREE.Uniform(CirclePointsMaterial.DEFAULT_CIRCLE_SIZE),
            diffuse: new THREE.Uniform(new THREE.Color()),
            opacity: new THREE.Uniform(1.0)
        };
        shaderParams.depthTest = false;
        shaderParams.extensions = Object.assign(Object.assign({}, shaderParams.extensions), { derivatives: true });
        super(shaderParams);
        // Blending needs to always be enabled to support smooth edges
        Utils_1.enforceBlending(this);
        this.type = "CirclePointsMaterial";
        this.m_color = this.uniforms.diffuse.value;
        this.m_opacity = this.uniforms.opacity.value;
        if (size !== undefined) {
            this.size = size;
        }
        if (color !== undefined) {
            this.color = color;
        }
        if (opacity !== undefined) {
            this.opacity = opacity;
        }
    }
    /**
     * Gets the circle screen size.
     */
    get size() {
        return this.uniforms.size.value;
    }
    /**
     * Sets the circle screen size.
     */
    set size(size) {
        this.uniforms.size.value = size;
    }
    /**
     * Get circle opacity.
     */
    get opacity() {
        return this.m_opacity;
    }
    /**
     * Set circle opacity.
     */
    set opacity(opacity) {
        this.m_opacity = opacity;
        // Base constructor may set opacity before uniform being created.
        if (this.uniforms && this.uniforms.opacity) {
            this.uniforms.opacity.value = opacity;
        }
    }
    /**
     * Gets the diffuse.
     */
    get color() {
        return this.m_color;
    }
    /**
     * Sets the diffuse.
     */
    set color(color) {
        this.m_color.set(color);
    }
}
exports.CirclePointsMaterial = CirclePointsMaterial;
CirclePointsMaterial.DEFAULT_CIRCLE_SIZE = 1;


/***/ }),

/***/ "../harp-materials/lib/CopyMaterial.ts":
/*!*********************************************!*\
  !*** ../harp-materials/lib/CopyMaterial.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const THREE = __webpack_require__(/*! three */ "three");
/**
 * The base shader to use for [[MapView]]'s composing passes, like [[MSAAMaterial]].
 */
exports.CopyShader = {
    uniforms: {
        tDiffuse: { value: null },
        opacity: { value: 1.0 }
    },
    vertexShader: `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }`,
    fragmentShader: `
    uniform float opacity;
    uniform sampler2D tDiffuse;
    varying vec2 vUv;
    void main() {
        vec4 texel = texture2D( tDiffuse, vUv );
        gl_FragColor = opacity * texel;
    }`
};
/**
 * The material is used for composing.
 */
class CopyMaterial extends THREE.ShaderMaterial {
    /**
     * The constructor of `CopyMaterial`.
     *
     * @param uniforms The [[CopyShader]]'s uniforms.
     */
    constructor(uniforms) {
        super({
            name: "CopyMaterial",
            uniforms,
            vertexShader: exports.CopyShader.vertexShader,
            fragmentShader: exports.CopyShader.fragmentShader,
            premultipliedAlpha: true,
            transparent: false,
            blending: THREE.NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}
exports.CopyMaterial = CopyMaterial;


/***/ }),

/***/ "../harp-materials/lib/DisplacementFeature.ts":
/*!****************************************************!*\
  !*** ../harp-materials/lib/DisplacementFeature.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Determines whether a given material supports displacement maps for elevation overlay.
 * @param material The material to check.
 * @returns Whether the given material supports displacement maps for elevation overlay.
 */
function hasDisplacementFeature(material) {
    return "displacementMap" in material;
}
exports.hasDisplacementFeature = hasDisplacementFeature;


/***/ }),

/***/ "../harp-materials/lib/EdgeMaterial.ts":
/*!*********************************************!*\
  !*** ../harp-materials/lib/EdgeMaterial.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const MapMeshMaterials_1 = __webpack_require__(/*! ./MapMeshMaterials */ "../harp-materials/lib/MapMeshMaterials.ts");
const MapMeshMaterialsDefs_1 = __webpack_require__(/*! ./MapMeshMaterialsDefs */ "../harp-materials/lib/MapMeshMaterialsDefs.ts");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-materials/lib/Utils.ts");
const vertexSource = `
#define EDGE_DEPTH_OFFSET 0.0001

attribute vec3 position;
attribute vec4 color;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat3 normalMatrix;
uniform vec3 edgeColor;
uniform float edgeColorMix;

#ifdef USE_DISPLACEMENTMAP
attribute vec3 normal;
attribute vec2 uv;
uniform sampler2D displacementMap;
#endif

varying vec3 vColor;

#ifdef USE_EXTRUSION
#include <extrusion_pars_vertex>
#endif

#ifdef USE_FADING
#include <fading_pars_vertex>
#endif

void main() {

    #ifdef USE_COLOR
    vColor = mix(edgeColor.rgb, color.rgb, edgeColorMix);
    #else
    vColor = edgeColor.rgb;
    #endif

    vec3 transformed = vec3( position );

    #ifdef USE_EXTRUSION
    #include <extrusion_vertex>
    #endif

    #ifdef USE_DISPLACEMENTMAP
    transformed += normalize( normal ) * texture2D( displacementMap, uv ).x;
    #endif

    vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );

    gl_Position = projectionMatrix * mvPosition;
    // After projection gl_Position contains clip space coordinates of each vertex
    // before perspective division (1 / w), thus only vertexes with -w < z < w should
    // be displayed and offset. We offset only those edges which z coordinate in NDC
    // space is between: -inf < z < 1
    float depthOffset = step(-1.0, -gl_Position.z / gl_Position.w) * EDGE_DEPTH_OFFSET;
    gl_Position.z -= depthOffset;

    #ifdef USE_FADING
    #include <fading_vertex>
    #endif
}`;
const fragmentSource = `
precision highp float;
precision highp int;

varying vec3 vColor;

#ifdef USE_EXTRUSION
#include <extrusion_pars_fragment>
#endif

#ifdef USE_FADING
#include <fading_pars_fragment>
#endif

void main() {
    float alphaValue = 1.0;
    gl_FragColor = vec4(vColor, alphaValue);

    #ifdef USE_EXTRUSION
    #include <extrusion_fragment>
    #endif

    #ifdef USE_FADING
    #include <fading_fragment>
    #endif
}`;
/**
 * Material designed to render the edges of extruded buildings using GL_LINES. It supports solid
 * colors, vertex colors, color mixing and distance fading.
 */
class EdgeMaterial extends THREE.RawShaderMaterial {
    /**
     * Constructs a new `EdgeMaterial`.
     *
     * @param params `EdgeMaterial` parameters.
     */
    constructor(params) {
        const defines = {};
        const hasDisplacementMap = params !== undefined && params.displacementMap !== undefined;
        const hasExtrusion = params !== undefined &&
            params.extrusionRatio !== undefined &&
            params.extrusionRatio >= MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MIN &&
            params.extrusionRatio < MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
        if (hasDisplacementMap) {
            Utils_1.setShaderDefine(defines, "USE_DISPLACEMENTMAP", true);
        }
        if (hasExtrusion) {
            Utils_1.setShaderDefine(defines, "USE_EXTRUSION", true);
        }
        const shaderParams = {
            name: "EdgeMaterial",
            vertexShader: vertexSource,
            fragmentShader: fragmentSource,
            uniforms: {
                edgeColor: new THREE.Uniform(new THREE.Color(EdgeMaterial.DEFAULT_COLOR)),
                edgeColorMix: new THREE.Uniform(EdgeMaterial.DEFAULT_COLOR_MIX),
                fadeNear: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_NEAR),
                fadeFar: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_FAR),
                extrusionRatio: new THREE.Uniform(MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX),
                displacementMap: new THREE.Uniform(hasDisplacementMap ? params.displacementMap : new THREE.Texture())
            },
            depthWrite: false,
            defines
        };
        super(shaderParams);
        Utils_1.enforceBlending(this);
        MapMeshMaterials_1.FadingFeature.patchGlobalShaderChunks();
        MapMeshMaterials_1.ExtrusionFeature.patchGlobalShaderChunks();
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.color !== undefined) {
                // Color may be set directly on object (omitting class setter), because we already
                // know that is does no require any special handling nor material update
                // (see: set color()).
                this.color.set(params.color);
            }
            if (params.colorMix !== undefined) {
                this.colorMix = params.colorMix;
            }
            if (params.fadeNear !== undefined) {
                this.fadeNear = params.fadeNear;
            }
            if (params.fadeFar !== undefined) {
                this.fadeFar = params.fadeFar;
            }
            if (params.displacementMap !== undefined) {
                this.displacementMap = params.displacementMap;
            }
            if (params.extrusionRatio !== undefined) {
                this.extrusionRatio = params.extrusionRatio;
            }
        }
    }
    /**
     * Edge color.
     */
    get color() {
        return this.uniforms.edgeColor.value;
    }
    set color(value) {
        this.uniforms.edgeColor.value.copy(value);
    }
    /**
     * Color mix value. Mixes between vertexColors and edgeColor.
     */
    get colorMix() {
        return this.uniforms.edgeColorMix.value;
    }
    set colorMix(value) {
        if (this.uniforms.edgeColorMix.value === value) {
            return;
        }
        this.uniforms.edgeColorMix.value = value;
        Utils_1.setShaderMaterialDefine(this, "USE_COLOR", value > 0.0);
    }
    get fadeNear() {
        return this.uniforms.fadeNear.value;
    }
    set fadeNear(value) {
        this.uniforms.fadeNear.value = value;
    }
    get fadeFar() {
        return this.uniforms.fadeFar.value;
    }
    set fadeFar(value) {
        if (this.uniforms.fadeFar.value === value) {
            return;
        }
        this.uniforms.fadeFar.value = value;
        Utils_1.setShaderMaterialDefine(this, "USE_FADING", value > 0.0);
    }
    get extrusionRatio() {
        return this.uniforms.extrusionRatio.value;
    }
    set extrusionRatio(value) {
        if (this.uniforms.extrusionRatio.value === value) {
            return;
        }
        this.uniforms.extrusionRatio.value = value;
        // NOTE: We could also disable shader extrusion chunks when it hits
        // ExtrusionFeatureDefs.DEFAULT_RATIO_MAX value, but this would cause shader re-compile.
        const useExtrusion = value >= MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MIN;
        Utils_1.setShaderMaterialDefine(this, "USE_EXTRUSION", useExtrusion);
    }
    get displacementMap() {
        return this.uniforms.displacementMap.value;
    }
    set displacementMap(map) {
        if (this.uniforms.displacementMap.value === map) {
            return;
        }
        this.uniforms.displacementMap.value = map;
        const useDisplacementMap = map !== null;
        if (useDisplacementMap) {
            this.uniforms.displacementMap.value.needsUpdate = true;
        }
        Utils_1.setShaderMaterialDefine(this, "USE_DISPLACEMENTMAP", useDisplacementMap);
    }
}
exports.EdgeMaterial = EdgeMaterial;
EdgeMaterial.DEFAULT_COLOR = 0x000000;
EdgeMaterial.DEFAULT_COLOR_MIX = 0.0;


/***/ }),

/***/ "../harp-materials/lib/HighPrecisionLineMaterial.ts":
/*!**********************************************************!*\
  !*** ../harp-materials/lib/HighPrecisionLineMaterial.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const LinesChunks_1 = __webpack_require__(/*! ./ShaderChunks/LinesChunks */ "../harp-materials/lib/ShaderChunks/LinesChunks.ts");
const vertexSource = `
#ifdef USE_COLOR
attribute vec4 color;
varying vec3 vColor;
#endif

// uniforms to implement double-precision
uniform mat4 u_mvp;             // combined modelView and projection matrix
uniform vec3 u_eyepos;          // eye position major
uniform vec3 u_eyepos_lowpart;  // eye position minor ((double) eyepos - (float) eyepos)

// vertex attributes
attribute vec3 position;        // high part
attribute vec3 positionLow;     // low part

#include <high_precision_vert_func>

void main() {
    #ifdef USE_COLOR
    vColor = color.rgb;
    #endif

    vec3 pos = subtractDblEyePos(position);
    gl_Position = u_mvp * vec4(pos, 1.0);
}`;
const fragmentSource = `
precision highp float;
precision highp int;

uniform vec3 diffuse;
uniform float opacity;

#ifdef USE_COLOR
varying vec3 color;
#endif

void main() {
    #ifdef USE_COLOR
    gl_FragColor = vec4( diffuse * vColor, opacity );
    #else
    gl_FragColor = vec4( diffuse, opacity );
    #endif
}`;
/**
 * Material designed to render high precision lines (ideal for position-sensible data).
 */
class HighPrecisionLineMaterial extends THREE.RawShaderMaterial {
    /**
     * Constructs a new `HighPrecisionLineMaterial`.
     *
     * @param params `HighPrecisionLineMaterial` parameters.
     */
    constructor(params) {
        Object.assign(THREE.ShaderChunk, LinesChunks_1.default);
        const shaderParams = {
            name: "HighPrecisionLineMaterial",
            vertexShader: vertexSource,
            fragmentShader: fragmentSource,
            uniforms: {
                diffuse: new THREE.Uniform(new THREE.Color(HighPrecisionLineMaterial.DEFAULT_COLOR)),
                opacity: new THREE.Uniform(HighPrecisionLineMaterial.DEFAULT_OPACITY),
                u_mvp: new THREE.Uniform(new THREE.Matrix4()),
                u_eyepos: new THREE.Uniform(new THREE.Vector3()),
                u_eyepos_lowpart: new THREE.Uniform(new THREE.Vector3())
            }
        };
        Object.assign(shaderParams, params);
        super(shaderParams);
        this.type = "HighPrecisionLineMaterial";
        this.isHighPrecisionLineMaterial = true;
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.color !== undefined) {
                this.color.set(params.color);
            }
            if (params.opacity !== undefined) {
                this.opacity = params.opacity;
            }
        }
        this.updateTransparencyFeature();
    }
    /**
     * Line color.
     */
    get color() {
        return this.uniforms.diffuse.value;
    }
    set color(value) {
        this.uniforms.diffuse.value.copy(value);
    }
    updateTransparencyFeature() {
        this.transparent = this.opacity < 1.0 ? true : false;
    }
}
exports.HighPrecisionLineMaterial = HighPrecisionLineMaterial;
HighPrecisionLineMaterial.DEFAULT_COLOR = 0x000050;
HighPrecisionLineMaterial.DEFAULT_OPACITY = 1.0;
function isHighPrecisionLineMaterial(material) {
    return (material !== undefined &&
        material.isHighPrecisionLineMaterial === true);
}
exports.isHighPrecisionLineMaterial = isHighPrecisionLineMaterial;


/***/ }),

/***/ "../harp-materials/lib/HighPrecisionPointMaterial.ts":
/*!***********************************************************!*\
  !*** ../harp-materials/lib/HighPrecisionPointMaterial.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const LinesChunks_1 = __webpack_require__(/*! ./ShaderChunks/LinesChunks */ "../harp-materials/lib/ShaderChunks/LinesChunks.ts");
const vertexSource = `
#ifdef USE_COLOR
varying vec3 vColor;
#endif

uniform float size;

// uniforms to implement double-precision
uniform mat4 u_mvp;             // combined modelView and projection matrix
uniform vec3 u_eyepos;          // eye position major
uniform vec3 u_eyepos_lowpart;  // eye position minor ((double) eyepos - (float) eyepos)

// vertex attributes
attribute vec3 positionLow;     // low part

#include <high_precision_vert_func>

void main() {
    #ifdef USE_COLOR
    vColor = color.rgb;
    #endif

    vec3 pos = subtractDblEyePos(position);
    gl_Position = u_mvp * vec4(pos, 1.0);

    // ignore sizeAttenuation for now!
    gl_PointSize = size;
}`;
/**
 * Material designed to render high precision points (ideal for position-sensible data).
 */
class HighPrecisionPointMaterial extends THREE.PointsMaterial {
    /**
     * Constructs a new `HighPrecisionPointMaterial`.
     *
     * @param params `HighPrecisionPointMaterial` parameters.
     */
    constructor(params) {
        Object.assign(THREE.ShaderChunk, LinesChunks_1.default);
        const shaderParams = params;
        super(shaderParams);
        this.type = "HighPrecisionPointMaterial";
        this.vertexShader = vertexSource;
        this.fragmentShader = THREE.ShaderChunk.points_frag;
        this.fog = false;
        this.uniforms = {
            diffuse: new THREE.Uniform(new THREE.Color(HighPrecisionPointMaterial.DEFAULT_COLOR)),
            opacity: new THREE.Uniform(HighPrecisionPointMaterial.DEFAULT_OPACITY),
            size: new THREE.Uniform(HighPrecisionPointMaterial.DEFAULT_SIZE),
            scale: new THREE.Uniform(HighPrecisionPointMaterial.DEFAULT_SCALE),
            map: new THREE.Uniform(new THREE.Texture()),
            uvTransform: new THREE.Uniform(new THREE.Matrix3()),
            u_mvp: new THREE.Uniform(new THREE.Matrix4()),
            u_eyepos: new THREE.Uniform(new THREE.Vector3()),
            u_eyepos_lowpart: new THREE.Uniform(new THREE.Vector3())
        };
        this.isHighPrecisionPointMaterial = true;
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.color !== undefined) {
                this.color.set(params.color);
            }
            if (params.opacity !== undefined) {
                this.opacity = params.opacity;
            }
            if (params.size !== undefined) {
                this.size = params.size;
            }
            if (params.scale !== undefined) {
                this.scale = params.scale;
            }
            if (params.uvTransform !== undefined) {
                this.uvTransform = params.uvTransform;
            }
            if (params.map !== undefined) {
                this.map = params.map;
            }
        }
    }
    /**
     *  Point scale.
     */
    get scale() {
        return this.uniforms.scale.value;
    }
    set scale(value) {
        this.uniforms.scale.value = value;
    }
    /**
     * UV transformation matrix.
     */
    get uvTransform() {
        return this.uniforms.uvTransform.value;
    }
    set uvTransform(value) {
        this.uniforms.uvTransform.value = value;
    }
}
exports.HighPrecisionPointMaterial = HighPrecisionPointMaterial;
HighPrecisionPointMaterial.DEFAULT_COLOR = 0x000050;
HighPrecisionPointMaterial.DEFAULT_OPACITY = 1.0;
HighPrecisionPointMaterial.DEFAULT_SIZE = 1.0;
HighPrecisionPointMaterial.DEFAULT_SCALE = 1.0;
function isHighPrecisionPointMaterial(material) {
    return (material !== undefined &&
        material.isHighPrecisionPointMaterial === true);
}
exports.isHighPrecisionPointMaterial = isHighPrecisionPointMaterial;


/***/ }),

/***/ "../harp-materials/lib/IconMaterial.ts":
/*!*********************************************!*\
  !*** ../harp-materials/lib/IconMaterial.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const vertexSource = `
attribute vec4 position;
attribute vec4 color;
attribute vec2 uv;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

varying vec4 vColor;
varying vec2 vUv;

void main() {
    vUv = uv;
    vColor = color;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);
}`;
const fragmentSource = `
precision highp float;
precision highp int;

uniform sampler2D map;

varying vec4 vColor;
varying vec2 vUv;

void main() {

    vec4 color = texture2D(map, vUv.xy);
    color *= vColor.a;
    if (color.a < 0.05) {
        discard;
    }
    gl_FragColor = color;
}`;
/**
 * 2D material for icons, similar to [[TextMaterial]]. Uses component in texture coordinates to
 * apply opacity.
 */
class IconMaterial extends THREE.RawShaderMaterial {
    /**
     * Constructs a new `IconMaterial`.
     *
     * @param params `IconMaterial` parameters.
     */
    constructor(params) {
        const shaderParams = {
            name: "IconMaterial",
            vertexShader: vertexSource,
            fragmentShader: fragmentSource,
            uniforms: {
                map: new THREE.Uniform(params.map)
            },
            depthTest: true,
            depthWrite: true,
            transparent: true,
            vertexColors: THREE.VertexColors,
            premultipliedAlpha: true,
            blending: THREE.NormalBlending
        };
        super(shaderParams);
    }
    /**
     * Icon texture map/atlas.
     */
    get map() {
        return this.uniforms.map.value;
    }
}
exports.IconMaterial = IconMaterial;


/***/ }),

/***/ "../harp-materials/lib/LuminosityHighPassShader.ts":
/*!*********************************************************!*\
  !*** ../harp-materials/lib/LuminosityHighPassShader.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * The shader used in the [[UnrealBloomPass]] for the bloom/glow effect.
 */
exports.LuminosityHighPassShader = {
    uniforms: {
        tDiffuse: { value: null },
        luminosityThreshold: { value: 1.0 },
        smoothWidth: { value: 1.0 },
        defaultColor: { value: new THREE.Color(0x000000) },
        defaultOpacity: { value: 0.0 }
    },
    vertexShader: `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }`,
    fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform vec3 defaultColor;
    uniform float defaultOpacity;
    uniform float luminosityThreshold;
    uniform float smoothWidth;
    varying vec2 vUv;
    void main() {
        vec4 texel = texture2D( tDiffuse, vUv );
        vec3 luma = vec3( 0.299, 0.587, 0.114 );
        float v = dot( texel.xyz, luma );
        vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );
        float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );
        gl_FragColor = mix( outputColor, texel, alpha );
    }`
};


/***/ }),

/***/ "../harp-materials/lib/MSAAMaterial.ts":
/*!*********************************************!*\
  !*** ../harp-materials/lib/MSAAMaterial.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const THREE = __webpack_require__(/*! three */ "three");
const CopyMaterial_1 = __webpack_require__(/*! ./CopyMaterial */ "../harp-materials/lib/CopyMaterial.ts");
/**
 * The material to use for the quad of the [[MSAARenderPass]] in the composing.
 */
class MSAAMaterial extends THREE.ShaderMaterial {
    /**
     * The constructor of `MSAAMaterial`.
     *
     * @param uniforms The [[CopyShader]]'s uniforms.
     */
    constructor(uniforms) {
        super({
            uniforms,
            vertexShader: CopyMaterial_1.CopyShader.vertexShader,
            fragmentShader: CopyMaterial_1.CopyShader.fragmentShader,
            premultipliedAlpha: true,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}
exports.MSAAMaterial = MSAAMaterial;


/***/ }),

/***/ "../harp-materials/lib/MapMeshMaterials.ts":
/*!*************************************************!*\
  !*** ../harp-materials/lib/MapMeshMaterials.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-materials/lib/Utils.ts");
const THREE = __webpack_require__(/*! three */ "three");
const MapMeshMaterialsDefs_1 = __webpack_require__(/*! ./MapMeshMaterialsDefs */ "../harp-materials/lib/MapMeshMaterialsDefs.ts");
const ExtrusionChunks_1 = __webpack_require__(/*! ./ShaderChunks/ExtrusionChunks */ "../harp-materials/lib/ShaderChunks/ExtrusionChunks.ts");
const FadingChunks_1 = __webpack_require__(/*! ./ShaderChunks/FadingChunks */ "../harp-materials/lib/ShaderChunks/FadingChunks.ts");
const emptyTexture = new THREE.Texture();
/**
 * Translates a linear distance value [0..1], where 1 is the distance to the far plane, into
 * [0..maxVisibilityRange].
 *
 * Copy from MapViewUtils, since it cannot be accessed here because of circular dependencies.
 *
 * @param distance Distance from the camera (range: [0, 1]).
 * @param visibilityRange object describing maximum and minimum visibility range - distances
 * from camera at which objects won't be rendered anymore.
 */
function cameraToWorldDistance(distance, visibilityRange) {
    return distance * visibilityRange.maximum;
}
/**
 * Provides common interface from mixin to internal material defines and shader uniforms.
 *
 * Call this function just after [THREE.Material] is constructed, so in derived classes after
 * super c-tor call.
 * @param mixin The mixin that will add features to [[THREE.Material]].
 * @param material The material that mixin feature is being applied.
 */
function linkMixinWithMaterial(mixin, material) {
    // Some materials (MeshBasicMaterial) have no defines property created in c-tor.
    // In such case create it manually, such defines will be also injected to the shader
    // via generic THREE.js code - see THREE/WebGLProgram.js.
    if (material.defines === undefined) {
        material.defines = {};
    }
    // Link internal THREE.js material defines with mixin reference.
    // Those defines are usually created in Material c-tor, if not we have fallback above.
    mixin.shaderDefines = material.defines;
    // Prepare map for holding uniforms references from the actual shader, but check if
    // it was not already created with other mixin feature.
    if (mixin.shaderUniforms === undefined) {
        mixin.shaderUniforms = {};
    }
    // Shader uniforms may not be linked at this stage, they are injected available via Shader
    // object in onBeforeCompile callback, see: linkMixinWithShader().
}
/**
 * Links mixin [[MixinShaderProperties.shaderUniforms]] with actual material shader uniforms.
 *
 * Function injects features (mixin) specific shader uniforms to material's shader, it also
 * updates uniforms references so [[MixinShaderProperties.shaderUniforms]] will contain full
 * uniforms map (both feature specific and internal ones).
 * This function should be called before material's shader is pre-compiled, so the new uniforms
 * from the mixin feature are known to shader processor. The best place to use is
 * [[Material.onBeforeCompile]].
 * @param mixin The mixin feature being applied to the material.
 * @param shader The actual shader linked to the [[THREE.Material]].
 */
function linkMixinWithShader(mixin, shader) {
    Object.assign(shader.uniforms, mixin.shaderUniforms);
    mixin.shaderUniforms = shader.uniforms;
}
var DisplacementFeature;
(function (DisplacementFeature) {
    /**
     * Checks if feature is enabled (displacement map defined).
     *
     * @param displacementMaterial
     */
    function isEnabled(displacementMaterial) {
        return displacementMaterial.displacementMap !== null;
    }
    DisplacementFeature.isEnabled = isEnabled;
    /**
     * Update the internals of the `DisplacementFeature` depending on the value of
     * [[displacementMap]].
     *
     * @param displacementMaterial DisplacementFeature
     */
    function updateDisplacementFeature(displacementMaterial) {
        harp_utils_1.assert(displacementMaterial.shaderDefines !== undefined);
        harp_utils_1.assert(displacementMaterial.shaderUniforms !== undefined);
        const useDisplacementMap = isEnabled(displacementMaterial);
        // Whenever displacement feature state changes (between enabled/disabled) material will be
        // re-compiled, forcing new shader chunks to be added (or removed).
        const needsUpdate = Utils_1.setShaderDefine(displacementMaterial.shaderDefines, "USE_DISPLACEMENTMAP", useDisplacementMap);
        displacementMaterial.needsUpdate = needsUpdate;
        // Update texture after change.
        if (useDisplacementMap) {
            const texture = displacementMaterial.displacementMap;
            texture.needsUpdate = true;
            displacementMaterial.shaderUniforms.displacementMap.value = texture;
        }
        else if (needsUpdate) {
            displacementMaterial.shaderUniforms.displacementMap.value = emptyTexture;
        }
    }
    DisplacementFeature.updateDisplacementFeature = updateDisplacementFeature;
    /**
     * This function should be called on implementors of DisplacementFeature in the
     * `onBeforeCompile` callback of that material. It adds the required code to the shaders to
     * apply displacement maps.
     *
     * @param displacementMaterial Material to add uniforms to.
     * @param shader [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the
     *                  special includes to.
     */
    function onBeforeCompile(displacementMaterial, shader) {
        if (!isEnabled(displacementMaterial)) {
            return;
        }
        harp_utils_1.assert(displacementMaterial.shaderUniforms !== undefined);
        // The vertex and fragment shaders have been constructed dynamically. The uniforms and
        // the shader includes are now appended to them.
        //
        // The object "defines" are required for this material, we use one define working as a flag,
        // which enables/disables some chunks of shader code.
        linkMixinWithShader(displacementMaterial, shader);
        // Append the displacement map chunk to the vertex shader.
        shader.vertexShader = shader.vertexShader.replace("#include <skinbase_vertex>", `#include <skinbase_vertex>
#ifndef USE_ENVMAP
    vec3 objectNormal = vec3( normal );
#endif`);
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "uv2_pars_vertex", "displacementmap_pars_vertex");
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "skinning_vertex", "displacementmap_vertex", true);
    }
    DisplacementFeature.onBeforeCompile = onBeforeCompile;
})(DisplacementFeature || (DisplacementFeature = {}));
class DisplacementFeatureMixin {
    constructor() {
        this.m_displacementMap = null;
    }
    // This is here to keep tslint from reporting a missing property, the getter that's actually
    // used by materials is added in [[addDisplacementProperties]].
    get displacementMap() {
        return this.m_displacementMap;
    }
    // This is here to keep tslint from reporting a missing property, the setter that's actually
    // used by materials is added in [[addDisplacementProperties]].
    set displacementMap(map) {
        this.setDisplacementMap(map);
    }
    getDisplacementMap() {
        return this.m_displacementMap;
    }
    setDisplacementMap(map) {
        if (map !== this.m_displacementMap) {
            this.m_displacementMap = map;
            DisplacementFeature.updateDisplacementFeature(this);
        }
    }
    /**
     * The mixin class should call this method to register the property [[displacementMap]]
     */
    addDisplacementProperties() {
        Object.defineProperty(this, "displacementMap", {
            get: () => {
                return this.getDisplacementMap();
            },
            set: val => {
                this.setDisplacementMap(val);
            }
        });
    }
    /**
     * Apply the displacementMap value from the parameters to the respective properties.
     */
    applyDisplacementParameters(params) {
        linkMixinWithMaterial(this, this);
        harp_utils_1.assert(this.shaderDefines !== undefined);
        harp_utils_1.assert(this.shaderUniforms !== undefined);
        // Create uniforms with default values, this ensures they are always set created,
        // so no need for checks in setters.
        const uniforms = this.shaderUniforms;
        uniforms.displacementMap = new THREE.Uniform(emptyTexture);
        uniforms.displacementScale = new THREE.Uniform(1);
        uniforms.displacementBias = new THREE.Uniform(0);
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.displacementMap !== undefined) {
                this.setDisplacementMap(params.displacementMap);
            }
        }
        this.onBeforeCompile = harp_utils_1.chainCallbacks(this.onBeforeCompile, (shader) => {
            DisplacementFeature.onBeforeCompile(this, shader);
        });
        // Require material update at least once, because of new shader chunks added.
        this.needsUpdate = DisplacementFeature.isEnabled(this);
    }
    /**
     * Copy displacementMap from other DisplacementFeature.
     *
     * @param source The material to copy property values from.
     */
    copyDisplacementParameters(source) {
        this.setDisplacementMap(source.displacementMap);
        return this;
    }
}
exports.DisplacementFeatureMixin = DisplacementFeatureMixin;
/**
 * Namespace with support functions for implementors of `FadingFeature`.
 */
var FadingFeature;
(function (FadingFeature) {
    FadingFeature.DEFAULT_FADE_NEAR = -1.0;
    FadingFeature.DEFAULT_FADE_FAR = -1.0;
    /**
     * Checks if feature is enabled based on feature params.
     *
     * Fading feature will be disabled if fadeFar is undefined or fadeFar <= 0.0.
     * This function is crucial for shader switching (chunks injection), whenever feature state
     * changes between enabled/disabled. Current approach is to keep feature on (once enabled)
     * whenever fading params are reasonable, even if it causes full fade in, no transparency.
     *
     * @param fadingMaterial FadingFeature.
     */
    function isEnabled(fadingMaterial) {
        // NOTE: We could also check if full fade is not achieved, then feature could be
        // disabled, but causing material re-compile.
        return (fadingMaterial.fadeNear !== undefined &&
            fadingMaterial.fadeFar !== undefined &&
            fadingMaterial.fadeFar > 0);
    }
    FadingFeature.isEnabled = isEnabled;
    /**
     * Patch the THREE.ShaderChunk on first call with some extra shader chunks.
     */
    function patchGlobalShaderChunks() {
        if (THREE.ShaderChunk.fading_pars_vertex === undefined) {
            Object.assign(THREE.ShaderChunk, FadingChunks_1.default);
        }
    }
    FadingFeature.patchGlobalShaderChunks = patchGlobalShaderChunks;
    /**
     * Update the internals of the `FadingFeature` depending on the value of [[fadeNear]]. The
     * fading feature will be disabled if fadeFar <= 0.0.
     *
     * @param fadingMaterial FadingFeature
     */
    function updateFadingFeature(fadingMaterial) {
        harp_utils_1.assert(fadingMaterial.shaderDefines !== undefined);
        harp_utils_1.assert(fadingMaterial.shaderUniforms !== undefined);
        // Update entire material to add/remove shader fading chunks, this happens when we
        // enable/disable fading after material creation. Feature is marked via dummy define, which
        // informs about fading feature state, even if such define is not required to control
        // feature state, it makes it easy to check for shader changes.
        const useFading = isEnabled(fadingMaterial);
        const needsUpdate = Utils_1.setShaderDefine(fadingMaterial.shaderDefines, "FADING_MATERIAL", useFading);
        // Enable/disable entire feature with material re-compile, this will also cause
        // new uniforms injection.
        fadingMaterial.needsUpdate = needsUpdate;
        // Check if shader uniforms references are already set in onBeforeCompile callback.
        harp_utils_1.assert(fadingMaterial.shaderUniforms.fadeNear !== undefined &&
            fadingMaterial.shaderUniforms.fadeFar !== undefined);
        // Update shader internal uniforms only if fading is enabled.
        if (useFading) {
            fadingMaterial.shaderUniforms.fadeNear.value = fadingMaterial.fadeNear;
            fadingMaterial.shaderUniforms.fadeFar.value = fadingMaterial.fadeFar;
            if (needsUpdate) {
                Utils_1.enableBlending(fadingMaterial);
            }
        }
        // Perform one time update of uniforms to defaults when feature disabled (for clarity).
        else if (needsUpdate) {
            fadingMaterial.shaderUniforms.fadeNear.value = FadingFeature.DEFAULT_FADE_NEAR;
            fadingMaterial.shaderUniforms.fadeFar.value = FadingFeature.DEFAULT_FADE_FAR;
            Utils_1.disableBlending(fadingMaterial);
        }
    }
    FadingFeature.updateFadingFeature = updateFadingFeature;
    /**
     * This function should be called on implementors of FadingFeature in the `onBeforeCompile`
     * callback of that material. It adds the required code to the shaders and declares the new
     * uniforms that control fading based on view distance.
     *
     * @param fadingMaterial Material to add uniforms to.
     * @param shader [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the
     *                  special includes to.
     */
    function onBeforeCompile(fadingMaterial, shader) {
        if (!isEnabled(fadingMaterial)) {
            return;
        }
        harp_utils_1.assert(fadingMaterial.shaderUniforms !== undefined);
        // The vertex and fragment shaders have been constructed dynamically. The uniforms and
        // the shader includes are now appended to them.
        //
        // The object "defines" are not required for this material, so the fading shader chunks
        // have no #ifdef preprocessed chunks. Feature utilized one define just to denote feature
        // attached and easy control its state, but this define may be stripped out if needed.
        linkMixinWithShader(fadingMaterial, shader);
        // Append the new fading shader cod directly after the fog code. This is done by adding an
        // include directive for the fading code.
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "fog_pars_vertex", "fading_pars_vertex");
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "fog_vertex", "fading_vertex", true);
        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, "fog_pars_fragment", "fading_pars_fragment");
        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, "fog_fragment", "fading_fragment", true);
    }
    FadingFeature.onBeforeCompile = onBeforeCompile;
    /**
     * As three.js is rendering the transparent objects last (internally), regardless of their
     * renderOrder value, we set the transparent value to false in the [[onAfterRenderCall]]. In
     * [[onBeforeRender]], the function [[calculateDepthFromCameraDistance]] sets it to true if the
     * fade distance value is less than 1.
     *
     * @param object [[THREE.Object3D]] to prepare for rendering.
     * @param viewRanges The visibility ranges (clip planes and maximum visible distance) for
     * actual camera setup.
     * @param fadeNear The fadeNear value to set in the material.
     * @param fadeFar The fadeFar value to set in the material.
     * @param updateUniforms If `true`, the fading uniforms are set. Not required if material is
     *          handling the uniforms already, like in a [[THREE.ShaderMaterial]].
     * @param additionalCallback If defined, this function will be called before the function will
     *          return.
     */
    function addRenderHelper(object, viewRanges, fadeNear, fadeFar, updateUniforms, additionalCallback) {
        // tslint:disable-next-line:no-unused-variable
        object.onBeforeRender = harp_utils_1.chainCallbacks(object.onBeforeRender, (renderer, scene, camera, geometry, material, group) => {
            const fadingMaterial = material;
            fadingMaterial.fadeNear =
                fadeNear === undefined || fadeNear === FadingFeature.DEFAULT_FADE_NEAR
                    ? FadingFeature.DEFAULT_FADE_NEAR
                    : cameraToWorldDistance(fadeNear, viewRanges);
            fadingMaterial.fadeFar =
                fadeFar === undefined || fadeFar === FadingFeature.DEFAULT_FADE_FAR
                    ? FadingFeature.DEFAULT_FADE_FAR
                    : cameraToWorldDistance(fadeFar, viewRanges);
            if (additionalCallback !== undefined) {
                additionalCallback(renderer, material);
            }
        });
    }
    FadingFeature.addRenderHelper = addRenderHelper;
})(FadingFeature = exports.FadingFeature || (exports.FadingFeature = {}));
/**
 * Mixin class for extended THREE materials. Adds new properties required for `fadeNear` and
 * `fadeFar`. There is some special handling for the fadeNear/fadeFar properties, which get some
 * setters and getters in a way that works well with the mixin.
 *
 * @see [[Tile#addRenderHelper]]
 */
class FadingFeatureMixin {
    constructor() {
        this.m_fadeNear = FadingFeature.DEFAULT_FADE_NEAR;
        this.m_fadeFar = FadingFeature.DEFAULT_FADE_FAR;
    }
    /**
     * @see [[FadingFeature#fadeNear]]
     */
    getFadeNear() {
        return this.m_fadeNear;
    }
    /**
     * @see [[FadingFeature#fadeNear]]
     */
    setFadeNear(value) {
        const needsUpdate = value !== this.m_fadeNear;
        if (needsUpdate) {
            this.m_fadeNear = value;
            FadingFeature.updateFadingFeature(this);
        }
    }
    /**
     * @see [[FadingFeature#fadeFar]]
     */
    getFadeFar() {
        return this.m_fadeFar;
    }
    /**
     * @see [[FadingFeature#fadeFar]]
     */
    setFadeFar(value) {
        const needsUpdate = value !== this.m_fadeFar;
        if (needsUpdate) {
            this.m_fadeFar = value;
            FadingFeature.updateFadingFeature(this);
        }
    }
    /**
     * The mixin classes should call this method to register the properties [[fadeNear]] and
     * [[fadeFar]].
     */
    addFadingProperties() {
        Object.defineProperty(this, "fadeNear", {
            get: () => {
                return this.getFadeNear();
            },
            set: val => {
                this.setFadeNear(val);
            }
        });
        Object.defineProperty(this, "fadeFar", {
            get: () => {
                return this.getFadeFar();
            },
            set: val => {
                this.setFadeFar(val);
            }
        });
    }
    /**
     * Apply the fadeNear/fadeFar values from the parameters to the respective properties.
     *
     * @param params `FadingMeshBasicMaterial` parameters.
     */
    applyFadingParameters(params) {
        // Prepare maps for holding uniforms and defines references from the actual material.
        linkMixinWithMaterial(this, this);
        harp_utils_1.assert(this.shaderDefines !== undefined);
        harp_utils_1.assert(this.shaderUniforms !== undefined);
        // Create uniforms with default values, this ensures they are always set created,
        // so no need for checks in setters.
        this.shaderUniforms.fadeNear = new THREE.Uniform(FadingFeature.DEFAULT_FADE_NEAR);
        this.shaderUniforms.fadeFar = new THREE.Uniform(FadingFeature.DEFAULT_FADE_FAR);
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.fadeNear !== undefined) {
                this.setFadeNear(params.fadeNear);
            }
            if (params.fadeFar !== undefined) {
                this.setFadeFar(params.fadeFar);
            }
        }
        this.onBeforeCompile = harp_utils_1.chainCallbacks(this.onBeforeCompile, (shader) => {
            FadingFeature.onBeforeCompile(this, shader);
        });
        // Update (re-compile) shader code to include new shader chunks only if feature is enabled.
        this.needsUpdate = FadingFeature.isEnabled(this);
    }
    /**
     * Copy fadeNear/fadeFar values from other FadingFeature.
     *
     * @param source The material to copy property values from.
     */
    copyFadingParameters(source) {
        this.setFadeNear(source.fadeNear === undefined ? FadingFeature.DEFAULT_FADE_NEAR : source.fadeNear);
        this.setFadeFar(source.fadeFar === undefined ? FadingFeature.DEFAULT_FADE_FAR : source.fadeFar);
        return this;
    }
}
exports.FadingFeatureMixin = FadingFeatureMixin;
var ExtrusionFeature;
(function (ExtrusionFeature) {
    /**
     * Checks if feature is enabled based on [[ExtrusionFeature]] properties.
     *
     * @param extrusionMaterial
     */
    function isEnabled(extrusionMaterial) {
        return (extrusionMaterial.extrusionRatio !== undefined &&
            extrusionMaterial.extrusionRatio >= MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MIN);
    }
    ExtrusionFeature.isEnabled = isEnabled;
    /**
     * Patch the THREE.ShaderChunk on first call with some extra shader chunks.
     */
    function patchGlobalShaderChunks() {
        if (THREE.ShaderChunk.extrusion_pars_vertex === undefined) {
            Object.assign(THREE.ShaderChunk, ExtrusionChunks_1.default);
        }
    }
    ExtrusionFeature.patchGlobalShaderChunks = patchGlobalShaderChunks;
    /**
     * Update the internals of the `ExtrusionFeature` depending on the value of [[extrusionRatio]].
     *
     * @param ExtrusionMaterial ExtrusionFeature
     */
    function updateExtrusionFeature(extrusionMaterial) {
        harp_utils_1.assert(extrusionMaterial.shaderDefines !== undefined);
        harp_utils_1.assert(extrusionMaterial.shaderUniforms !== undefined);
        // Setup shader define that when changed will force material re-compile.
        const useExtrusion = isEnabled(extrusionMaterial);
        // Use shader define as marker if feature is enabled/disabled, this is not necessary
        // required, but material requires update (re-compile) anyway to add/remove shader chunks.
        const needsUpdate = Utils_1.setShaderDefine(extrusionMaterial.shaderDefines, "EXTRUSION_MATERIAL", useExtrusion);
        // Enable/disable entire feature with material re-compile.
        extrusionMaterial.needsUpdate = needsUpdate;
        // Update uniform with new value
        if (useExtrusion) {
            extrusionMaterial.shaderUniforms.extrusionRatio.value =
                extrusionMaterial.extrusionRatio;
        }
        // Reset uniform to default, one time only, when feature is disabled (just for clarity).
        else if (needsUpdate) {
            extrusionMaterial.shaderUniforms.extrusionRatio.value =
                MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
        }
    }
    ExtrusionFeature.updateExtrusionFeature = updateExtrusionFeature;
    /**
     * This function should be called on implementors of ExtrusionFeature in the `onBeforeCompile`
     * callback of that material. It adds the required code to the shaders and declares the new
     * uniforms that control extrusion.
     *
     * @param extrusionMaterial Material to add uniforms to.
     * @param shader [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the
     *                  special includes to.
     */
    function onBeforeCompile(extrusionMaterial, shader) {
        if (!isEnabled(extrusionMaterial)) {
            return;
        }
        harp_utils_1.assert(extrusionMaterial.shaderUniforms !== undefined);
        // The vertex and fragment shaders have been constructed dynamically. The uniforms and
        // the shader includes are now appended to them. No defines are required to preprocess
        // shader chunks, but we utilize one just to note the feature is enabled/disabled
        // (easier debugging), this define may be easily stripped out or replaced with simple
        // boolean flag.
        linkMixinWithShader(extrusionMaterial, shader);
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "common", "extrusion_pars_vertex");
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "begin_vertex", "extrusion_vertex", true);
        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, "fog_pars_fragment", "extrusion_pars_fragment");
        shader.fragmentShader = shader.fragmentShader.replace("#include <normal_fragment_begin>", "#include <extrusion_normal_fragment_begin>");
        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, "fog_fragment", "extrusion_fragment", true);
    }
    ExtrusionFeature.onBeforeCompile = onBeforeCompile;
})(ExtrusionFeature = exports.ExtrusionFeature || (exports.ExtrusionFeature = {}));
/**
 * Mixin class for extended THREE materials. Adds new properties required for `extrusionRatio`.
 *
 * There is some special handling for the extrusionRatio property, which is animated via
 * [[AnimatedExtrusionHandler]] that is using [[extrusionRatio]] setter and getter to update
 * extrusion in a way that works well with the mixin and EdgeMaterial.
 */
class ExtrusionFeatureMixin {
    constructor() {
        this.m_extrusion = MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
    }
    /**
     * @see [[ExtrusionFeature#extrusion]]
     */
    getExtrusionRatio() {
        return this.m_extrusion;
    }
    /**
     * @see [[ExtrusionFeature#extrusion]]
     */
    setExtrusionRatio(value) {
        const needsUpdate = value !== this.m_extrusion;
        if (needsUpdate) {
            this.m_extrusion = value;
            ExtrusionFeature.updateExtrusionFeature(this);
        }
    }
    /**
     * The mixin class should call this method to register the property [[extrusionRatio]]
     */
    addExtrusionProperties() {
        Object.defineProperty(this, "extrusionRatio", {
            get: () => {
                return this.getExtrusionRatio();
            },
            set: val => {
                this.setExtrusionRatio(val);
            }
        });
    }
    /**
     * Apply the extrusionRatio value from the parameters to the respective properties.
     */
    applyExtrusionParameters(params) {
        // Prepare maps for holding uniforms and defines references from the actual material.
        linkMixinWithMaterial(this, this);
        harp_utils_1.assert(this.shaderDefines !== undefined);
        harp_utils_1.assert(this.shaderUniforms !== undefined);
        if (params && params.zFightingWorkaround === true) {
            this.shaderDefines.ZFIGHTING_WORKAROUND = "";
        }
        // Create uniform with default value, this ensures that it is always created,
        // so no need for checks in setters.
        this.shaderUniforms.extrusionRatio = new THREE.Uniform(MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX);
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.extrusionRatio !== undefined) {
                this.setExtrusionRatio(params.extrusionRatio);
            }
        }
        this.onBeforeCompile = harp_utils_1.chainCallbacks(this.onBeforeCompile, (shader) => {
            ExtrusionFeature.onBeforeCompile(this, shader);
        });
        this.needsUpdate = ExtrusionFeature.isEnabled(this);
    }
    /**
     * Copy extrusionRatio values from other ExtrusionFeature.
     *
     * @param source The material to copy property values from.
     */
    copyExtrusionParameters(source) {
        if (source.extrusionRatio !== undefined) {
            this.setExtrusionRatio(source.extrusionRatio);
        }
        return this;
    }
}
exports.ExtrusionFeatureMixin = ExtrusionFeatureMixin;
/**
 * Subclass of [[THREE.MeshBasicMaterial]]. Adds new properties required for [[fadeNear]] and
 * [[fadeFar]]. In addition to the new properties (which update their respective uniforms), it is
 * also required to update the material in their objects [[onBeforeRender]] and [[OnAfterRender]]
 * calls, where their flag [[transparent]] is set and the internal fadeNear/fadeFar values are
 * updated to world space distances.
 *
 * @see [[Tile#addRenderHelper]]
 */
class MapMeshBasicMaterial extends THREE.MeshBasicMaterial {
    /**
     * Constructs a new `FadingMeshBasicMaterial`.
     *
     * @param params `FadingMeshBasicMaterial` parameters.
     */
    constructor(params) {
        super(params);
        FadingFeature.patchGlobalShaderChunks();
        this.addFadingProperties();
        this.applyFadingParameters(params);
        ExtrusionFeature.patchGlobalShaderChunks();
        this.addExtrusionProperties();
        this.applyExtrusionParameters(Object.assign(Object.assign({}, params), { zFightingWorkaround: true }));
        this.addDisplacementProperties();
        this.applyDisplacementParameters(params);
    }
    clone() {
        return new MapMeshBasicMaterial().copy(this);
    }
    copy(source) {
        super.copy(source);
        this.copyFadingParameters(source);
        this.copyExtrusionParameters(source);
        this.copyDisplacementParameters(source);
        return this;
    }
    // Only here to make the compiler happy, these methods will be overriden: The actual
    // implementations are those in [[FadingFeatureMixin]] and [[ExtrusionFeatureMixin]], see below:
    //
    // applyMixinsWithoutProperties(FadingMeshBasicMaterial, [FadingFeatureMixin]);
    // applyMixinsWithoutProperties(ExtrudionMeshBasicMaterial, [ExtrusionFeatureMixin]);
    //
    // Mixin declarations start ---------------------------------------------------------
    get fadeNear() {
        return FadingFeature.DEFAULT_FADE_NEAR;
    }
    // tslint:disable-next-line:no-unused-variable
    set fadeNear(value) {
        // to be overridden
    }
    get fadeFar() {
        return FadingFeature.DEFAULT_FADE_FAR;
    }
    // tslint:disable-next-line:no-unused-variable
    set fadeFar(value) {
        // to be overridden
    }
    get extrusionRatio() {
        return MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
    }
    // tslint:disable-next-line:no-unused-variable
    set extrusionRatio(value) {
        // to be overridden
    }
    get displacementMap() {
        return null;
    }
    // tslint:disable-next-line:no-unused-variable
    set displacementMap(value) {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    setDisplacementMap(value) {
        // to be overridden
    }
    addFadingProperties() {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    applyFadingParameters(params) {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    copyFadingParameters(source) {
        // to be overridden
    }
    addExtrusionProperties() {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    applyExtrusionParameters(params) {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    copyExtrusionParameters(source) {
        // to be overridden
    }
    addDisplacementProperties() {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    applyDisplacementParameters(params) {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    copyDisplacementParameters(source) {
        // to be overridden
    }
}
exports.MapMeshBasicMaterial = MapMeshBasicMaterial;
/**
 * Subclass of THREE.MeshStandardMaterial. Adds new properties required for `fadeNear` and
 * `fadeFar`. In addition to the new properties (which fill respective uniforms), it is also
 * required to update the material in their objects `onBeforeRender` and `OnAfterRender` calls,
 * where their flag `transparent` is set and the internal fadeNear/fadeFar values are updated to
 * world space distances.
 *
 * @see [[Tile#addRenderHelper]]
 */
class MapMeshStandardMaterial extends THREE.MeshStandardMaterial {
    /**
     * Constructs a new `FadingMeshStandardMaterial`.
     *
     * @param params `FadingMeshStandardMaterial` parameters.
     */
    constructor(params) {
        super(params);
        FadingFeature.patchGlobalShaderChunks();
        this.addFadingProperties();
        this.applyFadingParameters(params);
        ExtrusionFeature.patchGlobalShaderChunks();
        this.addExtrusionProperties();
        this.applyExtrusionParameters(Object.assign(Object.assign({}, params), { zFightingWorkaround: true }));
    }
    clone() {
        return new MapMeshStandardMaterial().copy(this);
    }
    copy(source) {
        super.copy(source);
        this.copyFadingParameters(source);
        this.copyExtrusionParameters(source);
        return this;
    }
    /** @override */
    get displacementMap() {
        return super.displacementMap === undefined ? null : super.displacementMap;
    }
    /** @override */
    set displacementMap(map) {
        if (map === this.displacementMap) {
            return;
        }
        if (!map || !this.displacementMap) {
            this.needsUpdate = true;
        }
        if (map) {
            map.needsUpdate = true;
        }
        super.displacementMap = map;
    }
    // Only here to make the compiler happy, these methods will be overriden: The actual
    // implementations are those in [[FadingFeatureMixin]] and [[ExtrusionFeatureMixin]], see below:
    //
    // applyMixinsWithoutProperties(FadingMeshBasicMaterial, [FadingFeatureMixin]);
    // applyMixinsWithoutProperties(ExtrudionMeshBasicMaterial, [ExtrusionFeatureMixin]);
    //
    // Mixin declarations start ---------------------------------------------------------
    get fadeNear() {
        return FadingFeature.DEFAULT_FADE_NEAR;
    }
    // tslint:disable-next-line:no-unused-variable
    set fadeNear(value) {
        // to be overridden
    }
    get fadeFar() {
        return FadingFeature.DEFAULT_FADE_FAR;
    }
    // tslint:disable-next-line:no-unused-variable
    set fadeFar(value) {
        // to be overridden
    }
    get extrusionRatio() {
        return MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
    }
    // tslint:disable-next-line:no-unused-variable
    set extrusionRatio(value) {
        // to be overridden
    }
    addFadingProperties() {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    applyFadingParameters(params) {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    copyFadingParameters(source) {
        // to be overridden
    }
    addExtrusionProperties() {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    applyExtrusionParameters(params) {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    copyExtrusionParameters(source) {
        // to be overridden
    }
}
exports.MapMeshStandardMaterial = MapMeshStandardMaterial;
/**
 * Finish the classes MapMeshBasicMaterial and MapMeshStandardMaterial by assigning them the actual
 * implementations of the mixed in functions.
 */
harp_utils_1.applyMixinsWithoutProperties(MapMeshBasicMaterial, [FadingFeatureMixin]);
harp_utils_1.applyMixinsWithoutProperties(MapMeshStandardMaterial, [FadingFeatureMixin]);
harp_utils_1.applyMixinsWithoutProperties(MapMeshBasicMaterial, [ExtrusionFeatureMixin]);
harp_utils_1.applyMixinsWithoutProperties(MapMeshStandardMaterial, [ExtrusionFeatureMixin]);
harp_utils_1.applyMixinsWithoutProperties(MapMeshBasicMaterial, [DisplacementFeatureMixin]);


/***/ }),

/***/ "../harp-materials/lib/MapMeshMaterialsDefs.ts":
/*!*****************************************************!*\
  !*** ../harp-materials/lib/MapMeshMaterialsDefs.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
var ExtrusionFeatureDefs;
(function (ExtrusionFeatureDefs) {
    /**
     * Minimum ratio value for extrusion effect
     */
    ExtrusionFeatureDefs.DEFAULT_RATIO_MIN = 0.0;
    /**
     * Maximum ratio value for extrusion effect
     */
    ExtrusionFeatureDefs.DEFAULT_RATIO_MAX = 1;
    /**
     * Buildings height used whenever no height-data is present or height is very small.
     *
     * Used to avoid z-fighting between ground plane and building.
     */
    ExtrusionFeatureDefs.MIN_BUILDING_HEIGHT = 0.01;
})(ExtrusionFeatureDefs = exports.ExtrusionFeatureDefs || (exports.ExtrusionFeatureDefs = {}));


/***/ }),

/***/ "../harp-materials/lib/SepiaShader.ts":
/*!********************************************!*\
  !*** ../harp-materials/lib/SepiaShader.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * `SepiaShader`.
 */
exports.SepiaShader = {
    uniforms: {
        tDiffuse: { value: null },
        amount: { value: 1.0 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }`,
    fragmentShader: `
        uniform float amount;
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main() {
            vec4 color = texture2D( tDiffuse, vUv );
            vec3 c = color.rgb;
            color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );
            color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );
            color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );
            gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );
        }`
};


/***/ }),

/***/ "../harp-materials/lib/ShaderChunks/ExtrusionChunks.ts":
/*!*************************************************************!*\
  !*** ../harp-materials/lib/ShaderChunks/ExtrusionChunks.ts ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const MapMeshMaterialsDefs_1 = __webpack_require__(/*! ../MapMeshMaterialsDefs */ "../harp-materials/lib/MapMeshMaterialsDefs.ts");
const MIN_BUILDING_HEIGHT_SQUARED = MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.MIN_BUILDING_HEIGHT * MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.MIN_BUILDING_HEIGHT;
exports.default = {
    extrusion_pars_vertex: `
// Extrusion axis (xyz: vector, w: factor).
attribute vec4 extrusionAxis;
uniform float extrusionRatio;
varying vec4 vExtrusionAxis;
#ifdef ZFIGHTING_WORKAROUND
varying float vExtrusionRatio;
#endif
`,
    extrusion_vertex: `
#ifdef ZFIGHTING_WORKAROUND
// Cancel extrusionRatio (meaning, force to 1) if extrusionAxisLen < MIN_BUILDING_HEIGHT.
const float MIN_BUILDING_HEIGHT_SQUARED = ${MIN_BUILDING_HEIGHT_SQUARED};
float extrusionAxisLenSquared = dot(extrusionAxis.xyz, extrusionAxis.xyz);
vExtrusionRatio = (extrusionAxisLenSquared < MIN_BUILDING_HEIGHT_SQUARED) ? 1.0 : extrusionRatio;
#else
float vExtrusionRatio = extrusionRatio;
#endif
transformed = transformed + extrusionAxis.xyz * (vExtrusionRatio - 1.0);
vExtrusionAxis = vec4(normalMatrix * extrusionAxis.xyz, extrusionAxis.w);
`,
    // Modified version of THREE <normal_fragment_begin> shader chunk which, for flat shaded
    // geometries, computes the normal either with the extrusion axis or fragment derivatives based
    // on the extrusion factor (1.0 = ceiling, 0.0 = footprint).
    extrusion_normal_fragment_begin: `
#ifdef FLAT_SHADED
    // Flattened this divergent path to prevent undefined behaviour in the following derivatives
    // functions. For more info:
    // http://www.aclockworkberry.com/shader-derivative-functions/#Derivatives_and_branches

    // Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...
    vec3 fdx = vec3(dFdx(vViewPosition.x), dFdx(vViewPosition.y), dFdx(vViewPosition.z));
    vec3 fdy = vec3(dFdy(vViewPosition.x), dFdy(vViewPosition.y), dFdy(vViewPosition.z));
    vec3 normal = cross( fdx, fdy );
    if (vExtrusionAxis.w > 0.999999) {
        normal = vExtrusionAxis.xyz;
    }
    normal = normalize(normal);
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * (float(gl_FrontFacing) * 2.0 - 1.0);
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * (float(gl_FrontFacing) * 2.0 - 1.0);
			bitangent = bitangent * (float(gl_FrontFacing) * 2.0 - 1.0);
		#endif
	#endif
#endif
// non perturbed normal for clearcoat among others
vec3 geometryNormal = normal;
`,
    extrusion_pars_fragment: `
#ifdef ZFIGHTING_WORKAROUND
varying float vExtrusionRatio;
#else
uniform float extrusionRatio;
#endif
varying vec4 vExtrusionAxis;
`,
    extrusion_fragment: `
#ifndef ZFIGHTING_WORKAROUND
float vExtrusionRatio = extrusionRatio;
#endif
gl_FragColor.a *= smoothstep( 0.0, 0.25, vExtrusionRatio );
`
};


/***/ }),

/***/ "../harp-materials/lib/ShaderChunks/FadingChunks.ts":
/*!**********************************************************!*\
  !*** ../harp-materials/lib/ShaderChunks/FadingChunks.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The shader chunks have their lines "#ifdef USE_FADING" commented out, because currently the
 * mesh materials use individually created shader strings based on the materials settings.
 * @see [[FadingMeshBasicMaterial]]
 **/
exports.default = {
    fading_pars_vertex: `
varying float fadingDepth;
`,
    fading_vertex: `
fadingDepth = -mvPosition.z;
`,
    fading_pars_fragment: `
varying float fadingDepth;
uniform float fadeNear;
uniform float fadeFar;
`,
    fading_fragment: `

// lerp with "hard" edges
//float fadingFactor = 1.0 - clamp((fadingDepth - fadeNear) / (fadeFar - fadeNear), 0.0, 1.0);

// smooth transitions
float fadingFactor = smoothstep( fadeNear, fadeFar, fadingDepth );

gl_FragColor.a *= 1.0 - fadingFactor;

// debugging color:
// gl_FragColor = vec4(1., fadingFactor, fadingFactor, 1.0);
`
};


/***/ }),

/***/ "../harp-materials/lib/ShaderChunks/LinesChunks.ts":
/*!*********************************************************!*\
  !*** ../harp-materials/lib/ShaderChunks/LinesChunks.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Lists supported line caps types/modes.
 */
var LineCapsModes;
(function (LineCapsModes) {
    LineCapsModes[LineCapsModes["CAPS_NONE"] = 0] = "CAPS_NONE";
    LineCapsModes[LineCapsModes["CAPS_SQUARE"] = 1] = "CAPS_SQUARE";
    LineCapsModes[LineCapsModes["CAPS_ROUND"] = 2] = "CAPS_ROUND";
    LineCapsModes[LineCapsModes["CAPS_TRIANGLE_IN"] = 3] = "CAPS_TRIANGLE_IN";
    LineCapsModes[LineCapsModes["CAPS_TRIANGLE_OUT"] = 4] = "CAPS_TRIANGLE_OUT";
})(LineCapsModes = exports.LineCapsModes || (exports.LineCapsModes = {}));
exports.default = {
    extrude_line_vert_func: `
vec3 extrudeLine(
        in vec3 vertexPosition,
        in float linePosition,
        in float lineWidth,
        in vec4 bitangent,
        in vec3 tangent,
        inout vec2 uv
    ) {
    vec3 result = vertexPosition;
    // Retrieve the angle between this segment and the previous one (stored in the bitangent w
    // component).
    float angle = bitangent.w;
    // Extrude according to the angle between segments to properly render narrow joints...
    if (angle != 0.0) {
        result += uv.y * lineWidth * bitangent.xyz / cos(angle / 2.0);
        uv.x = linePosition + uv.x * lineWidth * uv.y * tan(angle / 2.0);
    }
    // ... or extrude in a simple manner for segments that keep the same direction.
    else {
        result += uv.y * lineWidth * bitangent.xyz + uv.x * lineWidth * tangent;
        uv.x = linePosition + uv.x * lineWidth;
    }
    uv.y *= lineWidth;
    return result;
}
`,
    round_edges_and_add_caps: `
#define CAPS_NONE ${LineCapsModes.CAPS_NONE}
#define CAPS_SQUARE ${LineCapsModes.CAPS_SQUARE}
#define CAPS_ROUND ${LineCapsModes.CAPS_ROUND}
#define CAPS_TRIANGLE_IN ${LineCapsModes.CAPS_TRIANGLE_IN}
#define CAPS_TRIANGLE_OUT ${LineCapsModes.CAPS_TRIANGLE_OUT}

float roundEdgesAndAddCaps(in vec4 coords, in vec3 range) {
    // Compute the line's width to length ratio.
    float widthRatio = range.y / range.x;

    // Compute the inner segment distance (same for all cap mode).
    float dist = abs(coords.y);
    float segmentBeginMask = clamp(ceil(coords.z - coords.x), 0.0, 1.0);
    float segmentEndMask = clamp(ceil(coords.x - coords.w), 0.0, 1.0);
    dist = max(dist, segmentBeginMask * length(vec2((coords.x - coords.z) / widthRatio, coords.y)));
    dist = max(dist, segmentEndMask * length(vec2((coords.x - coords.w) / widthRatio, coords.y)));

    #if CAPS_MODE != CAPS_ROUND
    // Compute the caps mask.
    float capRangeMask = clamp(1.0 - ceil(range.z - drawRange.y), 0.0, 1.0);
    float beginCapMask = clamp(ceil(drawRange.x - coords.x), 0.0, 1.0);
    float endCapMask = clamp(ceil(coords.x - drawRange.y), 0.0, 1.0);
    float capMask = capRangeMask * max(beginCapMask, endCapMask);

    // Compute the outer segment distance (specific for each cap mode).
    float capDist = max(coords.x - drawRange.y, drawRange.x - coords.x) / widthRatio;
    #if CAPS_MODE == CAPS_NONE
    dist = mix(dist, max(abs(coords.y), (capDist + 0.1) / 0.1), capMask);
    #elif CAPS_MODE == CAPS_SQUARE
    dist = mix(dist, max(abs(coords.y), capDist), capMask);
    #elif CAPS_MODE == CAPS_TRIANGLE_OUT
    dist = mix(dist, abs(coords.y) + capDist, capMask);
    #elif CAPS_MODE == CAPS_TRIANGLE_IN
    dist = mix(dist, max(abs(coords.y), (capDist - abs(coords.y)) + capDist), capMask);
    #endif
    #endif // CAPS_MODE != CAPS_ROUND

    return dist;
}
`,
    tile_clip_func: `
void tileClip(vec2 tilePos, vec2 tileSize) {
    if (tileSize.x > 0.0 && (tilePos.x < -tileSize.x / 2.0 || tilePos.x > tileSize.x / 2.0))
        discard;
    if (tileSize.y > 0.0 && (tilePos.y < -tileSize.y / 2.0 || tilePos.y > tileSize.y / 2.0))
        discard;
}
`,
    high_precision_vert_func: `
vec3 subtractDblEyePos( const in vec3 pos ) {
    vec3 t1 = positionLow - u_eyepos_lowpart;
    vec3 e = t1 - positionLow;
    vec3 t2 = ((-u_eyepos_lowpart - e) + (positionLow - (t1 - e))) + pos - u_eyepos;
    vec3 high_delta = t1 + t2;
    vec3 low_delta = t2 - (high_delta - t1);
    return (high_delta + low_delta);
}
`
};


/***/ }),

/***/ "../harp-materials/lib/SolidLineMaterial.ts":
/*!**************************************************!*\
  !*** ../harp-materials/lib/SolidLineMaterial.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const MapMeshMaterials_1 = __webpack_require__(/*! ./MapMeshMaterials */ "../harp-materials/lib/MapMeshMaterials.ts");
const LinesChunks_1 = __webpack_require__(/*! ./ShaderChunks/LinesChunks */ "../harp-materials/lib/ShaderChunks/LinesChunks.ts");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-materials/lib/Utils.ts");
const LineCapsDefinesMapping = {
    None: LinesChunks_1.LineCapsModes.CAPS_NONE,
    Square: LinesChunks_1.LineCapsModes.CAPS_SQUARE,
    Round: LinesChunks_1.LineCapsModes.CAPS_ROUND,
    TriangleIn: LinesChunks_1.LineCapsModes.CAPS_TRIANGLE_IN,
    TriangleOut: LinesChunks_1.LineCapsModes.CAPS_TRIANGLE_OUT
};
const DefinesLineCapsMapping = Object.keys(LineCapsDefinesMapping).reduce((r, lineCapsName) => {
    const defineKey = lineCapsName;
    const defineValue = LineCapsDefinesMapping[defineKey];
    r[defineValue] = defineKey;
    return r;
}, {});
var LineDashesModes;
(function (LineDashesModes) {
    LineDashesModes[LineDashesModes["DASHES_SQUARE"] = 0] = "DASHES_SQUARE";
    LineDashesModes[LineDashesModes["DASHES_ROUND"] = 1] = "DASHES_ROUND";
    LineDashesModes[LineDashesModes["DASHES_DIAMOND"] = 2] = "DASHES_DIAMOND";
})(LineDashesModes = exports.LineDashesModes || (exports.LineDashesModes = {}));
const LineDashesDefinesMapping = {
    Square: LineDashesModes.DASHES_SQUARE,
    Round: LineDashesModes.DASHES_ROUND,
    Diamond: LineDashesModes.DASHES_DIAMOND
};
const DefinesLineDashesMapping = Object.keys(LineDashesDefinesMapping).reduce((r, lineDashesName) => {
    const defineKey = lineDashesName;
    const defineValue = LineDashesDefinesMapping[defineKey];
    r[defineValue] = defineKey;
    return r;
}, {});
/**
 * The vLength contains the actual line length, it's needed for the creation of line caps by
 * detecting line ends. `vLength == vExtrusionCoord.x + lineWidth * 2`
 */
/**
 * The vExtrusionStrength relies on the edges of the lines. Represents how far the current point was
 * extruded on the edges because of the current angle. Needed for preventing line caps artifacts on
 * sharp line edges. For example, on sharp edges, some vertices can be extruded much further than
 * the full line length.
 */
const tmpColor = new THREE.Color();
const vertexSource = `
#define SEGMENT_OFFSET 0.1

attribute vec3 extrusionCoord;
attribute vec3 position;
attribute vec4 bitangent;
attribute vec3 tangent;
attribute vec2 uv;
attribute vec3 normal;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform float lineWidth;
uniform float outlineWidth;
uniform vec2 drawRange;

#ifdef USE_DISPLACEMENTMAP
uniform sampler2D displacementMap;
#endif

varying vec3 vPosition;
varying vec3 vRange;
varying vec4 vCoords;
#ifdef USE_COLOR
attribute vec3 color;
varying vec3 vColor;
#endif

#ifdef USE_FADING
#include <fading_pars_vertex>
#endif

#include <fog_pars_vertex>

#include <extrude_line_vert_func>

void main() {
    // Calculate the segment.
    vec2 segment = abs(extrusionCoord.xy) - SEGMENT_OFFSET;
    float segmentPos = sign(extrusionCoord.x) / 2.0 + 0.5;

    // Calculate the vertex position inside the line (segment) and extrusion direction and factor.
    float linePos = mix(segment.x, segment.y, segmentPos);
    vec2 extrusionDir = sign(extrusionCoord.xy);
    float extrusionFactor = extrusionDir.y * tan(bitangent.w / 2.0);

    // Calculate the extruded vertex position (and scale the extrusion direction).
    vec3 pos = extrudeLine(
        position, linePos, lineWidth + outlineWidth, bitangent, tangent, extrusionDir);

    // Store the normalized extrusion coordinates in vCoords (with their ranges in vRange).
    vRange = vec3(extrusionCoord.z, lineWidth, extrusionFactor);
    vCoords = vec4(extrusionDir / vRange.xy, segment / vRange.x);

    // Adjust the segment to fit the drawRange.
    float capDist = (lineWidth + outlineWidth) / extrusionCoord.z;
    if ((vCoords.w + capDist) < drawRange.x || (vCoords.z - capDist) > drawRange.y) {
        vCoords.zw += 1.0;
    }
    if (vCoords.z < drawRange.x) {
        vCoords.zw += vec2(drawRange.x - vCoords.z, 0.0);
    }
    if (vCoords.w > drawRange.y) {
        vCoords.zw -= vec2(0.0, vCoords.w - drawRange.y);
    }

    // Transform position.
    #ifdef USE_DISPLACEMENTMAP
    pos += normalize( normal ) * texture2D( displacementMap, uv ).x;
    #endif
    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
    gl_Position = projectionMatrix * mvPosition;

    // Pass extruded position to fragment shader.
    vPosition = pos;

    #ifdef USE_COLOR
    // Pass vertex color to fragment shader.
    vColor = color;
    #endif

    #ifdef USE_FADING
    #include <fading_vertex>
    #endif

    #include <fog_vertex>
}`;
const fragmentSource = `
precision highp float;
precision highp int;

uniform vec3 diffuse;
uniform vec3 outlineColor;
uniform float opacity;
uniform float lineWidth;
uniform float outlineWidth;
uniform vec2 tileSize;
uniform vec2 drawRange;

#ifdef USE_DASHED_LINE
uniform float dashSize;
uniform float gapSize;
uniform vec3 dashColor;

#define DASHES_SQUARE ${LineDashesModes.DASHES_SQUARE}
#define DASHES_ROUND ${LineDashesModes.DASHES_ROUND}
#define DASHES_DIAMOND ${LineDashesModes.DASHES_DIAMOND}
#endif

varying vec3 vPosition;
varying vec3 vRange;
varying vec4 vCoords;
#ifdef USE_COLOR
varying vec3 vColor;
#endif

#include <round_edges_and_add_caps>
#include <tile_clip_func>

#ifdef USE_FADING
#include <fading_pars_fragment>
#endif

#include <fog_pars_fragment>

void main() {
    float alpha = opacity;
    vec3 outputDiffuse = diffuse;

    #ifdef USE_TILE_CLIP
    tileClip(vPosition.xy, tileSize);
    #endif

    // Calculate distance to center (0.0: lineCenter, 1.0: lineEdge).
    float distToCenter = roundEdgesAndAddCaps(vCoords, vRange);
    // Calculate distance to edge (-1.0: lineCenter, 0.0: lineEdge).
    float distToEdge = distToCenter - (lineWidth + outlineWidth) / lineWidth;

    // Decrease the line opacity by the distToEdge, making the transition steeper when the slope
    // of distToChange increases (i.e. the line is further away).
    float width = fwidth(distToEdge);
    alpha *= (1.0 - smoothstep(-width, width, distToEdge));

    #ifdef USE_DASHED_LINE
    // Compute the distance to the dash origin (0.0: dashOrigin, 1.0: dashEnd, (d+g)/d: gapEnd).
    float d = dashSize / vRange.x;
    float g = gapSize / vRange.x;
    float distToDashOrigin = mod(vCoords.x, d + g) / d;

    // Compute distance to dash edge (0.5: dashCenter, 0.0: dashEdge) and compute the
    // dashBlendFactor similarly on how we did it for the line opacity.
    float distToDashEdge = 0.5 - distance(distToDashOrigin, (d + g) / d * 0.5);
    #if DASHES_MODE == DASHES_ROUND
    distToDashEdge = 0.5 - distance(vec2(distToCenter * 0.5, distToDashEdge), vec2(0.0, 0.5));
    #elif DASHES_MODE == DASHES_DIAMOND
    distToDashEdge -= distToCenter * 0.5;
    #endif
    float dashWidth = fwidth(distToDashEdge);
    float dashBlendFactor = 1.0 - smoothstep(-dashWidth, dashWidth, distToDashEdge);

    #ifdef USE_DASH_COLOR
    outputDiffuse = mix(diffuse, dashColor, dashBlendFactor);
    #endif
    #endif

    #ifdef USE_OUTLINE
    // Calculate distance to outline (0.0: lineEdge, outlineWidth/lineWidth: outlineEdge) and
    // compute the outlineBlendFactor (used to mix line and outline colors).
    float distToOutline = distToCenter - 1.0;
    float outlineWidth = fwidth(distToOutline);
    float outlineBlendFactor = smoothstep(-outlineWidth, outlineWidth, distToOutline);

    // Mix the colors using the different computed factors.
    #if defined(USE_DASHED_LINE) && !defined(USE_DASH_COLOR)
    float colorBlendFactor = smoothstep(-1.0, 1.0, dashBlendFactor - outlineBlendFactor);
    outputDiffuse = mix(
      mix(
        mix(outlineColor, diffuse, colorBlendFactor),
        outputDiffuse,
        dashBlendFactor
      ),
      outlineColor,
      outlineBlendFactor
    );
    #else
    outputDiffuse = mix(outputDiffuse, outlineColor, outlineBlendFactor);
    #endif
    #endif

    #if defined(USE_DASHED_LINE) && !defined(USE_DASH_COLOR)
    // Multiply the alpha by the dashBlendFactor.
    #if defined(USE_OUTLINE)
    alpha *= clamp(dashBlendFactor + outlineBlendFactor, 0.0, 1.0);
    #else
    alpha *= 1.0 - dashBlendFactor;
    #endif
    #endif

    #ifdef USE_COLOR
    gl_FragColor = vec4( outputDiffuse * vColor, alpha );
    #else
    gl_FragColor = vec4( outputDiffuse, alpha );
    #endif

    #include <fog_fragment>

    #ifdef USE_FADING
    #include <fading_fragment>
    #endif
}`;
/**
 * Material designed to render solid variable-width lines.
 */
class SolidLineMaterial extends THREE.RawShaderMaterial {
    /**
     * Constructs a new `SolidLineMaterial`.
     *
     * @param params `SolidLineMaterial` parameters.
     */
    constructor(params) {
        Object.assign(THREE.ShaderChunk, LinesChunks_1.default);
        MapMeshMaterials_1.FadingFeature.patchGlobalShaderChunks();
        // Setup default defines.
        const defines = {
            CAPS_MODE: LinesChunks_1.LineCapsModes.CAPS_ROUND,
            DASHES_MODE: LineDashesModes.DASHES_SQUARE
        };
        // Prepare defines based on params passed in, before super class c-tor, this ensures
        // proper set for shader compilation, without need to re-compile.
        let fogParam = true;
        let opacityParam = 1.0;
        let displacementMap;
        if (params !== undefined) {
            fogParam = params.fog === true;
            if (fogParam) {
                Utils_1.setShaderDefine(defines, "USE_FOG", true);
            }
            opacityParam = params.opacity !== undefined ? params.opacity : opacityParam;
            displacementMap = params.displacementMap;
            if (displacementMap !== undefined) {
                Utils_1.setShaderDefine(defines, "USE_DISPLACEMENTMAP", true);
            }
            const hasOutline = params.outlineWidth !== undefined && params.outlineWidth > 0;
            if (hasOutline) {
                Utils_1.setShaderDefine(defines, "USE_OUTLINE", true);
            }
        }
        const shaderParams = {
            name: "SolidLineMaterial",
            vertexShader: vertexSource,
            fragmentShader: fragmentSource,
            uniforms: THREE.UniformsUtils.merge([
                {
                    diffuse: new THREE.Uniform(new THREE.Color(SolidLineMaterial.DEFAULT_COLOR)),
                    dashColor: new THREE.Uniform(new THREE.Color(SolidLineMaterial.DEFAULT_COLOR)),
                    outlineColor: new THREE.Uniform(new THREE.Color(SolidLineMaterial.DEFAULT_COLOR)),
                    lineWidth: new THREE.Uniform(SolidLineMaterial.DEFAULT_WIDTH),
                    outlineWidth: new THREE.Uniform(SolidLineMaterial.DEFAULT_OUTLINE_WIDTH),
                    opacity: new THREE.Uniform(SolidLineMaterial.DEFAULT_OPACITY),
                    tileSize: new THREE.Uniform(new THREE.Vector2()),
                    fadeNear: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_NEAR),
                    fadeFar: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_FAR),
                    displacementMap: new THREE.Uniform(displacementMap !== undefined ? displacementMap : new THREE.Texture()),
                    drawRange: new THREE.Uniform(new THREE.Vector2(SolidLineMaterial.DEFAULT_DRAW_RANGE_START, SolidLineMaterial.DEFAULT_DRAW_RANGE_END)),
                    dashSize: new THREE.Uniform(SolidLineMaterial.DEFAULT_DASH_SIZE),
                    gapSize: new THREE.Uniform(SolidLineMaterial.DEFAULT_GAP_SIZE)
                },
                // We need the fog uniforms available when we use `fog` setter as the internal
                // recompilation cannot add or remove uniforms.
                THREE.UniformsLib.fog
            ]),
            defines,
            // No need to pass overridden `fog` and `opacity` params they will be set
            // after super c-tor call.
            fog: fogParam,
            opacity: opacityParam
        };
        super(shaderParams);
        // Required to satisfy compiler error if fields has no initializer or are not definitely
        // assigned in the constructor, this also mimics ShaderMaterial set of defaults
        // for overridden props.
        this.m_fog = fogParam;
        this.m_opacity = opacityParam;
        Utils_1.enforceBlending(this);
        this.extensions.derivatives = true;
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.color !== undefined) {
                tmpColor.set(params.color);
                this.color = tmpColor;
            }
            if (params.outlineColor !== undefined) {
                tmpColor.set(params.outlineColor);
                this.outlineColor = tmpColor;
            }
            if (params.lineWidth !== undefined) {
                this.lineWidth = params.lineWidth;
            }
            if (params.outlineWidth !== undefined) {
                this.outlineWidth = params.outlineWidth;
            }
            if (params.opacity !== undefined) {
                this.opacity = params.opacity;
            }
            if (params.depthTest !== undefined) {
                this.depthTest = params.depthTest;
            }
            if (params.depthWrite !== undefined) {
                this.depthWrite = params.depthWrite;
            }
            if (params.fadeNear !== undefined) {
                this.fadeNear = params.fadeNear;
            }
            if (params.fadeFar !== undefined) {
                this.fadeFar = params.fadeFar;
            }
            if (params.displacementMap !== undefined) {
                this.displacementMap = params.displacementMap;
            }
            if (params.caps !== undefined) {
                this.caps = params.caps;
            }
            if (params.drawRangeStart !== undefined) {
                this.drawRangeStart = params.drawRangeStart;
            }
            if (params.drawRangeEnd !== undefined) {
                this.drawRangeEnd = params.drawRangeEnd;
            }
            if (params.dashes !== undefined) {
                this.dashes = params.dashes;
            }
            if (params.dashColor !== undefined) {
                tmpColor.set(params.dashColor);
                this.dashColor = tmpColor;
            }
            if (params.dashSize !== undefined) {
                this.dashSize = params.dashSize;
            }
            if (params.gapSize !== undefined) {
                this.gapSize = params.gapSize;
            }
            if (params.fog !== undefined) {
                this.fog = params.fog;
            }
        }
        // ShaderMaterial overrides requires invalidation cause super c-tor may set this
        // properties before related `defines` and `uniforms` were created.
        this.invalidateFog();
        this.invalidateOpacity();
    }
    /**
     * Overrides THREE.Material.fog flag to add support for custom shader.
     *
     * @param enable Whether we want to enable the fog.
     */
    set fog(enable) {
        this.m_fog = enable;
        // Function may be called from THREE.js cause we override setter,
        // in this case defines are not yet initialized and require late invalidation in
        // SolidLineMaterial c-tor.
        if (this.defines !== undefined) {
            Utils_1.setShaderMaterialDefine(this, "USE_FOG", enable);
        }
    }
    /**
     * Checks if fog is enabled.
     */
    get fog() {
        return this.m_fog && Utils_1.getShaderMaterialDefine(this, "USE_FOG") === true;
    }
    /**
     * The method to call to recompile a material to enable/disable outline effect
     *
     * @param enable Whether we want to use outline.
     */
    set outline(enable) {
        Utils_1.setShaderMaterialDefine(this, "USE_OUTLINE", enable);
    }
    /**
     * Checks if outline is enabled.
     */
    get outline() {
        return Utils_1.getShaderMaterialDefine(this, "USE_OUTLINE") === true;
    }
    /**
     * Line opacity.
     */
    get opacity() {
        return this.m_opacity;
    }
    set opacity(value) {
        this.m_opacity = value;
        // Setting opacity before uniform being created requires late invalidation,
        // call to invalidateOpacity() is done at the end of c-tor.
        if (this.uniforms !== undefined) {
            this.uniforms.opacity.value = value;
        }
    }
    /**
     * Line color.
     */
    get color() {
        return this.uniforms.diffuse.value;
    }
    set color(value) {
        this.uniforms.diffuse.value.copy(value);
    }
    /**
     * Outline color.
     *
     * @note The width of outline ([[outlineWidth]]) need to be also set to enable outlining.
     */
    get outlineColor() {
        return this.uniforms.outlineColor.value;
    }
    set outlineColor(value) {
        this.uniforms.outlineColor.value.copy(value);
    }
    /**
     * Dash color.
     *
     * @note The property [[gapSize]] need to be set to enable dashed line.
     */
    get dashColor() {
        return this.uniforms.dashColor.value;
    }
    set dashColor(value) {
        this.uniforms.dashColor.value.copy(value);
        Utils_1.setShaderMaterialDefine(this, "USE_DASH_COLOR", true);
    }
    /**
     * Line width.
     */
    get lineWidth() {
        return this.uniforms.lineWidth.value;
    }
    set lineWidth(value) {
        this.uniforms.lineWidth.value = value;
    }
    /**
     * Outline width.
     */
    get outlineWidth() {
        return this.uniforms.outlineWidth.value;
    }
    set outlineWidth(value) {
        this.uniforms.outlineWidth.value = value;
        this.outline = value > 0.0;
    }
    /**
     * Size of the dashed segments.
     *
     * @note Ths [[gapSize]] need to be also set to enable dashed line.
     * @see gapSize.
     */
    get dashSize() {
        return this.uniforms.dashSize.value;
    }
    set dashSize(value) {
        this.uniforms.dashSize.value = value;
    }
    /**
     * Size of the gaps between dashed segments.
     *
     * @note You may also need to set [[dashSize]].
     * @see dashSize.
     */
    get gapSize() {
        return this.uniforms.gapSize.value;
    }
    set gapSize(value) {
        this.uniforms.gapSize.value = value;
        Utils_1.setShaderMaterialDefine(this, "USE_DASHED_LINE", value > 0.0);
    }
    /**
     * Caps mode.
     */
    get caps() {
        let result = "Round";
        const capsMode = Utils_1.getShaderMaterialDefine(this, "CAPS_MODE");
        // Sanity check if material define is numerical and has direct mapping to LineCaps type.
        if (typeof capsMode === "number" && DefinesLineCapsMapping.hasOwnProperty(capsMode)) {
            result = DefinesLineCapsMapping[capsMode];
        }
        return result;
    }
    set caps(value) {
        // Line caps mode may be set directly from theme, thus we need to check value
        // for correctness and provide string to define mapping in fragment shader.
        if (LineCapsDefinesMapping.hasOwnProperty(value)) {
            Utils_1.setShaderMaterialDefine(this, "CAPS_MODE", LineCapsDefinesMapping[value]);
        }
    }
    /**
     * Dashes mode.
     */
    get dashes() {
        let result = "Square";
        const dashesMode = Utils_1.getShaderMaterialDefine(this, "DASHES_MODE");
        // Sanity check if material define is numerical and has direct mapping to LineDashes type.
        if (typeof dashesMode === "number" && DefinesLineDashesMapping.hasOwnProperty(dashesMode)) {
            result = DefinesLineDashesMapping[dashesMode];
        }
        return result;
    }
    set dashes(value) {
        // Line dashes mode may be set directly from theme, thus we need to check value
        // for correctness and provide string to define mapping in fragment shader.
        if (LineDashesDefinesMapping.hasOwnProperty(value)) {
            Utils_1.setShaderMaterialDefine(this, "DASHES_MODE", LineDashesDefinesMapping[value]);
        }
    }
    get fadeNear() {
        return this.uniforms.fadeNear.value;
    }
    set fadeNear(value) {
        this.uniforms.fadeNear.value = value;
    }
    get fadeFar() {
        return this.uniforms.fadeFar.value;
    }
    set fadeFar(value) {
        this.uniforms.fadeFar.value = value;
        Utils_1.setShaderMaterialDefine(this, "USE_FADING", value > 0.0);
    }
    get displacementMap() {
        return this.uniforms.displacementMap.value;
    }
    set displacementMap(map) {
        if (this.uniforms.displacementMap.value === map) {
            return;
        }
        this.uniforms.displacementMap.value = map;
        const useDisplacementMap = map !== null;
        if (useDisplacementMap) {
            this.uniforms.displacementMap.value.needsUpdate = true;
        }
        Utils_1.setShaderMaterialDefine(this, "USE_DISPLACEMENTMAP", useDisplacementMap);
    }
    get drawRangeStart() {
        return this.uniforms.drawRange.value.x;
    }
    set drawRangeStart(value) {
        this.uniforms.drawRange.value.x = value;
    }
    get drawRangeEnd() {
        return this.uniforms.drawRange.value.y;
    }
    set drawRangeEnd(value) {
        this.uniforms.drawRange.value.y = value;
    }
    set clipTileSize(tileSize) {
        this.uniforms.tileSize.value.copy(tileSize);
        const useTileClip = tileSize.x > 0 && tileSize.y > 0;
        Utils_1.setShaderMaterialDefine(this, "USE_TILE_CLIP", useTileClip);
    }
    get clipTileSize() {
        return this.uniforms.tileSize.value;
    }
    invalidateFog() {
        if (this.m_fog !== Utils_1.getShaderMaterialDefine(this, "USE_FOG")) {
            Utils_1.setShaderMaterialDefine(this, "USE_FOG", this.m_fog);
        }
    }
    invalidateOpacity() {
        if (this.m_opacity !== this.uniforms.opacity.value) {
            this.uniforms.opacity.value = this.m_opacity;
        }
    }
}
exports.SolidLineMaterial = SolidLineMaterial;
SolidLineMaterial.DEFAULT_COLOR = 0xff0000;
SolidLineMaterial.DEFAULT_WIDTH = 1.0;
SolidLineMaterial.DEFAULT_OUTLINE_WIDTH = 0.0;
SolidLineMaterial.DEFAULT_OPACITY = 1.0;
SolidLineMaterial.DEFAULT_DRAW_RANGE_START = 0.0;
SolidLineMaterial.DEFAULT_DRAW_RANGE_END = 1.0;
SolidLineMaterial.DEFAULT_DASH_SIZE = 1.0;
SolidLineMaterial.DEFAULT_GAP_SIZE = 1.0;


/***/ }),

/***/ "../harp-materials/lib/Utils.ts":
/*!**************************************!*\
  !*** ../harp-materials/lib/Utils.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Values for boolean shader defines
 */
exports.DEFINE_BOOL_TRUE = "";
exports.DEFINE_BOOL_FALSE = undefined;
/**
 * Insert shader includes after another shader include.
 *
 * @param shaderContent Original string.
 * @param shaderName String to append to.
 * @param insertedShaderName String to append after string `shaderA`.
 * @param addTab If `true`, a tab character will be inserted before `shaderB`.
 */
function insertShaderInclude(shaderContent, shaderName, insertedShaderName, addTab) {
    const tabChar = addTab === true ? "\t" : "";
    const result = shaderContent.replace(`#include <${shaderName}>`, `#include <${shaderName}>
${tabChar}#include <${insertedShaderName}>`);
    return result;
}
exports.insertShaderInclude = insertShaderInclude;
/**
 * THREE.js is enabling blending only when transparent is `true` or when a blend mode
 * different than `NormalBlending` is set.
 * Since we don't want to set transparent to true and mess up the render order we set
 * `CustomBlending` with the same parameters as the `NormalBlending`.

 * @param material `Material` that should use blending
 * @note This function should not be used in frame update after material has been passed to WebGL.
 * In such cases use [[enableBlending]] instead.
 */
function enforceBlending(material) {
    if (material.transparent) {
        // Nothing to do
        return;
    }
    enableBlending(material);
    material.forcedBlending = true;
}
exports.enforceBlending = enforceBlending;
/**
 * Enable alpha blending using THREE.CustomBlending setup.
 *
 * Function enables blending using one of predefined modes, for both color and alpha components:
 * - Src: [[THREE.SrcAlphaFactor]], Dst: [[THREE.OneMinusSrcAlphaFactor]]
 * - Src: [[THREE.OneFactor]], Dst: [[THREE.OneMinusSrcAlphaFactor]]
 * The second blending equation is used when [[THREE.Material.premultipliedAlpha]] is enabled
 * for this material.
 * @note Blending mode change does not require material update.
 * @see THREE.Material.needsUpdate.
 * @param material The material or material parameters to modify.
 */
function enableBlending(material) {
    if (material.transparent || material.forcedBlending) {
        // Nothing to do
        return;
    }
    material.blending = THREE.CustomBlending;
    if (material.premultipliedAlpha === true) {
        material.blendSrc = THREE.OneFactor;
        material.blendDst = THREE.OneMinusSrcAlphaFactor;
        material.blendSrcAlpha = THREE.OneFactor;
        material.blendDstAlpha = THREE.OneMinusSrcAlphaFactor;
    }
    else {
        material.blendSrc = THREE.SrcAlphaFactor;
        material.blendDst = THREE.OneMinusSrcAlphaFactor;
        material.blendSrcAlpha = THREE.OneFactor;
        material.blendDstAlpha = THREE.OneMinusSrcAlphaFactor;
    }
}
exports.enableBlending = enableBlending;
/**
 * Disable alpha blending using THREE.CustomBlending mode, switches to [[THREE.NormalBlending]].
 *
 * @note Blending mode change does not require material update.
 * @see THREE.Material.needsUpdate.
 * @see enableBlending.
 * @param material The material or material parameters to modify.
 */
function disableBlending(material) {
    if (material.transparent || material.forcedBlending) {
        // Nothing to do
        return;
    }
    material.blending = THREE.NormalBlending;
}
exports.disableBlending = disableBlending;
/**
 * Setup material shader _define_ using two allowable semantics.
 *
 * Function accepts two types of values for shader preprocessor _define_:
 * - [[boolean]], simple [[true]] or [[false]] which causes _define_ to be set with empty string,
 * such defines may be handled in the shader using __#ifdef__ semantics:
 * ```
 * #ifdef SOME_DEFINE && !defined(OTHER_DEFINE)
 * // do something
 * #endif
 * ```
 *
 * - [[number]] which sets _define_ to explicit value. You may use it to enable/disable some
 * code or even set compile time constants affecting shaders math:
 * ```
 * #if SOME_DEFINE_SWITCH && OTHER_DEFINE_SWITCH == 0
 * gl_FragColor = vec4(1, 1, 1, DEFINE_ALPHA)
 * #endif
 * ```
 * @note Setting _define_ with `false` value is not the same as setting is with number value of `0`.
 *
 * @param material The [[THREE.ShaderMaterial]] which shader _define_ will be set.
 * @param key Name of shader _define_ as used in shader, i.e. `USE_FOG`, `COLOR_ALPHA`, etc.
 * @param value The value to be set as number or boolean specifying if preprocessor define
 * should be defined or not.
 * @returns [[true]] if material has been forced to update (re-compile) due to define changes,
 * return [[false]] whenever define has not been changed.
 */
function setShaderMaterialDefine(material, key, value) {
    harp_utils_1.assert(material.defines !== undefined, "Do not use this function in ShaderMaterial derived c-tor.");
    const semanticValue = getShaderMaterialDefine(material, key);
    const needsUpdate = value !== semanticValue;
    // Nothing to change - early exit
    if (!needsUpdate) {
        return false;
    }
    setShaderDefine(material.defines, key, value);
    material.needsUpdate = needsUpdate;
    return true;
}
exports.setShaderMaterialDefine = setShaderMaterialDefine;
/**
 * Acquire value of [[THREE.ShaderMaterial]] GPU shader preprocessor define.
 *
 * The semantic used in entire engine assumes that preprocessor defines may have only binary
 * (defined / not defined) or numerical values, this ensures consistency in the shaders and
 * materials code.
 * @note If _define_ with [[key]] is _undefined_ function returns [[false]], if defined but
 * not numerical value it returns [[true]], otherwise returns number.
 * @see setShaderMaterialDefine.
 *
 * @param material The material which shader defines are accessed.
 * @param key The _define_ name (identifier).
 * @param fallbackValue The value returned when material `defines` are not initialized yet,
 * specified by default as [[false]], provide your own default if you expect numeric value.
 */
function getShaderMaterialDefine(material, key, fallbackValue = false) {
    if (material.defines === undefined) {
        return fallbackValue;
    }
    return getShaderDefine(material.defines, key);
}
exports.getShaderMaterialDefine = getShaderMaterialDefine;
/**
 * Sets new value of 'define' regardless of current value set.
 *
 * Update `defines` map with new key and value, if key is already occupied it overrides its value.
 * Helper function that may be used to setup [[THREE.ShaderMaterialParameters]] before
 * material is create (i.e. in c-tor).
 *
 * @param defines Shader `defines` stored in key-value map.
 * @param key The key used to identify _define_.
 * @param value The value to be stored.
 * @returns [[true]] if define has actually changed, false is stayed the same.
 * @see setShaderMaterialDefine.
 */
function setShaderDefine(defines, key, value) {
    let updated = false;
    if (typeof value === "number") {
        updated = defines[key] !== value;
        defines[key] = value;
    }
    else if (value === true) {
        updated = defines[key] !== exports.DEFINE_BOOL_TRUE;
        defines[key] = exports.DEFINE_BOOL_TRUE;
    }
    else if (value === false && defines[key] !== undefined) {
        // Sets to DEFINE_BOOL_FALSE === undefined
        delete defines[key];
        updated = true;
    }
    return updated;
}
exports.setShaderDefine = setShaderDefine;
/**
 * Acquire shader 'define' value from `defines` map.
 *
 * If there is no value under [[key]] specified, function returns false, otherwise result is
 * true or numeric value if there is a number stored.
 * @param defines The `defines` map.
 * @param key The identifier of the _define_.
 */
function getShaderDefine(defines, key) {
    const currentValue = defines[key];
    const semanticValue = currentValue === exports.DEFINE_BOOL_FALSE
        ? false
        : currentValue === exports.DEFINE_BOOL_TRUE
            ? true
            : currentValue;
    return semanticValue;
}
exports.getShaderDefine = getShaderDefine;


/***/ }),

/***/ "../harp-materials/lib/VignetteShader.ts":
/*!***********************************************!*\
  !*** ../harp-materials/lib/VignetteShader.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * `VignetteShader`.
 */
exports.VignetteShader = {
    uniforms: {
        tDiffuse: { value: null },
        offset: { value: 1.0 },
        darkness: { value: 1.0 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }`,
    fragmentShader: `
        uniform float offset;
        uniform float darkness;
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D( tDiffuse, vUv );
            vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );
            gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );
        }`
};


/***/ }),

/***/ "../harp-omv-datasource/index.ts":
/*!***************************************!*\
  !*** ../harp-omv-datasource/index.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/OmvDataFilter */ "../harp-omv-datasource/lib/OmvDataFilter.ts"));
__export(__webpack_require__(/*! ./lib/OmvDataSource */ "../harp-omv-datasource/lib/OmvDataSource.ts"));
__export(__webpack_require__(/*! ./lib/OmvDecoderDefs */ "../harp-omv-datasource/lib/OmvDecoderDefs.ts"));
__export(__webpack_require__(/*! ./lib/OmvTile */ "../harp-omv-datasource/lib/OmvTile.ts"));
__export(__webpack_require__(/*! ./lib/OmvDebugLabelsTile */ "../harp-omv-datasource/lib/OmvDebugLabelsTile.ts"));
__export(__webpack_require__(/*! ./lib/OmvRestClient */ "../harp-omv-datasource/lib/OmvRestClient.ts"));


/***/ }),

/***/ "../harp-omv-datasource/lib/OmvDataFilter.ts":
/*!***************************************************!*\
  !*** ../harp-omv-datasource/lib/OmvDataFilter.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const OmvDecoderDefs_1 = __webpack_require__(/*! ./OmvDecoderDefs */ "../harp-omv-datasource/lib/OmvDecoderDefs.ts");
/**
 * Builds an `OmvFilterDescription` (internal type) that specifies an [[OmvFeatureFilter]] as well
 * as an [[OmvFeatureModifier]].
 *
 */
class OmvFeatureFilterDescriptionBuilder {
    /**
     * Builds an `OmvFilterDescription` (internal type) that specifies an [[OmvFeatureFilter]] as
     * well as an [[OmvFeatureModifier]].
     *
     * @param processLayersDefault If `true`, all unspecified layers will be processed. If `false`,
     * all unspecified layers will be ignored.
     * @param processPointsDefault If `true`, all unspecified point features will be processed. If
     * `false`, all unspecified point features will be ignored.
     * @param processLinesDefault If `true`, all unspecified line features will be processed. If
     * `false`, all unspecified line features will be ignored.
     * @param processPolygonsDefault If `true`, all unspecified polygon features will be processed.
     * If `false`, all unspecified polygon features will be ignored.
     */
    constructor(options) {
        this.m_processLayersDefault = true;
        this.m_processPointsDefault = true;
        this.m_processLinesDefault = true;
        this.m_processPolygonsDefault = true;
        this.m_layersToProcess = new Array();
        this.m_layersToIgnore = new Array();
        this.m_pointsToProcess = new Array();
        this.m_ignoredPoints = new Array();
        this.m_linesToProcess = new Array();
        this.m_linesToIgnore = new Array();
        this.m_polygonsToProcess = new Array();
        this.m_polygonsToIgnore = new Array();
        this.m_kindsToProcess = [];
        this.m_kindsToIgnore = [];
        if (options) {
            this.m_processLayersDefault =
                options.processLayersDefault !== undefined ? options.processLayersDefault : true;
            this.m_processPointsDefault =
                options.processPointsDefault !== undefined ? options.processPointsDefault : true;
            this.m_processLinesDefault =
                options.processLinesDefault !== undefined ? options.processLinesDefault : true;
            this.m_processPolygonsDefault =
                options.processPolygonsDefault !== undefined
                    ? options.processPolygonsDefault
                    : true;
        }
    }
    /**
     * Add a layer that should be processed.
     *
     * @param layer Layer name to be matched.
     * @param match Match condition.
     */
    processLayer(layer, match = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match, minLevel = 0, maxLevel = Infinity) {
        this.m_layersToProcess.push({
            name: { value: layer, match },
            minLevel,
            maxLevel
        });
    }
    /**
     * Add a layer that should be ignored.
     *
     * @param layer Layer name to be matched.
     * @param match Match condition.
     */
    ignoreLayer(layer, match = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match, minLevel = 0, maxLevel = Infinity) {
        this.m_layersToIgnore.push({
            name: { value: layer, match },
            minLevel,
            maxLevel
        });
    }
    /**
     * Add a valid point feature.
     *
     * @param options Feature options.
     */
    processPoint(options) {
        this.addItem(this.m_pointsToProcess, options);
    }
    /**
     * Add valid point features.
     *
     * @param options Multi feature options.
     */
    processPoints(options) {
        this.addItems(this.m_pointsToProcess, options);
    }
    /**
     * Add a point feature that should be ignored.
     *
     * @param options Feature options.
     */
    ignorePoint(options) {
        this.addItem(this.m_ignoredPoints, options);
    }
    /**
     * Add point features that should be ignored.
     *
     * @param options Multi feature options.
     */
    ignorePoints(options) {
        this.addItems(this.m_ignoredPoints, options);
    }
    /**
     * Add a valid line feature.
     *
     * @param options Feature options.
     */
    processLine(options) {
        this.addItem(this.m_linesToProcess, options);
    }
    /**
     * Add valid line features.
     *
     * @param options Multi feature options.
     */
    processLines(options) {
        this.addItems(this.m_linesToProcess, options);
    }
    /**
     * Ignore a line feature.
     *
     * @param options Feature options.
     */
    ignoreLine(options) {
        this.addItem(this.m_linesToIgnore, options);
    }
    /**
     * Ignore line features.
     *
     * @param options Multi feature options.
     */
    ignoreLines(options) {
        this.addItems(this.m_linesToIgnore, options);
    }
    /**
     * Add a valid polygon feature.
     *
     * @param options Feature options.
     */
    processPolygon(options) {
        this.addItem(this.m_polygonsToProcess, options);
    }
    /**
     * Add valid polygon features.
     *
     * @param options Multi feature options.
     */
    processPolygons(options) {
        this.addItems(this.m_polygonsToProcess, options);
    }
    /**
     * Ignore a valid polygon feature.
     *
     * @param options Feature options.
     */
    ignorePolygon(options) {
        this.addItem(this.m_polygonsToIgnore, options);
    }
    /**
     * Ignore polygon features.
     *
     * @param options Multi feature options.
     */
    ignorePolygons(options) {
        this.addItems(this.m_polygonsToIgnore, options);
    }
    /**
     * Add all the specified strings as "enabledKinds".
     *
     * @param {string[]} enabledKinds List of kinds that should be generated.
     */
    processKinds(enabledKinds) {
        this.m_kindsToProcess = this.m_kindsToProcess.concat(enabledKinds);
    }
    /**
     * Add all the specified strings as "disabledKinds".
     *
     * @param {string[]} disabledKinds List of kinds that should _not_ be generated.
     */
    ignoreKinds(disabledKinds) {
        this.m_kindsToIgnore = this.m_kindsToIgnore.concat(disabledKinds);
    }
    /**
     * Create a filter description that can be passed as an option to the [[OmvDataSource]].
     */
    createDescription() {
        return {
            processLayersDefault: this.m_processLayersDefault,
            processPointsDefault: this.m_processPointsDefault,
            processLinesDefault: this.m_processLinesDefault,
            processPolygonsDefault: this.m_processPolygonsDefault,
            layersToProcess: this.m_layersToProcess,
            layersToIgnore: this.m_layersToIgnore,
            pointsToProcess: this.m_pointsToProcess,
            pointsToIgnore: this.m_ignoredPoints,
            linesToProcess: this.m_linesToProcess,
            linesToIgnore: this.m_linesToIgnore,
            polygonsToProcess: this.m_polygonsToProcess,
            polygonsToIgnore: this.m_polygonsToIgnore,
            kindsToProcess: this.m_kindsToProcess,
            kindsToIgnore: this.m_kindsToIgnore
        };
    }
    addItem(items, options) {
        if (options.minLevel === undefined || isNaN(options.minLevel)) {
            options.minLevel = 0;
        }
        if (options.maxLevel === undefined || isNaN(options.maxLevel)) {
            options.maxLevel = Infinity;
        }
        const item = {
            layerName: {
                value: options.layer,
                match: options.matchLayer === undefined
                    ? OmvDecoderDefs_1.OmvFilterString.StringMatch.Match
                    : options.matchLayer
            },
            geometryTypes: options.geomType !== undefined
                ? Array.isArray(options.geomType)
                    ? options.geomType
                    : [options.geomType]
                : undefined,
            classes: [
                {
                    value: options.featureClass,
                    match: options.matchClass === undefined
                        ? OmvDecoderDefs_1.OmvFilterString.StringMatch.Match
                        : options.matchClass
                }
            ],
            minLevel: options.minLevel,
            maxLevel: options.maxLevel,
            featureAttribute: options.featureAttribute
        };
        items.push(item);
    }
    addItems(items, options) {
        if (options.minLevel === undefined || isNaN(options.minLevel)) {
            options.minLevel = 0;
        }
        if (options.maxLevel === undefined || isNaN(options.maxLevel)) {
            options.maxLevel = Infinity;
        }
        const item = {
            layerName: {
                value: options.layer,
                match: options.matchLayer === undefined
                    ? OmvDecoderDefs_1.OmvFilterString.StringMatch.Match
                    : options.matchLayer
            },
            geometryTypes: options.geomTypes !== undefined
                ? Array.isArray(options.geomTypes)
                    ? options.geomTypes
                    : [options.geomTypes]
                : undefined,
            classes: options.featureClasses,
            minLevel: options.minLevel,
            maxLevel: options.maxLevel,
            featureAttribute: options.featureAttribute
        };
        items.push(item);
    }
}
exports.OmvFeatureFilterDescriptionBuilder = OmvFeatureFilterDescriptionBuilder;
/**
 * `OmvFeatureFilter` implementation that uses a `OmvFeatureFilterDescription` to filter `TileData`
 * features before they are completely decoded.
 *
 * @hidden
 */
class OmvGenericFeatureFilter {
    constructor(description) {
        this.description = description;
        if (this.description.kindsToProcess.length > 0) {
            this.enabledKinds = new harp_datasource_protocol_1.GeometryKindSet(this.description.kindsToProcess);
        }
        if (this.description.kindsToIgnore.length > 0) {
            this.disabledKinds = new harp_datasource_protocol_1.GeometryKindSet(this.description.kindsToIgnore);
        }
    }
    static matchLayer(layer, layerItems, level) {
        for (const layerItem of layerItems) {
            if (level < layerItem.minLevel || level > layerItem.maxLevel) {
                continue;
            }
            if (OmvDecoderDefs_1.OmvFilterString.matchString(layer, layerItem.name)) {
                return true;
            }
        }
        return false;
    }
    wantsLayer(layer, level) {
        if (OmvGenericFeatureFilter.matchLayer(layer, this.description.layersToProcess, level)) {
            return true;
        }
        if (OmvGenericFeatureFilter.matchLayer(layer, this.description.layersToIgnore, level)) {
            return false;
        }
        return this.description.processLayersDefault;
    }
    wantsPointFeature(layer, geometryType, level) {
        return this.wantsFeature(this.description.pointsToProcess, this.description.pointsToIgnore, layer, geometryType, level, this.description.processPointsDefault);
    }
    wantsLineFeature(layer, geometryType, level) {
        return this.wantsFeature(this.description.linesToProcess, this.description.linesToIgnore, layer, geometryType, level, this.description.processLinesDefault);
    }
    wantsPolygonFeature(layer, geometryType, level) {
        return this.wantsFeature(this.description.polygonsToProcess, this.description.polygonsToIgnore, layer, geometryType, level, this.description.processPolygonsDefault);
    }
    wantsKind(kind) {
        // undefined -> no way to filter
        if (kind === undefined) {
            return true;
        }
        return (!(this.disabledKinds !== undefined &&
            this.disabledKinds.hasOrIntersects(kind)) ||
            (this.enabledKinds !== undefined &&
                this.enabledKinds.hasOrIntersects(kind)));
    }
    get hasKindFilter() {
        return this.enabledKinds !== undefined || this.disabledKinds !== undefined;
    }
    wantsFeature(itemsToProcess, itemsToIgnore, layer, geometryType, level, defaultResult) {
        for (const item of itemsToProcess) {
            if (level < item.minLevel || level > item.maxLevel) {
                continue;
            }
            if (!OmvDecoderDefs_1.OmvFilterString.matchString(layer, item.layerName)) {
                // this rule is not for this layer
                continue;
            }
            if (item.geometryTypes !== undefined && item.geometryTypes.indexOf(geometryType) >= 0) {
                return true;
            }
        }
        for (const item of itemsToIgnore) {
            if (!OmvDecoderDefs_1.OmvFilterString.matchString(layer, item.layerName)) {
                // this rule is not for this layer
                continue;
            }
            if (item.geometryTypes !== undefined && item.geometryTypes.indexOf(geometryType) >= 0) {
                return false;
            }
        }
        return defaultResult;
    }
}
exports.OmvGenericFeatureFilter = OmvGenericFeatureFilter;
/**
 * An [[OmvFeatureFilter]] implementation that delegates all filter decision
 * returning `true` for any predicate if all delegates return `true`.
 */
class ComposedDataFilter {
    constructor(filters) {
        this.filters = filters;
    }
    get hasKindFilter() {
        return this.filters.reduce((result, filter) => result && filter.hasKindFilter, true);
    }
    wantsLayer(layer, level) {
        return this.filters.reduce((result, filter) => result && filter.wantsLayer(layer, level), true);
    }
    wantsPointFeature(layer, geometryType, level) {
        return this.filters.reduce((result, filter) => result && filter.wantsPointFeature(layer, geometryType, level), true);
    }
    wantsLineFeature(layer, geometryType, level) {
        return this.filters.reduce((result, filter) => result && filter.wantsLineFeature(layer, geometryType, level), true);
    }
    wantsPolygonFeature(layer, geometryType, level) {
        return this.filters.reduce((result, filter) => result && filter.wantsPolygonFeature(layer, geometryType, level), true);
    }
    wantsKind(kind) {
        return this.filters.reduce((result, filter) => result && filter.wantsKind(kind), true);
    }
}
exports.ComposedDataFilter = ComposedDataFilter;
/**
 * `OmvFeatureModifier` implementation that uses a `OmvFeatureFilterDescription` to filter
 * `TileData` features before they are completely decoded.
 *
 * @hidden
 */
class OmvGenericFeatureModifier {
    constructor(description) {
        this.description = description;
    }
    static matchItems(layerName, featureClass, items) {
        for (const item of items) {
            if (item.classes !== undefined) {
                if (!OmvDecoderDefs_1.OmvFilterString.matchString(layerName, item.layerName)) {
                    continue;
                }
                for (const matchClass of item.classes) {
                    if (OmvDecoderDefs_1.OmvFilterString.matchString(featureClass, matchClass)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    static matchAttribute(layerName, env, items) {
        for (const item of items) {
            if (item.featureAttribute !== undefined) {
                if (OmvDecoderDefs_1.OmvFilterString.matchString(layerName, item.layerName) &&
                    env.lookup(item.featureAttribute.key) === item.featureAttribute.value) {
                    return true;
                }
            }
        }
        return false;
    }
    doProcessPointFeature(layer, env) {
        return this.doProcessFeature(this.description.pointsToProcess, this.description.pointsToIgnore, layer, env, this.description.processPointsDefault);
    }
    doProcessLineFeature(layer, env) {
        return this.doProcessFeature(this.description.linesToProcess, this.description.linesToIgnore, layer, env, this.description.processLinesDefault);
    }
    doProcessPolygonFeature(layer, env) {
        return this.doProcessFeature(this.description.polygonsToProcess, this.description.polygonsToIgnore, layer, env, this.description.processPolygonsDefault);
    }
    doProcessFeature(itemsToProcess, itemsToIgnore, layer, env, defaultResult) {
        if (layer === undefined || (itemsToProcess.length === 0 && itemsToIgnore.length === 0)) {
            return defaultResult;
        }
        let featureClass;
        const featureClassThing = env.lookup("class");
        if (featureClassThing !== undefined && featureClassThing !== null) {
            featureClass = featureClassThing.toString();
        }
        if (featureClass &&
            OmvGenericFeatureModifier.matchItems(layer, featureClass, itemsToProcess)) {
            return true;
        }
        if (featureClass &&
            OmvGenericFeatureModifier.matchItems(layer, featureClass, itemsToIgnore)) {
            return false;
        }
        if (OmvGenericFeatureModifier.matchAttribute(layer, env, itemsToProcess)) {
            return true;
        }
        if (OmvGenericFeatureModifier.matchAttribute(layer, env, itemsToIgnore)) {
            return false;
        }
        return defaultResult;
    }
}
exports.OmvGenericFeatureModifier = OmvGenericFeatureModifier;


/***/ }),

/***/ "../harp-omv-datasource/lib/OmvDataSource.ts":
/*!***************************************************!*\
  !*** ../harp-omv-datasource/lib/OmvDataSource.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_mapview_decoder_1 = __webpack_require__(/*! @here/harp-mapview-decoder */ "../harp-mapview-decoder/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const OmvDecoderDefs_1 = __webpack_require__(/*! ./OmvDecoderDefs */ "../harp-omv-datasource/lib/OmvDecoderDefs.ts");
const OmvRestClient_1 = __webpack_require__(/*! ./OmvRestClient */ "../harp-omv-datasource/lib/OmvRestClient.ts");
const OmvTile_1 = __webpack_require__(/*! ./OmvTile */ "../harp-omv-datasource/lib/OmvTile.ts");
const logger = harp_utils_1.LoggerManager.instance.create("OmvDataSource");
/**
 * A helper function to retrieve the [[DataProvider]] from the [[OmvDataSource]]s parameters.
 *
 * @param params The parameters passed into the OmvDataSource.
 */
function getDataProvider(params) {
    if (params.dataProvider) {
        return params.dataProvider;
    }
    else if (params.baseUrl ||
        params.url) {
        return new OmvRestClient_1.OmvRestClient(params);
    }
    else {
        throw new Error("OmvDataSource: missing url, baseUrl or dataProvider params");
    }
}
let missingOmvDecoderServiceInfoEmitted = false;
class OmvDataSource extends harp_mapview_decoder_1.TileDataSource {
    constructor(m_params) {
        super(m_params.tileFactory || new harp_mapview_decoder_1.TileFactory(OmvTile_1.OmvTile), {
            styleSetName: m_params.styleSetName || "omv",
            name: m_params.name,
            tilingScheme: harp_geoutils_1.webMercatorTilingScheme,
            dataProvider: getDataProvider(m_params),
            concurrentDecoderServiceName: OmvDecoderDefs_1.OMV_TILE_DECODER_SERVICE_TYPE,
            decoder: m_params.decoder,
            concurrentDecoderScriptUrl: m_params.concurrentDecoderScriptUrl,
            copyrightInfo: m_params.copyrightInfo,
            copyrightProvider: m_params.copyrightProvider,
            minZoomLevel: harp_utils_1.getOptionValue(m_params.minZoomLevel, 1),
            maxZoomLevel: harp_utils_1.getOptionValue(m_params.maxZoomLevel, 14),
            storageLevelOffset: harp_utils_1.getOptionValue(m_params.storageLevelOffset, -1)
        });
        this.m_params = m_params;
        this.cacheable = true;
        this.addGroundPlane =
            m_params.addGroundPlane === undefined || m_params.addGroundPlane === true;
        this.m_decoderOptions = {
            showMissingTechniques: this.m_params.showMissingTechniques === true,
            filterDescription: this.m_params.filterDescr,
            gatherFeatureAttributes: this.m_params.gatherFeatureAttributes === true,
            createTileInfo: this.m_params.createTileInfo === true,
            gatherRoadSegments: this.m_params.gatherRoadSegments === true,
            featureModifierId: this.m_params.featureModifierId,
            skipShortLabels: this.m_params.skipShortLabels,
            storageLevelOffset: harp_utils_1.getOptionValue(m_params.storageLevelOffset, -1),
            enableElevationOverlay: this.m_params.enableElevationOverlay === true
        };
        this.maxGeometryHeight = harp_utils_1.getOptionValue(m_params.maxGeometryHeight, harp_geoutils_1.EarthConstants.MAX_BUILDING_HEIGHT);
    }
    /** @override */
    async connect() {
        try {
            await super.connect();
        }
        catch (error) {
            if (harp_datasource_protocol_1.WorkerServiceProtocol.isUnknownServiceError(error) &&
                !missingOmvDecoderServiceInfoEmitted) {
                logger.info("Unable to create decoder service in worker. Use " +
                    " 'OmvTileDecoderService.start();' in decoder script.");
                missingOmvDecoderServiceInfoEmitted = true;
            }
            throw error;
        }
        this.configureDecoder(undefined, undefined, undefined, this.m_decoderOptions);
    }
    /**
     * Remove the current data filter.
     * Will be applied to the decoder, which might be shared with other omv datasources.
     */
    removeDataFilter() {
        this.configureDecoder(undefined, undefined, undefined, {
            filterDescription: null
        });
    }
    /**
     * Set a new data filter. Can also be done during the creation of an [[OmvDataSource]].
     * Will be applied to the decoder, which might be shared with other omv datasources.
     *
     * @param filterDescription Data filter description created with
     * [[OmvFeatureFilterDescriptionBuilder]].
     */
    setDataFilter(filterDescription) {
        this.m_decoderOptions.filterDescription =
            filterDescription !== null ? filterDescription : undefined;
        this.configureDecoder(undefined, undefined, undefined, {
            filterDescription
        });
    }
    /** @override */
    shouldPreloadTiles() {
        return true;
    }
    /**
     * Check if a data source should be rendered or not depending on the zoom level.
     *
     * @param zoomLevel Zoom level.
     * @param tileKey Level of the tile.
     * @returns `true` if the data source should be rendered.
     * @override
     */
    canGetTile(zoomLevel, tileKey) {
        if (tileKey.level > this.maxZoomLevel) {
            return false;
        }
        if (tileKey.level <= this.maxZoomLevel && zoomLevel >= this.maxZoomLevel) {
            return true;
        }
        return super.canGetTile(zoomLevel, tileKey);
    }
    /** @override */
    setLanguages(languages) {
        if (languages !== undefined) {
            this.configureDecoder(undefined, undefined, languages, undefined);
        }
    }
    /** @override */
    get storageLevelOffset() {
        return super.storageLevelOffset;
    }
    /** @override */
    set storageLevelOffset(levelOffset) {
        super.storageLevelOffset = levelOffset;
        this.m_decoderOptions.storageLevelOffset = this.storageLevelOffset;
        this.configureDecoder(undefined, undefined, undefined, {
            storageLevelOffset: this.storageLevelOffset
        });
    }
    /** @override */
    setEnableElevationOverlay(enable) {
        if (this.m_decoderOptions.enableElevationOverlay !== enable) {
            this.m_decoderOptions.enableElevationOverlay = enable;
            this.configureDecoder(undefined, undefined, undefined, {
                enableElevationOverlay: enable
            });
        }
    }
    configureDecoder(styleSet, definitions, languages, options) {
        this.clearCache();
        this.decoder.configure(styleSet, definitions, languages, options);
        this.mapView.markTilesDirty(this);
    }
}
exports.OmvDataSource = OmvDataSource;


/***/ }),

/***/ "../harp-omv-datasource/lib/OmvDebugLabelsTile.ts":
/*!********************************************************!*\
  !*** ../harp-omv-datasource/lib/OmvDebugLabelsTile.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.js");
const DebugContext_1 = __webpack_require__(/*! @here/harp-mapview/lib/DebugContext */ "../harp-mapview/lib/DebugContext.ts");
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "../harp-text-canvas/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const TileGeometryCreator_1 = __webpack_require__(/*! @here/harp-mapview/lib/geometry/TileGeometryCreator */ "../harp-mapview/lib/geometry/TileGeometryCreator.ts");
const OmvTile_1 = __webpack_require__(/*! ./OmvTile */ "../harp-omv-datasource/lib/OmvTile.ts");
const debugMaterial = new THREE.LineBasicMaterial({
    color: 0x000000,
    linewidth: 2,
    depthTest: false,
    depthFunc: THREE.NeverDepth
});
const debugCircleMaterial = new THREE.MeshBasicMaterial({
    color: 0xff0000,
    depthTest: false,
    depthFunc: THREE.NeverDepth
});
const debugCircleMaterialWF = new THREE.MeshBasicMaterial({
    color: 0xff0000,
    depthTest: false,
    depthFunc: THREE.NeverDepth
});
debugCircleMaterialWF.wireframe = true;
const debugCircleMaterial2WF = new THREE.MeshBasicMaterial({
    color: 0x8080ff,
    depthTest: false,
    depthFunc: THREE.NeverDepth
});
debugCircleMaterial2WF.wireframe = true;
const debugBlackCircleMaterial = new THREE.MeshBasicMaterial({
    color: 0x000000,
    depthTest: false,
    depthFunc: THREE.NeverDepth
});
const textRenderStyle = new harp_text_canvas_1.TextRenderStyle();
const textLayoutStyle = new harp_text_canvas_1.TextLayoutStyle();
textRenderStyle.fontSize = {
    unit: harp_text_canvas_1.FontUnit.Point,
    size: 9,
    backgroundSize: 0
};
textRenderStyle.opacity = 0.75;
textRenderStyle.backgroundOpacity = 0.75;
class OmvDebugLabelsTile extends OmvTile_1.OmvTile {
    constructor(dataSource, tileKey) {
        super(dataSource, tileKey);
    }
    /** @override */
    loadingFinished() {
        this.addLabelDebugInfo();
    }
    /**
     * Create [[TextElement]] objects from the given decoded [[Tile]] and list of materials.
     */
    addLabelDebugInfo() {
        // activate in the browser with:
        // window.__debugContext.setValue("DEBUG_TEXT_PATHS", true)
        const debugTextPaths = DebugContext_1.debugContext.getValue("DEBUG_TEXT_PATHS");
        const debugTextPathsFull = DebugContext_1.debugContext.getValue("DEBUG_TEXT_PATHS_FULL");
        if (!(debugTextPaths || debugTextPathsFull) || this.decodedTile === undefined) {
            return;
        }
        const tileGeometryCreator = TileGeometryCreator_1.TileGeometryCreator.instance;
        const decodedTile = this.decodedTile;
        tileGeometryCreator.createTextElements(this, decodedTile);
        const colorMap = new Map();
        // allow limiting to specific names and/or index. There can be many paths with the same text
        const textFilter = DebugContext_1.debugContext.getValue("DEBUG_TEXT_PATHS.FILTER.TEXT");
        const indexFilter = DebugContext_1.debugContext.getValue("DEBUG_TEXT_PATHS.FILTER.INDEX");
        const env = this.mapView.env;
        if (decodedTile.textPathGeometries !== undefined) {
            this.preparedTextPaths = tileGeometryCreator.prepareTextPaths(decodedTile.textPathGeometries, decodedTile);
        }
        if (this.preparedTextPaths !== undefined) {
            const lineGeometry = new THREE.BufferGeometry();
            const lineIndices = new Array();
            const linePositions = new Array();
            const redPointGeometry = new THREE.BufferGeometry();
            const redPointIndices = new Array();
            const redPointPositions = new Array();
            const blackPointGeometry = new THREE.BufferGeometry();
            const blackPointIndices = new Array();
            const blackPointPositions = new Array();
            let baseVertex = 0;
            const pointScale = this.mapView.pixelToWorld;
            const worldOffsetX = this.computeWorldOffsetX();
            for (const textPath of this.preparedTextPaths) {
                const technique = decodedTile.techniques[textPath.technique];
                if (!harp_datasource_protocol_1.isTextTechnique(technique)) {
                    continue;
                }
                if (technique.color !== undefined) {
                    colorMap.set(textPath.technique, new THREE.Color(harp_datasource_protocol_1.getPropertyValue(technique.color, env)));
                }
                baseVertex = linePositions.length / 3;
                const text = textPath.text;
                const elementIndex = this.preparedTextPaths.indexOf(textPath);
                const createDebugInfo = (!textFilter || (text && text.indexOf(textFilter) >= 0)) &&
                    (indexFilter === undefined || indexFilter === elementIndex);
                if (createDebugInfo) {
                    for (let i = 0; i < textPath.path.length; i += 3) {
                        const pathIndex = i / 3;
                        const x = textPath.path[i];
                        const y = textPath.path[i + 1];
                        // raise it a bit, so we get identify connectivity visually by tilting
                        const z = textPath.path[i + 2] + i / 3;
                        if (debugTextPaths) {
                            linePositions.push(x, y, z);
                        }
                        const isRedPoint = i === 0;
                        if (debugTextPathsFull || isRedPoint) {
                            const pointSize = pointScale * (isRedPoint ? 6 : 4);
                            const positions = isRedPoint ? redPointPositions : blackPointPositions;
                            const indices = isRedPoint ? redPointIndices : blackPointIndices;
                            positions.push(x, y - pointSize, z);
                            positions.push(x + pointSize, y, z);
                            positions.push(x, y + pointSize, z);
                            positions.push(x - pointSize, y, z);
                            const pointIndex = positions.length / 3;
                            indices.push(pointIndex - 4);
                            indices.push(pointIndex - 3);
                            indices.push(pointIndex - 2);
                            indices.push(pointIndex - 4);
                            indices.push(pointIndex - 2);
                            indices.push(pointIndex - 1);
                            if (debugTextPathsFull) {
                                // give point index a label
                                const label = pathIndex % 5 === 0
                                    ? text + ":" + pathIndex
                                    : Number(pathIndex).toString();
                                const labelElement = new harp_mapview_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(label), new THREE.Vector3(x + worldOffsetX, y, z), textRenderStyle, textLayoutStyle, harp_datasource_protocol_1.getPropertyValue(technique.priority || 0, env), technique.xOffset || 0.0, technique.yOffset || 0.0);
                                labelElement.minZoomLevel = technique.minZoomLevel;
                                labelElement.mayOverlap = true;
                                labelElement.reserveSpace = false;
                                labelElement.alwaysOnTop = true;
                                labelElement.ignoreDistance = true;
                                this.addUserTextElement(labelElement);
                            }
                        }
                    }
                    // the lines of a path share a common geometry
                    const N = textPath.path.length / 3;
                    for (let i = 0; i < N; ++i) {
                        if (i > 0) {
                            lineIndices.push(baseVertex + i);
                        }
                        if (i + 1 < N) {
                            lineIndices.push(baseVertex + i);
                        }
                    }
                }
            }
            if (lineIndices.length > 0) {
                lineGeometry.addGroup(0, lineIndices.length, 0);
                lineGeometry.setAttribute("position", new THREE.BufferAttribute(new Float32Array(linePositions), 3));
                lineGeometry.setIndex(new THREE.BufferAttribute(new Uint32Array(lineIndices), 1));
                const lineMesh = new THREE.LineSegments(lineGeometry, debugMaterial);
                lineMesh.renderOrder = 2000;
                this.objects.push(lineMesh);
            }
            if (redPointIndices.length > 0) {
                redPointGeometry.addGroup(0, redPointIndices.length, 0);
                redPointGeometry.setAttribute("position", new THREE.BufferAttribute(new Float32Array(redPointPositions), 3));
                redPointGeometry.setIndex(new THREE.BufferAttribute(new Uint32Array(redPointIndices), 1));
                const redPointMesh = new THREE.Mesh(redPointGeometry, debugCircleMaterial);
                redPointMesh.renderOrder = 3000;
                this.objects.push(redPointMesh);
            }
            if (blackPointIndices.length > 0) {
                blackPointGeometry.addGroup(0, blackPointIndices.length, 0);
                blackPointGeometry.setAttribute("position", new THREE.BufferAttribute(new Float32Array(blackPointPositions), 3));
                blackPointGeometry.setIndex(new THREE.BufferAttribute(new Uint32Array(blackPointIndices), 1));
                const blackPointMesh = new THREE.Mesh(blackPointGeometry, debugBlackCircleMaterial);
                blackPointMesh.renderOrder = 2500;
                this.objects.push(blackPointMesh);
            }
        }
    }
}
exports.OmvDebugLabelsTile = OmvDebugLabelsTile;


/***/ }),

/***/ "../harp-omv-datasource/lib/OmvDecoderDefs.ts":
/*!****************************************************!*\
  !*** ../harp-omv-datasource/lib/OmvDecoderDefs.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Feature Modifier ids to choose which OmvFeatureModifer should be used in OmvDecoder.
 */
var FeatureModifierId;
(function (FeatureModifierId) {
    /**
     * Identifier to use the OmvTomTomFeatureModifier in the OmvDecoder.
     */
    FeatureModifierId[FeatureModifierId["tomTom"] = 0] = "tomTom";
})(FeatureModifierId = exports.FeatureModifierId || (exports.FeatureModifierId = {}));
/**
 * Adding the match condition type and the matching function to the namespace of `OmvFilterString`.
 */
var OmvFilterString;
(function (OmvFilterString) {
    /**
     * Match condition.
     */
    let StringMatch;
    (function (StringMatch) {
        /** Matches any. */
        StringMatch[StringMatch["Any"] = 0] = "Any";
        /** Exact match. */
        StringMatch[StringMatch["Match"] = 1] = "Match";
        /** Matches if a test string starts with a filter string. */
        StringMatch[StringMatch["StartsWith"] = 2] = "StartsWith";
        /** Matches if a test string contains a filter string. */
        StringMatch[StringMatch["Contains"] = 3] = "Contains";
        /** Matches if a test string ends with a filter string. */
        StringMatch[StringMatch["EndsWith"] = 4] = "EndsWith";
    })(StringMatch = OmvFilterString.StringMatch || (OmvFilterString.StringMatch = {}));
    /**
     * Check for a string against a filter.
     *
     * @param str The string to check against a filter.
     * @param filterString The filter containing the match condition.
     * @returns `true` if the match condition is satisfied.
     */
    function matchString(str, filterString) {
        switch (filterString.match) {
            case OmvFilterString.StringMatch.Any:
                return true;
            case OmvFilterString.StringMatch.Match:
                return str === filterString.value;
            case OmvFilterString.StringMatch.StartsWith:
                return filterString.value.startsWith(str);
            case OmvFilterString.StringMatch.EndsWith:
                return filterString.value.endsWith(str);
            default:
                return str.indexOf(filterString.value) >= 0;
        }
    }
    OmvFilterString.matchString = matchString;
})(OmvFilterString = exports.OmvFilterString || (exports.OmvFilterString = {}));
var OmvGeometryType;
(function (OmvGeometryType) {
    OmvGeometryType[OmvGeometryType["UNKNOWN"] = 0] = "UNKNOWN";
    OmvGeometryType[OmvGeometryType["POINT"] = 1] = "POINT";
    OmvGeometryType[OmvGeometryType["LINESTRING"] = 2] = "LINESTRING";
    OmvGeometryType[OmvGeometryType["POLYGON"] = 3] = "POLYGON";
})(OmvGeometryType = exports.OmvGeometryType || (exports.OmvGeometryType = {}));
/**
 * Default OMV tile decoder service type.
 *
 * Used for requesting decoder services using [[WorkerServiceManager]].
 */
exports.OMV_TILE_DECODER_SERVICE_TYPE = "omv-tile-decoder";
/**
 * Default OMV tiler service type.
 *
 * Used for requesting tiler services using [[WorkerServiceManager]].
 */
exports.OMV_TILER_SERVICE_TYPE = "omv-tiler";


/***/ }),

/***/ "../harp-omv-datasource/lib/OmvRestClient.ts":
/*!***************************************************!*\
  !*** ../harp-omv-datasource/lib/OmvRestClient.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__(/*! @here/harp-fetch */ "../harp-fetch/index.web.ts");
const harp_transfer_manager_1 = __webpack_require__(/*! @here/harp-transfer-manager */ "../harp-transfer-manager/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const logger = harp_utils_1.LoggerManager.instance.create("OmvRestClient");
// tslint:disable:max-line-length
var APIFormat;
(function (APIFormat) {
    /**
     * Use the REST API format of HERE Vector Tiles Server component version 1.
     *
     * Usage:
     *
     *     <OmvRestClientParams.baseUrl>/<zoom>/<X>/<Y>/omv
     *
     * If [[OmvRestClientParams.authenticationToken]] is provided, it will be added as HTTP header:
     *
     *     Authorization: Bearer $authenticationToken
     *
     * Format definition:
     * `//http|s://<base-url>/{API version}/{layers}/{projection}/{z}/{x}/{y}/{format}`
     *
     * Default authentication method used: [[AuthenticationTypeBearer]].
     */
    APIFormat[APIFormat["HereV1"] = 0] = "HereV1";
    /**
     * Use the REST API format of Mapbox Vector Tile API v4.
     *
     * Usage:
     * `<OmvRestClientParams.baseUrl>/<zoom>/<X>/<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`
     *
     * Format definition:
     * `http|s://<base-url>/v4/{map_id}/{z}/{x}/{y}{@2x}.{format}?[style]&access_token={access_token}`
     *
     * Sample URL:
     * `http://a.tiles.mapbox.com/v4/mapbox.mapbox-streets-v7/14/4823/6160.mvt?access_token=your-mapbox-access-token`
     *
     * Default authentication method used: [[AuthenticationTypeAccessToken]].
     */
    APIFormat[APIFormat["MapboxV4"] = 1] = "MapboxV4";
    /**
     * Use the REST API format of XYZ Vector Tile API in MVT format.
     *
     * Usage:
     * `<OmvRestClientParams.baseUrl>/tiles/omsbase/256/<zoom>/<X>/<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`
     *
     * Format definition:
     * `http|s://<base-url>/tiles/{layers}/{z}/{x}/{y}/{format}?access_token={access_token}`
     *
     * Sample URL:
     * `https://xyz.api.here.com/tiles/osmbase/256/all/16/19293/24641.mvt?access_token=your-xyz-access-token`
     *
     * Default authentication method used: [[AuthenticationTypeAccessToken]].
     */
    APIFormat[APIFormat["XYZMVT"] = 2] = "XYZMVT";
    /**
     * Use the REST API format of XYZ Vector Tile API in JSON format.
     *
     * Usage:
     * `<OmvRestClientParams.baseUrl>/tiles/omsbase/256/<zoom>/<X>/<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`
     *
     * Format definition:
     * `http|s://<base-url>/tiles/{layers}/{z}/{x}/{y}/{format}?access_token={access_token}`
     *
     * Sample URL:
     * `https://xyz.api.here.com/tiles/osmbase/256/all/16/19293/24641.json?access_token=your-xyz-api-key`
     *
     * Default authentication method used: [[AuthenticationTypeAccessToken]].
     */
    APIFormat[APIFormat["XYZJson"] = 3] = "XYZJson";
    /**
     * Use the REST API format of XYZ Vector Tile API in OMV format.
     *
     * Usage:
     * `<OmvRestClientParams.baseUrl>/tiles/herebase.02/<zoom>/<X>/<Y>/omv?access_token=<OmvRestClientParams.authenticationCode>`
     *
     * Format definition:
     * `http|s://<base-url>/tiles/herebase.02/{z}/{x}/{y}/{format}?access_token={access_token}`
     *
     * Sample URL:
     * `https://xyz.api.here.com/tiles/herebase.02/14/2649/6338/omv?access_token=your-xyz-access-token`
     *
     * Default authentication method used: [[AuthenticationTypeAccessToken]].
     */
    APIFormat[APIFormat["XYZOMV"] = 4] = "XYZOMV";
    /**
     * Use the REST API format of Tomtoms Vector Tile API v1.
     *
     * Usage:
     * `<OmvRestClientParams.baseUrl>/<zoom>/<X>/<Y>.pbf?key=<OmvRestClientParams.authenticationCode>`
     *
     * Format definition:
     * `<http|https>://<baseURL>/map/<versionNumber>/tile/<layer>/<style>/<zoom>/<X>/<Y>.<format>?key=<apiKey>[&view=<view>][&language=<language>]`
     *
     * Sample URL:
     * `http://api.tomtom.com/map/1/tile/basic/main/0/0/0.pbf?key=<apiKey>`
     *
     * Default authentication method used: [[AuthenticationTypeTomTomV1]].
     */
    APIFormat[APIFormat["TomtomV1"] = 5] = "TomtomV1";
    /**
     * Use the REST API format of XYZ Space Vector Tile API in OMV format.
     *
     * Usage:
     * `<OmvRestClientParams.baseUrl>/hub/spaces/<space-id>/tile/web/<zoom>_<X>_<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`
     *
     * Format definition:
     * `http|s://<base-url>/hub/spaces/{spaceId}/tile/web/{z}_{x}_{y}.mvt?access_token={access_token}`
     *
     * Sample URL:
     * `https://xyz.api.here.com/hub/spaces/your-space-id/tile/web/{z}_{x}_{y}.mvt?access_token=your-access-token`
     *
     * Default authentication method used: [[AuthenticationTypeAccessToken]].
     */
    APIFormat[APIFormat["XYZSpace"] = 6] = "XYZSpace";
})(APIFormat = exports.APIFormat || (exports.APIFormat = {}));
var AuthenticationMethod;
(function (AuthenticationMethod) {
    AuthenticationMethod[AuthenticationMethod["QueryString"] = 0] = "QueryString";
    AuthenticationMethod[AuthenticationMethod["AuthorizationHeader"] = 1] = "AuthorizationHeader";
})(AuthenticationMethod = exports.AuthenticationMethod || (exports.AuthenticationMethod = {}));
/**
 * Authentication method, where token will be provided as HTTP Header:
 *
 *    Authorization: Bearer $authenticationToken
 */
exports.AuthenticationTypeBearer = {
    method: AuthenticationMethod.AuthorizationHeader,
    name: "Bearer"
};
/**
 * TomTomV1 API compatible authorization method, where token will be provided as HTTP Header:
 *
 *    Authorization: Bearer $authenticationToken
 */
exports.AuthenticationTypeTomTomV1 = {
    method: AuthenticationMethod.QueryString,
    name: "key"
};
exports.AuthenticationTypeAccessToken = {
    method: AuthenticationMethod.QueryString,
    name: "access_token"
};
/**
 * REST client supporting getting protobuf OMV Tile from REST-based servers.
 */
class OmvRestClient {
    constructor(params) {
        this.params = params;
        this.downloadManager =
            params.downloadManager === undefined
                ? harp_transfer_manager_1.TransferManager.instance()
                : params.downloadManager;
        this.urlParams = params.urlParams === undefined ? {} : params.urlParams;
    }
    /** Overriding abstract method, in this case doing nothing. */
    async connect() {
        // not needed
    }
    /** Overriding abstract method, in this case always returning `true`. */
    ready() {
        return true;
    }
    /**
     * Asynchronously fetches a tile from this restful server.
     *
     * **Note:** If the tile doesn't exist, a successful response with a `404` status code is
     * returned.
     *
     * @example
     * ```typescript
     * const response = layer.getTile(tileKey);
     * if (!response.ok) {
     *     // a network error happened
     *     console.error("Unable to download tile", response.statusText);
     *     return;
     * }
     * if (response.status === 404) {
     *     // 404 -, no data exists at the given tile. Do nothing.
     *     return;
     * }
     *
     * // the response is ok and contains data, access it e.g. as arrayBuffer:
     * const payload = await response.arrayBuffer();
     * ```
     *
     * @param tileKey The tile key of the tile.
     * @param tileRequestInit Optional request options to be passed to fetch when downloading a
     * tile.
     * @returns A `Promise` of the HTTP response that contains the payload of the requested tile.
     */
    async getTile(tileKey, abortSignal) {
        const init = { signal: abortSignal };
        let tileUrl = this.dataUrl(tileKey);
        const authenticationCode = await this.getActualAuthenticationCode();
        tileUrl = this.applyAuthCode(tileUrl, init, authenticationCode);
        tileUrl = this.addQueryParams(tileUrl, this.urlParams);
        if (this.params.apiFormat === APIFormat.XYZJson) {
            return this.downloadManager.downloadJson(tileUrl, init);
        }
        return this.downloadManager.downloadArrayBuffer(tileUrl, init);
    }
    /**
     * Get actual authentication code/token for this request according to configuration.
     */
    async getActualAuthenticationCode() {
        if (typeof this.params.authenticationCode === "string") {
            return this.params.authenticationCode;
        }
        else if (this.params.authenticationCode !== undefined) {
            return this.params.authenticationCode();
        }
        else if (this.params.getBearerToken !== undefined) {
            return this.params.getBearerToken();
        }
        else {
            return undefined;
        }
    }
    /**
     * Get default authnentication method basing on apiFormat and other params.
     */
    getDefaultAuthMethod() {
        if (this.params.getBearerToken !== undefined) {
            return exports.AuthenticationTypeBearer;
        }
        switch (this.params.apiFormat) {
            case APIFormat.HereV1:
                return exports.AuthenticationTypeBearer;
            case APIFormat.MapboxV4:
            case APIFormat.XYZOMV:
            case APIFormat.XYZMVT:
            case APIFormat.XYZSpace:
            case APIFormat.XYZJson:
                return exports.AuthenticationTypeAccessToken;
            case APIFormat.TomtomV1:
                return exports.AuthenticationTypeTomTomV1;
            default:
                logger.warn(`#getDefaultAuthMethod: Not supported API format: ${this.params.apiFormat}`);
                return undefined;
        }
    }
    /**
     * Apply athentication code/token using configured (or default) authentication method.
     *
     * @param url
     * @param init request extra data
     * @param authenticationCode authentication/token to be applied
     * @return new url to be used
     */
    applyAuthCode(url, init, authenticationCode) {
        if (authenticationCode === undefined) {
            return url;
        }
        const authMethod = this.params.authenticationMethod || this.getDefaultAuthMethod();
        if (authMethod === undefined) {
            return url;
        }
        if (authMethod.method === AuthenticationMethod.AuthorizationHeader) {
            if (init.headers === undefined) {
                init.headers = new Headers();
            }
            const authType = authMethod.name || "Bearer";
            init.headers.append("Authorization", `${authType} ${authenticationCode}`);
        }
        else if (authMethod.method === AuthenticationMethod.QueryString) {
            const attrName = authMethod.name || "access_token";
            const authParams = {};
            authParams[attrName] = authenticationCode;
            url = this.addQueryParams(url, authParams);
        }
        return url;
    }
    /**
     * Get actual tile URL depending on configured API format.
     */
    dataUrl(tileKey) {
        if (this.params.url !== undefined) {
            return this.params.url
                .replace("{x}", String(tileKey.column))
                .replace("{y}", String(tileKey.row))
                .replace("{z}", String(tileKey.level));
        }
        let path = [`/${tileKey.level}`, tileKey.column, tileKey.row].join(this.params.apiFormat === APIFormat.XYZSpace ? "_" : "/");
        switch (this.params.apiFormat) {
            case APIFormat.HereV1:
            case APIFormat.XYZOMV:
                path += "/omv";
                break;
            case APIFormat.MapboxV4:
                path += ".mvt";
                break;
            case APIFormat.XYZMVT:
                path += ".mvt";
                break;
            case APIFormat.XYZJson:
                path += ".json";
                break;
            case APIFormat.XYZSpace:
                path += ".mvt";
                break;
            case APIFormat.TomtomV1:
                path += ".pbf";
                break;
            default:
                logger.warn(`Not supported API format: ${this.params.apiFormat}`);
                break;
        }
        return this.params.baseUrl + path;
    }
    addQueryParams(url, queryParams) {
        let queryString = "";
        let concatinator = url.indexOf("?") !== -1 ? "&" : "?";
        Object.getOwnPropertyNames(queryParams).forEach(property => {
            const prop = property;
            queryString += concatinator + prop + "=" + queryParams[prop];
            if (concatinator === "?") {
                concatinator = "&";
            }
        });
        return url + queryString;
    }
}
exports.OmvRestClient = OmvRestClient;


/***/ }),

/***/ "../harp-omv-datasource/lib/OmvTile.ts":
/*!*********************************************!*\
  !*** ../harp-omv-datasource/lib/OmvTile.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.js");
class OmvTile extends harp_mapview_1.Tile {
    constructor(dataSource, tileKey) {
        super(dataSource, tileKey);
    }
}
exports.OmvTile = OmvTile;


/***/ }),

/***/ "../harp-text-canvas/index.ts":
/*!************************************!*\
  !*** ../harp-text-canvas/index.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/rendering/FontCatalog */ "../harp-text-canvas/lib/rendering/FontCatalog.ts"));
__export(__webpack_require__(/*! ./lib/rendering/GlyphData */ "../harp-text-canvas/lib/rendering/GlyphData.ts"));
__export(__webpack_require__(/*! ./lib/rendering/TextStyle */ "../harp-text-canvas/lib/rendering/TextStyle.ts"));
__export(__webpack_require__(/*! ./lib/rendering/TextBufferObject */ "../harp-text-canvas/lib/rendering/TextBufferObject.ts"));
__export(__webpack_require__(/*! ./lib/TextCanvas */ "../harp-text-canvas/lib/TextCanvas.ts"));
__export(__webpack_require__(/*! ./lib/utils/ContextualArabicConverter */ "../harp-text-canvas/lib/utils/ContextualArabicConverter.ts"));
__export(__webpack_require__(/*! ./lib/utils/MaterialUtils */ "../harp-text-canvas/lib/utils/MaterialUtils.ts"));
__export(__webpack_require__(/*! ./lib/utils/TypesettingUtils */ "../harp-text-canvas/lib/utils/TypesettingUtils.ts"));
__export(__webpack_require__(/*! ./lib/utils/UnicodeUtils */ "../harp-text-canvas/lib/utils/UnicodeUtils.ts"));


/***/ }),

/***/ "../harp-text-canvas/lib/TextCanvas.ts":
/*!*********************************************!*\
  !*** ../harp-text-canvas/lib/TextCanvas.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const TextBufferObject_1 = __webpack_require__(/*! ./rendering/TextBufferObject */ "../harp-text-canvas/lib/rendering/TextBufferObject.ts");
const TextGeometry_1 = __webpack_require__(/*! ./rendering/TextGeometry */ "../harp-text-canvas/lib/rendering/TextGeometry.ts");
const TextStyle_1 = __webpack_require__(/*! ./rendering/TextStyle */ "../harp-text-canvas/lib/rendering/TextStyle.ts");
const LineTypesetter_1 = __webpack_require__(/*! ./typesetting/LineTypesetter */ "../harp-text-canvas/lib/typesetting/LineTypesetter.ts");
const PathTypesetter_1 = __webpack_require__(/*! ./typesetting/PathTypesetter */ "../harp-text-canvas/lib/typesetting/PathTypesetter.ts");
const MaterialUtils_1 = __webpack_require__(/*! ./utils/MaterialUtils */ "../harp-text-canvas/lib/utils/MaterialUtils.ts");
const tempTextPosition = new THREE.Vector3();
const tempTextBounds = {
    array: [new THREE.Box2()],
    offset: 0
};
let tempVertexBuffer = new Float32Array();
/**
 * Default's [[TextCanvas]] layer identifier.
 */
exports.DEFAULT_TEXT_CANVAS_LAYER = 0;
/**
 * three.js text rendering engine which can manage and render high-quality, transformable, stylable
 * and properly layout SDF and MSDF text.
 */
class TextCanvas {
    /**
     * Constructs a new `TextCanvas`.
     *
     * @param params `TextCanvas` construction parameters.
     *
     * @returns New `TextCanvas`.
     */
    constructor(params) {
        this.m_renderer = params.renderer;
        this.m_fontCatalog = params.fontCatalog;
        this.minGlyphCount = params.minGlyphCount;
        this.maxGlyphCount = params.maxGlyphCount;
        if (params.material === undefined) {
            this.m_ownsMaterial = true;
            this.m_material = MaterialUtils_1.createSdfTextMaterial({ fontCatalog: params.fontCatalog });
        }
        else {
            this.m_ownsMaterial = false;
            this.m_material = params.material;
        }
        if (params.backgroundMaterial === undefined) {
            this.m_ownsBgMaterial = true;
            this.m_bgMaterial = MaterialUtils_1.createSdfTextMaterial({
                fontCatalog: params.fontCatalog,
                isBackground: true
            });
        }
        else {
            this.m_ownsBgMaterial = false;
            this.m_bgMaterial = params.backgroundMaterial;
        }
        this.m_defaultLayer = {
            id: exports.DEFAULT_TEXT_CANVAS_LAYER,
            storage: new TextGeometry_1.TextGeometry(new THREE.Scene(), this.m_material, this.m_bgMaterial, this.minGlyphCount, this.maxGlyphCount)
        };
        this.m_layers = [this.m_defaultLayer];
        this.m_defaultTextRenderStyle = new TextStyle_1.TextRenderStyle();
        this.m_currentTextRenderStyle = this.m_defaultTextRenderStyle;
        this.m_defaultTextLayoutStyle = new TextStyle_1.TextLayoutStyle();
        this.m_currentTextLayoutStyle = this.m_defaultTextLayoutStyle;
        this.m_lineTypesetter = new LineTypesetter_1.LineTypesetter();
        this.m_pathTypesetter = new PathTypesetter_1.PathTypesetter();
    }
    /**
     * Currently active [[FontCatalog]].
     */
    get fontCatalog() {
        return this.m_fontCatalog;
    }
    set fontCatalog(value) {
        this.m_fontCatalog = value;
        const material = this.m_material;
        material.uniforms.sdfTexture.value = this.m_fontCatalog.texture;
        material.uniforms.sdfParams.value = new THREE.Vector4(this.m_fontCatalog.textureSize.x, this.m_fontCatalog.textureSize.y, this.m_fontCatalog.size, this.m_fontCatalog.distanceRange);
        material.defines.MSDF = this.m_fontCatalog.type === "msdf" ? 1.0 : 0.0;
        const bgMaterial = this.m_bgMaterial;
        bgMaterial.uniforms.sdfTexture.value = this.m_fontCatalog.texture;
        bgMaterial.uniforms.sdfParams.value = new THREE.Vector4(this.m_fontCatalog.textureSize.x, this.m_fontCatalog.textureSize.y, this.m_fontCatalog.size, this.m_fontCatalog.distanceRange);
        bgMaterial.defines.MSDF = this.m_fontCatalog.type === "msdf" ? 1.0 : 0.0;
    }
    /**
     * Currently active text rendering material.
     */
    get material() {
        return this.m_material;
    }
    set material(value) {
        if (this.m_ownsMaterial) {
            this.m_material.dispose();
            this.m_ownsMaterial = false;
        }
        this.m_material = value;
        for (const layer of this.m_layers) {
            layer.storage.mesh.material = this.m_material;
        }
    }
    /**
     * Currently active text background rendering material.
     */
    get backgroundMaterial() {
        return this.m_bgMaterial;
    }
    set backgroundMaterial(value) {
        if (this.m_ownsBgMaterial) {
            this.m_bgMaterial.dispose();
            this.m_ownsBgMaterial = false;
        }
        this.m_bgMaterial = value;
        for (const layer of this.m_layers) {
            layer.storage.backgroundMesh.material = this.m_bgMaterial;
        }
    }
    /**
     * Currently active text rendering style.
     */
    get textRenderStyle() {
        return this.m_currentTextRenderStyle;
    }
    set textRenderStyle(style) {
        this.m_currentTextRenderStyle = style;
    }
    /**
     * Currently active text layout style.
     */
    get textLayoutStyle() {
        return this.m_currentTextLayoutStyle;
    }
    set textLayoutStyle(style) {
        this.m_currentTextLayoutStyle = style;
    }
    /**
     * Clears all the placed glyphs in this `TextCanvas` (as well as resetting the current style).
     */
    clear() {
        for (const layer of this.m_layers) {
            layer.storage.clear();
        }
        this.m_currentTextRenderStyle = this.m_defaultTextRenderStyle;
    }
    /**
     * Renders the content of this `TextCanvas`.
     *
     * @param camera Orthographic camera.
     * @param target Optional render target.
     * @param clear Optional render target clear operation.
     */
    render(camera, target, clear) {
        this.m_fontCatalog.update(this.m_renderer);
        let oldTarget = null;
        if (target !== undefined) {
            oldTarget = this.m_renderer.getRenderTarget();
            this.m_renderer.setRenderTarget(target);
        }
        if (clear === true) {
            this.m_renderer.clear(true);
        }
        for (const layer of this.m_layers) {
            layer.storage.update();
            this.m_renderer.clear(false, true);
            this.m_renderer.render(layer.storage.scene, camera);
        }
        if (target !== undefined) {
            this.m_renderer.setRenderTarget(oldTarget);
        }
    }
    /**
     * Creates a new `TextCanvas` rendering layer and returns. If there was already a layer for the
     * input `layerId`, it just returns this one instead.
     *
     * @param layerId Desired layer identifier.
     *
     * @returns Created [[TextCanvasLayer]].
     */
    addLayer(layerId) {
        let result = this.getLayer(layerId);
        if (result === undefined) {
            result = {
                id: layerId,
                storage: new TextGeometry_1.TextGeometry(new THREE.Scene(), this.m_material, this.m_bgMaterial, this.minGlyphCount, this.maxGlyphCount)
            };
            this.m_layers.push(result);
            this.m_layers.sort((a, b) => {
                return a.id - b.id;
            });
        }
        return result;
    }
    /**
     * Retrieves a specific `TextCanvas` rendering layer.
     *
     * @param layerId Desired layer identifier.
     *
     * @returns Selected [[TextCanvasLayer]].
     */
    getLayer(layerId) {
        return this.m_layers.find(layer => layer.id === layerId);
    }
    /**
     * Retrieves all `TextCanvas` rendering layers.
     *
     * @returns Array of [[TextCanvasLayer]]s.
     */
    getAllLayers() {
        return this.m_layers;
    }
    /**
     * Returns the computed bounding box for the input text. The current [[TextRenderStyle]] and
     * [[TextLayoutStyle]] will influence the results of this function.
     *
     * @param text Input text. Provide an array of [[GlyphData]] for better performance.
     * @param outputBounds Output text bounding box.
     * @param params Optional measurement parameters.
     *
     * @returns Result of the measurement. If `false`, some error occurred during execution and the
     * input text couldn't be properly measured.
     */
    measureText(text, outputBounds, params) {
        tempTextPosition.set(0, 0, 0);
        let path;
        let pathOverflow;
        let upperCaseArray;
        let outputCharacterBounds;
        if (params !== undefined) {
            path = params.path;
            pathOverflow = params.pathOverflow;
            outputCharacterBounds = params.outputCharacterBounds;
            if (params.path !== undefined) {
                const pathOrigin = params.path.getPoint(0);
                if (pathOrigin === null) {
                    return false;
                }
                tempTextPosition.set(pathOrigin.x, pathOrigin.y, 0.0);
            }
            if (params.letterCaseArray) {
                upperCaseArray = params.letterCaseArray;
            }
        }
        return this.placeText({
            input: text,
            layer: this.m_defaultLayer,
            textPath: path,
            textPathOverflow: pathOverflow,
            bounds: outputBounds,
            individualBounds: outputCharacterBounds,
            letterCaseArray: upperCaseArray
        });
    }
    /**
     * Adds the input text to this `TextCanvas` in the specified screen position. The current
     * [[TextRenderStyle]] and [[TextLayoutStyle]] will influence the results of this function.
     *
     * @param text Input text. Provide an array of [[GlyphData]] for better performance.
     * @param position Screen position.
     * @param params Optional addition parameters.
     *
     * @returns Result of the addition. If `false`, some error occurred during execution and the
     * input text couldn't be properly added.
     */
    addText(text, position, params) {
        tempTextPosition.copy(position);
        let path;
        let pathOverflow;
        let upperCaseArray;
        let targetLayer = this.m_defaultLayer;
        if (params !== undefined) {
            path = params.path;
            pathOverflow = params.pathOverflow;
            if (params.layer !== undefined) {
                let tempLayer = this.getLayer(params.layer);
                if (tempLayer === undefined) {
                    tempLayer = this.addLayer(params.layer);
                }
                targetLayer = tempLayer;
            }
            if (params.path !== undefined) {
                tempTextPosition.set(0, 0, tempTextPosition.z);
            }
            if (params.letterCaseArray) {
                upperCaseArray = params.letterCaseArray;
            }
        }
        const prevDrawCount = targetLayer.storage.drawCount;
        const result = this.placeText({
            input: text,
            textPath: path,
            textPathOverflow: pathOverflow,
            layer: targetLayer,
            letterCaseArray: upperCaseArray
        });
        if (result && params !== undefined) {
            if (params.updatePosition === true) {
                position.copy(tempTextPosition);
            }
            if (params.pickingData !== undefined) {
                targetLayer.storage.addPickingData(prevDrawCount, targetLayer.storage.drawCount, params.pickingData);
            }
        }
        else if (!result) {
            targetLayer.storage.m_drawCount = prevDrawCount;
        }
        return result;
    }
    /**
     * Creates a new [[TextBufferObject]]. The computed text vertex buffer is equivalent to the
     * result of performing the `addText` function for the input text in the screen origin.
     *
     * @param text Input text. Provide an array of [[GlyphData]] for better performance.
     * @param params Optional creation parameters.
     *
     * @returns New [[TextBufferObject]] (or `undefined` if requested text glyphs couldn't be
     * retrieved from the current [[FontCatalog]]).
     */
    createTextBufferObject(text, params) {
        tempTextPosition.set(0, 0, 0);
        let glyphArray;
        let upperCaseArray;
        const smallCapsEnabled = this.m_currentTextRenderStyle.fontVariant === TextStyle_1.FontVariant.SmallCaps;
        if (typeof text !== "string") {
            glyphArray = text;
            if (params !== undefined && params.letterCaseArray) {
                upperCaseArray = params.letterCaseArray;
            }
        }
        else {
            upperCaseArray = [];
            glyphArray = this.m_fontCatalog.getGlyphs(text, this.m_currentTextRenderStyle, smallCapsEnabled ? upperCaseArray : undefined);
            if (glyphArray === undefined) {
                return undefined;
            }
        }
        let path;
        let pathOverflow;
        let textBounds;
        let characterBounds;
        let renderStyle;
        let layoutStyle;
        if (params !== undefined) {
            path = params.path;
            pathOverflow = params.pathOverflow;
            if (params.outputBounds === true) {
                textBounds = new THREE.Box2();
            }
            if (params.outputCharacterBounds === true) {
                characterBounds = [];
            }
            if (params.storeStyles === true) {
                renderStyle = this.m_currentTextRenderStyle;
                layoutStyle = this.m_currentTextLayoutStyle;
            }
        }
        this.placeText({
            input: text,
            layer: this.m_defaultLayer,
            computeTextBuffer: true,
            textPath: path,
            textPathOverflow: pathOverflow,
            bounds: textBounds,
            individualBounds: characterBounds,
            letterCaseArray: upperCaseArray
        });
        return new TextBufferObject_1.TextBufferObject(glyphArray, new Float32Array(tempVertexBuffer), textBounds, characterBounds, renderStyle, layoutStyle);
    }
    /**
     * Adds a previously created [[TextBufferObject]] to the `TextCanvas`. Additional parameters can
     * be provided to override the attributes stored in the buffer.
     *
     * @param textBufferObject [[TextBufferObject]] to add.
     * @param params Optional addition parameters.
     *
     * @returns Result of the addition. If `false`, some error occurred during execution and the
     * input text couldn't be properly added.
     */
    addTextBufferObject(textBufferObject, params) {
        let targetLayer = this.m_defaultLayer;
        let position;
        let scale;
        let rotation;
        let color;
        let opacity;
        let bgColor;
        let bgOpacity;
        if (params !== undefined) {
            if (params.layer !== undefined) {
                let tempLayer = this.getLayer(params.layer);
                if (tempLayer === undefined) {
                    tempLayer = this.addLayer(params.layer);
                }
                targetLayer = tempLayer;
            }
            position = params.position;
            scale = params.scale;
            rotation = params.rotation;
            color = params.color;
            opacity = params.opacity;
            bgColor = params.backgroundColor;
            bgOpacity = params.backgroundOpacity;
        }
        const prevDrawCount = targetLayer.storage.drawCount;
        const result = targetLayer.storage.addTextBufferObject(textBufferObject, position, scale, rotation, color, opacity, bgColor, bgOpacity);
        if (result && params !== undefined) {
            if (params.pickingData !== undefined) {
                targetLayer.storage.addPickingData(prevDrawCount, targetLayer.storage.drawCount, params.pickingData);
            }
        }
        else if (!result) {
            targetLayer.storage.m_drawCount = prevDrawCount;
        }
        return result;
    }
    /**
     * Executes the `pickCallback` for all previously stored picking data for text covering the
     * specified screen position.
     *
     * @param screenPosition Screen coordinate of picking position.
     * @param pickCallback Callback to be called for every picked element.
     */
    pickText(position, callback) {
        for (const layer of this.m_layers) {
            layer.storage.pick(position, callback);
        }
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `TextCanvas`.
     *
     * @param info The info object to increment with the values from this `TextCanvas`.
     */
    getMemoryUsage(info) {
        this.m_fontCatalog.updateMemoryUsage(info);
        for (const layer of this.m_layers) {
            layer.storage.updateMemoryUsage(info);
        }
    }
    // Places all glyphs for input text. Depending on parameters, it can store the resulting glyphs
    // in the current [[TextGeometry]] (or into a separate buffer) or compute the bounding box for
    // the input (as a whole or on a per-character basis).
    placeText(params) {
        if (params.input.length === 0 || this.m_currentTextLayoutStyle.maxLines === 0) {
            if (params.bounds !== undefined) {
                params.bounds.min.set(0, 0);
                params.bounds.max.set(0, 0);
            }
            if (params.individualBounds !== undefined) {
                params.individualBounds.length = 0;
            }
            return true;
        }
        let glyphArray;
        let smallCapsTransformations;
        const smallCapsEnabled = this.m_currentTextRenderStyle.fontVariant === TextStyle_1.FontVariant.SmallCaps;
        if (typeof params.input !== "string") {
            glyphArray = params.input;
            if (params.letterCaseArray) {
                smallCapsTransformations = params.letterCaseArray;
            }
        }
        else {
            smallCapsTransformations = [];
            glyphArray = this.m_fontCatalog.getGlyphs(params.input, this.m_currentTextRenderStyle, smallCapsEnabled ? smallCapsTransformations : undefined);
            if (glyphArray === undefined) {
                return false;
            }
        }
        let glyphBounds;
        if (params.individualBounds !== undefined) {
            tempTextBounds.array = params.individualBounds;
            tempTextBounds.offset = 0;
            glyphBounds = tempTextBounds;
        }
        if (params.bounds !== undefined) {
            params.bounds.min.set(Infinity, Infinity);
            params.bounds.max.set(-Infinity, -Infinity);
        }
        if (params.computeTextBuffer === true) {
            tempVertexBuffer = new Float32Array(glyphArray.length * TextGeometry_1.QUAD_VERTEX_MEMORY_FOOTPRINT);
        }
        const isPath = params.textPath !== undefined;
        const typesettingParams = {
            glyphs: glyphArray,
            fontCatalog: this.m_fontCatalog,
            textRenderStyle: this.m_currentTextRenderStyle,
            textLayoutStyle: this.m_currentTextLayoutStyle,
            position: tempTextPosition,
            geometry: params.layer.storage,
            smallCapsArray: smallCapsEnabled ? smallCapsTransformations : undefined,
            globalBounds: params.bounds,
            individualBounds: glyphBounds,
            vertexBuffer: params.computeTextBuffer === true ? tempVertexBuffer : undefined
        };
        let result = true;
        if (isPath) {
            Object.assign(typesettingParams, {
                path: params.textPath,
                pathOverflow: params.textPathOverflow === true
            });
            result = this.m_pathTypesetter.arrangeGlyphs(typesettingParams);
        }
        else {
            result = this.m_lineTypesetter.arrangeGlyphs(typesettingParams);
        }
        if (glyphBounds !== undefined) {
            glyphBounds.array.length = glyphBounds.offset;
        }
        return result;
    }
}
exports.TextCanvas = TextCanvas;


/***/ }),

/***/ "../harp-text-canvas/lib/rendering/FontCatalog.ts":
/*!********************************************************!*\
  !*** ../harp-text-canvas/lib/rendering/FontCatalog.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const GlyphData_1 = __webpack_require__(/*! ./GlyphData */ "../harp-text-canvas/lib/rendering/GlyphData.ts");
const GlyphTextureCache_1 = __webpack_require__(/*! ./GlyphTextureCache */ "../harp-text-canvas/lib/rendering/GlyphTextureCache.ts");
const TextStyle_1 = __webpack_require__(/*! ./TextStyle */ "../harp-text-canvas/lib/rendering/TextStyle.ts");
const ASSETS_PATH = "_Assets/";
const BOLD_ASSETS_PATH = "_BoldAssets/";
const ITALIC_ASSETS_PATH = "_ItalicAssets/";
const BOLD_ITALIC_ASSETS_PATH = "_BoldItalicAssets/";
const REPLACEMENT_PATH = "_Assets/Extra/";
/**
 * Collection of font assets used to render glyphs when using a [[TextCanvas]].
 *
 * @summary A `FontCatalog` works as a stack of SDF bitmap fonts (using the BMFont format) designed
 * to cover the widest Unicode code point range possible. In order to manage all these assets
 * elegantly, the assets inside the `FontCatalog` are stored on a per-Unicode-Block basis, and
 * assets for a block are only loaded once a glyph belonging to that block is requested.
 *
 * Bitmap information coming from all different fonts is then stored in a unified WebGL GPU Texture
 * resource, which can be sampled to render all currently loaded glyphs.
 *
 */
class FontCatalog {
    /**
     * @hidden
     * Creates a new FontCatalog.
     *
     * @param url FontCatalog's URL.
     * @param name FontCatalog's name.
     * @param type FontCatalog's type (sdf or msdf).
     * @param size FontCatalog's glyph size (pixels).
     * @param maxWidth FontCatalog's maximum glyph width (pixels).
     * @param maxHeight FontCatalog's maximum glyph height (pixels).
     * @param distanceRange Distance range used to generate the SDF bitmaps.
     * @param fonts Array of supported fonts.
     * @param unicodeBlocks Array of supported Unicode blocks.
     * @param maxCodePointCount Maximum number of unique code points bitmaps this `FontCatalog`'s
     * internal texture can store simultaneously.
     * @param m_replacementGlyph [[GlyphData]] to be used whenever a Unicode code point is not
     * supported by this `FontCatalog`.
     *
     * @returns New FontCatalog.
     */
    constructor(url, name, type, size, maxWidth, maxHeight, distanceRange, fonts, unicodeBlocks, maxCodePointCount, m_replacementGlyph) {
        this.url = url;
        this.name = name;
        this.type = type;
        this.size = size;
        this.maxWidth = maxWidth;
        this.maxHeight = maxHeight;
        this.distanceRange = distanceRange;
        this.fonts = fonts;
        this.unicodeBlocks = unicodeBlocks;
        this.maxCodePointCount = maxCodePointCount;
        this.m_replacementGlyph = m_replacementGlyph;
        this.m_glyphTextureCache = new GlyphTextureCache_1.GlyphTextureCache(maxCodePointCount, this.maxWidth + 1, this.maxHeight + 1);
        this.m_loadingJson = new Map();
        this.m_loadingPages = new Map();
        this.m_loadingGlyphs = new Map();
        this.m_loadedJson = new Map();
        this.m_loadedPages = new Map();
        this.m_loadedGlyphs = new Map();
    }
    /**
     * Loads a `FontCatalog`.
     *
     * @param url Asset url.
     * @param maxCodePointCount Maximum number of unique code points bitmaps this `FontCatalog`'s
     * internal texture can store simultaneously.
     *
     * @returns `FontCatalog` Promise.
     */
    static async load(path, maxCodePointCount) {
        const url = new URL(path, window.location.href);
        const fontCatalog = await FontCatalog.loadJSON(url.href);
        const replacementDirUrl = new URL(`${fontCatalog.name}${REPLACEMENT_PATH}`, url);
        const replacementJson = await FontCatalog.loadJSON(replacementDirUrl.href + "Specials.json");
        const replacementTexture = await FontCatalog.loadTexture(replacementDirUrl.href + "Specials.png");
        replacementTexture.wrapS = THREE.ClampToEdgeWrapping;
        replacementTexture.wrapT = THREE.ClampToEdgeWrapping;
        replacementTexture.minFilter = THREE.NearestFilter;
        replacementTexture.needsUpdate = true;
        const replacementFont = fontCatalog.fonts.find((font) => font.name === "Extra");
        const replacementGlyph = new GlyphData_1.GlyphData(65533, "Specials", replacementJson.chars[0].width, replacementJson.chars[0].height, replacementJson.chars[0].xadvance, replacementJson.chars[0].xoffset, replacementJson.chars[0].yoffset, 0.0, 0.0, 1.0, 1.0, replacementTexture, replacementFont);
        const fontCatalogInfo = new FontCatalog(url.href.substr(0, url.href.lastIndexOf("/")), fontCatalog.name, fontCatalog.type, fontCatalog.size, fontCatalog.maxWidth, fontCatalog.maxHeight, fontCatalog.distanceRange, fontCatalog.fonts, fontCatalog.supportedBlocks, maxCodePointCount, replacementGlyph);
        return fontCatalogInfo;
    }
    static async loadTexture(url) {
        return new Promise(resolve => {
            new THREE.TextureLoader().load(url, resolve);
        });
    }
    static async loadJSON(url) {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`${url} Status Text:  ${response.statusText}`);
        }
        const rawJSON = await response.text();
        return JSON.parse(rawJSON);
    }
    /**
     * Release all allocated resources.
     */
    dispose() {
        this.fonts.length = 0;
        this.unicodeBlocks.length = 0;
        this.m_glyphTextureCache.dispose();
        this.m_loadingJson.clear();
        this.m_loadingPages.clear();
        this.m_loadingGlyphs.clear();
        this.m_loadedJson.clear();
        this.m_loadedPages.clear();
        this.m_loadedGlyphs.clear();
    }
    /**
     * Removes all loaded (and loading) assets.
     */
    clear() {
        this.m_glyphTextureCache.clear();
        this.m_loadingJson.clear();
        this.m_loadingPages.clear();
        this.m_loadingGlyphs.clear();
        this.m_loadedJson.clear();
        this.m_loadedPages.clear();
        this.m_loadedGlyphs.clear();
    }
    /**
     * Updates the internal WebGLRenderTarget.
     * The update will copy the newly introduced glyphs since the previous update.
     *
     * @param renderer WebGLRenderer.
     */
    update(renderer) {
        this.m_glyphTextureCache.update(renderer);
    }
    /**
     * Internal WebGL Texture.
     */
    get texture() {
        return this.m_glyphTextureCache.texture;
    }
    /**
     * Internal WebGL Texture size.
     */
    get textureSize() {
        return this.m_glyphTextureCache.textureSize;
    }
    /**
     * Current internal loading state.
     */
    get isLoading() {
        return (this.m_loadingJson.size > 0 ||
            this.m_loadingPages.size > 0 ||
            this.m_loadingGlyphs.size > 0);
    }
    /**
     * Loads the description file for a specific [[UnicodeBlock]]. This speeds up consequent calls
     * to `FontCatalog`.loadCharset() that require glyphs from this block to be loaded.
     *
     * @param block Requested [[UnicodeBlock]].
     * @param font [[Font]] to retrieve this Unicode block from.
     * @param fontStyle [[FontStyle]] assets to load.
     * @param loadPages If `true`, all pages in this Unicode block will also be loaded.
     *
     * @returns Loaded Unicode Block json.
     */
    async loadBlock(block, font, fontStyle, loadPages) {
        const assetsPath = this.getAssetsPath(fontStyle, font);
        const jsonPath = `${assetsPath}/${block.name.replace(/ /g, "_")}.json`;
        let json = this.m_loadedJson.get(jsonPath);
        if (json === undefined) {
            let jsonPromise = this.m_loadingJson.get(jsonPath);
            if (jsonPromise === undefined) {
                try {
                    jsonPromise = FontCatalog.loadJSON(jsonPath);
                    this.m_loadingJson.set(jsonPath, jsonPromise);
                    json = await jsonPromise;
                    this.m_loadingJson.delete(jsonPath);
                    this.m_loadedJson.set(jsonPath, json);
                }
                catch (e) {
                    // tslint:disable-next-line:no-console
                    console.error(e);
                    this.m_loadingJson.delete(jsonPath);
                }
            }
            else {
                json = await jsonPromise;
            }
        }
        const pagePromises = [];
        if (loadPages === true) {
            for (const page of json.pages) {
                pagePromises.push(this.loadPage(`${assetsPath}/${page}`));
            }
        }
        await Promise.all(pagePromises);
        return json;
    }
    /**
     * Releases the description file for a specific [[UnicodeBlock]] (and all downloaded pages).
     * Safe to call when no assets for this block have been loaded.
     *
     * @param block Requested [[UnicodeBlock]].
     * @param font [[Font]] to remove this Unicode block from.
     * @param fontStyle [[FontStyle]] assets to remove.
     */
    removeBlock(block, font, fontStyle) {
        const assetsPath = this.getAssetsPath(fontStyle, font);
        const jsonPath = `${assetsPath}/${block.name.replace(/ /g, "_")}.json`;
        const json = this.m_loadedJson.get(jsonPath);
        if (json !== undefined) {
            for (const page of json.pages) {
                const pagePath = `${assetsPath}/${page}`;
                this.m_loadingPages.delete(pagePath);
                this.m_loadedPages.delete(pagePath);
            }
            this.m_loadingJson.delete(jsonPath);
            this.m_loadedJson.delete(jsonPath);
        }
    }
    /**
     * Loads all the required glyphs needed to render the input text. Character repetition will not
     * be considered, and only styled assets (with applied font selection, style and variants) will
     * be loaded.
     *
     * @param input Input text.
     * @param style Specific [[TextRenderStyle]] for which glyphs will be loaded.
     *
     * @returns Promise containing an array of all loaded [[GlyphData]] for the input text.
     */
    async loadCharset(input, style) {
        const fontName = style.fontName;
        const fontStyle = style.fontStyle;
        const shouldTransform = style.fontVariant === TextStyle_1.FontVariant.AllCaps ||
            style.fontVariant === TextStyle_1.FontVariant.SmallCaps;
        const charset = (shouldTransform ? input.toUpperCase() : input).replace(/[\s\S](?=([\s\S]+))/g, (c, s) => {
            return s.indexOf(c) + 1 ? "" : c;
        });
        const glyphPromises = [];
        for (const char of charset) {
            const codePoint = char.codePointAt(0);
            const font = this.getFont(codePoint, fontName);
            const fontHash = `${font.name}_${fontStyle}`;
            const glyphHash = `${fontHash}_${codePoint}`;
            let fontGlyphMap = this.m_loadedGlyphs.get(fontHash);
            if (fontGlyphMap === undefined) {
                fontGlyphMap = new Map();
                this.m_loadedGlyphs.set(fontHash, fontGlyphMap);
            }
            const glyph = fontGlyphMap.get(codePoint);
            if (glyph === undefined) {
                let glyphPromise = this.m_loadingGlyphs.get(glyphHash);
                if (glyphPromise === undefined) {
                    if (font.charset.indexOf(String.fromCodePoint(codePoint)) === -1) {
                        const replacementGlyph = this.createReplacementGlyph(codePoint, char, font);
                        fontGlyphMap.set(codePoint, replacementGlyph);
                        this.m_glyphTextureCache.add(glyphHash, replacementGlyph);
                        continue;
                    }
                    let charUnicodeBlock;
                    for (const block of this.unicodeBlocks) {
                        if (codePoint >= block.min && codePoint <= block.max) {
                            charUnicodeBlock = block;
                            break;
                        }
                    }
                    glyphPromise = this.loadAssets(codePoint, fontStyle, charUnicodeBlock, font);
                    this.m_loadingGlyphs.set(glyphHash, glyphPromise);
                    glyphPromise.then((loadedGlyph) => {
                        this.m_loadingGlyphs.delete(glyphHash);
                        fontGlyphMap.set(codePoint, loadedGlyph);
                        this.m_glyphTextureCache.add(glyphHash, loadedGlyph);
                    });
                }
                glyphPromises.push(glyphPromise);
            }
            else if (!this.m_glyphTextureCache.has(glyphHash)) {
                glyphPromises.push(Promise.resolve(glyph));
                this.m_glyphTextureCache.add(glyphHash, glyph);
            }
        }
        return Promise.all(glyphPromises);
    }
    /**
     * Retrieves the loaded [[GlyphData]] for a specific character.
     * Returns `undefined` if the assets for this glyph haven't been loaded yet.
     *
     * @param codePoint Character's Unicode code point.
     * @param font [[Font]] to get this glyph from.
     * @param fontStyle Specific [[FontStyle]] to get glyphs for.
     *
     * @returns [[GlyphData]] for this code point.
     */
    getGlyph(codePoint, font, fontStyle) {
        const fontGlyphMap = this.m_loadedGlyphs.get(`${font.name}_${fontStyle}`);
        if (fontGlyphMap === undefined) {
            return undefined;
        }
        return fontGlyphMap.get(codePoint);
    }
    /**
     * Retrieves the loaded [[GlyphData]] for the specified text.
     * Returns `undefined` if the assets for these glyphs haven't been loaded yet.
     *
     * @param input Input text.
     * @param style Specific [[TextRenderStyle]] to get glyphs for.
     * @param letterCaseArray Array containing the original letter case for the requested glyphs.
     *
     * @returns Array containing [[GlyphData]] for each character of the input text.
     */
    getGlyphs(input, style, letterCaseArray) {
        const result = [];
        const fontName = style.fontName;
        const fontStyle = style.fontStyle;
        const fontVariant = style.fontVariant;
        const shouldTransform = fontVariant === TextStyle_1.FontVariant.AllCaps || fontVariant === TextStyle_1.FontVariant.SmallCaps;
        for (const character of input) {
            const transformedCharacter = shouldTransform ? character.toUpperCase() : character;
            for (const char of transformedCharacter) {
                const codePoint = char.codePointAt(0);
                const font = this.getFont(codePoint, fontName);
                const glyphData = this.getGlyph(codePoint, font, fontStyle);
                if (glyphData !== undefined) {
                    result.push(glyphData);
                    if (letterCaseArray !== undefined) {
                        letterCaseArray.push(char !== character);
                    }
                }
                else {
                    return undefined;
                }
            }
        }
        return result;
    }
    /**
     * Gets the best matched font for a specific character.
     *
     * @param codePoint Character's Unicode code point.
     * @param fontName Font name suggestion.
     *
     * @returns Best matched font.
     */
    getFont(codePoint, fontName) {
        let selectedFontName = this.fonts[0].name;
        for (const block of this.unicodeBlocks) {
            if (codePoint >= block.min && codePoint <= block.max) {
                selectedFontName =
                    fontName !== undefined &&
                        block.fonts.find(element => {
                            return element === fontName;
                        }) !== undefined
                        ? fontName
                        : block.fonts[0];
                break;
            }
        }
        return this.fonts.find(element => {
            return element.name === selectedFontName;
        });
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `FontCatalog`.
     *
     * @param info The info object to increment with the values from this `FontCatalog`.
     */
    updateMemoryUsage(info) {
        let numBytes = 0;
        for (const block of this.unicodeBlocks) {
            numBytes += (block.max - block.min) * 2;
        }
        // Always stored in RGBA internally.
        let textureBytes = this.m_glyphTextureCache.textureSize.x * this.m_glyphTextureCache.textureSize.y * 4;
        for (const page in this.m_loadedPages.entries) {
            if (this.m_loadedPages.get(page) !== undefined) {
                const loadedPage = this.m_loadedPages.get(page);
                if (loadedPage !== undefined) {
                    textureBytes += loadedPage.image.width * loadedPage.image.height * 4;
                }
            }
        }
        info.heapSize += numBytes + textureBytes;
        info.gpuSize += textureBytes;
    }
    createReplacementGlyph(codePoint, char, font) {
        const replacementGlyph = this.m_replacementGlyph.clone();
        replacementGlyph.codePoint = codePoint;
        replacementGlyph.character = char;
        replacementGlyph.font = font;
        return replacementGlyph;
    }
    async loadAssets(codePoint, fontStyle, block, font) {
        const json = await this.loadBlock(block, font, fontStyle);
        if (json === undefined) {
            return this.m_replacementGlyph;
        }
        const sourceGlyphData = json.chars.find(char => char.id === codePoint);
        const assetsPath = this.getAssetsPath(fontStyle, font);
        const texturePath = `${assetsPath}/${json.pages[sourceGlyphData.page]}`;
        const texture = await this.loadPage(texturePath);
        const glyphData = new GlyphData_1.GlyphData(sourceGlyphData.id, block.name, sourceGlyphData.width, sourceGlyphData.height, sourceGlyphData.xadvance, sourceGlyphData.xoffset, sourceGlyphData.yoffset, sourceGlyphData.x / texture.image.width, 1.0 - (sourceGlyphData.y + sourceGlyphData.height) / texture.image.height, (sourceGlyphData.x + sourceGlyphData.width) / texture.image.width, 1.0 - sourceGlyphData.y / texture.image.height, texture, font);
        return glyphData;
    }
    async loadPage(pagePath) {
        let page = this.m_loadedPages.get(pagePath);
        if (page === undefined) {
            let pagePromise = this.m_loadingPages.get(pagePath);
            if (pagePromise === undefined) {
                pagePromise = FontCatalog.loadTexture(pagePath);
                this.m_loadingPages.set(pagePath, pagePromise);
                page = await pagePromise;
                page.wrapS = THREE.ClampToEdgeWrapping;
                page.wrapT = THREE.ClampToEdgeWrapping;
                page.minFilter = THREE.NearestFilter;
                page.needsUpdate = true;
                if (this.m_loadingPages.delete(pagePath)) {
                    this.m_loadedPages.set(pagePath, page);
                }
                this.m_loadingPages.delete(pagePath);
            }
            else {
                page = await pagePromise;
            }
        }
        return page;
    }
    getAssetsPath(fontStyle, font) {
        let fontStylePath = ASSETS_PATH;
        switch (fontStyle) {
            case TextStyle_1.FontStyle.Bold:
                if (font.bold !== undefined) {
                    fontStylePath = BOLD_ASSETS_PATH;
                }
                break;
            case TextStyle_1.FontStyle.Italic:
                if (font.italic !== undefined) {
                    fontStylePath = ITALIC_ASSETS_PATH;
                }
                break;
            case TextStyle_1.FontStyle.BoldItalic:
                if (font.boldItalic !== undefined) {
                    fontStylePath = BOLD_ITALIC_ASSETS_PATH;
                }
                else if (font.italic !== undefined) {
                    fontStylePath = ITALIC_ASSETS_PATH;
                }
                else if (font.bold !== undefined) {
                    fontStylePath = BOLD_ASSETS_PATH;
                }
                break;
        }
        return `${this.url}/${this.name}${fontStylePath}${font.name}`;
    }
}
exports.FontCatalog = FontCatalog;


/***/ }),

/***/ "../harp-text-canvas/lib/rendering/GlyphData.ts":
/*!******************************************************!*\
  !*** ../harp-text-canvas/lib/rendering/GlyphData.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const UnicodeUtils_1 = __webpack_require__(/*! ../utils/UnicodeUtils */ "../harp-text-canvas/lib/utils/UnicodeUtils.ts");
/**
 * Structure containing all the required information necessary to render a BMFont glyph using
 * [[TextCanvas]].
 */
class GlyphData {
    /**
     * Creates a new `GlyphData` object.
     *
     * @param codePoint Unicode code point.
     * @param block Unicode block.
     * @param width Glyph' width.
     * @param height Glyph' height.
     * @param advanceX Amount of pixel to move after placing this glyph.
     * @param offsetX Horizontal offset from the glyph' origin.
     * @param offsetY Vertical offset from the glyph' origin.
     * @param u0 Glyph' left texture coordinate.
     * @param v0 Glyph' bottom texture coordinate.
     * @param u1 Glyph' right texture coordinate.
     * @param v1 Glyph' top texture coordinate.
     * @param texture Glyph' source texture atlas page.
     * @param font Glyph' font.
     *
     * @returns New `GlyphData`.
     */
    constructor(codePoint, block, width, height, advanceX, offsetX, offsetY, u0, v0, u1, v1, texture, font) {
        this.codePoint = codePoint;
        this.block = block;
        this.width = width;
        this.height = height;
        this.advanceX = advanceX;
        this.offsetX = offsetX;
        this.offsetY = offsetY;
        this.texture = texture;
        this.font = font;
        /**
         * Array containing the positions for all corners of this glyph.
         */
        this.positions = [];
        /**
         * Array containing the source texture coordinates for all corners of this glyph.
         * Used to sample the original texture atlas pages.
         */
        this.sourceTextureCoordinates = [];
        /**
         * Array containing the dynamic texture coordinates for all corners of this glyph.
         * Used to sample the dynamic texture atlas page.
         */
        this.dynamicTextureCoordinates = [];
        /**
         * Source texture atlas' page copy index.
         */
        this.copyIndex = 0;
        /**
         * Flag indicating if glyph can be currently rendered.
         */
        this.isInCache = false;
        this.character = String.fromCodePoint(codePoint);
        this.direction = UnicodeUtils_1.UnicodeUtils.getDirection(codePoint, block);
        const left = this.offsetX;
        const right = left + this.width;
        const top = font.metrics.lineHeight - this.offsetY;
        const bottom = top - this.height;
        this.positions.push(new THREE.Vector3(left, bottom, 1.0), new THREE.Vector3(right, bottom, 1.0), new THREE.Vector3(left, top, 1.0), new THREE.Vector3(right, top, 1.0));
        this.sourceTextureCoordinates.push(new THREE.Vector2(u0, v0), new THREE.Vector2(u1, v0), new THREE.Vector2(u0, v1), new THREE.Vector2(u1, v1));
        this.dynamicTextureCoordinates.push(new THREE.Vector2(0.0, 0.0), new THREE.Vector2(1.0, 0.0), new THREE.Vector2(0.0, 1.0), new THREE.Vector2(1.0, 1.0));
    }
    /**
     * Clone this `GlyphData`.
     *
     * @returns Cloned `GlyphData`.
     */
    clone() {
        return new GlyphData(this.codePoint, this.block, this.width, this.height, this.advanceX, this.offsetX, this.offsetY, this.sourceTextureCoordinates[0].x, this.sourceTextureCoordinates[0].y, this.sourceTextureCoordinates[3].x, this.sourceTextureCoordinates[3].y, this.texture, this.font);
    }
}
exports.GlyphData = GlyphData;


/***/ }),

/***/ "../harp-text-canvas/lib/rendering/GlyphTextureCache.ts":
/*!**************************************************************!*\
  !*** ../harp-text-canvas/lib/rendering/GlyphTextureCache.ts ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_lrucache_1 = __webpack_require__(/*! @here/harp-lrucache */ "../harp-lrucache/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const GlyphData_1 = __webpack_require__(/*! ./GlyphData */ "../harp-text-canvas/lib/rendering/GlyphData.ts");
const TextMaterials_1 = __webpack_require__(/*! ./TextMaterials */ "../harp-text-canvas/lib/rendering/TextMaterials.ts");
/**
 * Maximum number of texture atlas pages we can copy from in a single go. This amount is determined
 * by the maximum number of texture units available on a pixel shader for all devices:
 * https://webglstats.com/webgl/parameter/MAX_TEXTURE_IMAGE_UNITS
 */
const MAX_NUM_COPY_PAGES = 8;
/**
 * Maximum texture size supported. This amount is determined by the maximum texture size supported
 * for all devices:
 * https://webglstats.com/webgl/parameter/MAX_TEXTURE_SIZE
 */
const MAX_TEXTURE_SIZE = 4096;
/**
 * @hidden
 * Unified glyph SDF bitmap storage for all fonts in a [[FontCatalog]].
 * Implemented as an abstraction layer on top of an LRUCache and WebGLRenderTarget.
 */
class GlyphTextureCache {
    /**
     * Creates a `GlyphTextureCache` object.
     *
     * @param capacity Cache's maximum glyph capacity.
     * @param entryWidth Maximum entry width.
     * @param entryHeight Maximum entry height.
     *
     * @returns New `GlyphTextureCache`.
     */
    constructor(capacity, entryWidth, entryHeight) {
        this.capacity = capacity;
        this.entryWidth = entryWidth;
        this.entryHeight = entryHeight;
        const nRows = Math.floor(Math.sqrt(capacity));
        this.m_cacheHeight = nRows * nRows < capacity ? nRows + 1 : nRows;
        this.m_cacheWidth = nRows * this.m_cacheHeight < capacity ? nRows + 1 : nRows;
        this.m_textureSize = new THREE.Vector2(this.m_cacheWidth * entryWidth, this.m_cacheHeight * entryHeight);
        if (this.m_textureSize.y > MAX_TEXTURE_SIZE || this.m_textureSize.x > MAX_TEXTURE_SIZE) {
            // tslint:disable-next-line:no-console
            console.warn("GlyphTextureCache texture size (" +
                this.m_textureSize.x +
                ", " +
                this.m_textureSize.y +
                ") exceeds WebGL's widely supported MAX_TEXTURE_SIZE (" +
                MAX_TEXTURE_SIZE +
                ").\n" +
                "This could result in rendering errors on some devices.\n" +
                "Please consider reducing its capacity or input assets size.");
        }
        this.m_entryCache = new harp_lrucache_1.LRUCache(capacity);
        this.initCacheEntries();
        this.m_scene = new THREE.Scene();
        this.m_camera = new THREE.OrthographicCamera(0, this.m_textureSize.x, this.m_textureSize.y, 0);
        this.m_camera.position.z = 1;
        this.m_camera.updateMatrixWorld(false);
        this.m_rt = new THREE.WebGLRenderTarget(this.m_textureSize.x, this.m_textureSize.y, {
            wrapS: THREE.ClampToEdgeWrapping,
            wrapT: THREE.ClampToEdgeWrapping,
            depthBuffer: false,
            stencilBuffer: false
        });
        this.m_copyTextureSet = new Set();
        this.m_copyTransform = new THREE.Matrix3();
        this.m_copyPositions = [];
        this.m_copyPositions.push(new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2());
        this.m_copyMaterial = new TextMaterials_1.GlyphCopyMaterial();
        this.m_copyVertexBuffer = new THREE.InterleavedBuffer(new Float32Array(capacity * 20), 5);
        this.m_copyVertexBuffer.setUsage(THREE.DynamicDrawUsage);
        this.m_copyPositionAttribute = new THREE.InterleavedBufferAttribute(this.m_copyVertexBuffer, 3, 0);
        this.m_copyUVAttribute = new THREE.InterleavedBufferAttribute(this.m_copyVertexBuffer, 2, 3);
        this.m_copyGeometry = new THREE.BufferGeometry();
        this.m_copyGeometry.setAttribute("position", this.m_copyPositionAttribute);
        this.m_copyGeometry.setAttribute("uv", this.m_copyUVAttribute);
        const copyIndexBuffer = new THREE.BufferAttribute(new Uint32Array(capacity * 6), 1);
        copyIndexBuffer.setUsage(THREE.DynamicDrawUsage);
        this.m_copyGeometry.setIndex(copyIndexBuffer);
        this.m_copyMesh = new THREE.Mesh(this.m_copyGeometry, this.m_copyMaterial);
        this.m_copyMesh.frustumCulled = false;
        this.m_copyGeometryDrawCount = 0;
        this.m_clearMaterial = new TextMaterials_1.GlyphClearMaterial();
        this.m_clearPositionAttribute = new THREE.BufferAttribute(new Float32Array(capacity * 8), 2);
        this.m_clearPositionAttribute.setUsage(THREE.DynamicDrawUsage);
        this.m_clearGeometry = new THREE.BufferGeometry();
        this.m_clearGeometry.setAttribute("position", this.m_clearPositionAttribute);
        const clearIndexBuffer = new THREE.BufferAttribute(new Uint32Array(capacity * 6), 1);
        clearIndexBuffer.setUsage(THREE.DynamicDrawUsage);
        this.m_clearGeometry.setIndex(clearIndexBuffer);
        this.m_clearMesh = new THREE.Mesh(this.m_clearGeometry, this.m_clearMaterial);
        this.m_clearMesh.frustumCulled = false;
        this.m_clearGeometryDrawCount = 0;
        this.m_scene.add(this.m_clearMesh, this.m_copyMesh);
    }
    /**
     * Release all allocated resources.
     */
    dispose() {
        this.m_entryCache.clear();
        this.m_scene.remove(this.m_clearMesh, this.m_copyMesh);
        this.m_rt.dispose();
        this.m_clearMaterial.dispose();
        this.m_copyMaterial.dispose();
        this.m_copyTextureSet.clear();
        this.m_clearGeometry.dispose();
        this.m_copyGeometry.dispose();
    }
    /**
     * Internal WebGL Texture.
     */
    get texture() {
        return this.m_rt.texture;
    }
    /**
     * Internal WebGL Texture size.
     */
    get textureSize() {
        return this.m_textureSize;
    }
    /**
     * Add a new entry to the GlyphTextureCache. If the limit of entries is hit, the least requested
     * entry will be replaced.
     *
     * @param hash Entry's hash.
     * @param glyph Entry's glyph data.
     */
    add(hash, glyph) {
        const entry = this.m_entryCache.get(hash);
        if (entry !== undefined) {
            return;
        }
        const oldestEntry = this.m_entryCache.oldest;
        if (oldestEntry === null) {
            throw new Error("GlyphTextureCache is uninitialized!");
        }
        this.clearCacheEntry(oldestEntry.value);
        this.copyGlyphToCache(hash, glyph, oldestEntry.value.location);
    }
    /**
     * Checks if an entry is in the cache.
     *
     * @param hash Entry's hash.
     *
     * @returns Test result.
     */
    has(hash) {
        return this.m_entryCache.has(hash);
    }
    /**
     * Retrieves an entry from the cache.
     *
     * @param hash Entry's hash.
     *
     * @returns Retrieval result.
     */
    get(hash) {
        return this.m_entryCache.get(hash);
    }
    /**
     * Clears the internal LRUCache.
     */
    clear() {
        this.m_copyGeometryDrawCount = 0;
        this.m_clearGeometryDrawCount = 0;
        this.m_entryCache.clear();
        this.m_copyTextureSet.clear();
        this.initCacheEntries();
    }
    /**
     * Updates the internal WebGLRenderTarget.
     * The update will copy the newly introduced glyphs since the previous update.
     *
     * @param renderer WebGLRenderer.
     */
    update(renderer) {
        let oldRenderTarget = null;
        const willClearGeometry = this.m_clearGeometryDrawCount > 0;
        const willCopyGeometry = this.m_copyGeometryDrawCount > 0;
        if (willClearGeometry || willCopyGeometry) {
            oldRenderTarget = renderer.getRenderTarget();
            renderer.setRenderTarget(this.m_rt);
        }
        if (willClearGeometry) {
            if (this.m_clearGeometry.index === null) {
                throw new Error("GlyphTextureCache clear geometry index is uninitialized!");
            }
            this.m_clearPositionAttribute.needsUpdate = true;
            this.m_clearPositionAttribute.updateRange.offset = 0;
            this.m_clearPositionAttribute.updateRange.count = this.m_clearGeometryDrawCount * 8;
            this.m_clearGeometry.index.needsUpdate = true;
            this.m_clearGeometry.index.updateRange.offset = 0;
            this.m_clearGeometry.index.updateRange.count = this.m_clearGeometryDrawCount * 6;
            this.m_clearGeometry.setDrawRange(0, this.m_clearGeometryDrawCount * 6);
            this.m_clearMesh.visible = true;
            this.m_copyMesh.visible = false;
            renderer.render(this.m_scene, this.m_camera);
            this.m_clearGeometryDrawCount = 0;
            this.m_clearMesh.visible = false;
        }
        if (willCopyGeometry) {
            if (this.m_copyGeometry.index === null) {
                throw new Error("GlyphTextureCache copy geometry index is uninitialized!");
            }
            this.m_copyVertexBuffer.needsUpdate = true;
            this.m_copyVertexBuffer.updateRange.offset = 0;
            this.m_copyVertexBuffer.updateRange.count = this.m_copyGeometryDrawCount * 20;
            this.m_copyGeometry.index.needsUpdate = true;
            this.m_copyGeometry.index.updateRange.offset = 0;
            this.m_copyGeometry.index.updateRange.count = this.m_copyGeometryDrawCount * 6;
            this.m_copyGeometry.setDrawRange(0, this.m_copyGeometryDrawCount * 6);
            this.m_copyMesh.visible = true;
            const srcPages = Array.from(this.m_copyTextureSet);
            const nCopies = Math.ceil(this.m_copyTextureSet.size / MAX_NUM_COPY_PAGES);
            for (let copyIndex = 0; copyIndex < nCopies; copyIndex++) {
                const pageOffset = copyIndex * MAX_NUM_COPY_PAGES;
                this.m_copyMaterial.uniforms.pageOffset.value = pageOffset;
                for (let i = 0; i < MAX_NUM_COPY_PAGES; i++) {
                    const pageIndex = pageOffset + i;
                    if (pageIndex < this.m_copyTextureSet.size) {
                        this.m_copyMaterial.uniforms["page" + i].value = srcPages[pageIndex];
                    }
                }
                renderer.render(this.m_scene, this.m_camera);
            }
            this.m_copyTextureSet.clear();
            this.m_copyGeometryDrawCount = 0;
        }
        if (willClearGeometry || willCopyGeometry) {
            renderer.setRenderTarget(oldRenderTarget);
        }
    }
    initCacheEntries() {
        const dummyMetrics = {
            size: 0,
            distanceRange: 0,
            base: 0,
            lineHeight: 0,
            lineGap: 0,
            capHeight: 0,
            xHeight: 0
        };
        const dummyFont = {
            name: "",
            metrics: dummyMetrics,
            charset: ""
        };
        const dummyGlyphData = new GlyphData_1.GlyphData(0, "", 0, 0, 0, 0, 0, 0, 0, 0, 0, THREE.Texture.DEFAULT_IMAGE, dummyFont);
        for (let i = 0; i < this.m_cacheHeight; i++) {
            for (let j = 0; j < this.m_cacheWidth; j++) {
                const dummyEntry = {
                    glyphData: dummyGlyphData,
                    location: new THREE.Vector2(j, i)
                };
                this.m_entryCache.set(`Dummy_${i * this.m_cacheHeight + j}`, dummyEntry);
            }
        }
    }
    copyGlyphToCache(hash, glyph, cacheLocation) {
        this.m_copyTextureSet.add(glyph.texture);
        let copyTextureIndex = 0;
        for (const value of this.m_copyTextureSet.values()) {
            if (value === glyph.texture) {
                break;
            }
            copyTextureIndex++;
        }
        glyph.copyIndex = copyTextureIndex;
        this.m_copyTransform.set(1.0, 0.0, cacheLocation.x * this.entryWidth - glyph.offsetX, 0.0, 1.0, cacheLocation.y * this.entryHeight - glyph.positions[0].y, 0.0, 0.0, 0.0);
        for (let i = 0; i < 4; ++i) {
            this.m_copyPositions[i].set(glyph.positions[i].x, glyph.positions[i].y);
            this.m_copyPositions[i].applyMatrix3(this.m_copyTransform);
        }
        if (this.m_copyGeometryDrawCount >= this.capacity) {
            return;
        }
        const baseVertex = this.m_copyGeometryDrawCount * 4;
        const baseIndex = this.m_copyGeometryDrawCount * 6;
        for (let i = 0; i < 4; ++i) {
            this.m_copyPositionAttribute.setXYZ(baseVertex + i, this.m_copyPositions[i].x, this.m_copyPositions[i].y, glyph.copyIndex);
            this.m_copyUVAttribute.setXY(baseVertex + i, glyph.sourceTextureCoordinates[i].x, glyph.sourceTextureCoordinates[i].y);
        }
        if (this.m_copyGeometry.index === null) {
            throw new Error("GlyphTextureCache copy geometry index is uninitialized!");
        }
        this.m_copyGeometry.index.setX(baseIndex, baseVertex);
        this.m_copyGeometry.index.setX(baseIndex + 1, baseVertex + 1);
        this.m_copyGeometry.index.setX(baseIndex + 2, baseVertex + 2);
        this.m_copyGeometry.index.setX(baseIndex + 3, baseVertex + 2);
        this.m_copyGeometry.index.setX(baseIndex + 4, baseVertex + 1);
        this.m_copyGeometry.index.setX(baseIndex + 5, baseVertex + 3);
        ++this.m_copyGeometryDrawCount;
        const u0 = this.m_copyPositions[0].x / this.m_textureSize.x;
        const v0 = this.m_copyPositions[0].y / this.m_textureSize.y;
        const u1 = this.m_copyPositions[3].x / this.m_textureSize.x;
        const v1 = this.m_copyPositions[3].y / this.m_textureSize.y;
        glyph.dynamicTextureCoordinates[0].set(u0, v0);
        glyph.dynamicTextureCoordinates[1].set(u1, v0);
        glyph.dynamicTextureCoordinates[2].set(u0, v1);
        glyph.dynamicTextureCoordinates[3].set(u1, v1);
        glyph.isInCache = true;
        this.m_entryCache.set(hash, {
            glyphData: glyph,
            location: cacheLocation
        });
    }
    clearCacheEntry(entry) {
        entry.glyphData.isInCache = false;
        this.m_copyPositions[0].set(entry.location.x * this.entryWidth, entry.location.y * this.entryHeight);
        this.m_copyPositions[1].set((entry.location.x + 1) * this.entryWidth, entry.location.y * this.entryHeight);
        this.m_copyPositions[2].set(entry.location.x * this.entryWidth, (entry.location.y + 1) * this.entryHeight);
        this.m_copyPositions[3].set((entry.location.x + 1) * this.entryWidth, (entry.location.y + 1) * this.entryHeight);
        if (this.m_clearGeometryDrawCount >= this.capacity) {
            return;
        }
        const baseVertex = this.m_clearGeometryDrawCount * 4;
        const baseIndex = this.m_clearGeometryDrawCount * 6;
        for (let i = 0; i < 4; ++i) {
            this.m_clearPositionAttribute.setXY(baseVertex + i, this.m_copyPositions[i].x, this.m_copyPositions[i].y);
        }
        if (this.m_clearGeometry.index === null) {
            throw new Error("GlyphTextureCache clear geometry index is uninitialized!");
        }
        this.m_clearGeometry.index.setX(baseIndex, baseVertex);
        this.m_clearGeometry.index.setX(baseIndex + 1, baseVertex + 1);
        this.m_clearGeometry.index.setX(baseIndex + 2, baseVertex + 2);
        this.m_clearGeometry.index.setX(baseIndex + 3, baseVertex + 2);
        this.m_clearGeometry.index.setX(baseIndex + 4, baseVertex + 1);
        this.m_clearGeometry.index.setX(baseIndex + 5, baseVertex + 3);
        ++this.m_clearGeometryDrawCount;
    }
}
exports.GlyphTextureCache = GlyphTextureCache;


/***/ }),

/***/ "../harp-text-canvas/lib/rendering/TextBufferObject.ts":
/*!*************************************************************!*\
  !*** ../harp-text-canvas/lib/rendering/TextBufferObject.ts ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Object containing vertex buffer data generated by [[TextCanvas]].
 */
class TextBufferObject {
    /**
     * Constructs a new `TextBufferObject`.
     *
     * @param glyphs Input glyphs.
     * @param buffer Buffer containing the data generated by [[TextCanvas]].
     * @param bounds Optional text bounds.
     * @param characterBounds Optional character bounds.
     * @param textRenderStyle [[TextRenderStyle]] applied by [[TextCanvas]].
     * @param textLayoutStyle [[TextLayoutStyle]] applied by [[TextCanvas]].
     *
     * @returns New `TextBufferObject`.
     */
    constructor(glyphs, buffer, bounds, characterBounds, textRenderStyle, textLayoutStyle) {
        this.glyphs = glyphs;
        this.buffer = buffer;
        this.bounds = bounds;
        this.characterBounds = characterBounds;
        this.textRenderStyle = textRenderStyle;
        this.textLayoutStyle = textLayoutStyle;
    }
}
exports.TextBufferObject = TextBufferObject;


/***/ }),

/***/ "../harp-text-canvas/lib/rendering/TextGeometry.ts":
/*!*********************************************************!*\
  !*** ../harp-text-canvas/lib/rendering/TextGeometry.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const THREE = __webpack_require__(/*! three */ "three");
exports.MAX_CAPACITY = 65536;
exports.VERTEX_BUFFER_STRIDE = 16;
exports.INDEX_BUFFER_STRIDE = 1;
exports.VERTICES_PER_QUAD = 4;
exports.INDICES_PER_QUAD = 6;
exports.QUAD_VERTEX_MEMORY_FOOTPRINT = exports.VERTICES_PER_QUAD * exports.VERTEX_BUFFER_STRIDE;
exports.QUAD_INDEX_MEMORY_FOOTPRINT = exports.INDICES_PER_QUAD * exports.INDEX_BUFFER_STRIDE;
/**
 * Number of bytes for float in an Float32Array.
 */
const NUM_BYTES_PER_FLOAT = 4;
/**
 * Number of bytes for integer number in an UInt32Array.
 */
const NUM_BYTES_PER_INT32 = 4;
/**
 * Procedural geometry that holds vertex attribute data for all glyphs in a [[TextCanvas]].
 */
class TextGeometry {
    /**
     * Creates a new `TextGeometry`.
     *
     * @param material Material used to render foreground glyphs.
     * @param backgroundMaterial Material used to render background glyphs.
     * @param initialSize Initial amount of glyphs that can be stored.
     * @param capacity Maximum glyph capacity.
     *
     * @returns New `TextGeometry`.
     */
    constructor(scene, material, backgroundMaterial, initialSize, capacity) {
        this.scene = scene;
        this.capacity = Math.min(capacity, exports.MAX_CAPACITY);
        this.m_currentCapacity = Math.min(initialSize, capacity);
        this.m_drawCount = 0;
        this.m_updateOffset = 0;
        this.m_pickingCount = 0;
        this.m_vertexBuffer = new THREE.InterleavedBuffer(new Float32Array(this.m_currentCapacity * exports.QUAD_VERTEX_MEMORY_FOOTPRINT), exports.VERTEX_BUFFER_STRIDE);
        this.m_vertexBuffer.setUsage(THREE.DynamicDrawUsage);
        this.m_positionAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 0);
        this.m_uvAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 4);
        this.m_colorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 8);
        this.m_bgColorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 12);
        this.m_indexBuffer = new THREE.BufferAttribute(new Uint32Array(this.m_currentCapacity * exports.QUAD_INDEX_MEMORY_FOOTPRINT), exports.INDEX_BUFFER_STRIDE);
        this.m_indexBuffer.setUsage(THREE.DynamicDrawUsage);
        this.m_geometry = new THREE.BufferGeometry();
        this.m_geometry.setAttribute("position", this.m_positionAttribute);
        this.m_geometry.setAttribute("uv", this.m_uvAttribute);
        this.m_geometry.setAttribute("color", this.m_colorAttribute);
        this.m_geometry.setAttribute("bgColor", this.m_bgColorAttribute);
        this.m_geometry.setIndex(this.m_indexBuffer);
        this.m_pickingDataArray = new Array(this.m_currentCapacity);
        this.m_mesh = new THREE.Mesh(this.m_geometry, material);
        this.m_bgMesh = new THREE.Mesh(this.m_geometry, backgroundMaterial);
        this.m_mesh.renderOrder = Number.MAX_SAFE_INTEGER;
        this.m_bgMesh.renderOrder = Number.MAX_SAFE_INTEGER - 1;
        this.m_mesh.frustumCulled = false;
        this.m_bgMesh.frustumCulled = false;
        this.scene.add(this.m_bgMesh, this.m_mesh);
    }
    /**
     * Count of currently drawn glyphs.
     */
    get drawCount() {
        return this.m_drawCount;
    }
    /**
     * Mesh used to render foreground glyphs.
     */
    get mesh() {
        return this.m_mesh;
    }
    /**
     * Mesh used to render background glyphs.
     */
    get backgroundMesh() {
        return this.m_bgMesh;
    }
    /**
     * Release all allocated resources.
     */
    dispose() {
        this.scene.remove(this.m_bgMesh, this.m_mesh);
        this.m_geometry.dispose();
    }
    /**
     * Clear the geometry.
     */
    clear() {
        this.m_drawCount = 0;
        this.m_updateOffset = 0;
        this.m_pickingCount = 0;
    }
    /**
     * Update the GPU resources to reflect the latest additions to the geometry.
     */
    update() {
        if (this.drawCount > this.m_updateOffset) {
            this.m_vertexBuffer.needsUpdate = true;
            this.m_vertexBuffer.updateRange.offset =
                this.m_updateOffset * exports.QUAD_VERTEX_MEMORY_FOOTPRINT;
            this.m_vertexBuffer.updateRange.count =
                (this.m_drawCount - this.m_updateOffset) * exports.QUAD_VERTEX_MEMORY_FOOTPRINT;
            this.m_indexBuffer.needsUpdate = true;
            this.m_indexBuffer.updateRange.offset =
                this.m_updateOffset * exports.QUAD_INDEX_MEMORY_FOOTPRINT;
            this.m_indexBuffer.updateRange.count =
                (this.m_drawCount - this.m_updateOffset) * exports.QUAD_INDEX_MEMORY_FOOTPRINT;
        }
        this.m_updateOffset = this.m_drawCount;
        this.m_geometry.setDrawRange(0, this.m_drawCount * exports.INDICES_PER_QUAD);
    }
    /**
     * Add a new glyph to the `TextGeometry`.
     *
     * @param glyphData [[GlyphData]] holding the glyph description.
     * @param corners Transformed glyph corners.
     * @param weight Foreground glyph sampling weight.
     * @param bgWeight Foreground glyph sampling weight.
     * @param mirrored If `true`, UVs will be horizontally mirrored (needed for RTL punctuation).
     * @param style Currently set [[TextRenderStyle]].
     *
     * @returns Result of the addition.
     */
    add(glyphData, corners, weight, bgWeight, mirrored, style) {
        if (this.m_drawCount >= this.capacity) {
            return false;
        }
        else if (this.m_drawCount >= this.m_currentCapacity) {
            const newSize = Math.min(this.m_currentCapacity * 2, this.capacity);
            this.resizeBuffers(newSize);
        }
        const baseVertex = this.m_drawCount * exports.VERTICES_PER_QUAD;
        const baseIndex = this.m_drawCount * exports.INDICES_PER_QUAD;
        for (let i = 0; i < exports.VERTICES_PER_QUAD; ++i) {
            this.m_positionAttribute.setXYZW(baseVertex + i, corners[i].x, corners[i].y, corners[i].z, (mirrored ? -1.0 : 1.0) * style.rotation);
            const mirroredUVIdx = mirrored ? ((i + 1) % 2) + Math.floor(i / 2) * 2 : i;
            this.m_uvAttribute.setXYZW(baseVertex + i, glyphData.dynamicTextureCoordinates[mirroredUVIdx].x, glyphData.dynamicTextureCoordinates[mirroredUVIdx].y, weight, bgWeight);
            this.m_colorAttribute.setXYZW(baseVertex + i, style.color.r, style.color.g, style.color.b, style.opacity);
            this.m_bgColorAttribute.setXYZW(baseVertex + i, style.backgroundColor.r, style.backgroundColor.g, style.backgroundColor.b, style.backgroundOpacity);
        }
        this.m_indexBuffer.setX(baseIndex, baseVertex);
        this.m_indexBuffer.setX(baseIndex + 1, baseVertex + 1);
        this.m_indexBuffer.setX(baseIndex + 2, baseVertex + 2);
        this.m_indexBuffer.setX(baseIndex + 3, baseVertex + 2);
        this.m_indexBuffer.setX(baseIndex + 4, baseVertex + 1);
        this.m_indexBuffer.setX(baseIndex + 5, baseVertex + 3);
        ++this.m_drawCount;
        return true;
    }
    /**
     * Add a new glyph to a text buffer.
     *
     * @param buffer Target buffer where glyph attributes will be stored.
     * @param offset Offset of the target buffer.
     * @param glyphData [[GlyphData]] holding the glyph description.
     * @param corners Transformed glyph corners.
     * @param weight Foreground glyph sampling weight.
     * @param bgWeight Foreground glyph sampling weight.
     * @param mirrored If `true`, UVs will be mirrored (needed for RTL punctuation).
     * @param style Currently set [[TextRenderStyle]].
     */
    addToBuffer(buffer, offset, glyphData, corners, weight, bgWeight, mirrored, style) {
        for (let i = 0; i < exports.VERTICES_PER_QUAD; ++i) {
            const vertexOffset = offset + exports.VERTEX_BUFFER_STRIDE * i;
            buffer[vertexOffset] = corners[i].x;
            buffer[vertexOffset + 1] = corners[i].y;
            buffer[vertexOffset + 2] = corners[i].z;
            buffer[vertexOffset + 3] = (mirrored ? -1.0 : 1.0) * style.rotation;
            const mirroredUVIdx = mirrored ? ((i + 1) % 2) + Math.floor(i / 2) * 2 : i;
            buffer[vertexOffset + 4] = glyphData.dynamicTextureCoordinates[mirroredUVIdx].x;
            buffer[vertexOffset + 5] = glyphData.dynamicTextureCoordinates[mirroredUVIdx].y;
            buffer[vertexOffset + 6] = weight;
            buffer[vertexOffset + 7] = bgWeight;
            buffer[vertexOffset + 8] = style.color.r;
            buffer[vertexOffset + 9] = style.color.g;
            buffer[vertexOffset + 10] = style.color.b;
            buffer[vertexOffset + 11] = style.opacity;
            buffer[vertexOffset + 12] = style.backgroundColor.r;
            buffer[vertexOffset + 13] = style.backgroundColor.g;
            buffer[vertexOffset + 14] = style.backgroundColor.b;
            buffer[vertexOffset + 15] = style.backgroundOpacity;
        }
    }
    /**
     * Add a previously computed [[TextBufferObject]] to the `TextGeometry`. Extra parameters can
     * be passed to override the passed attribute data.
     *
     * @param textBufferObject [[TextBufferObject]] containing computed glyphs.
     * @param position Override position value.
     * @param scale Override scale value.
     * @param rotation Override rotation value.
     * @param color Override color value.
     * @param opacity Override opacity value.
     * @param bgColor Override background color value.
     * @param bgOpacity Override background opacity value.
     *
     * @returns Result of the addition.
     */
    addTextBufferObject(textBufferObject, position, scale, rotation, color, opacity, bgColor, bgOpacity) {
        if (this.m_drawCount + textBufferObject.glyphs.length >= this.capacity) {
            return false;
        }
        else if (this.m_drawCount + textBufferObject.glyphs.length >= this.m_currentCapacity) {
            const newSize = Math.min(this.m_currentCapacity * 2, this.capacity);
            this.resizeBuffers(newSize);
        }
        const s = scale || 1.0;
        const r = rotation || 0.0;
        const cosR = Math.cos(r);
        const sinR = Math.sin(r);
        const offsetX = position !== undefined ? position.x : 0.0;
        const offsetY = position !== undefined ? position.y : 0.0;
        const offsetZ = position !== undefined ? position.z : 0.0;
        const buffer = textBufferObject.buffer;
        const rot = buffer[3];
        const rotSign = rot < 0 ? -1.0 : 1.0;
        const red = color !== undefined ? color.r : buffer[8];
        const green = color !== undefined ? color.g : buffer[9];
        const blue = color !== undefined ? color.b : buffer[10];
        const alpha = opacity !== undefined ? opacity : buffer[11];
        const bgRed = bgColor !== undefined ? bgColor.r : buffer[12];
        const bgGreen = bgColor !== undefined ? bgColor.g : buffer[13];
        const bgBlue = bgColor !== undefined ? bgColor.b : buffer[14];
        const bgAlpha = bgOpacity !== undefined ? bgOpacity : buffer[15];
        const targetOffset = this.m_drawCount * exports.VERTICES_PER_QUAD;
        for (let i = 0; i < textBufferObject.glyphs.length; ++i) {
            const srcOffset = i * exports.QUAD_VERTEX_MEMORY_FOOTPRINT;
            const glyph = textBufferObject.glyphs[i];
            if (!glyph.isInCache) {
                return false;
            }
            const mirrored = buffer[srcOffset + 4] > buffer[srcOffset + exports.VERTEX_BUFFER_STRIDE + 4];
            const w = buffer[srcOffset + 6];
            const bw = buffer[srcOffset + 7];
            for (let j = 0; j < exports.VERTICES_PER_QUAD; ++j) {
                const x = buffer[srcOffset + j * exports.VERTEX_BUFFER_STRIDE];
                const y = buffer[srcOffset + j * exports.VERTEX_BUFFER_STRIDE + 1];
                this.m_positionAttribute.setXYZW(targetOffset + i * exports.VERTICES_PER_QUAD + j, x * s * cosR + y * s * -sinR + offsetX, x * s * sinR + y * s * cosR + offsetY, buffer[srcOffset + j * exports.VERTEX_BUFFER_STRIDE + 2] + offsetZ, buffer[srcOffset + j * exports.VERTEX_BUFFER_STRIDE + 3] + rotSign * r);
                const mirroredUVIdx = mirrored ? ((j + 1) % 2) + Math.floor(j / 2) * 2 : j;
                this.m_uvAttribute.setXYZW(targetOffset + i * exports.VERTICES_PER_QUAD + j, glyph.dynamicTextureCoordinates[mirroredUVIdx].x, glyph.dynamicTextureCoordinates[mirroredUVIdx].y, w, (bw - w) / s + w);
                this.m_colorAttribute.setXYZW(targetOffset + i * exports.VERTICES_PER_QUAD + j, red, green, blue, alpha);
                this.m_bgColorAttribute.setXYZW(targetOffset + i * exports.VERTICES_PER_QUAD + j, bgRed, bgGreen, bgBlue, bgAlpha);
            }
            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD);
            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 1, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 1);
            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 2, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 2);
            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 3, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 2);
            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 4, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 1);
            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 5, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 3);
        }
        this.m_drawCount += textBufferObject.glyphs.length;
        return true;
    }
    /**
     * Adds picking data for glyphs from the specified start until the last glyph added.
     *
     * @param startIdx First glyph index that this picking data is associated to.
     * @param endIdx Last glyph index that this picking data is associated to.
     * @param pickingData Picking data to be added.
     */
    addPickingData(startIdx, endIdx, pickingData) {
        if (this.m_pickingCount >= this.m_currentCapacity) {
            return false;
        }
        this.m_pickingDataArray[this.m_pickingCount] = {
            start: Math.min(startIdx, this.capacity),
            end: Math.min(endIdx, this.capacity),
            data: pickingData
        };
        ++this.m_pickingCount;
        return true;
    }
    /**
     * Fill the picking results for the pixel with the given screen coordinate. If multiple glyphs
     * are found, the order of the results is unspecified.
     *
     * @param screenPosition Screen coordinate of picking position.
     * @param pickCallback Callback to be called for every picked element.
     */
    pick(screenPosition, pickCallback) {
        for (const pickingData of this.m_pickingDataArray) {
            if (pickingData === undefined) {
                return;
            }
            for (let i = pickingData.start; i < pickingData.end; ++i) {
                const positionIndex = i * exports.VERTICES_PER_QUAD;
                const minX = Math.min(this.m_positionAttribute.getX(positionIndex + 2), this.m_positionAttribute.getX(positionIndex + 1));
                if (screenPosition.x < minX) {
                    continue;
                }
                const maxX = Math.max(this.m_positionAttribute.getX(positionIndex + 2), this.m_positionAttribute.getX(positionIndex + 1));
                if (screenPosition.x > maxX) {
                    continue;
                }
                const minY = Math.min(this.m_positionAttribute.getY(positionIndex + 2), this.m_positionAttribute.getY(positionIndex + 1));
                if (screenPosition.y < minY) {
                    continue;
                }
                const maxY = Math.max(this.m_positionAttribute.getY(positionIndex + 2), this.m_positionAttribute.getY(positionIndex + 1));
                if (screenPosition.y > maxY) {
                    continue;
                }
                pickCallback(pickingData.data);
                break;
            }
        }
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `TextGeometry`.
     *
     * @param info The info object to increment with the values from this `TextGeometry`.
     */
    updateMemoryUsage(info) {
        const numBytes = this.m_vertexBuffer.count * NUM_BYTES_PER_FLOAT +
            this.m_indexBuffer.count * NUM_BYTES_PER_INT32;
        info.heapSize += numBytes;
        info.gpuSize += numBytes;
    }
    resizeBuffers(size) {
        this.m_currentCapacity = size;
        const newVertexBuffer = new Float32Array(size * exports.QUAD_VERTEX_MEMORY_FOOTPRINT);
        newVertexBuffer.set(this.m_vertexBuffer.array);
        this.m_vertexBuffer = new THREE.InterleavedBuffer(newVertexBuffer, exports.VERTEX_BUFFER_STRIDE);
        this.m_vertexBuffer.setUsage(THREE.DynamicDrawUsage);
        this.m_positionAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 0);
        this.m_uvAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 4);
        this.m_colorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 8);
        this.m_bgColorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 12);
        const newIndexBuffer = new Uint32Array(size * exports.QUAD_INDEX_MEMORY_FOOTPRINT);
        newIndexBuffer.set(this.m_indexBuffer.array);
        this.m_indexBuffer = new THREE.BufferAttribute(newIndexBuffer, exports.INDEX_BUFFER_STRIDE);
        this.m_indexBuffer.setUsage(THREE.DynamicDrawUsage);
        this.m_geometry.dispose();
        this.m_geometry = new THREE.BufferGeometry();
        this.m_geometry.setAttribute("position", this.m_positionAttribute);
        this.m_geometry.setAttribute("uv", this.m_uvAttribute);
        this.m_geometry.setAttribute("color", this.m_colorAttribute);
        this.m_geometry.setAttribute("bgColor", this.m_bgColorAttribute);
        this.m_geometry.setIndex(this.m_indexBuffer);
        this.m_pickingDataArray.length = this.m_currentCapacity;
        this.scene.remove(this.m_bgMesh, this.m_mesh);
        this.m_mesh = new THREE.Mesh(this.m_geometry, this.m_mesh.material);
        this.m_bgMesh = new THREE.Mesh(this.m_geometry, this.m_bgMesh.material);
        this.m_mesh.renderOrder = Number.MAX_SAFE_INTEGER;
        this.m_bgMesh.renderOrder = Number.MAX_SAFE_INTEGER - 1;
        this.m_mesh.frustumCulled = false;
        this.m_bgMesh.frustumCulled = false;
        this.scene.add(this.m_bgMesh, this.m_mesh);
    }
}
exports.TextGeometry = TextGeometry;


/***/ }),

/***/ "../harp-text-canvas/lib/rendering/TextMaterials.ts":
/*!**********************************************************!*\
  !*** ../harp-text-canvas/lib/rendering/TextMaterials.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const SdfShaderChunks = {
    sdf_attributes: `
        attribute vec4 position;
        attribute vec4 uv;
        attribute vec4 color;
        attribute vec4 bgColor;
        `,
    sdf_varying: `
        varying vec4 vColor;
        varying float vWeight;
        varying vec2 vUv;
        varying float vRotation;
        `,
    sdf_varying_computation: `
        #if BG_TEXT
        vColor = bgColor;
        vWeight = uv.w;
        #else
        vColor = color;
        vWeight = uv.z;
        #endif
        vUv = vec2(uv.xy);
        vRotation = position.w;
        `,
    sdf_frag_uniforms: `
        uniform sampler2D sdfTexture;
        uniform vec4 sdfParams;
        `,
    sdf_sampling_functions: `
        float median(float r, float g, float b) {
            return max(min(r, g), min(max(r, g), b));
        }

        float getDistance(vec2 uvOffset) {
            vec3 sample = texture2D(sdfTexture, vUv.xy + uvOffset).rgb;
            #if MSDF
            return median(sample.r, sample.g, sample.b);
            #else
            return sample.r;
            #endif
        }

        float getOpacity(vec2 uvOffset, float weight) {
            vec2 uv = vUv + uvOffset;
            vec2 rotatedUVs = abs(vec2(
                cos(vRotation) * uv.x - sin(vRotation) * uv.y,
                sin(vRotation) * uv.x + cos(vRotation) * uv.y));

            float dx = dFdx(rotatedUVs.x) * sdfParams.x;
            float dy = dFdy(rotatedUVs.y) * sdfParams.y;
            float toPixels = sdfParams.w * inversesqrt( dx * dx + dy * dy );

            float dist = getDistance(uvOffset) + min(weight, 0.5 - 1.0 / sdfParams.w) - 0.5;
            return clamp(dist * toPixels + 0.5, 0.0, 1.0);
        }
        `
};
Object.assign(THREE.ShaderChunk, SdfShaderChunks);
const clearVertexSource = `
    attribute vec2 position;

    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;

    void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xy, 0.0, 1.0);
    }`;
const clearFragmentSource = `
    precision highp float;
    precision highp int;

    void main() {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
    }`;
const copyVertexSource = `
    attribute vec3 position;
    attribute vec2 uv;

    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;

    varying vec3 vUv;

    void main() {
        vUv = vec3(uv.xy, position.z);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xy, 0.0, 1.0);
    }`;
const copyFragmentSource = `
    precision highp float;
    precision highp int;

    uniform float pageOffset;
    uniform sampler2D page0;
    uniform sampler2D page1;
    uniform sampler2D page2;
    uniform sampler2D page3;
    uniform sampler2D page4;
    uniform sampler2D page5;
    uniform sampler2D page6;
    uniform sampler2D page7;

    varying vec3 vUv;

    void main() {
        vec4 sample = vec4(0.0);
        if (vUv.z < pageOffset || vUv.z > (pageOffset + 7.0)) discard;
        else if (vUv.z < pageOffset + 1.0) sample = texture2D(page0, vUv.xy);
        else if (vUv.z < pageOffset + 2.0) sample = texture2D(page1, vUv.xy);
        else if (vUv.z < pageOffset + 3.0) sample = texture2D(page2, vUv.xy);
        else if (vUv.z < pageOffset + 4.0) sample = texture2D(page3, vUv.xy);
        else if (vUv.z < pageOffset + 5.0) sample = texture2D(page4, vUv.xy);
        else if (vUv.z < pageOffset + 6.0) sample = texture2D(page5, vUv.xy);
        else if (vUv.z < pageOffset + 7.0) sample = texture2D(page6, vUv.xy);
        else sample = texture2D(page7, vUv.xy);

        gl_FragColor = sample;
    }`;
const sdfTextVertexSource = `
    #include <sdf_attributes>
    #include <sdf_varying>

    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;

    void main() {
        #include <sdf_varying_computation>
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);
    }`;
const sdfTextFragmentSource = `
    precision highp float;
    precision highp int;

    #include <sdf_varying>
    #include <sdf_frag_uniforms>
    #include <sdf_sampling_functions>

    void main() {
        vec4 color = vColor;
        color.a *= getOpacity(vec2(0.0), vWeight);
        if (color.a < 0.05) {
            discard;
        }
        gl_FragColor = color;
    }`;
/**
 * @hidden
 * Material used for clearing glyphs from a [[GlyphTextureCache]].
 */
class GlyphClearMaterial extends THREE.RawShaderMaterial {
    /**
     * Creates a new `GlyphClearMaterial`.
     *
     * @returns New `GlyphClearMaterial`.
     */
    constructor() {
        const shaderParams = {
            name: "GlyphClearMaterial",
            vertexShader: clearVertexSource,
            fragmentShader: clearFragmentSource,
            uniforms: {},
            depthTest: false,
            depthWrite: false
        };
        super(shaderParams);
    }
}
exports.GlyphClearMaterial = GlyphClearMaterial;
/**
 * @hidden
 * Material used for copying glyphs into a [[GlyphTextureCache]].
 */
class GlyphCopyMaterial extends THREE.RawShaderMaterial {
    /**
     * Creates a new `GlyphCopyMaterial`.
     *
     * @returns New `GlyphCopyMaterial`.
     */
    constructor() {
        const shaderParams = {
            name: "GlyphCopyMaterial",
            vertexShader: copyVertexSource,
            fragmentShader: copyFragmentSource,
            uniforms: {
                pageOffset: new THREE.Uniform(0.0),
                page0: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                page1: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                page2: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                page3: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                page4: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                page5: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                page6: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                page7: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE)
            },
            depthTest: false,
            depthWrite: false
        };
        super(shaderParams);
    }
}
exports.GlyphCopyMaterial = GlyphCopyMaterial;
/**
 * Material designed to render transformable, high quality SDF text.
 */
class SdfTextMaterial extends THREE.RawShaderMaterial {
    /**
     * Creates a new `SdfTextMaterial`.
     *
     * @param params Material parameters.
     *
     * @returns New `SdfTextMaterial`.
     */
    constructor(params) {
        const shaderParams = {
            name: "SdfTextMaterial",
            vertexShader: params.vertexSource !== undefined ? params.vertexSource : sdfTextVertexSource,
            fragmentShader: params.fragmentSource !== undefined ? params.fragmentSource : sdfTextFragmentSource,
            uniforms: {
                sdfTexture: new THREE.Uniform(params.texture),
                sdfParams: new THREE.Uniform(new THREE.Vector4(params.textureSize.x, params.textureSize.y, params.size, params.distanceRange))
            },
            defines: {
                MSDF: params.isMsdf ? 1.0 : 0.0,
                BG_TEXT: params.isBackground ? 1.0 : 0.0
            },
            depthTest: true,
            depthWrite: true,
            side: THREE.DoubleSide,
            transparent: true
        };
        super(shaderParams);
        this.extensions.derivatives = true;
    }
}
exports.SdfTextMaterial = SdfTextMaterial;


/***/ }),

/***/ "../harp-text-canvas/lib/rendering/TextStyle.ts":
/*!******************************************************!*\
  !*** ../harp-text-canvas/lib/rendering/TextStyle.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Unit of measurement used to specify a font's size.
 */
var FontUnit;
(function (FontUnit) {
    FontUnit[FontUnit["Em"] = 0] = "Em";
    FontUnit[FontUnit["Pixel"] = 1] = "Pixel";
    FontUnit[FontUnit["Point"] = 2] = "Point";
    FontUnit[FontUnit["Percent"] = 3] = "Percent";
})(FontUnit = exports.FontUnit || (exports.FontUnit = {}));
/**
 * Style to be used when rendering glyphs.
 */
var FontStyle;
(function (FontStyle) {
    FontStyle[FontStyle["Regular"] = 0] = "Regular";
    FontStyle[FontStyle["Bold"] = 1] = "Bold";
    FontStyle[FontStyle["Italic"] = 2] = "Italic";
    FontStyle[FontStyle["BoldItalic"] = 3] = "BoldItalic";
})(FontStyle = exports.FontStyle || (exports.FontStyle = {}));
/**
 * Variant to be used when rendering.
 */
var FontVariant;
(function (FontVariant) {
    FontVariant[FontVariant["Regular"] = 0] = "Regular";
    FontVariant[FontVariant["AllCaps"] = 1] = "AllCaps";
    FontVariant[FontVariant["SmallCaps"] = 2] = "SmallCaps";
})(FontVariant = exports.FontVariant || (exports.FontVariant = {}));
/**
 * Vertical alignment to be used when placing text.
 */
var VerticalAlignment;
(function (VerticalAlignment) {
    VerticalAlignment[VerticalAlignment["Above"] = 0] = "Above";
    VerticalAlignment[VerticalAlignment["Center"] = -0.5] = "Center";
    VerticalAlignment[VerticalAlignment["Below"] = -1] = "Below";
})(VerticalAlignment = exports.VerticalAlignment || (exports.VerticalAlignment = {}));
/**
 * Horizontal alignment to be used when placing text.
 */
var HorizontalAlignment;
(function (HorizontalAlignment) {
    HorizontalAlignment[HorizontalAlignment["Left"] = 0] = "Left";
    HorizontalAlignment[HorizontalAlignment["Center"] = -0.5] = "Center";
    HorizontalAlignment[HorizontalAlignment["Right"] = -1] = "Right";
})(HorizontalAlignment = exports.HorizontalAlignment || (exports.HorizontalAlignment = {}));
/**
 * Text wrapping rule used when `lineWidth` is reached.
 */
var WrappingMode;
(function (WrappingMode) {
    WrappingMode[WrappingMode["None"] = 0] = "None";
    WrappingMode[WrappingMode["Character"] = 1] = "Character";
    WrappingMode[WrappingMode["Word"] = 2] = "Word";
})(WrappingMode = exports.WrappingMode || (exports.WrappingMode = {}));
/**
 * Namespace containing default values for all members of [[TextRenderParameters]] and
 * [[TextLayoutParameters]].
 */
var DefaultTextStyle;
(function (DefaultTextStyle) {
    DefaultTextStyle.DEFAULT_FONT_NAME = "";
    DefaultTextStyle.DEFAULT_FONT_SIZE = {
        unit: Object.freeze(FontUnit.Pixel),
        size: Object.freeze(16.0),
        backgroundSize: Object.freeze(0.0)
    };
    DefaultTextStyle.DEFAULT_FONT_STYLE = FontStyle.Regular;
    DefaultTextStyle.DEFAULT_FONT_VARIANT = FontVariant.Regular;
    DefaultTextStyle.DEFAULT_ROTATION = 0.0;
    DefaultTextStyle.DEFAULT_COLOR = new THREE.Color(0x000000);
    DefaultTextStyle.DEFAULT_OPACITY = 1.0;
    DefaultTextStyle.DEFAULT_BACKGROUND_COLOR = new THREE.Color(0x000000);
    DefaultTextStyle.DEFAULT_BACKGROUND_OPACITY = 0.0;
    DefaultTextStyle.DEFAULT_TRACKING = 0.0;
    DefaultTextStyle.DEFAULT_LEADING = 0.0;
    DefaultTextStyle.DEFAULT_MAX_LINES = Infinity;
    DefaultTextStyle.DEFAULT_LINE_WIDTH = Infinity;
    DefaultTextStyle.DEFAULT_CANVAS_ROTATION = 0.0;
    DefaultTextStyle.DEFAULT_LINE_ROTATION = 0.0;
    DefaultTextStyle.DEFAULT_WRAPPING_MODE = WrappingMode.Word;
    DefaultTextStyle.DEFAULT_VERTICAL_ALIGNMENT = VerticalAlignment.Above;
    DefaultTextStyle.DEFAULT_HORIZONTAL_ALIGNMENT = HorizontalAlignment.Left;
})(DefaultTextStyle = exports.DefaultTextStyle || (exports.DefaultTextStyle = {}));
/**
 * [[TextCanvas]] text rendering style.
 */
class TextRenderStyle {
    /**
     * Creates a new `TextRenderStyle`.
     *
     * @param params Input [[TextRenderParameters]].
     *
     * @returns New `TextRenderStyle`.
     */
    constructor(params = {}) {
        this.m_params = {
            fontName: params.fontName !== undefined
                ? params.fontName
                : DefaultTextStyle.DEFAULT_FONT_NAME,
            fontSize: params.fontSize !== undefined
                ? params.fontSize
                : {
                    unit: DefaultTextStyle.DEFAULT_FONT_SIZE.unit,
                    size: DefaultTextStyle.DEFAULT_FONT_SIZE.size,
                    backgroundSize: DefaultTextStyle.DEFAULT_FONT_SIZE.backgroundSize
                },
            fontStyle: params.fontStyle !== undefined
                ? params.fontStyle
                : DefaultTextStyle.DEFAULT_FONT_STYLE,
            fontVariant: params.fontVariant !== undefined
                ? params.fontVariant
                : DefaultTextStyle.DEFAULT_FONT_VARIANT,
            rotation: params.rotation !== undefined ? params.rotation : DefaultTextStyle.DEFAULT_ROTATION,
            color: params.color !== undefined
                ? params.color
                : new THREE.Color(DefaultTextStyle.DEFAULT_COLOR),
            opacity: params.opacity !== undefined ? params.opacity : DefaultTextStyle.DEFAULT_OPACITY,
            backgroundColor: params.backgroundColor !== undefined
                ? params.backgroundColor
                : new THREE.Color(DefaultTextStyle.DEFAULT_BACKGROUND_COLOR),
            backgroundOpacity: params.backgroundOpacity !== undefined
                ? params.backgroundOpacity
                : DefaultTextStyle.DEFAULT_BACKGROUND_OPACITY
        };
    }
    /**
     * Current [[TextRenderParameters]] for this style.
     */
    get params() {
        return this.m_params;
    }
    set params(value) {
        this.m_params = Object.assign(Object.assign({}, this.m_params), value);
    }
    /**
     * Name of the preferred [[Font]] to be used when rendering.
     */
    get fontName() {
        return this.m_params.fontName;
    }
    set fontName(value) {
        this.m_params.fontName = value;
    }
    /**
     * Collection of unit and sizes to apply for the currently active [[Font]].
     */
    get fontSize() {
        return this.m_params.fontSize;
    }
    set fontSize(value) {
        this.m_params.fontSize = value;
    }
    /**
     * Glyph style to apply for the currently active [[Font]].
     */
    get fontStyle() {
        return this.m_params.fontStyle;
    }
    set fontStyle(value) {
        this.m_params.fontStyle = value;
    }
    /**
     * Glyph variant to apply for the currently active [[Font]].
     */
    get fontVariant() {
        return this.m_params.fontVariant;
    }
    set fontVariant(value) {
        this.m_params.fontVariant = value;
    }
    /**
     * Glyph local rotation (radians).
     */
    get rotation() {
        return this.m_params.rotation;
    }
    set rotation(value) {
        this.m_params.rotation = value;
    }
    /**
     * Glyph color.
     */
    get color() {
        return this.m_params.color;
    }
    set color(value) {
        this.m_params.color = value;
    }
    /**
     * Glyph background color.
     */
    get backgroundColor() {
        return this.m_params.backgroundColor;
    }
    set backgroundColor(value) {
        this.m_params.backgroundColor = value;
    }
    /**
     * Glyph opacity.
     */
    get opacity() {
        return this.m_params.opacity;
    }
    set opacity(value) {
        this.m_params.opacity = value;
    }
    /**
     * Glyph background opacity.
     */
    get backgroundOpacity() {
        return this.m_params.backgroundOpacity;
    }
    set backgroundOpacity(value) {
        this.m_params.backgroundOpacity = value;
    }
    /**
     * Clone this `TextRenderStyle`.
     *
     * @param params Input [[TextRenderParameters]].
     *
     * @returns Cloned `TextRenderStyle`.
     */
    clone(params = {}) {
        return new TextRenderStyle(Object.assign(Object.assign({}, this.m_params), params));
    }
}
exports.TextRenderStyle = TextRenderStyle;
/**
 * [[TextCanvas]] text rendering style.
 */
class TextLayoutStyle {
    /**
     * Creates a new `TextLayoutStyle`.
     *
     * @param params Input [[TextLayoutParameters]].
     *
     * @returns New `TextLayoutStyle`.
     */
    constructor(params = {}) {
        this.m_params = {
            tracking: params.tracking !== undefined ? params.tracking : DefaultTextStyle.DEFAULT_TRACKING,
            leading: params.leading !== undefined ? params.leading : DefaultTextStyle.DEFAULT_LEADING,
            maxLines: params.maxLines !== undefined
                ? params.maxLines
                : DefaultTextStyle.DEFAULT_MAX_LINES,
            lineWidth: params.lineWidth !== undefined
                ? params.lineWidth
                : DefaultTextStyle.DEFAULT_LINE_WIDTH,
            canvasRotation: params.canvasRotation !== undefined
                ? params.canvasRotation
                : DefaultTextStyle.DEFAULT_CANVAS_ROTATION,
            lineRotation: params.lineRotation !== undefined
                ? params.lineRotation
                : DefaultTextStyle.DEFAULT_LINE_ROTATION,
            wrappingMode: params.wrappingMode !== undefined
                ? params.wrappingMode
                : DefaultTextStyle.DEFAULT_WRAPPING_MODE,
            verticalAlignment: params.verticalAlignment !== undefined
                ? params.verticalAlignment
                : DefaultTextStyle.DEFAULT_VERTICAL_ALIGNMENT,
            horizontalAlignment: params.horizontalAlignment !== undefined
                ? params.horizontalAlignment
                : DefaultTextStyle.DEFAULT_HORIZONTAL_ALIGNMENT
        };
    }
    /**
     * Current [[TextLayoutParameters]] for this style.
     */
    get params() {
        return this.m_params;
    }
    set params(value) {
        this.m_params = Object.assign(Object.assign({}, this.m_params), value);
    }
    /**
     * Inter-glyph spacing (pixels). Scaled by [[FontSize]].
     */
    get tracking() {
        return this.m_params.tracking;
    }
    set tracking(value) {
        this.m_params.tracking = value;
    }
    /**
     * Inter-line spacing (pixels). Scaled by [[FontSize]].
     */
    get leading() {
        return this.m_params.leading;
    }
    set leading(value) {
        this.m_params.leading = value;
    }
    /**
     * Maximum number of lines to be considered when using [[TextCanvas]].
     */
    get maxLines() {
        return this.m_params.maxLines;
    }
    set maxLines(value) {
        this.m_params.maxLines = value;
    }
    /**
     * Maximum line width (pixels).
     */
    get lineWidth() {
        return this.m_params.lineWidth;
    }
    set lineWidth(value) {
        this.m_params.lineWidth = value;
    }
    /**
     * [[TextCanvas]] rotation (radians).
     */
    get canvasRotation() {
        return this.m_params.canvasRotation;
    }
    set canvasRotation(value) {
        this.m_params.canvasRotation = value;
    }
    /**
     * Line typesetting rotation (radians).
     */
    get lineRotation() {
        return this.m_params.lineRotation;
    }
    set lineRotation(value) {
        this.m_params.lineRotation = value;
    }
    /**
     * Wrapping (line-breaking) mode.
     */
    get wrappingMode() {
        return this.m_params.wrappingMode;
    }
    set wrappingMode(value) {
        this.m_params.wrappingMode = value;
    }
    /**
     * Text position regarding the baseline.
     */
    get verticalAlignment() {
        return this.m_params.verticalAlignment;
    }
    set verticalAlignment(value) {
        this.m_params.verticalAlignment = value;
    }
    /**
     * Text position inside a line.
     */
    get horizontalAlignment() {
        return this.m_params.horizontalAlignment;
    }
    set horizontalAlignment(value) {
        this.m_params.horizontalAlignment = value;
    }
    /**
     * Clone this `TextLayoutStyle`.
     *
     * @param params Input [[TextLayoutParameters]].
     *
     * @returns Cloned `TextLayoutStyle`.
     */
    clone(params = {}) {
        return new TextLayoutStyle(Object.assign(Object.assign({}, this.m_params), params));
    }
}
exports.TextLayoutStyle = TextLayoutStyle;


/***/ }),

/***/ "../harp-text-canvas/lib/typesetting/LineTypesetter.ts":
/*!*************************************************************!*\
  !*** ../harp-text-canvas/lib/typesetting/LineTypesetter.ts ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const TextGeometry_1 = __webpack_require__(/*! ../rendering/TextGeometry */ "../harp-text-canvas/lib/rendering/TextGeometry.ts");
const TextStyle_1 = __webpack_require__(/*! ../rendering/TextStyle */ "../harp-text-canvas/lib/rendering/TextStyle.ts");
const TypesettingUtils_1 = __webpack_require__(/*! ../utils/TypesettingUtils */ "../harp-text-canvas/lib/utils/TypesettingUtils.ts");
const UnicodeUtils_1 = __webpack_require__(/*! ../utils/UnicodeUtils */ "../harp-text-canvas/lib/utils/UnicodeUtils.ts");
/**
 * [[Typesetter]] implementation that handles multi-line complex layout text.
 */
class LineTypesetter {
    /**
     * Creates a `LineTypesetter` object.
     *
     * @returns New `LineTypesetter`.
     */
    constructor() {
        this.m_tempTransform = new THREE.Matrix3();
        this.m_tempCorners = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3()
        ];
        this.m_tempLineDirection = UnicodeUtils_1.UnicodeUtils.Direction.LTR;
        this.m_tempRunDirection = UnicodeUtils_1.UnicodeUtils.Direction.LTR;
        this.m_tempPixelSize = 1.0;
        this.m_tempPixelBgSize = 1.0;
        this.m_tempScale = 1.0;
        this.m_tempSmallCaps = false;
    }
    /**
     * Arranges the specified glyphs using this `LineTypesetter`. Text will be placed into multiple
     * bidirectional lines, that will be generated taking into account [[textLayoutStyle]] features,
     * such as:
     * - Maximum line width.
     * - Word and character wrapping.
     * - Maximum number of lines.
     * - Vertical and horizontal alignment.
     * - Leading (spacing between lines).
     *
     * @param params Typesetting parameters.
     *
     * @returns If `false`, some error occurred during execution and the output should be dismissed.
     */
    arrangeGlyphs(params) {
        // Initializes common typesetting parameters (used across all functions in this class).
        this.m_currentParams = params;
        this.m_tempLineDirection = TypesettingUtils_1.TypesettingUtils.getDirection(this.m_currentParams.glyphs, 0);
        this.m_tempRunDirection = this.m_tempLineDirection;
        this.m_tempPixelSize = TypesettingUtils_1.TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.size, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size);
        this.m_tempScale = this.m_tempPixelSize / this.m_currentParams.fontCatalog.size;
        this.m_tempPixelBgSize = Math.min(TypesettingUtils_1.TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.backgroundSize, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size), this.m_currentParams.fontCatalog.distanceRange * this.m_tempScale);
        this.m_tempSmallCaps = this.m_currentParams.smallCapsArray !== undefined;
        this.m_currentParams.position.y +=
            this.m_currentParams.textLayoutStyle.verticalAlignment *
                this.m_currentParams.glyphs[0].font.metrics.capHeight *
                this.m_tempScale;
        const isOnlyMeasured = this.m_currentParams.globalBounds !== undefined &&
            this.m_currentParams.vertexBuffer === undefined;
        // Compute line origin and height.
        const origin = this.m_currentParams.position.x;
        const lineHeight = this.m_currentParams.glyphs[0].font.metrics.lineHeight +
            this.m_currentParams.textLayoutStyle.leading;
        // Initialize line-breaking and wrapping variables.
        let lineStartIdx = 0;
        let glyphWrapIdx = 0;
        let wordWrapIdx = 0;
        let lineStartX = 0;
        let lineCurrX = 0;
        let glyphWrapX = 0;
        let wordWrapX = 0;
        let lineCount = 0;
        let isBidirectionalLine = false;
        for (let i = 0; i < this.m_currentParams.glyphs.length; ++i) {
            if (lineCount > this.m_currentParams.textLayoutStyle.maxLines - 1) {
                break;
            }
            const glyphData = this.m_currentParams.glyphs[i];
            if (!glyphData.isInCache && !isOnlyMeasured) {
                return false;
            }
            const isNewLine = UnicodeUtils_1.UnicodeUtils.isNewLine(glyphData.codePoint);
            const isWhiteSpace = UnicodeUtils_1.UnicodeUtils.isWhiteSpace(glyphData.codePoint);
            // Check if this line should be treated as bidirectional.
            if (!isBidirectionalLine && glyphData.direction === -this.m_tempLineDirection) {
                isBidirectionalLine = true;
            }
            // Advance the line's current X offset (only for printable characters).
            if (UnicodeUtils_1.UnicodeUtils.isPrintable(glyphData.codePoint)) {
                lineCurrX +=
                    (glyphData.advanceX + this.m_currentParams.textLayoutStyle.tracking) *
                        this.m_tempScale *
                        (this.m_tempSmallCaps
                            ? TypesettingUtils_1.TypesettingUtils.getSmallCapsScale(this.m_currentParams.glyphs, this.m_currentParams.smallCapsArray, i, this.m_currentParams.textRenderStyle.fontVariant)
                            : 1.0);
            }
            // If this is the first character in a line, update the line's X offset values (needed
            // to properly center and wrap).
            if (i === lineStartIdx) {
                lineStartX = lineCurrX;
                glyphWrapX = lineCurrX;
                wordWrapX = lineCurrX;
            }
            // Check if should break the current line.
            if (isNewLine ||
                (this.m_currentParams.textLayoutStyle.wrappingMode === TextStyle_1.WrappingMode.Character &&
                    lineCurrX > this.m_currentParams.textLayoutStyle.lineWidth) ||
                (this.m_currentParams.textLayoutStyle.wrappingMode === TextStyle_1.WrappingMode.Word &&
                    lineCurrX > this.m_currentParams.textLayoutStyle.lineWidth &&
                    wordWrapX !== lineStartX)) {
                // Perform wrapping.
                if (this.m_currentParams.textLayoutStyle.wrappingMode !== TextStyle_1.WrappingMode.None) {
                    let wrapPointIdx = glyphWrapIdx;
                    let wrapPointX = glyphWrapX;
                    // Only wrap words when more than a single word fits into the current line.
                    if (this.m_currentParams.textLayoutStyle.wrappingMode === TextStyle_1.WrappingMode.Word &&
                        wordWrapX !== lineStartX) {
                        wrapPointIdx = wordWrapIdx;
                        wrapPointX = wordWrapX;
                    }
                    lineCurrX = wrapPointX;
                    i = Math.min(isNewLine ? (lineStartIdx === i ? wrapPointIdx : i) : wrapPointIdx, this.m_currentParams.glyphs.length - 1);
                }
                // Calculate the correct starting position for the line base on alignment, and place
                // all glyphs in it.
                const lineAlignment = this.m_tempLineDirection === UnicodeUtils_1.UnicodeUtils.Direction.RTL && isBidirectionalLine
                    ? 1.0 + this.m_currentParams.textLayoutStyle.horizontalAlignment
                    : this.m_currentParams.textLayoutStyle.horizontalAlignment;
                this.m_currentParams.position.x =
                    this.m_currentParams.position.x + lineCurrX * lineAlignment;
                if (!this.placeLine(lineStartIdx, i, this.m_tempLineDirection, isBidirectionalLine)) {
                    return false;
                }
                // Update the line position.
                this.m_currentParams.position.y -= lineHeight * this.m_tempScale;
                this.m_currentParams.position.x = origin;
                // Find the beginning of a new line (removing trailing white spaces).
                while (i !== lineStartIdx &&
                    i + 1 < this.m_currentParams.glyphs.length &&
                    UnicodeUtils_1.UnicodeUtils.isWhiteSpace(this.m_currentParams.glyphs[i + 1].codePoint)) {
                    ++i;
                }
                lineStartIdx = i + 1;
                if (lineStartIdx === this.m_currentParams.glyphs.length) {
                    break;
                }
                // Only reset the line's direction when a new line character is found (to keep
                // correct bidirectional behaviour when a bidirectional run is placed between
                // multiple lines).
                if (isNewLine) {
                    this.m_tempLineDirection = TypesettingUtils_1.TypesettingUtils.getDirection(this.m_currentParams.glyphs, lineStartIdx);
                    this.m_tempRunDirection = this.m_tempLineDirection;
                }
                // Reset the line placement parameters.
                lineStartX = 0;
                lineCurrX = 0;
                glyphWrapIdx = lineStartIdx;
                glyphWrapX = 0;
                wordWrapIdx = lineStartIdx;
                wordWrapX = 0;
                isBidirectionalLine = false;
                lineCount++;
            }
            // If not, should if we should record any new wrapping points.
            else if (this.m_currentParams.textLayoutStyle.wrappingMode !== TextStyle_1.WrappingMode.None &&
                !isWhiteSpace) {
                // Update the per-glyph wrapping point.
                glyphWrapIdx = i;
                glyphWrapX = lineCurrX;
                // Update the word wrapping point (only if mode is correctly set and we are
                // currently placed at the end of a word).
                if (this.m_currentParams.textLayoutStyle.wrappingMode === TextStyle_1.WrappingMode.Word &&
                    i + 1 < this.m_currentParams.glyphs.length &&
                    (UnicodeUtils_1.UnicodeUtils.isWhiteSpace(this.m_currentParams.glyphs[i + 1].codePoint) ||
                        UnicodeUtils_1.UnicodeUtils.isNewLine(this.m_currentParams.glyphs[i + 1].codePoint))) {
                    wordWrapIdx = i;
                    wordWrapX = lineCurrX;
                }
            }
        }
        // If we still haven't placed all characters, place a final line.
        if (lineCount <= this.m_currentParams.textLayoutStyle.maxLines - 1 &&
            lineStartIdx <= this.m_currentParams.glyphs.length - 1) {
            const offset = this.m_tempLineDirection === UnicodeUtils_1.UnicodeUtils.Direction.RTL && isBidirectionalLine
                ? 1.0 + this.m_currentParams.textLayoutStyle.horizontalAlignment
                : this.m_currentParams.textLayoutStyle.horizontalAlignment;
            this.m_currentParams.position.setX(this.m_currentParams.position.x + lineCurrX * offset);
            if (!this.placeLine(lineStartIdx, this.m_currentParams.glyphs.length - 1, this.m_tempLineDirection, isBidirectionalLine)) {
                return false;
            }
        }
        return true;
    }
    // Place characters alongside a line. Text direction is taken into account, and text is broken
    // into directional runs.
    placeLine(startIdx, endIdx, direction, isBidirectional) {
        // If the line is not bidirectional, place it as a single directional run.
        if (!isBidirectional) {
            return this.placeRun(startIdx, endIdx, direction);
        }
        // Gather common typesetting parameters.
        const glyphDataArray = this.m_currentParams.glyphs;
        const smallCapsArray = this.m_currentParams.smallCapsArray;
        const textRenderStyle = this.m_currentParams.textRenderStyle;
        const textLayoutStyle = this.m_currentParams.textLayoutStyle;
        const position = this.m_currentParams.position;
        // Initialize line placement parameters.
        const isRTL = direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL;
        const origin = position.x;
        let offset = 0;
        let runStart = startIdx;
        for (let i = startIdx; i <= endIdx; ++i) {
            const glyphData = glyphDataArray[i];
            // If the current glyph changes the line direction, place the current run.
            if (glyphData.direction === -this.m_tempRunDirection) {
                if (isRTL) {
                    position.x = origin + offset;
                }
                if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {
                    return false;
                }
                if (!isRTL) {
                    position.x = origin + offset;
                }
                runStart = i;
                this.m_tempRunDirection *= -1.0;
            }
            // If the current glyph has neutral direction (i.e. white space) and we're in the middle
            // of a run with direction opposite to the line's main direction, check for the closest
            // strong direction in the run.
            else if (glyphData.direction === UnicodeUtils_1.UnicodeUtils.Direction.Neutral &&
                this.m_tempRunDirection === -direction) {
                let neutralIdx = i;
                while (neutralIdx + 1 < glyphDataArray.length &&
                    Math.abs(glyphDataArray[neutralIdx].direction) !== 1) {
                    ++neutralIdx;
                }
                // If the closest strong direction in the run is not the current run's direction,
                // place the current run.
                if (glyphDataArray[neutralIdx].direction !== this.m_tempRunDirection) {
                    if (isRTL) {
                        position.x = origin + offset;
                    }
                    if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {
                        return false;
                    }
                    if (!isRTL) {
                        position.x = origin + offset;
                    }
                    runStart = i;
                    this.m_tempRunDirection *= -1.0;
                }
            }
            // Advance the offset position in the line.
            offset +=
                (glyphData.advanceX + textLayoutStyle.tracking) *
                    this.m_tempScale *
                    (this.m_tempSmallCaps
                        ? TypesettingUtils_1.TypesettingUtils.getSmallCapsScale(glyphDataArray, smallCapsArray, i, textRenderStyle.fontVariant)
                        : 1.0) *
                    direction;
        }
        // If we still haven't placed all characters in the line, place a final run.
        if (runStart <= endIdx) {
            if (isRTL) {
                position.x = origin + offset;
            }
            if (!this.placeRun(runStart, endIdx, this.m_tempRunDirection)) {
                return false;
            }
            if (!isRTL) {
                position.x = origin + offset;
            }
        }
        return true;
    }
    // Place a directional run of index inside a line.
    placeRun(startIdx, endIdx, direction) {
        // Gather common typesetting parameters.
        const glyphDataArray = this.m_currentParams.glyphs;
        const smallCapsArray = this.m_currentParams.smallCapsArray;
        const fontCatalog = this.m_currentParams.fontCatalog;
        const textRenderStyle = this.m_currentParams.textRenderStyle;
        const textLayoutStyle = this.m_currentParams.textLayoutStyle;
        const position = this.m_currentParams.position;
        const geometry = this.m_currentParams.geometry;
        const globalBounds = this.m_currentParams.globalBounds;
        const individualBounds = this.m_currentParams.individualBounds;
        const vertexBuffer = this.m_currentParams.vertexBuffer;
        // Move through the glyph array following the run's direction (as the order of the glyphs in
        // memory might not match the order on glyphs on scree).
        const start = direction === UnicodeUtils_1.UnicodeUtils.Direction.LTR ? startIdx : endIdx;
        const end = direction === UnicodeUtils_1.UnicodeUtils.Direction.LTR ? endIdx : startIdx;
        for (let i = start; direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL ? i >= end : i <= end; i += direction) {
            // Only process printable characters.
            const glyphData = glyphDataArray[i];
            if (!UnicodeUtils_1.UnicodeUtils.isPrintable(glyphData.codePoint)) {
                continue;
            }
            // When placing a RTL run, we need to check for weak runs (numerical runs of characters
            // that don't change the overall run direction, but should always be displayed as LTR
            // text).
            if (startIdx !== endIdx &&
                i !== 0 &&
                direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL &&
                glyphData.direction === UnicodeUtils_1.UnicodeUtils.Direction.Weak) {
                let weakRunStart = i;
                let weakGlyph = glyphDataArray[weakRunStart - 1];
                while (weakRunStart !== startIdx &&
                    (weakGlyph.direction === UnicodeUtils_1.UnicodeUtils.Direction.Weak ||
                        (weakGlyph.direction === UnicodeUtils_1.UnicodeUtils.Direction.Neutral &&
                            !UnicodeUtils_1.UnicodeUtils.isWhiteSpace(weakGlyph.codePoint)))) {
                    --weakRunStart;
                    weakGlyph = glyphDataArray[weakRunStart - 1];
                }
                this.placeRun(Math.max(weakRunStart, startIdx), i, UnicodeUtils_1.UnicodeUtils.Direction.LTR);
                i = weakRunStart;
                continue;
            }
            // Compute various rendering parameters for this glyph.
            const glyphFont = glyphData.font;
            const glyphFontMetrics = glyphFont.metrics;
            const fontStyle = textRenderStyle.fontStyle;
            const isBoldEmulated = (fontStyle === TextStyle_1.FontStyle.Bold && glyphFont.bold === undefined) ||
                (fontStyle === TextStyle_1.FontStyle.BoldItalic &&
                    glyphFont.bold === undefined &&
                    glyphFont.boldItalic === undefined);
            const isItalicEmulated = (fontStyle === TextStyle_1.FontStyle.Italic && glyphFont.italic === undefined) ||
                (fontStyle === TextStyle_1.FontStyle.BoldItalic &&
                    glyphFont.italic === undefined &&
                    glyphFont.boldItalic === undefined);
            const isSmallCaps = this.m_tempSmallCaps
                ? smallCapsArray[i] && textRenderStyle.fontVariant === TextStyle_1.FontVariant.SmallCaps
                : false;
            const smallCapsScale = isSmallCaps
                ? glyphFontMetrics.xHeight / glyphFontMetrics.capHeight
                : 1.0;
            const glyphScale = this.m_tempScale * smallCapsScale;
            const emulationWeight = ((isBoldEmulated ? 0.02 : 0.0) + (isSmallCaps ? 0.01 : 0.0)) *
                (fontCatalog.size / fontCatalog.distanceRange);
            const bgWeight = (0.5 * this.m_tempPixelBgSize) /
                (fontCatalog.distanceRange * Math.max(glyphScale, 1.0));
            const isMirrored = UnicodeUtils_1.UnicodeUtils.isRtlMirrored(glyphData.codePoint) &&
                direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL;
            const verticalOffset = glyphFontMetrics.lineHeight -
                glyphFontMetrics.base -
                glyphFontMetrics.distanceRange * 0.5;
            // Compute the glyphs transformation matrix and apply to all corners of a glyph.
            TypesettingUtils_1.TypesettingUtils.computeGlyphTransform(this.m_tempTransform, position, glyphScale, textLayoutStyle.canvasRotation, textRenderStyle.rotation);
            for (let j = 0; j < 4; ++j) {
                const glyphVertexPosition = glyphData.positions[j];
                const horizontalOffset = isItalicEmulated && j > 1
                    ? TypesettingUtils_1.TypesettingUtils.OBLIQUE_OFFSET * glyphFontMetrics.size
                    : 0.0;
                this.m_tempCorners[j].set(glyphVertexPosition.x + horizontalOffset, glyphVertexPosition.y - verticalOffset, glyphVertexPosition.z);
                this.m_tempCorners[j].applyMatrix3(this.m_tempTransform);
            }
            // Depending on the typesetting options, add the computed glyph to the TextGeometry or
            // update the text bounds.
            if (globalBounds === undefined && vertexBuffer === undefined) {
                if (!geometry.add(glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle)) {
                    return false;
                }
            }
            else {
                if (globalBounds !== undefined) {
                    TypesettingUtils_1.TypesettingUtils.updateBounds(this.m_tempCorners, globalBounds, individualBounds);
                }
                if (vertexBuffer !== undefined) {
                    geometry.addToBuffer(vertexBuffer, i * TextGeometry_1.QUAD_VERTEX_MEMORY_FOOTPRINT, glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle);
                }
            }
            // Advance the current position and proceed to next glyph in the run.
            position.set(position.x +
                (glyphData.advanceX + textLayoutStyle.tracking) *
                    glyphScale *
                    Math.cos(textLayoutStyle.lineRotation), position.y +
                (glyphData.advanceX + textLayoutStyle.tracking) *
                    glyphScale *
                    Math.sin(textLayoutStyle.lineRotation), position.z);
        }
        return true;
    }
}
exports.LineTypesetter = LineTypesetter;


/***/ }),

/***/ "../harp-text-canvas/lib/typesetting/PathTypesetter.ts":
/*!*************************************************************!*\
  !*** ../harp-text-canvas/lib/typesetting/PathTypesetter.ts ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const TextGeometry_1 = __webpack_require__(/*! ../rendering/TextGeometry */ "../harp-text-canvas/lib/rendering/TextGeometry.ts");
const TextStyle_1 = __webpack_require__(/*! ../rendering/TextStyle */ "../harp-text-canvas/lib/rendering/TextStyle.ts");
const TypesettingUtils_1 = __webpack_require__(/*! ../utils/TypesettingUtils */ "../harp-text-canvas/lib/utils/TypesettingUtils.ts");
const UnicodeUtils_1 = __webpack_require__(/*! ../utils/UnicodeUtils */ "../harp-text-canvas/lib/utils/UnicodeUtils.ts");
/**
 * [[Typesetter]] implementation that arranges glyphs alongside a specified path.
 */
class PathTypesetter {
    /**
     * Creates a `PathTypesetter` object.
     *
     * @returns New `PathTypesetter`.
     */
    constructor() {
        this.m_tempTransform = new THREE.Matrix3();
        this.m_tempCorners = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3()
        ];
        this.m_tempLineDirection = UnicodeUtils_1.UnicodeUtils.Direction.LTR;
        this.m_tempRunDirection = UnicodeUtils_1.UnicodeUtils.Direction.LTR;
        this.m_tempPixelSize = 1.0;
        this.m_tempPixelBgSize = 1.0;
        this.m_tempScale = 1.0;
        this.m_tempSmallCaps = false;
        this.m_tempPathPosition = new THREE.Vector3();
        this.m_tempPathLength = 0.0;
        this.m_tempPathOffset = 0.0;
    }
    /**
     * Arranges the specified glyphs using this `PathTypesetter`. Text will be placed into a single
     * bidirectional line that follows the specified path. Characters will be orientated and placed
     * alongside this path following [[TextLayout]]'s [[VerticalAlignment]] and
     * [[HorizontalAlignment]].
     *
     * @param params Typesetting parameters.
     *
     * @returns If `false`, some error occurred during execution and the output should be dismissed.
     */
    arrangeGlyphs(params) {
        // Initializes common typesetting parameters (used across all functions in this class).
        this.m_currentParams = params;
        this.m_tempLineDirection = TypesettingUtils_1.TypesettingUtils.getDirection(this.m_currentParams.glyphs, 0);
        this.m_tempRunDirection = this.m_tempLineDirection;
        this.m_tempPixelSize = TypesettingUtils_1.TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.size, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size);
        this.m_tempScale = this.m_tempPixelSize / this.m_currentParams.fontCatalog.size;
        this.m_tempPixelBgSize = Math.min(TypesettingUtils_1.TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.backgroundSize, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size), this.m_currentParams.fontCatalog.distanceRange * this.m_tempScale);
        this.m_tempSmallCaps = this.m_currentParams.smallCapsArray !== undefined;
        this.m_tempPathLength = this.m_currentParams.path.getLength();
        this.m_tempPathOffset = 0.0;
        const isOnlyMeasured = this.m_currentParams.globalBounds !== undefined &&
            this.m_currentParams.vertexBuffer === undefined;
        // To be able to properly set the horizontal alignment on a path, we need to first retrieve
        // how much of the path the input text covers, so we can calculate the correct initial
        // offset.
        let isBidirectional = false;
        let pathWidth = 0.0;
        for (let i = 0; i < this.m_currentParams.glyphs.length; ++i) {
            const glyphData = this.m_currentParams.glyphs[i];
            if (!glyphData.isInCache && !isOnlyMeasured) {
                return false;
            }
            if (!UnicodeUtils_1.UnicodeUtils.isPrintable(glyphData.codePoint)) {
                continue;
            }
            if (!isBidirectional && glyphData.direction === -this.m_tempLineDirection) {
                isBidirectional = true;
            }
            pathWidth +=
                (glyphData.advanceX + this.m_currentParams.textLayoutStyle.tracking) *
                    this.m_tempScale *
                    (this.m_tempSmallCaps
                        ? TypesettingUtils_1.TypesettingUtils.getSmallCapsScale(this.m_currentParams.glyphs, this.m_currentParams.smallCapsArray, i, this.m_currentParams.textRenderStyle.fontVariant)
                        : 1.0);
        }
        this.m_tempPathOffset = Math.min(Math.max(-this.m_currentParams.textLayoutStyle.horizontalAlignment +
            (this.m_currentParams.textLayoutStyle.horizontalAlignment * pathWidth) /
                this.m_tempPathLength, 0), 1);
        // Place the input text as a single path line.
        return this.placeLine(this.m_tempLineDirection, isBidirectional);
    }
    // Place characters alongside a path line. Text direction is taken into account, and text is
    // broken into directional runs.
    placeLine(direction, isBidirectional) {
        // If the line is not bidirectional, place it as a single directional run.
        if (!isBidirectional) {
            return this.placeRun(0, this.m_currentParams.glyphs.length - 1, direction);
        }
        // Gather common typesetting parameters.
        const glyphDataArray = this.m_currentParams.glyphs;
        // Initialize line placement parameters.
        let runStart = 0;
        for (let i = runStart; i < glyphDataArray.length; ++i) {
            const glyphData = glyphDataArray[i];
            // If the current glyph changes the line direction, place the current run.
            if (glyphData.direction === -this.m_tempRunDirection) {
                if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {
                    return false;
                }
                runStart = i;
                this.m_tempRunDirection *= -1.0;
            }
            // If the current glyph has neutral direction (i.e. white space) and we're in the middle
            // of a run with direction opposite to the line's main direction, check for the closest
            // strong direction in the run.
            else if (glyphData.direction === UnicodeUtils_1.UnicodeUtils.Direction.Neutral &&
                this.m_tempRunDirection === -direction) {
                let neutralIdx = i;
                while (neutralIdx + 1 < glyphDataArray.length &&
                    Math.abs(glyphDataArray[neutralIdx].direction) !== 1) {
                    ++neutralIdx;
                }
                // If the closest strong direction in the run is not the current run's direction,
                // place the current run.
                if (glyphDataArray[neutralIdx].direction !== this.m_tempRunDirection) {
                    if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {
                        return false;
                    }
                    runStart = i;
                    this.m_tempRunDirection *= -1.0;
                }
            }
        }
        // If we still haven't placed all characters in the line, place a final run.
        if (runStart < glyphDataArray.length) {
            if (!this.placeRun(runStart, glyphDataArray.length - 1, this.m_tempRunDirection)) {
                return false;
            }
        }
        return true;
    }
    // Place a directional run of index inside a path line.
    placeRun(startIdx, endIdx, direction) {
        // Gather common typesetting parameters.
        const glyphDataArray = this.m_currentParams.glyphs;
        const smallCapsArray = this.m_currentParams.smallCapsArray;
        const fontCatalog = this.m_currentParams.fontCatalog;
        const textRenderStyle = this.m_currentParams.textRenderStyle;
        const textLayoutStyle = this.m_currentParams.textLayoutStyle;
        const position = this.m_currentParams.position;
        const geometry = this.m_currentParams.geometry;
        const globalBounds = this.m_currentParams.globalBounds;
        const individualBounds = this.m_currentParams.individualBounds;
        const vertexBuffer = this.m_currentParams.vertexBuffer;
        const path = this.m_currentParams.path;
        const defaultGlyphRotation = textRenderStyle.rotation;
        const normalDisplacement = textLayoutStyle.verticalAlignment *
            glyphDataArray[0].font.metrics.capHeight *
            this.m_tempScale;
        // Move through the glyph array following the run's direction (as the order of the glyphs in
        // memory might not match the order on glyphs on scree).
        const start = direction === UnicodeUtils_1.UnicodeUtils.Direction.LTR ? startIdx : endIdx;
        const end = direction === UnicodeUtils_1.UnicodeUtils.Direction.LTR ? endIdx : startIdx;
        for (let i = start; direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL ? i >= end : i <= end; i += direction) {
            // Only process printable characters.
            const glyphData = glyphDataArray[i];
            if (!UnicodeUtils_1.UnicodeUtils.isPrintable(glyphData.codePoint)) {
                continue;
            }
            // When placing a RTL run, we need to check for weak runs (numerical runs of characters
            // that don't change the overall run direction, but should always be displayed as LTR
            // text).
            if (startIdx !== endIdx &&
                i !== 0 &&
                direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL &&
                glyphData.direction === UnicodeUtils_1.UnicodeUtils.Direction.Weak) {
                let weakRunStart = i;
                let weakGlyph = glyphDataArray[weakRunStart - 1];
                while (weakRunStart !== startIdx &&
                    (weakGlyph.direction === UnicodeUtils_1.UnicodeUtils.Direction.Weak ||
                        (weakGlyph.direction === UnicodeUtils_1.UnicodeUtils.Direction.Neutral &&
                            !UnicodeUtils_1.UnicodeUtils.isWhiteSpace(weakGlyph.codePoint)))) {
                    --weakRunStart;
                    weakGlyph = glyphDataArray[weakRunStart - 1];
                }
                this.placeRun(Math.max(weakRunStart, startIdx), i, UnicodeUtils_1.UnicodeUtils.Direction.LTR);
                i = weakRunStart;
                continue;
            }
            // Compute various rendering parameters for this glyph.
            const glyphFont = glyphData.font;
            const glyphFontMetrics = glyphFont.metrics;
            const fontStyle = textRenderStyle.fontStyle;
            const isBoldEmulated = (fontStyle === TextStyle_1.FontStyle.Bold && glyphFont.bold === undefined) ||
                (fontStyle === TextStyle_1.FontStyle.BoldItalic &&
                    glyphFont.bold === undefined &&
                    glyphFont.boldItalic === undefined);
            const isItalicEmulated = (fontStyle === TextStyle_1.FontStyle.Italic && glyphFont.italic === undefined) ||
                (fontStyle === TextStyle_1.FontStyle.BoldItalic &&
                    glyphFont.italic === undefined &&
                    glyphFont.boldItalic === undefined);
            const isSmallCaps = this.m_tempSmallCaps
                ? smallCapsArray[i] && textRenderStyle.fontVariant === TextStyle_1.FontVariant.SmallCaps
                : false;
            const smallCapsScale = isSmallCaps
                ? glyphFontMetrics.xHeight / glyphFontMetrics.capHeight
                : 1.0;
            const glyphScale = this.m_tempScale * smallCapsScale;
            const emulationWeight = ((isBoldEmulated ? 0.02 : 0.0) + (isSmallCaps ? 0.01 : 0.0)) *
                (fontCatalog.size / fontCatalog.distanceRange);
            const bgWeight = (0.5 * this.m_tempPixelBgSize) /
                (fontCatalog.distanceRange * Math.max(glyphScale, 1.0));
            const isMirrored = UnicodeUtils_1.UnicodeUtils.isRtlMirrored(glyphData.codePoint) &&
                direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL;
            const verticalOffset = glyphFontMetrics.lineHeight -
                glyphFontMetrics.base -
                glyphFontMetrics.distanceRange * 0.5;
            // Update the current interpolated path position and angle.
            const textPoint = path.getPoint(this.m_tempPathOffset);
            if (textPoint === null) {
                return this.m_currentParams.pathOverflow;
            }
            const tangent = path.getTangent(this.m_tempPathOffset);
            const normal = new THREE.Vector2(-tangent.y, tangent.x).multiplyScalar(normalDisplacement);
            const angle = Math.atan2(tangent.y, tangent.x);
            this.m_tempPathPosition.set(normal.x + textPoint.x, normal.y + textPoint.y, position.z);
            textRenderStyle.rotation = defaultGlyphRotation + angle;
            // Compute the glyphs transformation matrix and apply to all corners of a glyph.
            TypesettingUtils_1.TypesettingUtils.computeGlyphTransform(this.m_tempTransform, this.m_tempPathPosition, glyphScale, 0.0, textRenderStyle.rotation);
            for (let j = 0; j < 4; ++j) {
                const glyphVertexPosition = glyphData.positions[j];
                const horizontalOffset = isItalicEmulated && j > 1
                    ? TypesettingUtils_1.TypesettingUtils.OBLIQUE_OFFSET * glyphFontMetrics.size
                    : 0.0;
                this.m_tempCorners[j].set(glyphVertexPosition.x + horizontalOffset, glyphVertexPosition.y - verticalOffset, glyphVertexPosition.z);
                this.m_tempCorners[j].applyMatrix3(this.m_tempTransform);
                this.m_tempCorners[j].x -= position.x;
                this.m_tempCorners[j].y -= position.y;
            }
            // Depending on the typesetting options, add the computed glyph to the TextGeometry or
            // update the text bounds.
            if (globalBounds === undefined && vertexBuffer === undefined) {
                if (!geometry.add(glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle)) {
                    return false;
                }
            }
            else {
                if (globalBounds !== undefined) {
                    TypesettingUtils_1.TypesettingUtils.updateBounds(this.m_tempCorners, globalBounds, individualBounds);
                }
                if (vertexBuffer !== undefined) {
                    geometry.addToBuffer(vertexBuffer, i * TextGeometry_1.QUAD_VERTEX_MEMORY_FOOTPRINT, glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle);
                }
            }
            // Restore the original glyph rotation.
            textRenderStyle.rotation = defaultGlyphRotation;
            // Advance the current position and proceed to next glyph in the run.
            this.m_tempPathOffset +=
                ((glyphData.advanceX + textLayoutStyle.tracking) * glyphScale) /
                    this.m_tempPathLength;
        }
        return true;
    }
}
exports.PathTypesetter = PathTypesetter;


/***/ }),

/***/ "../harp-text-canvas/lib/utils/ContextualArabicConverter.ts":
/*!******************************************************************!*\
  !*** ../harp-text-canvas/lib/utils/ContextualArabicConverter.ts ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
var ContextualForm;
(function (ContextualForm) {
    ContextualForm[ContextualForm["Initial"] = 0] = "Initial";
    ContextualForm[ContextualForm["Medial"] = 1] = "Medial";
    ContextualForm[ContextualForm["Final"] = 2] = "Final";
})(ContextualForm || (ContextualForm = {}));
var CombinedForm;
(function (CombinedForm) {
    CombinedForm[CombinedForm["Isolated"] = 0] = "Isolated";
    CombinedForm[CombinedForm["Connected"] = 1] = "Connected";
})(CombinedForm || (CombinedForm = {}));
/**
 * Converter between arabic isolated forms (in Unicode Block 'Arabic') and their contextual forms
 * (in Unicode Block 'Arabic Presentation Forms-B').
 */
class ContextualArabicConverter {
    constructor() {
        this.m_singleCharactersMap = new Map();
        this.m_combinedCharactersMap = new Map();
        // Single characters.
        this.m_singleCharactersMap.set(0x0621, [undefined, undefined, undefined]); // HAMZA
        this.m_singleCharactersMap.set(0x0622, [undefined, undefined, 0xfe82]); // ALEF_MADDA
        this.m_singleCharactersMap.set(0x0623, [undefined, undefined, 0xfe84]); // ALEF_HAMZA_ABOVE
        this.m_singleCharactersMap.set(0x0624, [undefined, undefined, 0xfe86]); // WAW_HAMZA
        this.m_singleCharactersMap.set(0x0625, [undefined, undefined, 0xfe88]); // ALEF_HAMZA_BELOW
        this.m_singleCharactersMap.set(0x0626, [0xfe8b, 0xfe8c, 0xfe8a]); // YEH_HAMZA
        this.m_singleCharactersMap.set(0x0627, [undefined, undefined, 0xfe8e]); // ALEF
        this.m_singleCharactersMap.set(0x0628, [0xfe91, 0xfe92, 0xfe90]); // BEH
        this.m_singleCharactersMap.set(0x0629, [undefined, undefined, 0xfe94]); // TEH_MARBUTA
        this.m_singleCharactersMap.set(0x062a, [0xfe97, 0xfe98, 0xfe96]); // TEH
        this.m_singleCharactersMap.set(0x062b, [0xfe9b, 0xfe9c, 0xfe9a]); // THEH
        this.m_singleCharactersMap.set(0x062c, [0xfe9f, 0xfea0, 0xfe9e]); // JEEM
        this.m_singleCharactersMap.set(0x062d, [0xfea3, 0xfea4, 0xfea2]); // HAH
        this.m_singleCharactersMap.set(0x062e, [0xfea7, 0xfea8, 0xfea6]); // KHAH
        this.m_singleCharactersMap.set(0x062f, [undefined, undefined, 0xfeaa]); // DAL
        this.m_singleCharactersMap.set(0x0630, [undefined, undefined, 0xfeac]); // THAL
        this.m_singleCharactersMap.set(0x0631, [undefined, undefined, 0xfeae]); // REH
        this.m_singleCharactersMap.set(0x0632, [undefined, undefined, 0xfeb0]); // ZAIN
        this.m_singleCharactersMap.set(0x0633, [0xfeb3, 0xfeb4, 0xfeb2]); // SEEN
        this.m_singleCharactersMap.set(0x0634, [0xfeb7, 0xfeb8, 0xfeb6]); // SHEEN
        this.m_singleCharactersMap.set(0x0635, [0xfebb, 0xfebc, 0xfeba]); // SAD
        this.m_singleCharactersMap.set(0x0636, [0xfebf, 0xfec0, 0xfebe]); // DAD
        this.m_singleCharactersMap.set(0x0637, [0xfec3, 0xfec4, 0xfec2]); // TAH
        this.m_singleCharactersMap.set(0x0638, [0xfec7, 0xfec8, 0xfec6]); // ZAH
        this.m_singleCharactersMap.set(0x0639, [0xfecb, 0xfecc, 0xfeca]); // AIN
        this.m_singleCharactersMap.set(0x063a, [0xfecf, 0xfed0, 0xfece]); // GHAIN
        this.m_singleCharactersMap.set(0x0640, [0x0640, 0x0640, 0x0640]); // TATWEEL
        this.m_singleCharactersMap.set(0x0641, [0xfed3, 0xfed4, 0xfed2]); // FEH
        this.m_singleCharactersMap.set(0x0642, [0xfed7, 0xfed8, 0xfed6]); // QAF
        this.m_singleCharactersMap.set(0x0643, [0xfedb, 0xfedc, 0xfeda]); // KAF
        this.m_singleCharactersMap.set(0x0644, [0xfedf, 0xfee0, 0xfede]); // LAM
        this.m_singleCharactersMap.set(0x0645, [0xfee3, 0xfee4, 0xfee2]); // MEEM
        this.m_singleCharactersMap.set(0x0646, [0xfee7, 0xfee8, 0xfee6]); // NOON
        this.m_singleCharactersMap.set(0x0647, [0xfeeb, 0xfeec, 0xfeea]); // HEH
        this.m_singleCharactersMap.set(0x0648, [undefined, undefined, 0xfeee]); // WAW
        this.m_singleCharactersMap.set(0x0649, [undefined, undefined, 0xfef0]); // ALEF_MAKSURA
        this.m_singleCharactersMap.set(0x064a, [0xfef3, 0xfef4, 0xfef2]); // YEH
        this.m_singleCharactersMap.set(0x067e, [0xfb58, 0xfb59, 0xfb57]); // PEH
        this.m_singleCharactersMap.set(0x06cc, [0xfbfe, 0xfbff, 0xfbfd]); // Farsi Yeh
        this.m_singleCharactersMap.set(0x0686, [0xfb7c, 0xfb7d, 0xfb7b]); // Tcheh
        this.m_singleCharactersMap.set(0x06a9, [0xfb90, 0xfb91, 0xfb8f]); // Keheh
        this.m_singleCharactersMap.set(0x06af, [0xfb94, 0xfb95, 0xfb93]); // Gaf
        this.m_singleCharactersMap.set(0x0698, [undefined, undefined, 0xfb8b]); // Jeh
        // Combined characters.
        this.m_combinedCharactersMap.set(0x0644, new Map());
        // LAM_ALEF_MADDA
        this.m_combinedCharactersMap.get(0x0644).set(0x0622, [0xfef5, 0xfef6]);
        // LAM_ALEF_HAMZA_ABOVE
        this.m_combinedCharactersMap.get(0x0644).set(0x0623, [0xfef7, 0xfef8]);
        // LAM_ALEF_HAMZA_BELOW
        this.m_combinedCharactersMap.get(0x0644).set(0x0625, [0xfef9, 0xfefa]);
        // LAM_ALEF
        this.m_combinedCharactersMap.get(0x0644).set(0x0627, [0xfefb, 0xfefc]);
        // Neutral characters.
        this.m_neutralCharacters = [
            0x0610,
            0x0612,
            0x0613,
            0x0614,
            0x0615,
            0x064b,
            0x064c,
            0x064d,
            0x064e,
            0x064f,
            0x0650,
            0x0651,
            0x0652,
            0x0653,
            0x0654,
            0x0655,
            0x0656,
            0x0657,
            0x0658,
            0x0670,
            0x06d6,
            0x06d7,
            0x06d8,
            0x06d9,
            0x06da,
            0x06db,
            0x06dc,
            0x06df,
            0x06e0,
            0x06e1,
            0x06e2,
            0x06e3,
            0x06e4,
            0x06e7,
            0x06e8,
            0x06ea,
            0x06eb,
            0x06ec,
            0x06ed // ARABIC SMALL LOW MEEM
        ];
    }
    static get instance() {
        if (this.m_instance === undefined) {
            this.m_instance = new ContextualArabicConverter();
        }
        return this.m_instance;
    }
    /**
     * Converts isolated arabic characters into their contextual form.
     *
     * @param input String with isolated arabic characters.
     */
    convert(input) {
        let output = "";
        for (let i = 0; i < input.length; ++i) {
            const currentCodePoint = input.charCodeAt(i);
            // Only process arabic characters in the map.
            if (this.isArabicCharacter(currentCodePoint)) {
                // Find the first previous non-neutral character.
                let prevIndex = i - 1;
                for (; prevIndex >= 0; --prevIndex) {
                    if (!this.isNeutral(input.charCodeAt(prevIndex))) {
                        break;
                    }
                }
                // Check if the previous character has ligatures with following characters.
                let prevCodePoint = prevIndex >= 0 ? input.charCodeAt(prevIndex) : undefined;
                if (prevCodePoint !== undefined) {
                    const prevMap = this.getCharacterMap(prevCodePoint);
                    if (prevMap === undefined ||
                        (prevMap[ContextualForm.Initial] === undefined &&
                            prevMap[ContextualForm.Medial] === undefined)) {
                        prevCodePoint = undefined;
                    }
                }
                // Find the first next non-neutral character.
                let nextIndex = i + 1;
                for (; nextIndex < input.length; ++nextIndex) {
                    if (!this.isNeutral(input.charCodeAt(nextIndex))) {
                        break;
                    }
                }
                // Check if the next character has ligatures with previous characters.
                let nextCodePoint = nextIndex < input.length ? input.charCodeAt(nextIndex) : undefined;
                if (nextCodePoint !== undefined) {
                    const nextMap = this.getCharacterMap(nextCodePoint);
                    if (nextMap === undefined ||
                        (nextMap[ContextualForm.Medial] === undefined &&
                            nextMap[ContextualForm.Final] === undefined)) {
                        nextCodePoint = undefined;
                    }
                }
                // Check for Lam Alef combinated forms.
                if (currentCodePoint === 0x0644 &&
                    nextCodePoint !== undefined &&
                    (nextCodePoint === 0x0622 ||
                        nextCodePoint === 0x0623 ||
                        nextCodePoint === 0x0625 ||
                        nextCodePoint === 0x0627)) {
                    const combinedMap = this.getCombinedCharacterMap(currentCodePoint, nextCodePoint);
                    if (prevCodePoint !== undefined) {
                        output += String.fromCharCode(combinedMap[CombinedForm.Connected]);
                    }
                    else {
                        output += String.fromCharCode(combinedMap[CombinedForm.Isolated]);
                    }
                    // Skip the next character and continue.
                    ++i;
                    continue;
                }
                // Check for single character contextual forms.
                const map = this.getCharacterMap(currentCodePoint);
                // Intermediate.
                if (prevCodePoint !== undefined &&
                    nextCodePoint !== undefined &&
                    map[ContextualForm.Medial] !== undefined) {
                    output += String.fromCharCode(map[ContextualForm.Medial]);
                }
                // Final.
                else if (prevCodePoint !== undefined && map[ContextualForm.Final] !== undefined) {
                    output += String.fromCharCode(map[ContextualForm.Final]);
                }
                // Initial.
                else if (nextCodePoint !== undefined && map[ContextualForm.Initial] !== undefined) {
                    output += String.fromCharCode(map[ContextualForm.Initial]);
                }
                // Isolated.
                else {
                    output += String.fromCharCode(currentCodePoint);
                }
            }
            else {
                output += String.fromCharCode(currentCodePoint);
            }
        }
        return output;
    }
    isArabicCharacter(codePoint) {
        return this.m_singleCharactersMap.has(codePoint);
    }
    getCharacterMap(codePoint) {
        return this.m_singleCharactersMap.get(codePoint);
    }
    getCombinedCharacterMap(codePoint, nextCodePoint) {
        const map = this.m_combinedCharactersMap.get(codePoint);
        if (map !== undefined) {
            return map.get(nextCodePoint);
        }
        return undefined;
    }
    isNeutral(codePoint) {
        for (const character of this.m_neutralCharacters) {
            if (character === codePoint) {
                return true;
            }
        }
        return false;
    }
}
exports.ContextualArabicConverter = ContextualArabicConverter;


/***/ }),

/***/ "../harp-text-canvas/lib/utils/MaterialUtils.ts":
/*!******************************************************!*\
  !*** ../harp-text-canvas/lib/utils/MaterialUtils.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const TextMaterials_1 = __webpack_require__(/*! ../rendering/TextMaterials */ "../harp-text-canvas/lib/rendering/TextMaterials.ts");
/**
 * Helper function designed to create [[SdfTextMaterials]] that can be rendered using
 * [[TextCanvas]].
 *
 * @param params Material parameters.
 *
 * @returns New `SdfTextMaterial`.
 */
function createSdfTextMaterial(params) {
    return new TextMaterials_1.SdfTextMaterial({
        texture: params.fontCatalog.texture,
        textureSize: params.fontCatalog.textureSize,
        size: params.fontCatalog.size,
        distanceRange: params.fontCatalog.distanceRange,
        isMsdf: params.fontCatalog.type === "msdf",
        isBackground: params.isBackground === true,
        vertexSource: params.vertexSource,
        fragmentSource: params.fragmentSource
    });
}
exports.createSdfTextMaterial = createSdfTextMaterial;


/***/ }),

/***/ "../harp-text-canvas/lib/utils/TypesettingUtils.ts":
/*!*********************************************************!*\
  !*** ../harp-text-canvas/lib/utils/TypesettingUtils.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
const TextStyle_1 = __webpack_require__(/*! ../rendering/TextStyle */ "../harp-text-canvas/lib/rendering/TextStyle.ts");
const UnicodeUtils_1 = __webpack_require__(/*! ../utils/UnicodeUtils */ "../harp-text-canvas/lib/utils/UnicodeUtils.ts");
/**
 * Collection of different constants and utility functions used by [[Typesetter]]s.
 */
var TypesettingUtils;
(function (TypesettingUtils) {
    /**
     * Ratio between EMs and Pixels.
     */
    TypesettingUtils.EM_TO_PX = 16.0;
    /**
     * Ratio between Points and Pixels.
     */
    TypesettingUtils.PT_TO_PX = 1.25;
    /**
     * Angle used when emulating italic fonts (oblique).
     */
    TypesettingUtils.OBLIQUE_ANGLE = 0.174533;
    /**
     * Horizontal offset used when emulating italic fonts (oblique).
     */
    TypesettingUtils.OBLIQUE_OFFSET = Math.tan(TypesettingUtils.OBLIQUE_ANGLE);
    /**
     * Convert between any size specified in any [[FontUnit]] to pixels.
     *
     * @param size Font size (specified in `unit`).
     * @param unit Size unit.
     * @param originalSize Original size (pixels)
     *
     * @returns Pixel size.
     */
    function getPixelSize(size, unit, originalSize) {
        let result = size;
        switch (unit) {
            case TextStyle_1.FontUnit.Em:
                result *= TypesettingUtils.EM_TO_PX;
                break;
            case TextStyle_1.FontUnit.Point:
                result *= TypesettingUtils.PT_TO_PX;
                break;
            case TextStyle_1.FontUnit.Percent:
                result *= (1.0 / 100) * originalSize;
                break;
        }
        return result;
    }
    TypesettingUtils.getPixelSize = getPixelSize;
    /**
     * Gets the scale applied to a certain character when using the [[FontVariant]].`SmallCaps`.
     *
     * @param glyphs Array containing [[TransformedGlyphData]].
     * @param index Index to `glyphDataArray`.
     * @param fontVariant Currently active [[FontVariant]].
     *
     * @returns Glyph `SmallCaps` scale.
     */
    function getSmallCapsScale(glyphs, smallCapsTransformations, index, fontVariant) {
        const isSmallCaps = smallCapsTransformations[index] && fontVariant === TextStyle_1.FontVariant.SmallCaps;
        return isSmallCaps
            ? glyphs[index].font.metrics.xHeight / glyphs[index].font.metrics.capHeight
            : 1.0;
    }
    TypesettingUtils.getSmallCapsScale = getSmallCapsScale;
    /**
     * Returns the first strong direction (LTR or RTL) found for a given array of [[GlyphData]].
     *
     * @param glyphs Array containing [[GlyphData]].
     * @param offset `glyphDataArray` offset.
     *
     * @returns Strong direction.
     */
    function getDirection(glyphs, offset) {
        let result = UnicodeUtils_1.UnicodeUtils.Direction.LTR;
        let index = offset;
        while (glyphs[index].direction !== UnicodeUtils_1.UnicodeUtils.Direction.LTR &&
            glyphs[index].direction !== UnicodeUtils_1.UnicodeUtils.Direction.RTL &&
            index < glyphs.length - 1) {
            ++index;
        }
        if (Math.abs(glyphs[index].direction) === 1.0) {
            result = glyphs[index].direction;
        }
        return result;
    }
    TypesettingUtils.getDirection = getDirection;
    /**
     * Computes the transformation matrix for a glyph.
     *
     * @param transform Matrix used to store the results.
     * @param position Glyph' position.
     * @param scale Glyph' scale.
     * @param rotation [[TextCanvas]] rotation.
     * @param localRotation Glyph' local rotation.
     */
    function computeGlyphTransform(transform, position, scale, rotation, localRotation) {
        const cosAngle = Math.cos(rotation);
        const sinAngle = Math.sin(rotation);
        const localCosAngle = Math.cos(localRotation);
        const localSinAngle = Math.sin(localRotation);
        transform.set(scale * localCosAngle, scale * -localSinAngle, cosAngle * position.x - sinAngle * position.y, scale * localSinAngle, scale * localCosAngle, sinAngle * position.x + cosAngle * position.y, 0, 0, 1.0);
    }
    TypesettingUtils.computeGlyphTransform = computeGlyphTransform;
    /**
     * Updates the supplied bounds with the computed screen-space corners for a given glyph.
     *
     * @param corners Glyph' corners.
     * @param globalBounds Global text bounds.
     * @param individualBounds Individual per-character bounds.
     */
    function updateBounds(corners, globalBounds, individualBounds) {
        const minX = Math.min(corners[0].x, corners[1].x, corners[2].x, corners[3].x);
        const maxX = Math.max(corners[0].x, corners[1].x, corners[2].x, corners[3].x);
        const minY = Math.min(corners[0].y, corners[1].y, corners[2].y, corners[3].y);
        const maxY = Math.max(corners[0].y, corners[1].y, corners[2].y, corners[3].y);
        if (individualBounds !== undefined) {
            if (individualBounds.array[individualBounds.offset] !== undefined) {
                individualBounds.array[individualBounds.offset].min.set(minX, minY);
                individualBounds.array[individualBounds.offset].max.set(maxX, maxY);
            }
            else {
                individualBounds.array.push(new THREE.Box2(new THREE.Vector2(minX, minY), new THREE.Vector2(maxX, maxY)));
            }
            ++individualBounds.offset;
        }
        globalBounds.min.set(Math.min(globalBounds.min.x, minX), Math.min(globalBounds.min.y, minY));
        globalBounds.max.set(Math.max(globalBounds.max.x, maxX), Math.max(globalBounds.max.y, maxY));
    }
    TypesettingUtils.updateBounds = updateBounds;
})(TypesettingUtils = exports.TypesettingUtils || (exports.TypesettingUtils = {}));


/***/ }),

/***/ "../harp-text-canvas/lib/utils/UnicodeUtils.ts":
/*!*****************************************************!*\
  !*** ../harp-text-canvas/lib/utils/UnicodeUtils.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Namespace containing useful information when dealing with Unicode's code points.
 */
var UnicodeUtils;
(function (UnicodeUtils) {
    /**
     * Range of Unicode code points considered as white space.
     * https://en.wikipedia.org/wiki/Whitespace_character
     */
    UnicodeUtils.whiteSpaceRanges = [
        [0x0009, 0x0009],
        [0x0020, 0x0020],
        [0x1680, 0x1680],
        [0x2000, 0x2006],
        [0x2008, 0x200a],
        [0x205f, 0x3000],
        [0x180e, 0x180e],
        [0x200b, 0x200d]
    ];
    /**
     * Checks if a character should be considered as a white space.
     *
     * @param codePoint Character's Unicode code point.
     *
     * @returns Result of the test.
     */
    function isWhiteSpace(codePoint) {
        for (const range of UnicodeUtils.whiteSpaceRanges) {
            if (codePoint >= range[0] && codePoint <= range[1]) {
                return true;
            }
        }
        return false;
    }
    UnicodeUtils.isWhiteSpace = isWhiteSpace;
    /**
     * Range of Unicode code points considered as `NewLine`.
     * https://en.wikipedia.org/wiki/Newline#Unicode
     */
    UnicodeUtils.newLineRanges = [
        [0x000a, 0x000d],
        [0x0085, 0x0085],
        [0x2028, 0x2029]
    ];
    /**
     * Checks if a character should be considered as a new line.
     *
     * @param codePoint Character's Unicode code point.
     *
     * @returns Result of the test.
     */
    function isNewLine(codePoint) {
        for (const range of UnicodeUtils.newLineRanges) {
            if (codePoint >= range[0] && codePoint <= range[1]) {
                return true;
            }
        }
        return false;
    }
    UnicodeUtils.isNewLine = isNewLine;
    /**
     * Range of Unicode code points considered as non-printable.
     * https://en.wikipedia.org/wiki/Unicode_control_characters
     */
    UnicodeUtils.nonPrintableRanges = [
        [0x0000, 0x001f],
        [0x007f, 0x009f]
    ];
    /**
     * Checks if a character's can be printed (rendered).
     *
     * @param codePoint Character's Unicode code point.
     *
     * @returns Result of the test.
     */
    function isPrintable(codePoint) {
        for (const range of UnicodeUtils.nonPrintableRanges) {
            if (codePoint >= range[0] && codePoint <= range[1]) {
                return false;
            }
        }
        return true;
    }
    UnicodeUtils.isPrintable = isPrintable;
    /**
     * Unicode code point direction.
     */
    let Direction;
    (function (Direction) {
        Direction[Direction["Neutral"] = 0] = "Neutral";
        Direction[Direction["Weak"] = 0.5] = "Weak";
        Direction[Direction["LTR"] = 1] = "LTR";
        Direction[Direction["RTL"] = -1] = "RTL";
    })(Direction = UnicodeUtils.Direction || (UnicodeUtils.Direction = {}));
    // TODO: Review/Remove/Add any additional needed blocks (HARP-3330).
    /**
     * Unicode Blocks which have inherent RTL direction.
     * These blocks correspond to the scripts described here:
     * https://en.wikipedia.org/wiki/Right-to-left#List_of_RTL_scripts
     */
    UnicodeUtils.rtlBlocks = [
        "Hebrew",
        "Alphabetic Presentation Forms",
        "Arabic",
        "Arabic Supplement",
        "Arabic Extended-A",
        "Arabic Presentation Forms-A",
        "Arabic Presentation Forms-B",
        "Arabic Mathematical Alphabetic Symbols",
        "Indic Siyaq Numbers",
        "Rumi Numeral Symbols",
        "Syriac",
        "Syriac Supplement",
        "Samaritan",
        "Mandaic",
        "Thaana",
        "Mende Kikakui",
        "NKo",
        "Adlam",
        "Hanifi Rohingya"
    ];
    /**
     * ASCII punctuation is considered to have neutral direction:
     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters
     */
    UnicodeUtils.neutralBidirectionalRanges = [
        [0x0020, 0x002f],
        [0x003a, 0x0040],
        [0x005b, 0x0060],
        [0x007b, 0x007e]
    ];
    /**
     * Latin and arabic numerals are considered to have weak directionality:
     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters
     * https://en.wikipedia.org/wiki/Arabic_(Unicode_block)#Block
     */
    UnicodeUtils.weakBidirectionalRanges = [
        [0x0030, 0x0039],
        [0x0660, 0x0669],
        [0x06f0, 0x06f9]
    ];
    /**
     * Returns the Unicode's character direction.
     *
     * @param codePoint Character's Unicode code point.
     * @param block Character's Unicode block.
     *
     * @returns Character's direction.
     */
    function getDirection(codePoint, block) {
        // Test for neutral and weak code points first (they're inside LTR/RTL ranges).
        for (const weakRange of UnicodeUtils.weakBidirectionalRanges) {
            if (codePoint >= weakRange[0] && codePoint <= weakRange[1]) {
                return Direction.Weak;
            }
        }
        for (const neutralRange of UnicodeUtils.neutralBidirectionalRanges) {
            if (codePoint >= neutralRange[0] && codePoint <= neutralRange[1]) {
                return Direction.Neutral;
            }
        }
        // Check for RTL/LTR.
        const rtl = UnicodeUtils.rtlBlocks.find(element => {
            return element === block;
        });
        if (rtl !== undefined) {
            return Direction.RTL;
        }
        else {
            return Direction.LTR;
        }
    }
    UnicodeUtils.getDirection = getDirection;
    /**
     * Some punctuation characters (like: (, ), <, >, [,], {, }) need to be mirrored when rendering
     * a RTL string to preserve their intrinsic meaning.
     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters
     */
    UnicodeUtils.rtlMirroredCodePoints = [
        0x0028,
        0x0029,
        0x003c,
        0x003e,
        0x005b,
        0x005d,
        0x007b,
        0x007d
    ];
    /**
     * Checks if a character should be mirrored on an RTL run.
     *
     * @param codePoint Character's Unicode code point.
     *
     * @returns Result of the test.
     */
    function isRtlMirrored(codePoint) {
        return (UnicodeUtils.rtlMirroredCodePoints.find(element => {
            return element === codePoint;
        }) !== undefined);
    }
    UnicodeUtils.isRtlMirrored = isRtlMirrored;
})(UnicodeUtils = exports.UnicodeUtils || (exports.UnicodeUtils = {}));


/***/ }),

/***/ "../harp-transfer-manager/index.ts":
/*!*****************************************!*\
  !*** ../harp-transfer-manager/index.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./src/TransferManager */ "../harp-transfer-manager/src/TransferManager.ts"));


/***/ }),

/***/ "../harp-transfer-manager/src/DeferredPromise.ts":
/*!*******************************************************!*\
  !*** ../harp-transfer-manager/src/DeferredPromise.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 *
 * DeferredPromise takes an executor function for executing it later, when [[exec]] is called.
 * This class allows wrapping other promises or long running functions for later execution.
 * @internal
 * @hidden
 */
class DeferredPromise {
    /**
     * Constructs a new [[DeferredPromise]]
     * @param executor Async function that should be executed at a later point in time.
     */
    constructor(executor) {
        this.executor = executor;
        this.promise = new Promise((resolve, reject) => {
            this.resolveFunc = resolve;
            this.rejectFunc = reject;
        });
    }
    /**
     * When `exec` is called the deferred executor function is executed.
     */
    exec() {
        this.executor()
            .then(result => this.resolveFunc(result))
            .catch(error => this.rejectFunc(error));
    }
}
exports.DeferredPromise = DeferredPromise;


/***/ }),

/***/ "../harp-transfer-manager/src/TransferManager.ts":
/*!*******************************************************!*\
  !*** ../harp-transfer-manager/src/TransferManager.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/** @module
 *
 * This module provides classes to ease downloading URLs. In particular, following redirects,
 * retrying on HTTP errors, and limiting the number of parallel concurrent downloads.
 */
__webpack_require__(/*! @here/harp-fetch */ "../harp-fetch/index.web.ts");
const DeferredPromise_1 = __webpack_require__(/*! ./DeferredPromise */ "../harp-transfer-manager/src/DeferredPromise.ts");
/**
 * `TransferManager` for downloading URLs.
 *
 * Features:
 *
 * * Merges JSON downloads, for example, the same URL if requested as JSON will only be downloaded
 *   once.
 * * Limits the amount of parallel downloads, useful when requesting a large amount of URLs that
 *   would otherwise stall the browser.
 * * Retries the downloads with an increasing timeout on HTTP 503 replies.
 *
 * The static method [[instance]] can be used to get a default constructed instance.
 */
class TransferManager {
    /**
     * Constructs a new [[TransferManager]].
     *
     * @param fetchFunction The default fetch function to use.
     * @param maxRetries The maximum amount to try to re-fetch a resource.
     */
    constructor(fetchFunction = fetch, maxRetries = 5) {
        this.fetchFunction = fetchFunction;
        this.maxRetries = maxRetries;
        this.activeDownloadCount = 0;
        this.downloadQueue = new Array();
        this.activeDownloads = new Map();
    }
    /**
     * Returns a default instance of [[TransferManager]].
     */
    static instance() {
        return TransferManager.defaultInstance;
    }
    static async fetchRepeatedly(fetchFunction, retryCount, maxRetries, url, init) {
        try {
            const response = await fetchFunction(url, init);
            if (response.status !== 503 || retryCount > maxRetries) {
                return response;
            }
        }
        catch (err) {
            if (err.hasOwnProperty("isCancelled") ||
                (err.hasOwnProperty("name") && err.name === "AbortError") ||
                retryCount > maxRetries) {
                throw err;
            }
        }
        return TransferManager.waitFor(TransferManager.retryTimeout * retryCount).then(() => TransferManager.fetchRepeatedly(fetchFunction, maxRetries, retryCount + 1, url, init));
    }
    static waitFor(milliseconds) {
        return new Promise(resolve => setTimeout(resolve, milliseconds));
    }
    /**
     * Downloads a JSON object. Merges downloads if requested multiple times.
     *
     * Note: This method merges multiple downloads of the same resource to
     * only one request. The init parameter is ignored if the download is merged.
     * Call [[download]] instead to download the resource without merging.
     *
     * @param url The URL to download
     * @param init Optional extra parameters for the download.
     */
    downloadJson(url, init) {
        return this.downloadAs(response => response.json(), url, init);
    }
    /**
     * Downloads a binary object. Merges downloads if requested multiple times.
     *
     * Note: This method merges multiple downloads of the same resource to
     * only one request. The init parameter is ignored if the download is merged.
     * Call [[download]] instead to download the resource without merging.
     *
     * @param url The URL to download
     * @param init Optional extra parameters for the download
     */
    downloadArrayBuffer(url, init) {
        return this.download(url, init).then(response => response.arrayBuffer());
    }
    /**
     * Downloads a URL and returns the response.
     *
     * Does not merge multiple requests to the same URL.
     *
     * @param url The URL to download.
     * @param init Optional extra parameters for the download.
     */
    download(url, init) {
        if (this.activeDownloadCount >= TransferManager.maxParallelDownloads) {
            const deferred = new DeferredPromise_1.DeferredPromise(() => this.doDownload(url, init));
            this.downloadQueue.push(deferred);
            return deferred.promise;
        }
        return this.doDownload(url, init);
    }
    async doDownload(url, init) {
        try {
            ++this.activeDownloadCount;
            const response = await TransferManager.fetchRepeatedly(this.fetchFunction, 0, this.maxRetries, url, init);
            this.onDownloadDone();
            return response;
        }
        catch (error) {
            this.onDownloadDone();
            throw error;
        }
    }
    onDownloadDone() {
        --this.activeDownloadCount;
        this.execDeferredDownload();
    }
    execDeferredDownload() {
        const future = this.downloadQueue.pop();
        if (future === undefined) {
            return;
        }
        future.exec();
    }
    downloadAs(converter, url, init) {
        const cacheKey = url;
        const pendingFetch = this.activeDownloads.get(cacheKey);
        if (pendingFetch !== undefined) {
            return Promise.resolve(pendingFetch);
        }
        const newFetch = this.download(url, init)
            .then(response => {
            this.activeDownloads.delete(cacheKey);
            if (response.ok) {
                return converter(response);
            }
            throw new Error(JSON.stringify(response));
        })
            .catch(err => {
            this.activeDownloads.delete(cacheKey);
            throw err;
        });
        this.activeDownloads.set(cacheKey, newFetch);
        return newFetch;
    }
}
exports.TransferManager = TransferManager;
/**
 * The timeout in milliseconds to wait between retries. This timeout is multiplied with the
 * number of retries. First retry waits for 0 ms, second retry for 500 ms, third for 1000 ms and
 * so on.
 */
TransferManager.retryTimeout = 500;
/**
 * The amount of maximum parallel downloads to allow.
 */
TransferManager.maxParallelDownloads = 16;
TransferManager.defaultInstance = new TransferManager();


/***/ }),

/***/ "../harp-utils/index-common.ts":
/*!*************************************!*\
  !*** ../harp-utils/index-common.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/GroupedPriorityList */ "../harp-utils/lib/GroupedPriorityList.ts"));
__export(__webpack_require__(/*! ./lib/Logger */ "../harp-utils/lib/Logger/index.ts"));
__export(__webpack_require__(/*! ./lib/Math2D */ "../harp-utils/lib/Math2D.ts"));
__export(__webpack_require__(/*! ./lib/MathUtils */ "../harp-utils/lib/MathUtils.ts"));
__export(__webpack_require__(/*! ./lib/Mixins */ "../harp-utils/lib/Mixins.ts"));
__export(__webpack_require__(/*! ./lib/assert */ "../harp-utils/lib/assert.ts"));
__export(__webpack_require__(/*! ./lib/ContextLogger */ "../harp-utils/lib/ContextLogger.ts"));
__export(__webpack_require__(/*! ./lib/PerformanceTimer */ "../harp-utils/lib/PerformanceTimer.ts"));
__export(__webpack_require__(/*! ./lib/ObjectUtils */ "../harp-utils/lib/ObjectUtils.ts"));
__export(__webpack_require__(/*! ./lib/OptionsUtils */ "../harp-utils/lib/OptionsUtils.ts"));
__export(__webpack_require__(/*! ./lib/UriResolver */ "../harp-utils/lib/UriResolver.ts"));
__export(__webpack_require__(/*! ./lib/UrlUtils */ "../harp-utils/lib/UrlUtils.ts"));
__export(__webpack_require__(/*! ./lib/Functions */ "../harp-utils/lib/Functions.ts"));


/***/ }),

/***/ "../harp-utils/index.web.ts":
/*!**********************************!*\
  !*** ../harp-utils/index.web.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./index-common */ "../harp-utils/index-common.ts"));
__export(__webpack_require__(/*! ./lib/UrlPlatformUtils.web */ "../harp-utils/lib/UrlPlatformUtils.web.ts"));


/***/ }),

/***/ "../harp-utils/lib/ContextLogger.ts":
/*!******************************************!*\
  !*** ../harp-utils/lib/ContextLogger.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Context-aware logger that decorates log message with stack-based prefix, emits `headerMessage`
 * before first actual log message.
 */
class ContextLogger {
    /**
     * Construct a context-aware logger that logs to `m_logger`.
     */
    constructor(m_logger, headerMessage) {
        this.m_logger = m_logger;
        this.headerMessage = headerMessage;
        this.context = [];
        this.m_headerLogged = false;
        // They, are public member functions it's just tslint who doesn't understand this.
        // tslint:disable:member-ordering
        this.warn = this.createLogMethod("warn");
        this.info = this.createLogMethod("info");
        this.error = this.createLogMethod("error");
    }
    /**
     * Push "attribute-like" context.
     *
     * Following log messages will be prefixed with `name` or `.name` depending on current context.
     */
    pushAttr(name) {
        this.context.push(`${this.context.length > 0 ? "." : ""}${name}`);
    }
    /**
     * Push "index-like" context.
     *
     * Following log messages will be prefixed with `[index]`.
     */
    pushIndex(index) {
        this.context.push(`[${index}]`);
    }
    pop() {
        this.context.pop();
    }
    // tslint:enable:member-ordering
    createLogMethod(severity) {
        return (message, ...rest) => {
            if (!this.m_headerLogged) {
                this.m_logger.info(this.headerMessage);
                this.m_headerLogged = true;
            }
            this.m_logger[severity](`${this.context.join("")}: ${message}`, ...rest);
        };
    }
}
exports.ContextLogger = ContextLogger;


/***/ }),

/***/ "../harp-utils/lib/Functions.ts":
/*!**************************************!*\
  !*** ../harp-utils/lib/Functions.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Chains two functions for further assigning as one wrapped callback function
 */
function chainCallbacks(f1, f2) {
    return function (...args) {
        if (f1) {
            f1.apply(this, args);
        }
        return f2.apply(this, args);
    };
}
exports.chainCallbacks = chainCallbacks;


/***/ }),

/***/ "../harp-utils/lib/GroupedPriorityList.ts":
/*!************************************************!*\
  !*** ../harp-utils/lib/GroupedPriorityList.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The `PriorityListGroup` contains a list of [[PriorityListElement]]s that all have the same
 * (integer) priority.
 */
class PriorityListGroup {
    constructor(priority, elements = new Array()) {
        this.priority = priority;
        this.elements = elements;
    }
    /**
     * Create and return a deep copy of the `PriorityListGroup<T>`.
     *
     * @returns A clone of the `PriorityListGroup<T>`.
     */
    clone() {
        return new PriorityListGroup(this.priority, this.elements.slice());
    }
}
exports.PriorityListGroup = PriorityListGroup;
/**
 * The `GroupedPriorityList` contains a [[PriorityListGroupMap]] to manage a larger number of items
 * in priority groups.
 */
class GroupedPriorityList {
    constructor() {
        this.groups = new Map();
    }
    /**
     * Add an element to the `GroupedPriorityList`. Selects group based on the elements priority.
     *
     * @param element Element to be added.
     */
    add(element) {
        this.getGroup(element.priority).elements.push(element);
    }
    /**
     * Remove an element from the `GroupedPriorityList`.
     *
     * Note: It is required that the priority is the same as it was when the element has been added.
     * Otherwise, the removal will fail.
     *
     * @param element Element to be removed.
     * @returns `True` if the element was removed, `false` otherwise.
     */
    remove(element) {
        const group = this.getGroup(element.priority);
        if (group !== undefined) {
            const foundIndex = group.elements.indexOf(element);
            if (foundIndex >= 0) {
                group.elements.splice(foundIndex, 1);
                if (group.elements.length === 0) {
                    const normalizedPriority = Math.floor(element.priority);
                    this.groups.delete(normalizedPriority);
                    if (this.m_sortedGroups) {
                        this.m_sortedGroups = [];
                    }
                }
                return true;
            }
        }
        return false;
    }
    /**
     * Remove all internal [[PriorityListGroup]]s.
     */
    clear() {
        this.groups.clear();
        if (this.m_sortedGroups) {
            this.m_sortedGroups = [];
        }
    }
    /**
     * Merge another [[GroupedPriorityList]] into this one.
     *
     * @param other Other group to merge.
     */
    merge(other) {
        for (const otherGroup of other.groups) {
            const group = this.findGroup(otherGroup[1].priority);
            if (group === undefined) {
                this.groups.set(Math.floor(otherGroup[1].priority), otherGroup[1].clone());
                if (this.m_sortedGroups) {
                    this.m_sortedGroups = [];
                }
                continue;
            }
            group.elements = group.elements.concat(otherGroup[1].elements);
        }
        return this;
    }
    /**
     * Return a sorted list of [[PriorityListGroup]]s.
     */
    get sortedGroups() {
        if (this.m_sortedGroups && this.m_sortedGroups.length > 0) {
            return this.m_sortedGroups;
        }
        if (!this.m_sortedGroups) {
            this.m_sortedGroups = [];
        }
        for (const priorityList of this.groups) {
            this.m_sortedGroups.push(priorityList[1]);
        }
        this.m_sortedGroups.sort((a, b) => {
            return b.priority - a.priority;
        });
        return this.m_sortedGroups;
    }
    /**
     * Apply function to all elements in this `GroupedPriorityList`.
     *
     * @param {(element: T) => void} fun Function to apply.
     */
    forEach(fun) {
        for (const group of this.groups) {
            group[1].elements.forEach(fun);
        }
    }
    /**
     * Count the number of elements in this `GroupedPriorityList`.
     */
    count() {
        let n = 0;
        for (const group of this.groups) {
            n += group[1].elements.length;
        }
        return n;
    }
    /**
     * Get group of elements that have the same (integer) priority.
     *
     * @param priority The priority to retrieve all elements from.
     */
    findGroup(priority) {
        const normalizedPriority = Math.floor(priority);
        const group = this.groups.get(normalizedPriority);
        return group;
    }
    /**
     * Get group of elements that have the same (integer) priority.
     *
     * @param priority The priority to retrieve all elements from.
     */
    getGroup(priority) {
        let group = this.findGroup(priority);
        if (group === undefined) {
            const normalizedPriority = Math.floor(priority);
            group = new PriorityListGroup(normalizedPriority);
            this.groups.set(normalizedPriority, group);
            if (this.m_sortedGroups) {
                this.m_sortedGroups = [];
            }
        }
        return group;
    }
}
exports.GroupedPriorityList = GroupedPriorityList;


/***/ }),

/***/ "../harp-utils/lib/Logger/ConsoleChannel.ts":
/*!**************************************************!*\
  !*** ../harp-utils/lib/Logger/ConsoleChannel.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Class for the default console channel.
 */
class ConsoleChannel {
    error(message, ...optionalParams) {
        // tslint:disable-next-line:no-console
        console.error(message, ...optionalParams);
    }
    debug(message, ...optionalParams) {
        // tslint:disable-next-line:no-console
        console.debug(message, ...optionalParams);
    }
    info(message, ...optionalParams) {
        // tslint:disable-next-line:no-console
        console.info(message, ...optionalParams);
    }
    log(message, ...optionalParams) {
        // tslint:disable-next-line:no-console
        console.log(message, ...optionalParams);
    }
    trace(message, ...optionalParams) {
        // tslint:disable-next-line:no-console
        console.trace(message, ...optionalParams);
    }
    warn(message, ...optionalParams) {
        // tslint:disable-next-line:no-console
        console.warn(message, ...optionalParams);
    }
}
exports.ConsoleChannel = ConsoleChannel;


/***/ }),

/***/ "../harp-utils/lib/Logger/ILogger.ts":
/*!*******************************************!*\
  !*** ../harp-utils/lib/Logger/ILogger.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Enum log levels
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Trace"] = 0] = "Trace";
    LogLevel[LogLevel["Debug"] = 1] = "Debug";
    LogLevel[LogLevel["Log"] = 2] = "Log";
    LogLevel[LogLevel["Info"] = 3] = "Info";
    LogLevel[LogLevel["Warn"] = 4] = "Warn";
    LogLevel[LogLevel["Error"] = 5] = "Error";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
/**
 * Logger options to configure logger
 */
class LoggerOptions {
}
exports.LoggerOptions = LoggerOptions;


/***/ }),

/***/ "../harp-utils/lib/Logger/Logger.ts":
/*!******************************************!*\
  !*** ../harp-utils/lib/Logger/Logger.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ILogger_1 = __webpack_require__(/*! ./ILogger */ "../harp-utils/lib/Logger/ILogger.ts");
/**
 * Logger class.
 */
class Logger {
    constructor(name, m_channel, options) {
        this.name = name;
        this.m_channel = m_channel;
        this.enabled = true;
        this.level = ILogger_1.LogLevel.Trace;
        if (options !== undefined) {
            this.update(options);
        }
    }
    error(message, ...optionalParams) {
        if (this.enabled && this.level <= ILogger_1.LogLevel.Error) {
            this.m_channel.error(this.prefix, message, ...optionalParams);
        }
    }
    debug(message, ...optionalParams) {
        if (this.enabled && this.level <= ILogger_1.LogLevel.Debug) {
            this.m_channel.debug(this.prefix, message, ...optionalParams);
        }
    }
    info(message, ...optionalParams) {
        if (this.enabled && this.level <= ILogger_1.LogLevel.Info) {
            this.m_channel.info(this.prefix, message, ...optionalParams);
        }
    }
    log(message, ...optionalParams) {
        if (this.enabled && this.level <= ILogger_1.LogLevel.Log) {
            this.m_channel.log(this.prefix, message, ...optionalParams);
        }
    }
    trace(message, ...optionalParams) {
        if (this.enabled && this.level <= ILogger_1.LogLevel.Trace) {
            this.m_channel.trace(this.prefix, message, ...optionalParams);
        }
    }
    warn(message, ...optionalParams) {
        if (this.enabled && this.level <= ILogger_1.LogLevel.Warn) {
            this.m_channel.warn(this.prefix, message, ...optionalParams);
        }
    }
    update(options) {
        this.enabled = options.enabled === undefined ? this.enabled : options.enabled;
        this.level = options.level === undefined ? this.level : options.level;
    }
    get prefix() {
        return this.name + ":";
    }
}
exports.Logger = Logger;


/***/ }),

/***/ "../harp-utils/lib/Logger/LoggerManager.ts":
/*!*************************************************!*\
  !*** ../harp-utils/lib/Logger/LoggerManager.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const LoggerManagerImpl_1 = __webpack_require__(/*! ./LoggerManagerImpl */ "../harp-utils/lib/Logger/LoggerManagerImpl.ts");
/**
 * The LoggerManager class implements a singleton object that handles logging.
 *
 * Example:
 *
 * ```typescript
 *
 * const logger = LoggerManager.instance.create("MyFontLoaderClass");
 * if (missingFonts.length > 0) {
 *     logger.error("These fonts can not be loaded: ", missingFonts);
 * } else {
 *     logger.log("All fonts have been loaded.");
 * }
 * ```
 */
class LoggerManager {
    static get instance() {
        return this.m_instance || (this.m_instance = new LoggerManagerImpl_1.LoggerManagerImpl());
    }
}
exports.LoggerManager = LoggerManager;


/***/ }),

/***/ "../harp-utils/lib/Logger/LoggerManagerImpl.ts":
/*!*****************************************************!*\
  !*** ../harp-utils/lib/Logger/LoggerManagerImpl.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ConsoleChannel_1 = __webpack_require__(/*! ./ConsoleChannel */ "../harp-utils/lib/Logger/ConsoleChannel.ts");
const Logger_1 = __webpack_require__(/*! ./Logger */ "../harp-utils/lib/Logger/Logger.ts");
const WorkerChannel_1 = __webpack_require__(/*! ./WorkerChannel */ "../harp-utils/lib/Logger/WorkerChannel.ts");
/**
 * LoggerManagerImpl is the class for the singleton instance of the logger manager.
 * It handles channels and loggers.
 */
class LoggerManagerImpl {
    constructor() {
        this.m_loggers = [];
        this.channel =
            typeof self === "undefined" || typeof self.document !== "undefined"
                ? new ConsoleChannel_1.ConsoleChannel()
                : new WorkerChannel_1.WorkerChannel();
    }
    getLoggerNames() {
        return this.m_loggers.map(logger => logger.name);
    }
    getLogger(name) {
        return this.m_loggers.find(logger => logger.name === name);
    }
    create(loggerName, options = {}) {
        if (this.m_levelSetForAll !== undefined &&
            (options.level === undefined || options.level < this.m_levelSetForAll)) {
            options.level = this.m_levelSetForAll;
        }
        const logger = new Logger_1.Logger(loggerName, this.channel, options);
        this.m_loggers.push(logger);
        return logger;
    }
    dispose(logger) {
        const found = this.m_loggers.indexOf(logger);
        if (found < 0) {
            throw new Error(`Cannot unregister "${logger}" : no such logger registered.`);
        }
        this.m_loggers.splice(found, 1);
    }
    updateAll(options) {
        for (const logger of this.m_loggers) {
            logger.update(options);
        }
    }
    update(loggerName, config) {
        for (const logger of this.m_loggers) {
            if (logger.name === loggerName) {
                logger.update(config);
            }
        }
    }
    enableAll(enabled) {
        for (const logger of this.m_loggers) {
            logger.enabled = enabled;
        }
    }
    enable(loggerName, value) {
        this.update(loggerName, { enabled: value });
    }
    setLogLevelForAll(level) {
        this.m_levelSetForAll = level;
        for (const logger of this.m_loggers) {
            logger.level = level;
        }
    }
    setLogLevel(loggerName, level) {
        this.update(loggerName, { level });
    }
    setChannel(channel) {
        this.channel = channel;
    }
}
exports.LoggerManagerImpl = LoggerManagerImpl;


/***/ }),

/***/ "../harp-utils/lib/Logger/MultiChannel.ts":
/*!************************************************!*\
  !*** ../harp-utils/lib/Logger/MultiChannel.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Class allowing mixing several channels.
 */
class MultiChannel {
    constructor(...channels) {
        this.channels = [];
        this.channels = channels;
    }
    error(message, ...optionalParams) {
        for (const channel of this.channels) {
            channel.error(message, ...optionalParams);
        }
    }
    debug(message, ...optionalParams) {
        for (const channel of this.channels) {
            channel.debug(message, ...optionalParams);
        }
    }
    info(message, ...optionalParams) {
        for (const channel of this.channels) {
            channel.info(message, ...optionalParams);
        }
    }
    log(message, ...optionalParams) {
        for (const channel of this.channels) {
            channel.log(message, ...optionalParams);
        }
    }
    trace(message, ...optionalParams) {
        for (const channel of this.channels) {
            channel.trace(message, ...optionalParams);
        }
    }
    warn(message, ...optionalParams) {
        for (const channel of this.channels) {
            channel.warn(message, ...optionalParams);
        }
    }
}
exports.MultiChannel = MultiChannel;


/***/ }),

/***/ "../harp-utils/lib/Logger/WorkerChannel.ts":
/*!*************************************************!*\
  !*** ../harp-utils/lib/Logger/WorkerChannel.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ILogger_1 = __webpack_require__(/*! ./ILogger */ "../harp-utils/lib/Logger/ILogger.ts");
exports.WORKERCHANNEL_MSG_TYPE = "worker-channel-message";
/**
 * The class for the worker channel.
 */
class WorkerChannel {
    error(message, ...optionalParams) {
        const workerMessage = {
            message: [message, ...optionalParams],
            type: exports.WORKERCHANNEL_MSG_TYPE,
            level: ILogger_1.LogLevel.Error
        };
        self.postMessage(workerMessage);
    }
    debug(message, ...optionalParams) {
        const workerMessage = {
            message: [message, ...optionalParams],
            type: exports.WORKERCHANNEL_MSG_TYPE,
            level: ILogger_1.LogLevel.Debug
        };
        self.postMessage(workerMessage);
    }
    info(message, ...optionalParams) {
        const workerMessage = {
            message: [message, ...optionalParams],
            type: exports.WORKERCHANNEL_MSG_TYPE,
            level: ILogger_1.LogLevel.Info
        };
        self.postMessage(workerMessage);
    }
    log(message, ...optionalParams) {
        const workerMessage = {
            message: [message, ...optionalParams],
            type: exports.WORKERCHANNEL_MSG_TYPE,
            level: ILogger_1.LogLevel.Log
        };
        self.postMessage(workerMessage);
    }
    trace(message, ...optionalParams) {
        const workerMessage = {
            message: [message, ...optionalParams],
            type: exports.WORKERCHANNEL_MSG_TYPE,
            level: ILogger_1.LogLevel.Trace
        };
        self.postMessage(workerMessage);
    }
    warn(message, ...optionalParams) {
        const workerMessage = {
            message: [message, ...optionalParams],
            type: exports.WORKERCHANNEL_MSG_TYPE,
            level: ILogger_1.LogLevel.Warn
        };
        self.postMessage(workerMessage);
    }
}
exports.WorkerChannel = WorkerChannel;


/***/ }),

/***/ "../harp-utils/lib/Logger/index.ts":
/*!*****************************************!*\
  !*** ../harp-utils/lib/Logger/index.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./ConsoleChannel */ "../harp-utils/lib/Logger/ConsoleChannel.ts"));
__export(__webpack_require__(/*! ./ILogger */ "../harp-utils/lib/Logger/ILogger.ts"));
__export(__webpack_require__(/*! ./Logger */ "../harp-utils/lib/Logger/Logger.ts"));
__export(__webpack_require__(/*! ./LoggerManager */ "../harp-utils/lib/Logger/LoggerManager.ts"));
__export(__webpack_require__(/*! ./MultiChannel */ "../harp-utils/lib/Logger/MultiChannel.ts"));
__export(__webpack_require__(/*! ./WorkerChannel */ "../harp-utils/lib/Logger/WorkerChannel.ts"));


/***/ }),

/***/ "../harp-utils/lib/Math2D.ts":
/*!***********************************!*\
  !*** ../harp-utils/lib/Math2D.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Math2D;
(function (Math2D) {
    /**
     * Alternative 2D box object with less memory impact (four numbers instead of two min/max
     * objects with two numbers each). Should be faster.
     */
    class Box {
        /**
         * Alternative 2D box object with less memory impact (four numbers instead of two min/max
         * objects with two numbers each). Should be faster.
         *
         * @param x New X value.
         * @param y New y value.
         * @param w New w value.
         * @param h New h value.
         */
        constructor(x = 0, y = 0, w = 0, h = 0) {
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
        }
        /**
         * Set new values to all properties of the box.
         *
         * @param x New X value.
         * @param y New y value.
         * @param w New w value.
         * @param h New h value.
         */
        set(x, y, w, h) {
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
        }
        /**
         * Test box for inclusion of point.
         *
         * @param x X coordinate of point.
         * @param y Y coordinate of point.
         */
        contains(x, y) {
            return this.x <= x && this.x + this.w >= x && this.y <= y && this.y + this.h >= y;
        }
        /**
         * Test box for inclusion of another box.
         *
         * @param other Box 2 to test for inclusion.
         */
        containsBox(other) {
            const xmax = other.x + other.w;
            const ymax = other.y + other.h;
            return (this.contains(other.x, other.y) &&
                this.contains(xmax, other.y) &&
                this.contains(other.x, ymax) &&
                this.contains(xmax, ymax));
        }
        /**
         * Test two boxes for intersection.
         *
         * @param other Box 2 to test for intersection.
         */
        intersects(other) {
            return (this.x <= other.x + other.w &&
                this.x + this.w >= other.x &&
                this.y <= other.y + other.h &&
                this.y + this.h >= other.y);
        }
    }
    Math2D.Box = Box;
    /**
     * Compute squared distance between two 2D points `a` and `b`.
     *
     * @param ax Point a.x
     * @param ay Point a.y
     * @param bx Point b.x
     * @param by Point b.y
     * @returns Squared distance between the two points
     */
    function distSquared(ax, ay, bx, by) {
        return (ax - bx) * (ax - bx) + (ay - by) * (ay - by);
    }
    Math2D.distSquared = distSquared;
    /**
     * Computes the squared length of a line.
     *
     * @param line An array of that forms a line via [x,y,z,x,y,z,...] tuples.
     */
    function computeSquaredLineLength(line) {
        let squaredLineLength = 0;
        const length = line.length - 4;
        for (let i = 0; i < length; i += 3) {
            const xDiff = line[i + 3] - line[i];
            const yDiff = line[i + 4] - line[i + 1];
            squaredLineLength += xDiff * xDiff + yDiff * yDiff;
        }
        return squaredLineLength;
    }
    Math2D.computeSquaredLineLength = computeSquaredLineLength;
    /**
     * Compute squared distance between a 2D point and a 2D line segment.
     *
     * @param px Test point X
     * @param py Test point y
     * @param l0x Line segment start X
     * @param l0y Line segment start Y
     * @param l1x Line segment end X
     * @param l1y Line segment end Y
     * @returns Squared distance between point and line segment
     */
    function distToSegmentSquared(px, py, l0x, l0y, l1x, l1y) {
        const lineLengthSuared = distSquared(l0x, l0y, l1x, l1y);
        if (lineLengthSuared === 0) {
            return distSquared(px, py, l0x, l0y);
        }
        let t = ((px - l0x) * (l1x - l0x) + (py - l0y) * (l1y - l0y)) / lineLengthSuared;
        t = Math.max(0, Math.min(1, t));
        return distSquared(px, py, l0x + t * (l1x - l0x), l0y + t * (l1y - l0y));
    }
    Math2D.distToSegmentSquared = distToSegmentSquared;
})(Math2D = exports.Math2D || (exports.Math2D = {}));


/***/ }),

/***/ "../harp-utils/lib/MathUtils.ts":
/*!**************************************!*\
  !*** ../harp-utils/lib/MathUtils.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
var MathUtils;
(function (MathUtils) {
    /**
     * Ensures that input value fits in a given range.
     *
     * @param value The value to be clamped.
     * @param min Minimum value.
     * @param max Maximum value.
     *
     * @returns Clamped value.
     */
    function clamp(value, min, max) {
        return value < min ? min : value > max ? max : value;
    }
    MathUtils.clamp = clamp;
    /**
     * Returns a linear interpolation between the values of edge0 and edge1 based on the factor.
     *
     * Given two known points the linear interpolant between these points may be presented as
     * straight line. This means that for given factor change the resulting change of return
     * value is always const.
     * @see https://en.wikipedia.org/wiki/Linear_interpolation
     *
     * @param edge0
     * @param edge1
     * @param factor Interpolation factor that ranges between: 0 <= x <= 1.
     */
    function lerp(edge0, edge1, factor) {
        return edge0 * (1 - factor) + edge1 * factor;
    }
    MathUtils.lerp = lerp;
    /**
     * Returns a smooth interpolation between the values edge0 and edge1 based on the interpolation
     * factor x. `0 <= x <= 1`.
     * @see https://en.wikipedia.org/wiki/Smoothstep
     *
     * @param edge0
     * @param edge1
     * @param x
     */
    function smoothStep(edge0, edge1, x) {
        // Scale, bias and saturate x to 0..1 range
        x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
        // Evaluate polynomial
        return x * x * (3 - 2 * x);
    }
    MathUtils.smoothStep = smoothStep;
    /**
     * Returns a smooth interpolation between the values edge0 and edge1 based on the interpolation
     * factor x. `0 <= x <= 1`.
     *
     * Improved version by Ken Perlin, which has zero 1st- and 2nd-order derivatives at `x = 0` and
     * `x = 1`:
     *
     * @see https://en.wikipedia.org/wiki/Smoothstep
     *
     * @param edge0
     * @param edge1
     * @param x
     */
    function smootherStep(edge0, edge1, x) {
        // Scale, and clamp x to 0..1 range
        x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
        // Evaluate polynomial
        return x * x * x * (x * (x * 6 - 15) + 10);
    }
    MathUtils.smootherStep = smootherStep;
    /**
     * Maps a number from one range to another.
     *
     * @param val The incoming value to be converted.
     * @param inMin Lower bound of the value's current range.
     * @param inMax Upper bound of the value's current range.
     * @param outMin Lower bound of the value's target range.
     * @param outMax Upper bound of the value's target range.
     */
    function map(val, inMin, inMax, outMin, outMax) {
        return ((val - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;
    }
    MathUtils.map = map;
    /**
     * Returns the smaller of the two given numbers. Both numbers may be undefined, in which case
     * the result is undefined. If only one of the numbers is undefined, the other number is
     * returned.
     *
     * @param a First number.
     * @param b Second number.
     */
    function min2(a, b) {
        let result;
        if (a !== undefined) {
            result = a;
        }
        if (b !== undefined) {
            result = result === undefined ? b : Math.min(result, b);
        }
        return result;
    }
    MathUtils.min2 = min2;
    /**
     * Returns the larger of the two given numbers. Both numbers may be undefined, in which case
     * the result is undefined. If only one of the numbers is undefined, the other number is
     * returned.
     *
     * @param a First number.
     * @param b Second number.
     */
    function max2(a, b) {
        let result;
        if (a !== undefined) {
            result = a;
        }
        if (b !== undefined) {
            result = result === undefined ? b : Math.max(result, b);
        }
        return result;
    }
    MathUtils.max2 = max2;
    /**
     * Checks if the value of a given number is inside an upper or lower bound. The bounds may be
     * undefined, in which case their value is ignored.
     *
     * @param value Value to check.
     * @param lowerBound The lower bound to check the value against.
     * @param upperBound The upper bound to check the value against.
     *
     * @returns `true` if value is inside the bounds or if the bounds are `undefined`, `false`
     *          otherwise.
     */
    function isClamped(value, lowerBound, upperBound) {
        if (lowerBound !== undefined && value < lowerBound) {
            return false;
        }
        if (upperBound !== undefined && value > upperBound) {
            return false;
        }
        return true;
    }
    MathUtils.isClamped = isClamped;
    /**
     * Smoothly interpolates between two values using cubic formula
     *
     * @param startValue
     * @param endValue
     * @param time
     * @returns Result of the interpolation within the range of `[startValue, endValue]`
     */
    function easeInOutCubic(startValue, endValue, time) {
        const timeValue = time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1;
        return startValue + (endValue - startValue) * timeValue;
    }
    MathUtils.easeInOutCubic = easeInOutCubic;
})(MathUtils = exports.MathUtils || (exports.MathUtils = {}));


/***/ }),

/***/ "../harp-utils/lib/Mixins.ts":
/*!***********************************!*\
  !*** ../harp-utils/lib/Mixins.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copy methods and properties from one prototype into another.
 *
 * @see https://www.typescriptlang.org/docs/handbook/mixins.html
 *
 * @param derivedCtor Class to mix methods and properties into.
 * @param baseCtors Class to take all methods and properties from.
 */
function applyMixins(derivedCtor, baseCtors) {
    baseCtors.forEach(baseCtor => {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
            derivedCtor.prototype[name] = baseCtor.prototype[name];
        });
    });
}
exports.applyMixins = applyMixins;
/**
 * Copy methods from one prototype into another.
 *
 * @see https://www.typescriptlang.org/docs/handbook/mixins.html
 *
 * @param derivedCtor Class to mix methods into.
 * @param baseCtors Class to take all methods from.
 */
function applyMixinsWithoutProperties(derivedCtor, baseCtors) {
    baseCtors.forEach(baseCtor => {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
            const descriptor = Object.getOwnPropertyDescriptor(baseCtor.prototype, name);
            if (descriptor !== undefined &&
                descriptor.get === undefined &&
                name !== "constructor") {
                derivedCtor.prototype[name] = baseCtor.prototype[name];
            }
        });
    });
}
exports.applyMixinsWithoutProperties = applyMixinsWithoutProperties;


/***/ }),

/***/ "../harp-utils/lib/ObjectUtils.ts":
/*!****************************************!*\
  !*** ../harp-utils/lib/ObjectUtils.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Deep clone of object.
 *
 * Like `JSON.parse(JSON.stringify(obj))`, but supports basic javascript types (string, number,
 * object), `Date` and `RegExp`s and cycles.
 *
 * Throws error if enounters object with `prototype` assuming that in general class instances
 * cannot be reliably cloned by generic algorithm.
 */
function cloneDeep(obj) {
    const cache = new Map();
    function cloneInternal(src) {
        if (src === null) {
            return null;
        }
        else if (typeof src === "object") {
            const cached = cache.get(src);
            if (cached !== undefined) {
                return cached;
            }
            if (Array.isArray(src)) {
                const result = [];
                cache.set(src, result);
                result.length = src.length;
                for (let i = 0; i < result.length; ++i) {
                    result[i] = cloneInternal(src[i]);
                }
                return result;
            }
            else if (src instanceof Date) {
                const result = new Date(src.getTime());
                cache.set(src, result);
                return result;
            }
            else if (src instanceof RegExp) {
                const result = new RegExp(src.source, src.flags);
                cache.set(src, result);
                return result;
            }
            else if (src.constructor !== Object) {
                throw new Error("cloneDeep doesn't support objects with custom prototypes");
            }
            else {
                const result = {};
                cache.set(src, result);
                for (const key in src) {
                    if (src.hasOwnProperty(key)) {
                        result[key] = cloneInternal(src[key]);
                    }
                }
                return result;
            }
        }
        else {
            // string, number, boolean, undefined and functions are returned as is
            return src;
        }
    }
    const r = cloneInternal(obj);
    cache.clear();
    return r;
}
exports.cloneDeep = cloneDeep;


/***/ }),

/***/ "../harp-utils/lib/OptionsUtils.ts":
/*!*****************************************!*\
  !*** ../harp-utils/lib/OptionsUtils.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
function getOptionValue(...values) {
    for (const candidate of values) {
        if (candidate !== undefined && candidate !== null) {
            return candidate;
        }
    }
    return undefined;
}
exports.getOptionValue = getOptionValue;
/**
 * Merge options into existing parameters object.
 *
 * Convenience helper with _similar_ semantics as:
 *
 *     const finalParams1 = { ...defaults, ... options };
 *     const finalParams2 = Object.assign({}, defaults, options);
 *
 * This function doesn't copy _extra_ properties of `options` that doesn't exist in `defaults`.
 * `defaults` is used as _parameters_ template.
 *
 * This doc uses following notion of `option` and `parameter` terms:
 * * `parameter` is a variable, or 'almost constant' of procedure/function/algorith/object
 *    * `parameter` usually have sensible and usually used default
 *    * `parameter` is always defined (no `undefined`, `null` or `?` in type)
 *    * `parameter` can be overriden by specyfying `option` with same name
 * * `option` means value that may be passed optionally, overrides `parameter` value with same name
 *
 * Usage:
 *
 *     interface FooParams {
 *         useTextures: boolean;
 *         opacity: number;
 *     }
 *
 *     const FOO_DEFAULTS: FooParams = {
 *         useTextures: true,
 *         opacity: 0.8
 *     };
 *
 *     type FooOptions = Partial<FooParams>;
 *
 *     function doSomething(options: FooOptions) {
 *         const params = mergeWithOptions(FOO_DEFAULTS, options);
 *             // typeof params === FooParams
 *             // params.opacity = 0.5
 *             // params.useTextures = true
 *             // params.someOtherOptionFromOtherApi is not defined
 *     }
 *     const opt = {opacity: 0.5, someOtherOptionFromOtherApi: 'aaa'};
 *     doSomething(opt);
 *
 * Rationale:
 *   * both `Object.assign` and spread operator copy extra options
 *   * `Object.assign` & `spread operator` may copy `undefined` and `null`s if they really exist
 *     in options object
 *
 * @param parameters parmeters template object holding all expected parameters
 * @param options options object
 * @returns new object with `parameters` overriden by values from `options`
 */
function mergeWithOptions(parameters, options) {
    // NOTE: `as object` needed due to TypeScript bug:
    //       https://github.com/Microsoft/TypeScript/issues/14409
    // tslint:disable-next-line:no-object-literal-type-assertion
    const result = Object.assign({}, parameters);
    if (options === undefined || options === null) {
        return result;
    }
    for (const prop in parameters) {
        if (parameters.hasOwnProperty(prop)) {
            const optionValue = options[prop];
            if (optionValue !== undefined && optionValue !== null) {
                result[prop] = optionValue;
            }
        }
    }
    return result;
}
exports.mergeWithOptions = mergeWithOptions;


/***/ }),

/***/ "../harp-utils/lib/PerformanceTimer.ts":
/*!*********************************************!*\
  !*** ../harp-utils/lib/PerformanceTimer.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable:max-line-length */
/**
 * See:
 * https://developers.google.com/web/updates/2012/08/When-milliseconds-are-not-enough-performance-now
 */
/* tslint:ensable:max-line-length */
class PerformanceTimer {
    /**
     * Returns timestamp in milliseconds since page load.
     *
     * If the [[DOMHighResTimeStamp]] is supported, the resolution is up to 5 microseconds,
     * otherwise it is in milliseconds. Timespans are computed by taking the difference between two
     * samples.
     *
     * Example:
     * ```typescript
     * const now = PerformanceTimer.now();
     * // call some expensive function for which you want to check the duration.
     * const end = PerformanceTimer.now();
     * const elapsedTime = end - now;
     * ```
     */
    static now() {
        return PerformanceTimer.nowFunc();
    }
    static getNowFunc() {
        if (typeof performance !== "undefined" && typeof performance.now !== "undefined") {
            return () => performance.now();
        }
        // fall back to Date.getTime()
        return () => {
            return new Date().getTime();
        };
    }
}
exports.PerformanceTimer = PerformanceTimer;
// tslint:disable-next-line:no-unused-variable
PerformanceTimer.instance = new PerformanceTimer();
PerformanceTimer.nowFunc = PerformanceTimer.getNowFunc();


/***/ }),

/***/ "../harp-utils/lib/UriResolver.ts":
/*!****************************************!*\
  !*** ../harp-utils/lib/UriResolver.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const UrlUtils_1 = __webpack_require__(/*! ./UrlUtils */ "../harp-utils/lib/UrlUtils.ts");
/**
 * Basic, import-map like [[UriResolver]].
 *
 * Resolves `uris` basing on exact or prefix match of `key` from `definitions`.
 *
 * In definitions, `key` is matched against input uri with following strategy:
 *  - `key` without trailing `/` -> `key` and input `uri` must be identical
 *  - `key` with trailing `/`, -> `key` is treated as "package prefix", so `uri` must start with
 *    `key`
 *
 * Example:
 * ```
 * {
 *     "local://poiMasterList": "/assets/poiMasterList.json"
 *        // will match only 'local://poiMasterList' and resolve `/assets/poiMasterList.json`
 *     "local://icons/": "/assets/icons/"
 *        // will match only 'local://icons/ANYPATH' (and similar) and resolve to
 *        // `/assets/icons/ANYPATH
 * }
 * ```
 * Inspired by [`WICG` import maps proposal](https://github.com/WICG/import-maps#the-import-map).
 */
class PrefixMapUriResolver {
    constructor(definitions) {
        this.definitions = definitions;
    }
    resolveUri(uri) {
        return Object.keys(this.definitions).reduce((r, key) => {
            if (key.endsWith("/") && r.startsWith(key)) {
                const newPrefix = this.definitions[key];
                return newPrefix + r.substr(key.length);
            }
            else if (r === key) {
                return this.definitions[key];
            }
            return r;
        }, uri);
    }
}
exports.PrefixMapUriResolver = PrefixMapUriResolver;
/**
 * [UriResolver] that resolve relative `uri`s against to parent resource `uri`.
 */
class RelativeUriResolver {
    constructor(parentUri) {
        this.parentUri = parentUri;
    }
    resolveUri(uri) {
        return UrlUtils_1.resolveReferenceUri(this.parentUri, uri);
    }
}
exports.RelativeUriResolver = RelativeUriResolver;
/**
 * Compose URI resolvers.
 *
 * Creates new [[UriResolver]] that applies resolvers in orders or arguments.
 *
 * Example:
 *
 *     const themeUrl = ...; // url of parent object
 *     const childUrlResolver = composeUrlResolvers(
 *           new RelativeUriResolver(themeUrl),
 *           defaultUrlResolver
 *     );
 */
function composeUriResolvers(...resolvers) {
    return {
        resolveUri(originalUrl) {
            return resolvers.reduce((url, resolver) => {
                if (resolver !== undefined) {
                    return resolver.resolveUri(url);
                }
                else {
                    return url;
                }
            }, originalUrl);
        }
    };
}
exports.composeUriResolvers = composeUriResolvers;


/***/ }),

/***/ "../harp-utils/lib/UrlPlatformUtils.web.ts":
/*!*************************************************!*\
  !*** ../harp-utils/lib/UrlPlatformUtils.web.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const UrlUtils_1 = __webpack_require__(/*! ./UrlUtils */ "../harp-utils/lib/UrlUtils.ts");
/**
 * Get base URL for from where relative URLs will be loaded.
 *
 * * In browser, it resolves to `baseUrl(location.href)` i.e document's base URL
 * (see: https://www.w3.org/TR/WD-html40-970917/htmlweb.html#h-5.1.2).
 *
 * * In node, it resolves to `file://${process.cwd()}`.
 */
function getAppBaseUrl() {
    return UrlUtils_1.baseUrl(window.location.href);
}
exports.getAppBaseUrl = getAppBaseUrl;


/***/ }),

/***/ "../harp-utils/lib/UrlUtils.ts":
/*!*************************************!*\
  !*** ../harp-utils/lib/UrlUtils.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Resolve URI of referenced object w.r.t parent URI.
 *
 * Resolves `childUri` as it would be loaded from location specified by `parentUri`.
 *
 * If `childUri` is absolute, then it is returned unchanged.
 * If `childUri` is origin-absolute path, then only origin path is taken from `parentUri`.
 *
 * See [[baseUri]] for reference how base URL of `parentUri` is determined.
 *
 * Examples:
 *
 *     // normal case, child is sibling
 *     https://foo.com/themes/day.json + images/foo.png -> https://foo.com/themes/images/foo.png
 *
 *     // parent is "folder", so child is just located in this folder
 *     https://foo.com/themes/ + images/foo.png -> https://foo.com/themes/images/foo.png
 *
 *     // parent looks like leaf, so last component is stripped
 *     https://foo.com/themes + images/foo.png -> https://foo.com/images/foo.png
 *
 *     // origin-absolute URL, takes only origin from parent
 *     https://foo.com/themes/day.json + /fonts/foo.json -> https://foo.com/fonts/foo.json
 *
 * @param parentUri URI of parent resource
 * @param childUri URI of child as referenced from parent resource
 * @return `childUrl` as if anchored in location of `parentUrl`
 */
function resolveReferenceUri(parentUri, childUri) {
    if (absoluteUrlWithOriginRe.test(childUri)) {
        return childUri;
    }
    else if (childUri.startsWith("/")) {
        const origin = getUrlOrigin(parentUri);
        return origin + childUri;
    }
    else {
        if (childUri.startsWith("./")) {
            childUri = childUri.substr(2);
        }
        const parentBaseUrl = baseUrl(parentUri);
        return parentBaseUrl + childUri;
    }
}
exports.resolveReferenceUri = resolveReferenceUri;
const absoluteUrlWithOriginRe = new RegExp("^(?:[a-z]+:)?//", "i");
/**
 * Returns base URL of given resource URL.
 *
 * `Url` with trailing slash are considered genuine 'locations', they are returned as is, however if
 * `url` ends with name component it is treated as "leaf", so last path component is removed.
 *
 * Standalone files (without any folder structure) are considered relative to `./`.
 *
 * Examples:
 * ```
 *     https://foo.com/themes/a.json -> https://foo.com/themes/
 *     https://foo.com/themes/ -> https://foo.com/themes/
 *     https://foo.com/themes -> https://foo.com/ // note, themes is treated as leaf
 *     themes/day.json -> themes/
 *     themes -> ./
 * ```
 */
function baseUrl(url) {
    if (url === undefined) {
        return "./";
    }
    let idx = url.indexOf("#");
    if (idx !== -1) {
        url = url.slice(0, idx);
    }
    idx = url.indexOf("?");
    if (idx !== -1) {
        url = url.slice(0, idx);
    }
    idx = url.lastIndexOf("/");
    if (idx === -1) {
        return "./";
    }
    else {
        return url.substring(0, idx + 1);
    }
}
exports.baseUrl = baseUrl;
/**
 * Get `origin` part of URL.
 *
 * @example
 *    https://example.com/foo -> https://example.com
 *    //example.com:8080/ -> //example.com:8080
 *    file:///etc/hosts ->
 *
 * @param url input URL
 * @return origin of given URL
 */
function getUrlOrigin(url) {
    if (url === undefined) {
        return "";
    }
    const parsed = getUrlHostAndProtocol(url);
    if (parsed.protocol === "file:") {
        return "file://";
    }
    else if (parsed.host && parsed.protocol) {
        return parsed.protocol + "//" + parsed.host;
    }
    else if (parsed.host) {
        return "//" + parsed.host;
    }
    else if (parsed.protocol) {
        return parsed.protocol + "//";
    }
    else {
        return "";
    }
}
exports.getUrlOrigin = getUrlOrigin;
/**
 * Parse `host` and `protocol` part from URL.
 */
function getUrlHostAndProtocol(url) {
    const urlOriginRe = new RegExp(/^(?:([a-z]+:))?\/\/([^\/]*)/, "i");
    const match = url.match(urlOriginRe);
    if (!match) {
        throw new Error(`getUrlHostAndProtocol: unable to parse URL '${url}'`);
    }
    return {
        protocol: match[1],
        host: match[2]
    };
}
exports.getUrlHostAndProtocol = getUrlHostAndProtocol;


/***/ }),

/***/ "../harp-utils/lib/assert.ts":
/*!***********************************!*\
  !*** ../harp-utils/lib/assert.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
// cache value, because access to process.env.NODE_ENV is SLOW!
const isProduction = "development" === "production";
//TODO: Make assertHandler configurable
/**
 * Implementation of assert as a development help
 *
 * Note - this is deliberately a global function so that minimizers remove the
 * entire call when building for production.
 *
 * @hidden
 * @param condition Condition to match, if false, throws an Error(message)
 * @param message Optional message, defaults to "ASSERTION failed"
 */
function assert(condition, message) {
    if (!isProduction) {
        if (!condition) {
            throw new Error(message !== undefined ? message : "ASSERTION failed");
        }
    }
}
exports.assert = assert;
function assertExists(element, message) {
    if (!isProduction) {
        if (element === undefined || element === null) {
            throw new Error(message !== undefined ? message : "ASSERTION failed: Element is undefined or null");
        }
    }
    return element;
}
exports.assertExists = assertExists;


/***/ }),

/***/ "../harp-webtile-datasource/index.ts":
/*!*******************************************!*\
  !*** ../harp-webtile-datasource/index.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./lib/WebTileDataSource */ "../harp-webtile-datasource/lib/WebTileDataSource.ts"));


/***/ }),

/***/ "../harp-webtile-datasource/lib/WebTileDataSource.ts":
/*!***********************************************************!*\
  !*** ../harp-webtile-datasource/lib/WebTileDataSource.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __webpack_require__(/*! three */ "three");
// tslint:disable-next-line: max-line-length
const SphericalGeometrySubdivisionModifier_1 = __webpack_require__(/*! @here/harp-geometry/lib/SphericalGeometrySubdivisionModifier */ "../harp-geometry/lib/SphericalGeometrySubdivisionModifier.ts");
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
const logger = harp_utils_1.LoggerManager.instance.create("MapView");
const textureLoader = new THREE.TextureLoader();
textureLoader.crossOrigin = ""; // empty assignment required to support CORS
/**
 * Mapping from ISO-639-1 language codes to codes used by HERE Map Tile API (MARC)
 *
 * @see https://developer.here.com/documentation/map-tile/topics/resource-base-maptile.html
 * @see [MARC Code List for Languages](https://www.loc.gov/marc/languages/)
 */
const WEBTILE_LANGUAGE_DICTIONARY = {
    eu: "baq",
    ca: "cat",
    zh: "chi",
    cs: "cze",
    da: "dan",
    nl: "dut",
    en: "eng",
    fi: "fin",
    fr: "fre",
    de: "ger",
    ga: "gle",
    el: "gre",
    he: "heb",
    hi: "hin",
    id: "ind",
    it: "ita",
    no: "nor",
    fa: "per",
    pl: "pol",
    pt: "por",
    ru: "rus",
    si: "sin",
    es: "spa",
    sv: "swe",
    th: "tha",
    tr: "tur",
    uk: "ukr",
    ur: "urd",
    vi: "vie",
    cy: "wel"
};
/**
 * Instances of `WebTileDataSource` can be used to add Web Tile to [[MapView]].
 *
 * Example:
 *
 * ```typescript
 * const webTileDataSource = new WebTileDataSource({
 *     appId: <appId>,
 *     appCode: <appCode>
 * });
 * ```
 * @see [[DataSource]], [[OmvDataSource]].
 */
class WebTileDataSource extends harp_mapview_1.DataSource {
    /**
     * Constructs a new `WebTileDataSource`.
     *
     * @param m_options Represents the [[WebTileDataSourceParameters]].
     */
    constructor(m_options) {
        super("webtile", undefined, 1, 20);
        this.m_options = m_options;
        /** Predefined fixed HERE copyright info. */
        this.HERE_COPYRIGHT_INFO = {
            id: "here.com",
            year: new Date().getFullYear(),
            label: "HERE",
            link: "https://legal.here.com/terms"
        };
        this.cacheable = true;
        this.storageLevelOffset = -1;
        this.m_resolution = harp_utils_1.getOptionValue(m_options.resolution, 512 /* resolution512 */);
        if (this.m_resolution === 512 /* resolution512 */) {
            this.maxZoomLevel = 19; // 512x512 tiles do not have z19
        }
        this.m_ppi = harp_utils_1.getOptionValue(m_options.ppi, 72 /* ppi72 */);
        this.m_tileBaseAddress = m_options.tileBaseAddress || WebTileDataSource.TILE_BASE_NORMAL;
        if (this.m_tileBaseAddress === WebTileDataSource.TILE_AERIAL_SATELLITE &&
            this.m_ppi !== 72 /* ppi72 */) {
            throw new Error("Requested combination of scheme satellite.day and ppi is not valid");
        }
        const mapTileParams = this.parseBaseUrl(this.m_tileBaseAddress);
        const baseHostName = mapTileParams.baseUrl;
        const mapId = harp_utils_1.getOptionValue(mapTileParams.mapVersion, "newest");
        const scheme = mapTileParams.scheme || "normal.day";
        const baseScheme = scheme.split(".")[0] || "normal";
        const { appId, appCode } = this.m_options;
        const url = `https://1.${baseHostName}/maptile/2.1/copyright/${mapId}` +
            `?output=json&app_id=${appId}&app_code=${appCode}`;
        this.m_copyrightProvider = new harp_mapview_1.UrlCopyrightProvider(url, baseScheme);
    }
    /** @override */
    shouldPreloadTiles() {
        return true;
    }
    /** @override */
    getTilingScheme() {
        return harp_geoutils_1.webMercatorTilingScheme;
    }
    /** @override */
    setLanguages(languages) {
        if (languages !== undefined) {
            this.mapIsoLanguageToWebTile(languages);
            this.mapView.markTilesDirty(this);
        }
    }
    /** @override */
    getTile(tileKey) {
        const tile = new harp_mapview_1.Tile(this, tileKey);
        const column = tileKey.column;
        const row = tileKey.row;
        const level = tileKey.level;
        const { appId, appCode } = this.m_options;
        const quadKey = tileKey.toQuadKey();
        const server = parseInt(quadKey[quadKey.length - 1], 10) + 1;
        let url = `https://${server}.${this.m_tileBaseAddress}/` +
            `${level}/${column}/${row}/${this.m_resolution}/png8` +
            `?app_id=${appId}&app_code=${appCode}` +
            harp_utils_1.getOptionValue(this.m_options.additionalRequestParameters, "");
        if (this.m_ppi !== 72 /* ppi72 */) {
            // because ppi=72 is default, we do not include it in the request
            url += `&ppi=${this.m_ppi}`;
        }
        if (this.m_languages !== undefined && this.m_languages[0] !== undefined) {
            url += `&lg=${this.m_languages[0]}`;
        }
        if (this.m_languages !== undefined && this.m_languages[1] !== undefined) {
            url += `&lg2=${this.m_languages[1]}`;
        }
        Promise.all([this.loadTexture(url), this.getTileCopyright(tile)])
            .then(([texture, copyrightInfo]) => {
            tile.copyrightInfo = copyrightInfo;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.generateMipmaps = false;
            tile.addOwnedTexture(texture);
            const shouldSubdivide = this.projection.type === harp_geoutils_1.ProjectionType.Spherical;
            const sourceProjection = this.getTilingScheme().projection;
            const tmpV = new THREE.Vector3();
            const { east, west, north, south } = tile.geoBox;
            const g = new THREE.BufferGeometry();
            const posAttr = new THREE.BufferAttribute(new Float32Array([
                ...sourceProjection
                    .projectPoint(new harp_geoutils_1.GeoCoordinates(south, west), tmpV)
                    .toArray(),
                ...sourceProjection
                    .projectPoint(new harp_geoutils_1.GeoCoordinates(south, east), tmpV)
                    .toArray(),
                ...sourceProjection
                    .projectPoint(new harp_geoutils_1.GeoCoordinates(north, west), tmpV)
                    .toArray(),
                ...sourceProjection
                    .projectPoint(new harp_geoutils_1.GeoCoordinates(north, east), tmpV)
                    .toArray()
            ]), 3);
            g.setAttribute("position", posAttr);
            const uvAttr = new THREE.BufferAttribute(new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), 2);
            g.setAttribute("uv", uvAttr);
            g.setIndex(new THREE.BufferAttribute(new Uint16Array([0, 1, 2, 2, 1, 3]), 1));
            if (shouldSubdivide) {
                const modifier = new SphericalGeometrySubdivisionModifier_1.SphericalGeometrySubdivisionModifier(THREE.Math.degToRad(10), sourceProjection);
                modifier.modify(g);
            }
            for (let i = 0; i < posAttr.array.length; i += 3) {
                tmpV.set(posAttr.array[i], posAttr.array[i + 1], posAttr.array[i + 2]);
                this.projection.reprojectPoint(sourceProjection, tmpV, tmpV);
                tmpV.sub(tile.center);
                posAttr.array[i] = tmpV.x;
                posAttr.array[i + 1] = tmpV.y;
                posAttr.array[i + 2] = tmpV.z;
            }
            posAttr.needsUpdate = true;
            const opacity = this.m_options.renderingOptions !== undefined
                ? this.m_options.renderingOptions.opacity
                : 1;
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                depthTest: false,
                depthWrite: false,
                opacity,
                transparent: opacity !== undefined && opacity < 1.0 ? true : false
            });
            const mesh = new THREE.Mesh(g, material);
            tile.objects.push(mesh);
            tile.invalidateResourceInfo();
            this.requestUpdate();
        })
            .catch(error => {
            logger.error(`failed to load webtile ${tileKey.mortonCode()}: ${error}`);
        });
        return tile;
    }
    parseBaseUrl(url) {
        const parsed = new URL(url.startsWith("https:") ? url : `https://${url}`);
        const fullPath = parsed.pathname;
        const maptilePathRegexp = new RegExp("^(/maptile/2.1/)([^/]+)/([^/]+)/([^/]+)");
        const match = fullPath.match(maptilePathRegexp);
        if (!match) {
            throw new Error(`WebTileDataSource: invalid baseUrl: ${url}`);
        }
        return {
            baseUrl: parsed.host,
            path: match[1],
            tileType: match[2],
            mapVersion: match[3],
            scheme: match[4]
        };
    }
    loadTexture(url) {
        return new Promise((resolve, reject) => {
            textureLoader.load(url, texture => {
                resolve(texture);
            }, undefined, // onProgress
            () => {
                // ErrorEvent received here doesn't have any meaningful code/ message to be
                // shown
                reject(new Error("failed to load texture"));
            });
        });
    }
    async getTileCopyright(tile) {
        if (this.m_options.gatherCopyrightInfo === false) {
            return [this.HERE_COPYRIGHT_INFO];
        }
        return this.m_copyrightProvider.getCopyrights(tile.geoBox, tile.tileKey.level);
    }
    mapIsoLanguageToWebTile(languages) {
        this.m_languages = [];
        for (const language of languages) {
            if (WEBTILE_LANGUAGE_DICTIONARY[language] !== undefined) {
                this.m_languages.push(WEBTILE_LANGUAGE_DICTIONARY[language]);
            }
        }
    }
}
exports.WebTileDataSource = WebTileDataSource;
/**
 * Base address for Base Map rendered using `normal.day` scheme.
 * @see https://developer.here.com/documentation/map-tile/topics/example-normal-day-view.html
 */
WebTileDataSource.TILE_BASE_NORMAL = "base.maps.api.here.com/maptile/2.1/maptile/newest/normal.day";
/**
 * Base address for Aerial Map rendered using `hybrid.day` scheme.
 * @see https://developer.here.com/documentation/map-tile/topics/example-hybrid-map.html
 */
WebTileDataSource.TILE_AERIAL_HYBRID = "aerial.maps.api.here.com/maptile/2.1/maptile/newest/hybrid.day";
/**
 * Base address for Aerial Map rendered using `satellite.day` scheme.
 * @see https://developer.here.com/documentation/map-tile/topics/example-satellite-map.html
 */
WebTileDataSource.TILE_AERIAL_SATELLITE = "aerial.maps.api.here.com/maptile/2.1/maptile/newest/satellite.day";
/**
 * Base address for Traffic Map rendered using `normal.day` scheme.
 * @see https://developer.here.com/documentation/map-tile/topics/example-traffic.html
 */
WebTileDataSource.TILE_TRAFFIC_NORMAL = "traffic.maps.api.here.com/maptile/2.1/traffictile/newest/normal.day";


/***/ }),

/***/ "./lib/BundleMain.ts":
/*!***************************!*\
  !*** ./lib/BundleMain.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.js");
const WorkerLoader_1 = __webpack_require__(/*! @here/harp-mapview/lib/workers/WorkerLoader */ "../harp-mapview/lib/workers/WorkerLoader.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.web.ts");
/**
 * Default decoder url for bundled map component.
 */
exports.DEFAULT_DECODER_SCRIPT_URL = "harp.js-bundle://harp-decoders.js";
/**
 * Basename of map bundle script - used by [[getBundleScriptUrl]] as fallback, when
 * `document.currentScript` is not present.
 *
 * @hidden
 */
exports.BUNDLE_SCRIPT_BASENAME = "harp";
/**
 * Guess `harp(.min).js` script URL.
 *
 * Required to find default URLs `harp-decoders.js` which are hosted together, not necessarily with
 * base URL of current page.
 *
 * @see https://stackoverflow.com/questions/2976651
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/currentScript
 * @hidden
 */
function getBundleScriptUrl() {
    if (bundleScriptUrl !== undefined) {
        return bundleScriptUrl;
    }
    const currentScript = document.currentScript;
    const baseScriptUrl = currentScript !== null &&
        typeof currentScript.src === "string" &&
        (currentScript.src.endsWith(exports.BUNDLE_SCRIPT_BASENAME + ".js") ||
            currentScript.src.endsWith(exports.BUNDLE_SCRIPT_BASENAME + ".min.js"))
        ? currentScript.src
        : getScriptUrl(exports.BUNDLE_SCRIPT_BASENAME);
    if (baseScriptUrl) {
        bundleScriptUrl = baseScriptUrl;
        return bundleScriptUrl;
    }
    else {
        bundleScriptUrl = null;
        return undefined;
    }
}
exports.getBundleScriptUrl = getBundleScriptUrl;
/**
 * Memoizes result of [[getBundleScriptUrl]].
 * @hidden
 */
let bundleScriptUrl;
/**
 * Get script URL assumet it's already loaded in DOM.
 *
 * Required to find default URLs `harp.(min.)js` and `three().min).js` which are required to
 * properly start decoder bundle.
 *
 * @see https://stackoverflow.com/questions/2976651
 * @hidden
 */
function getScriptUrl(name) {
    const scriptElement = document.querySelector(`script[src*='/${name}.min.js']`) ||
        document.querySelector(`script[src='${name}.min.js']`) ||
        document.querySelector(`script[src*='/${name}.js']`) ||
        document.querySelector(`script[src='${name}.js']`);
    if (scriptElement) {
        return scriptElement.src;
    }
    else {
        return undefined;
    }
}
exports.getScriptUrl = getScriptUrl;
const HARP_GL_BUNDLED_ASSETS_PREFIX = "harp.js-bundle://";
/**
 * Resolve URLs with support for `harp.gl` bundle specific URLs.
 *
 * URLs with prefix `harp.gl:` are resolved relatively to `harp.js` bundle's base URL.
 *
 * @hidden
 */
class BundledUriResolver {
    resolveUri(uri) {
        if (uri.startsWith(HARP_GL_BUNDLED_ASSETS_PREFIX)) {
            const bundleSriptUrl = getBundleScriptUrl();
            if (bundleSriptUrl === null || bundleSriptUrl === undefined) {
                throw new Error(`harp.js: cannot resolve ${uri} because 'harp.gl' base url is not set.`);
            }
            else {
                uri = uri.substring(HARP_GL_BUNDLED_ASSETS_PREFIX.length);
                if (uri.startsWith("/")) {
                    uri = uri.substring(1);
                }
                return harp_utils_1.baseUrl(bundleSriptUrl) + uri;
            }
        }
        return uri;
    }
}
exports.BundledUriResolver = BundledUriResolver;
const bundledUriResolver = new BundledUriResolver();
const getActualDecoderScriptUrl = () => {
    const baseScriptUrl = getBundleScriptUrl();
    if (!baseScriptUrl) {
        // tslint:disable-next-line:no-console
        console.error(`harp.js: Unable to determine default location of 'harp-decoders(min).js'. ` +
            `See https://github.com/heremaps/harp.gl/@here/harp.gl.`);
    }
    if (!WorkerLoader_1.WorkerLoader.dependencyUrlMapping.three) {
        // tslint:disable-next-line:no-console
        console.error(`harp.js: Unable to determine location of 'three(.min).js'. ` +
            "`See https://github.com/heremaps/harp.gl/@here/harp.gl.`");
    }
    const isMinified = baseScriptUrl && baseScriptUrl.endsWith(".min.js");
    const decoderScriptName = !isMinified
        ? exports.DEFAULT_DECODER_SCRIPT_URL
        : exports.DEFAULT_DECODER_SCRIPT_URL.replace(".js$", ".min.js");
    return bundledUriResolver.resolveUri(decoderScriptName);
};
/**
 * Guess decoder script URL.
 *
 * Assumes that decoder script - `harp-decoders.js` is in same place as main bundle and calculates
 * it's URL.
 *
 * Minified version of `harp.js` bundle loads minified version of decoder.
 * Hooks in [[ConcurrentDecoderFacade]] to use this URL as default `defaultScriptUrl`.
 *
 * @hidden
 */
function installDefaultDecoderUrlHook() {
    harp_mapview_1.ConcurrentDecoderFacade.defaultScriptUrl = "";
    harp_mapview_1.ConcurrentTilerFacade.defaultScriptUrl = "";
    const threeUrl = getScriptUrl("three");
    WorkerLoader_1.WorkerLoader.dependencyUrlMapping.three = threeUrl;
    const oldDecoderGetWorkerSet = harp_mapview_1.ConcurrentDecoderFacade.getWorkerSet;
    harp_mapview_1.ConcurrentDecoderFacade.getWorkerSet = (scriptUrl) => {
        if (scriptUrl === undefined && harp_mapview_1.ConcurrentDecoderFacade.defaultScriptUrl === "") {
            const newScriptUrl = getActualDecoderScriptUrl();
            harp_mapview_1.ConcurrentDecoderFacade.defaultScriptUrl = newScriptUrl;
        }
        return oldDecoderGetWorkerSet.apply(harp_mapview_1.ConcurrentDecoderFacade, [scriptUrl]);
    };
    const oldTilerGetWorkerSet = harp_mapview_1.ConcurrentTilerFacade.getWorkerSet;
    harp_mapview_1.ConcurrentTilerFacade.getWorkerSet = (scriptUrl) => {
        if (scriptUrl === undefined && harp_mapview_1.ConcurrentTilerFacade.defaultScriptUrl === "") {
            const newScriptUrl = getActualDecoderScriptUrl();
            harp_mapview_1.ConcurrentTilerFacade.defaultScriptUrl = newScriptUrl;
        }
        return oldTilerGetWorkerSet.apply(harp_mapview_1.ConcurrentTilerFacade, [scriptUrl]);
    };
}
/**
 * Initialize `harp.gl` bundle.
 *
 * Install specific default decoder urls into [[ConcurrentDecoderFacade]].
 * @hidden
 */
function mapBundleMain() {
    getBundleScriptUrl();
    installDefaultDecoderUrlHook();
}
exports.mapBundleMain = mapBundleMain;


/***/ }),

/***/ "./lib/index.ts":
/*!**********************!*\
  !*** ./lib/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const BundleMain_1 = __webpack_require__(/*! ./BundleMain */ "./lib/BundleMain.ts");
if (!window.THREE) {
    // tslint:disable-next-line:no-console
    console.warn("harp.js: It looks like 'three.js' is not loaded. This script requires 'THREE' object to " +
        "be defined. See https://github.com/heremaps/harp.gl/@here/harp.gl.");
}
__export(__webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.js"));
__export(__webpack_require__(/*! @here/harp-omv-datasource */ "../harp-omv-datasource/index.ts"));
__export(__webpack_require__(/*! @here/harp-debug-datasource */ "../harp-debug-datasource/index.ts"));
__export(__webpack_require__(/*! @here/harp-geojson-datasource */ "../harp-geojson-datasource/index.ts"));
__export(__webpack_require__(/*! @here/harp-features-datasource */ "../harp-features-datasource/index.ts"));
__export(__webpack_require__(/*! @here/harp-webtile-datasource */ "../harp-webtile-datasource/index.ts"));
__export(__webpack_require__(/*! @here/harp-map-controls/lib/MapControls */ "../harp-map-controls/lib/MapControls.ts"));
__export(__webpack_require__(/*! @here/harp-map-controls/lib/MapControlsUI */ "../harp-map-controls/lib/MapControlsUI.ts"));
__export(__webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts"));
__export(__webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts"));
__export(__webpack_require__(/*! @here/harp-mapview-decoder */ "../harp-mapview-decoder/index.ts"));
BundleMain_1.mapBundleMain();


/***/ }),

/***/ "three":
/*!************************!*\
  !*** external "THREE" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = THREE;

/***/ })

/******/ });
//# sourceMappingURL=harp.js.map